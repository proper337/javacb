//@@@@@@//
//applet/AppletFinder.java
//@@@@@@//
import java.net.*;
import java.io.*;
import java.util.*;

/** Get list of APPLET tags in one HTML file.
 *
 * @author	Ian Darwin, Darwin Open Systems, www.darwinsys.com.
 * Routine "readTag" shamelessly stolen from
 * Elliott Rusty Harold's "ImageSizer" program.
 */
public class AppletFinder {

	public static void main(String[] av) {
		String[] tags = new AppletFinder().doPage(av[0]);
		for (int i=0;i<tags.length; i++)
			System.out.println("APPLET: " +i+" " + tags[i]);
	}

	public String[] doPage(String pageURL) {
		String result[] = null;
		URL root;

		if (pageURL != null) {
			//Open the URL for reading
			try {
				if (pageURL.indexOf(":") != -1) {
					root = new URL(pageURL);
				}
				else {
					root = new URL("http://" + pageURL);
				}
				result = findApplets(root);
			}
			catch (MalformedURLException e) {
				System.err.println(pageURL + 
					" is not a parseable URL");
				System.err.println(e);
			}
		}
		return result;
	}

	public String[] findApplets(URL u) {
		BufferedReader inrdr = null;
		Vector v = new Vector();
		char thisChar = 0;
	  
		try {
			inrdr = new BufferedReader(new InputStreamReader(u.openStream()));
			int i;
			while ((i = inrdr.read()) != -1) {
				thisChar = (char)i;
				if (thisChar == '<') {
					String tag = readTag(inrdr);
					// System.out.println("TAG: " + tag);
					if (tag.toUpperCase().startsWith("<APPLET"))
						v.addElement(tag);
				}
			}
			inrdr.close();
		}
		catch (IOException e) {
			System.err.println("Error reading from main URL: " + e);
		}
		String applets[] = new String[v.size()];
		v.copyInto(applets);
		return applets;
	}
 
	public String readTag(BufferedReader is) {
    StringBuffer theTag = new StringBuffer("<");
    char theChar = '<';
  
    try {
       while (theChar != '>' && ((theChar = (char)is.read()) != -1)) {
         theTag.append(theChar);
       } // end while
     }  // end try
     catch (IOException e) {
        System.err.println(e);
     }     

     return theTag.toString();
  }
}
//@@@@@@//
//applet/AppletJavaScript.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import netscape.javascript.*;

/** Simple demonstration of an Applet invoking JavaScript.
 * SERIOUSLY BROWSER DEPENDANT; requires a Netscape "javaxx.jar" or
 * "netscape.jar" on CLASSPATH to compile, AND a browser that makes the 
 * JSObject and related classes available at runtime.
 */
public class AppletJavaScript extends Applet {
	/** Called to set up the Applet */
	public void init() {
		final TextArea ta = new TextArea();
		Button button = new Button("Launch");
		ActionListener listener = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				try {
					String htmlText = ta.getText();
					JSObject topWindow = 
						JSObject.getWindow(AppletJavaScript.this);
					Object args[] = new Object[3];
					// XXX what goes in 0 and 1 of this array?
					args[2] = "width=300,height=300," +
						"location=0,menubar=0,status=0,toolbar=0";
					JSObject popupWindow = 
						(JSObject)topWindow.call("open", args);
					JSObject document = (JSObject)
						popupWindow.getMember("document");
					args = new Object[] {htmlText};
					document.call("write", args);
				} catch (Exception ex) {
					showStatus(ex.getClass().getName() + " " + ex.getMessage());
				}
			}
		};
		button.addActionListener(listener);
		setLayout(new BorderLayout());
		add(ta, BorderLayout.CENTER);
		add(button, BorderLayout.SOUTH);
	}
}
//@@@@@@//
//applet/AppletMethods.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.net.*;

/** AppletMethods -- show stop/start and AudioClip methods */

public class AppletMethods extends Applet {
	/** AudioClip object, used to load and play a sound file. */
	AudioClip snd = null;

	/** Initialize the sound file object and the GUI. */
	public void init() {
		System.out.println("In AppletMethods.init()");
		try {
			snd = getAudioClip(new URL(getCodeBase(), "laugh.au"));
		} catch (MalformedURLException e) {
			showStatus(e.toString());
		}
		setSize(200,100);	// take the place of a GUI
	}

	/** Called from the Browser when the page is ready to go. */
	public void start() {
		System.out.println("In AppletMethods.start()");
		if (snd != null)
			snd.play();	// loop() to be obnoxious...
	}

	/** Called from the Browser when the page is being vacated. */
	public void stop() {
		System.out.println("In AppletMethods.stop()");
		if (snd != null)
			snd.stop();	// stop play() or loop() 
	}

	/** Called from the Browser (when the applet is being un-cached?).
	 * Not actually used here, but the println will show when it's called.
	 */
	public void destroy() {
		System.out.println("In AppletMethods.destroy()");
	}

	public void paint(Graphics g) {
		g.drawString("Welcome to Java", 50, 50);
	}

	/** An alternate form of getParameter that lets
	 * you provide a default value, since this is so common.
	 */
	public String getParameter(String p, String def) {
		return getParameter(p)==null?def:getParameter(p);
	}
}
//@@@@@@//
//applet/ByeBye.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/** BadGuy demo -- exit from within an applet
 * (just to show that it has no effect).
 */

public class ByeBye extends Applet implements ActionListener {
	Button b1;

	public void init() {
		System.err.println("In byebye::init()");

		setLayout(new FlowLayout());
		setFont(new Font("Helvetica", Font.PLAIN, 14));
   
		add(b1 = new Button("Exit"));
		b1.addActionListener(this);
	}

	public void actionPerformed(ActionEvent event) {
		// User pushed the (one and only) button, so we exit.
		System.err.println("And now, byebye!");
		System.exit(0);
	}

}
//@@@@@@//
//applet/FirstApplet.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/**
 * FirstApplet is a simple applet that changes color when you click on a
 * Draw button.
 */
public class FirstApplet extends Applet implements ActionListener {
	boolean requested;

	/** init() is an Applet method called by the browser to initialize.
	 * In this program, we use it to initialize the "requested" flag
	 * to false, create a Draw button and add it to the Applet, and
	 * hang an ActionListener (which is also this Applet itself) onto
	 * the Button.
	 */
	public void init() {
		requested = false;
		Button b;
		b = new Button("Draw");
		add(b);						// connect Button into Applet
		b.addActionListener(this);	// connect Actions back to Applet
	}

	/** actionPerformed is called when a "high level" action happens
	 *  (like the user pushing a Button!) in one of the components for
	 *  which we are registered as an actionListener.  In this applet, 
	 *  we just toggle the state of the "requested" flag, to draw or
	 *  not to draw.
	 */
	public void actionPerformed(ActionEvent e) {
		// Invert or "toggle" the state of the draw request.
		requested = !requested;
		repaint();			// Then ask AWT to repaint us.
	}

	/** paint() is an AWT Component method, called when the 
	 *  component needs to be painted. We look at the draw flag and,
	 * if we've turned it on in actionPerformed, we draw some colored
	 * boxes in the Applet's window.
	 */
	public void paint(Graphics g) {
		/* If the drawn button has been pressed, draw something */
		if (requested) {
			int w = getSize().width, h=getSize().height;
			g.setColor(Color.yellow);
			g.fillRect(0, 0, w/2, h);
			g.setColor(Color.green);
			g.fillRect(w/2, 0, w, h);
			g.setColor(Color.black);
			g.drawString("Welcome to Java", 50, 50);
		}
	}
}
//@@@@@@//
//applet/ParmInfoDemo.java
//@@@@@@//
import java.applet.*;
import java.awt.*;

/** Null Demo, just demonstrates getParameterInfo() and getAppletInfo() */
public class ParmInfoDemo extends Applet {

	/** Init routine: set a font, initialize UI components. */
	public void init() {
		setLayout(new FlowLayout());

		String psize = getParameter("fontsize"); 
		if (psize == null) psize = "12";
		System.out.println("Fontsize is " + psize);
		Font f = new Font("Helvetica", Font.PLAIN,
			Integer.parseInt(psize));
		Label l = new Label("Font Demo");
		l.setFont(f);
		add(l);
	}

	/** Return information about this applet. */
	public String getAppletInfo() {
		return "ParmInfoDemo Applet, Version 0\n" +
			"Copyright Learning Tree International";
	}

	/** Return list of allowable parameters. */
	public String[][] getParameterInfo() {
		String param_info[][] = {
			{"fontsize",    "10-20",    "Size of font"},
		};
		return param_info;
	}
}
//@@@@@@//
//applet/Redir.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
import java.net.*;

/** A simple redirection applet.
 * @author Ian Darwin
 */
public class Redir extends Applet implements Runnable {
	protected String urlString;
	protected URL theNewURL;
	protected final static int NSECONDS = 5;
	protected Thread t;

	public void init() {
		try {
			// Get the address from a PARAM...
			urlString = getParameter("URL");
			if (urlString == null)  {
				urlString = "MISSING URL";
				throw new IllegalArgumentException(
				"Redir requires a URL parameter in the HTML");
			}

			// Make up the URL object
			theNewURL = new URL(urlString);

			// debug...
			// showStatus("URL = " + theNewURL);

		} catch (Exception err) {
			System.err.println("Error!\n" + err);
			showStatus("Error, look in Java Console for details!");
		}
	}

	public void start() {
		if (theNewURL == null)
			return;

		t = new Thread(this);
		t.start();
	}

	/** Print a little message to the user. */
	public void paint(Graphics g) {
		if (urlString != null)
			g.drawString(urlString, 20, 50);
		else
			g.drawString("Initializing...", 20, 50);
	}

	/** If users moves off the page, set Thread t to null so
	 * we don't showDocument from within the middle of the new page!
	 */
	public void stop() {
		t = null;
	}

	/** run, called by the Thread, does the work of sleeping
	 * for a fixed number of seconds then, if the user hasn't
	 * moved off the page, actually passing control to the new page.
	 */
	public void run() {
		for (int i=NSECONDS; i>=0; i--) {
			try {
				Thread.sleep(1000);
				if (t == null)
					return;
			} catch (InterruptedException e) {
				// so what?
			}
			if (t == null)
				return;
			showStatus(Integer.toString(i));

			if (t == null)
				return;

			showStatus("Ignition!");
			// "And then a miracle occurs..."
			getAppletContext().showDocument(theNewURL);
		}
	}
}
//@@@@@@//
//applet/SecondApplet.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/**
 * FirstApplet is a simple applet that changes color when you click on a
 * Draw button. SecondApplet extends it to allow Parameters.
 * Depends on our ColorName class to map names to java.awt.Colors.
 */
public class SecondApplet extends FirstApplet {
	/** the number of colors */
	int nColors;
	/** The array of Colors to use */
	Color colors[];

	/** init() is an Applet method called by the browser to initialize */
	public void init() {

		super.init();			// Call FirstApplet's init() to setup the GUI.

		// Now get the colors. Since we don't want the webmaster
		// to have to specify both the list of colors and the name,
		// we first count the colors.
		for (nColors=0; ; nColors++)
			if (getParameter("color" + nColors) == null)
				break;
		// Now we know the number, make the array
		if (nColors == 0)
			throw new IllegalArgumentException("SecondApplet needs colors!");
		colors = new Color[nColors];
		for (int i=0; i<nColors; i++)
			// colors[i] = ColorName.lookup(getParameter("color" + i));
			colors[i] = new Color(i, 123, 456);
	}

	/** paint() is an AWT Component method, called when the 
	 *  component needs to be painted.
	 */
	public void paint(Graphics g) {
		/* If the drawn button has been pressed, draw something */
		if (requested) {
			int w = getSize().width, h=getSize().height;
			for (int i = 0; i<nColors; i++) {
				if (colors[i] == null)
					g.setColor(Color.white);
				else
					g.setColor(colors[i]);
				g.fillRect(i*w/nColors, 0, w/nColors, h);
			}
			g.setColor(Color.black);
			g.drawString("Welcome to Java", 50, 50);
		}
	}

	/** Return information about this applet. */
	public String getAppletInfo() {
		return "SecondApplet (Parameter Demo), Version 0\n" +
			"Copyright Ian F. Darwin";
	}

	/** Return list of allowable parameters. */
	public String[][] getParameterInfo() {
		String param_info[][] = {
			{"colorN",    "n = 0, 1, ...",    "Name or hex-tuple of color"},
		};
		return param_info;
	}
}
//@@@@@@//
//applet/ShowDocApplet.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
import java.net.*;

/** ShowDocApplet: Demonstrate showDocument().
 * @author Ian Darwin, http://www.darwinsys.com/
 */ 
public class ShowDocApplet extends Applet {
	// String targetString = "http://www.darwinsys.com/javacook/secret.html";
	String targetString = "file:///c:/javasrc/network/ShowDocApplet.java";
	/** The URL to go to */
	URL targetURL;

	/** Initialize the Applet */
	public void init() {
		setBackground(Color.gray);
		try {
			targetURL = new URL(targetString);
		} catch (MalformedURLException mfu) {
			throw new IllegalArgumentException(
				"ShowDocApplet got bad URL " + targetString);
		}
		Button b = new Button("View Secret");
		add(b);
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				getAppletContext().showDocument(targetURL);
			}
		});
	}

	public void stop() {
		System.out.println("Ack! Its been fun being an Applet. Goodbye!");
	}
}
//@@@@@@//
//applet/SocketApplet.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;

/**
 * Socket Applet for "legacy" server connection via Socket.
 * @version $Id: SocketApplet.java,v 1.5 2004/02/09 03:33:44 ian Exp $
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 */
public class SocketApplet extends Applet {
	TextField nameTF, passTF, domainTF;
	Image im;
	Button sendButton;
	/** Where the Applet came from */
	URL whence;

	//+
	/** Initialize the GUI nicely. */
	public void init() {
		Label aLabel;

		setLayout(new GridBagLayout());
		int LOGO_COL = 1;
		int LABEL_COL = 2;
		int TEXT_COL = 3;
		int BUTTON_COL = 1;
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.weightx = 100.0; gbc.weighty = 100.0;

		gbc.gridx = LABEL_COL; gbc.gridy = 0; 
		gbc.anchor = GridBagConstraints.EAST;
		add(aLabel = new Label("Name:", Label.CENTER), gbc);
		gbc.anchor = GridBagConstraints.CENTER;
		gbc.gridx = TEXT_COL; gbc.gridy = 0;
		add(nameTF=new TextField(10), gbc);

		gbc.gridx = LABEL_COL; gbc.gridy = 1;
		gbc.anchor = GridBagConstraints.EAST;
		add(aLabel = new Label("Password:", Label.CENTER), gbc);
		gbc.anchor = GridBagConstraints.CENTER;
		gbc.gridx = TEXT_COL; gbc.gridy = 1;
		add(passTF=new TextField(10), gbc);
		passTF.setEchoChar('*');

		gbc.gridx = LABEL_COL; gbc.gridy = 2;
		gbc.anchor = GridBagConstraints.EAST;
		add(aLabel = new Label("Domain:", Label.CENTER), gbc);
		gbc.anchor = GridBagConstraints.CENTER;
		gbc.gridx = TEXT_COL; gbc.gridy = 2;
		add(domainTF=new TextField(10), gbc);
		sendButton = new Button("Send data");
		gbc.gridx = BUTTON_COL; gbc.gridy = 3;
		gbc.gridwidth = 3;
		add(sendButton, gbc);

		whence = getCodeBase();

		// Now the action begins...
		sendButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				String name = nameTF.getText();
				if (name.length() == 0) {
					showStatus("Name required");
					return;
				}
				String domain = domainTF.getText();
				if (domain.length() == 0) {
					showStatus("Domain required");
					return;
				}
				showStatus("Connecting to host " + whence.getHost() +
					" as " + nameTF.getText());

				try {
					Socket s = new Socket(getCodeBase().getHost(), 
						SocketServer.PORT);
					PrintWriter pf = new PrintWriter(s.getOutputStream(), true);
					// send login name
					pf.println(nameTF.getText());
					// passwd
					pf.println(passTF.getText());
					// and domain
					pf.println(domainTF.getText());

					BufferedReader is = new BufferedReader(
						new InputStreamReader(s.getInputStream()));
					String response = is.readLine();
					showStatus(response);
				} catch (IOException e) {
					showStatus("ERROR: " + e.getMessage());
				}
			}
		});
	}
	//-
}

//@@@@@@//
//applet/SocketServer.java
//@@@@@@//
import java.io.*;
import java.net.*;

public class SocketServer extends Thread {
	public static void main(String[] argv) throws IOException {
		new SocketServer().start();
	}

	/** The hang-around time */
	final static int MINUTES = 1;
	/** The port number */
	public final static int PORT = 64208;
	/** The server socket. */
	ServerSocket ss;

	/** Constructor -- just creates the ServerSocket */
	public SocketServer() throws IOException {
		ss = new ServerSocket(PORT);
	}

	public void run() {
		while (true) {
			try {
			System.out.println("SocketServer waiting for connection");
			Socket s = ss.accept();
			BufferedReader is = new BufferedReader(
				new InputStreamReader(s.getInputStream()));
			String name = is.readLine();
			String passwd = is.readLine();
			String domain = is.readLine();
			PrintWriter pout = new PrintWriter(s.getOutputStream(), true);
			pout.println("Welcome to " + domain + ", " + name);
			} catch (IOException e) {
				System.err.println("Oh, dear me! " + e);
			}
		} 
	}
}
//@@@@@@//
//applet/SumUp.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.net.*;

/**
 * <p>
 * SumUp is a simple applet that adds up some numbers.
 * To make this really useful for production, should implement a "little
 * language" either in HTML PARAMs, such as
 * <pre>
 *	&ltparam name="title1" value="Option One">
 *	&ltparam name="values1" value="0|100|200|300|400">
 *	&ltparam name="title1" value="Option Two">
 *	&ltparam name="values1" value="0|400|600|800|1000">
 * </pre>
 * <br/>or<br/>
 * in a configuration file which we download and parse (see
 * TreeLink.java in this directory) or load as a Properties file
 * (see MenuIntl.java). </p>
 * <p>
 * Also, of course, the URL to go to should be a PARAM.
 * Not to mention the colors (see ColorName and/or XColor).</p>
 * @author Ian F. Darwin, http://www.darwinsys.com/
 */
public class SumUp extends Applet implements ActionListener {
	/** The array of Choice items */
	protected Choice cs[] = new Choice[10];
	/** How many are actually in the array. */
	protected int numChoices = 0;
	/** The result of the summation */
	protected Label resultField;
	/** The pushbutton to send the form in */
	protected Button sendButton;

	/** init() is an Applet method called by the browser to initialize */
	public void init() {
		setBackground(Color.magenta);
		// The layout of the Applet is a Grid; always add things in pairs!
		setLayout(new GridLayout(0,2));
		Choice c;
		add(new Label("Option 1"));
		add(c = new Choice());
			c.addItem("0");
			c.addItem("100");
			c.addItem("200");
			c.addItem("400");
		cs[numChoices++] = c;

		add(new Label("Option 2"));
		add(c = new Choice());
			c.addItem("0");
			c.addItem("100");
			c.addItem("200");
			c.addItem("400");
		cs[numChoices++] = c;

		Panel p = new Panel();
		p.setBackground(Color.pink);
		p.add(new Label("Total:"));
		p.add(resultField = new Label("000000"));
		add(p);

		sendButton = new Button("Send it");
		add(sendButton);						// connect Button into Applet
		sendButton.addActionListener(this);		// connect it back to Applet
	}

	/** actionPerforformed() is called when a "high level" action happens
	 *  (like the user pushing a Button!) in one of the components
	 *  added to this Applet. 
	 */
	public void actionPerformed(ActionEvent e) {	// 1.1
		int total = 0;
		for (int i=0; i<numChoices; i++) {
			String text = cs[i].getSelectedItem();
			// System.err.println("Selection " + i + " = " + text);
			int value = Integer.parseInt(text);
			total += value;
		}
		resultField.setText(Integer.toString(total));

		try {
			URL myNewURL = new URL(
				"http://server/cgi-bin/credit?sum=" + total);

			// System.out.println("URL = " + myNewURL); // debug...

			// "And then a miracle occurs..."
			getAppletContext().showDocument(myNewURL);

		} catch (Exception err) {
			System.err.println("Error!\n" + err);
			showStatus("Error, look in Java Console for details!");
		}
	}
}
//@@@@@@//
//applet/TinyApplet.java
//@@@@@@//
import java.awt.*;
import java.applet.*;

/** Simple demo of creating a program with a button. */
public class TinyApplet extends Applet {

	/** The init method is used to set up the GUI */
	public void init() {
		add(new Button("A button")); // no action yet
	}
}
//@@@@@@//
//applet/TryCGI.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
import java.net.*;

/**
 * Try running a CGI-BIN script from within Java.
 */
public class TryCGI extends Applet implements ActionListener {
	protected Button goButton;

	public void init() {
		add(goButton = new Button("Go for it!"));
		goButton.addActionListener(this);
	}

	public void actionPerformed(ActionEvent evt) {
		try {
			URL myNewURL = new URL("http://server/cgi-bin/credit");

			// debug...
			System.out.println("URL = " + myNewURL);

			// "And then a miracle occurs..."
			getAppletContext().showDocument(myNewURL);

		} catch (Exception err) {
			System.err.println("Error!\n" + err);
			showStatus("Error, look in Java Console for details!");
		}
	}
}
//@@@@@@//
//applet/WalkingText.java
//@@@@@@//
import java.applet.*;
import java.awt.*;

public class WalkingText extends Applet implements Runnable {
	protected String mesg = null;
	protected int  xloc, yloc, width, height, textWidth, textHeight;
	protected Thread t;
	protected boolean done = false;
	/** How long to nap for each move */
	protected int napTime = 150;

	/** Applet Initializer */
	public void init() {
		xloc = 0;
		width = getSize().width;
		height = getSize().height;

		if ((mesg = getParameter("text")) == null)
			mesg = "Hello World of Java";

		String pSize = getParameter("fontsize"); 
		if (pSize == null)
			pSize = "12";

		String fontName = getParameter("fontName"); 
		if (fontName == null)
			fontName = "Helvetica";

		// System.out.println("Font is " + pSize + " point " + fontName);
		Font f = new Font(fontName, Font.PLAIN, Integer.parseInt(pSize));
		setFont(f);

		FontMetrics fm = getToolkit().getFontMetrics(f);
		textWidth = fm.stringWidth(mesg);
		textHeight = fm.getHeight();
		// System.out.println("TextWidth " + textWidth + ", ht " + textHeight);

		// use textHeight in y coordinate calculation
		yloc = height - ((height-textHeight) / 2);
	}

	/** This is important: we create a thread, so we must kill it */
	public void stop() {
		done = true;
		t = null;
	}

	/** create the thread and start it. */
	public void start() {
		if (t == null)
			t = new Thread(this);
		done = false;
		t.start();
	}

	// Usage:
	public String[][] getParameterInfo() {
		String[][] params = {
			{ "text", "text", "Text to walk across the screen" },
			{ "fontName", "text", "Name of font to display in" },
			{ "fontsize", "int", "How big to make the text" },
		};

		return params;
	}


	/** Run is called by the Thread class when there is work to do */
	public void run() {
		while (!done) {
			if ((xloc+=5) > getSize().width)
				xloc = 0;
			repaint();
			try {
				Thread.sleep(napTime);
			} catch (Exception e) {
				System.out.println("Who dares to interrupt my Sleep()? " + e);
			};
		}
	}

	/** Paint is called by Applet to redraw the screen */
	public void paint(Graphics g) {
		g.drawString(mesg, xloc, yloc);
		// if ((xloc + textWidth) > getSize().width) {
		// 	int negLoc = textWidth-(width-xloc);
		// 	System.out.println("xloc, textWidth, negLoc: " + xloc + "," +
		// 			textWidth + ", " + negLoc);
		// 	g.drawString(mesg, negLoc, yloc);
		// }
	}
}
//@@@@@@//
//beans/BSFAction.java
//@@@@@@//
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;

import org.apache.bsf.*;
import org.apache.bsf.util.*;

import com.darwinsys.swingui.LabelText;
import com.darwinsys.io.FileIO;

/** Longer sample of using Bean Scripting Framework with JPython */
public class BSFAction {
	protected String FILENAME = "buttonhandler.py";
	protected BSFManager manager;
	protected BSFEngine jpythonengine;
	protected String language;
	protected String script;

	public static void main(String[] args) {
		new BSFAction();
	}

	BSFAction() {

		// Construct the Bean instance
		LabelText bean = new LabelText("Message to Python script");

		try {
			manager = new BSFManager();

			// register scripting language
			String[] fntypes = { ".py" };
			manager.registerScriptingEngine("jpython",
			  "org.apache.bsf.engines.jpython.JPythonEngine", fntypes);
			jpythonengine = manager.loadScriptingEngine("jpython");

			// Tell BSF about the bean.
			manager.declareBean("bean", bean, LabelText.class);

			// Read the script file into BSF
			language = manager.getLangFromFilename(FILENAME);
			script = FileIO.readerToString(
				new FileReader(FILENAME));

		} catch (Exception ex) {
			System.err.println(ex.toString());
			System.exit(0);
		}

		System.out.println("Scripting setup done, building GUI.");

		final JFrame jf = new JFrame(getClass().getName());

		Container cp = jf.getContentPane();
		cp.setLayout(new FlowLayout());

		cp.add(bean);			// add the LabelText

		JButton b = new JButton("Click me!");
		cp.add(b);				// and the button under it.
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				try {

					// When the button is pressed, run the script.
					System.out.println("Script output: -->");
					manager.exec(language, FILENAME, 0, 0, script);
					System.out.println("<-- End of Script output.");
				} catch (BSFException bse) {
					JOptionPane.showMessageDialog(jf,
						"ERROR: " + bse, "Script Error",
						JOptionPane.ERROR_MESSAGE);
				}
			}
		});

		// A Quit button at the bottom
		JButton qb = new JButton("Quit");
		cp.add(qb);
		qb.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				System.exit(0);
			}
		});

		// Routine JFrame setup
		jf.pack();
		jf.setVisible(true);
	}
}
//@@@@@@//
//beans/BSFSample.java
//@@@@@@//
import java.io.*;
import org.apache.bsf.*;
import org.apache.bsf.util.*;

/** Sample of using Bean Scripting Framework with JPython */
public class BSFSample {
	public static void main(String[] args) {
		BSFManager manager = new BSFManager();

		// register scripting language
		String[] fntypes = { ".py" };
		manager.registerScriptingEngine("jython",
			"org.apache.bsf.engines.jython.JythonEngine", fntypes);

		try {
			// try an expression
			Object r = manager.eval("jython", "testString", 0, 0, "22.0/7");
			System.out.println("Result type is " + r.getClass().getName());
			System.out.println("Result value is " + r);
		} catch (Exception ex) {
			System.err.println(ex.toString());
		}
		System.out.println("Scripting demo done.");
		return;
	}
}
//@@@@@@//
//beans/CodeBean.java
//@@@@@@//
package com.darwinsys.codebean;

import java.awt.*;
import java.io.*;

/**
 * Create a Text Insert from a file.
 */ 
public class CodeBean extends TextArea implements Serializable {
	protected String fileName;
	protected Font myFont;

	public String getFileName() {
		return fileName;
	}
	public void setFileName(String _fileName) {
		fileName = _fileName;
	}

	public CodeBean() {
		super("", 20, 80, SCROLLBARS_NONE);

		if (myFont == null) {
			myFont = new Font("Courier", Font.BOLD, 10);
		}
		setFont(myFont);
		setForeground(Color.red);
		setText("\nWould load " + fileName + "\nNOW.");
	}

	public static void main(String[] args) {
		Frame f = new Frame("CodeBean Demo");
		CodeBean cb = new CodeBean();
		cb.setFileName("TESTING 1 2 3");
		f.add(cb);
		f.pack();
		f.setVisible(true);
	}
}
//@@@@@@//
//ChartBean/Chart.java
//@@@@@@//
package com.darwinsys.charts;

import java.awt.*;

/**
 * Simple charting bean. This version just draws a Pie Chart.
 *
 * It doesn't even label the pie slices; that is left as a
 * (non-trivial) exercise for the reader. Please read the 1987
 * Technical Report "How Hard can it be to draw a Pie Chart?"
 * by D. L. Souvaine and Chris van Wyck, Rutgers Computer Science,
 * LCSR-TR-90, before you decide how easy the work is going to be!
 */
public class Chart extends Component {

	/** The title to print on the chart */
	protected String title;

	/** the data to draw */
	protected ChartData data[];

	/** The data to draw a Demo */
	protected ChartData demoData[] = {
		new ChartData(73, "Java"),
		new ChartData(15, "Microsoft"),
		new ChartData(10, "Macintosh"),
	};

	/** degrees in a circle */
	public static final int CIRCLE = 360;

	/** a set of colors to draw the pies in */
	protected Color[] colors = {
		Color.red, 
		Color.blue,
		Color.green,
		Color.pink,
		Color.orange
	};

	/** Construct a Chart with a title */
	public Chart(String s) {
		title = s;
		setBackground(Color.white);
	}
	/** Construct a Chart with no title (no-arg constructor
	 * required for Beans).
	 */
	public Chart() {
	 	this("DarwinSys ChartBean");
	}

	public void setLabel(String s) {
		title = s;
	}

	public String getLabel() {
		return title;
	}
	public void setData(ChartData[] newStuff) {
		data = newStuff;
		repaint();
	}
	public void doDemo() {
		setData(demoData);
	}

	public void paint(Graphics g) {
		Dimension sz = getSize();
		int w = sz.width, h = sz.width;

		if (title != null)
			g.drawString(title, w/9, (int)(h*1.1));

		if (data == null || data.length == 0) {
			g.drawOval(0, 0, w, h);
			g.drawString("Please provide some data!", w/10, h/2);
			return;
		}

		int total = 0;
		int angle = 0;
		int rad = 0;	// "radians" (actually degrees) to draw
		int colNum = 0;

		for (int i=0; i<data.length; i++)
			total += data[i].value;
		for (int i=0; i<data.length; i++) {
			rad = (int)(CIRCLE * ((float)data[i].value / (float)total));
			// System.out.println("data: "+data[i].name+";"+data[i].value+
			//	",rad="+rad);
			g.setColor(colors[colNum++]);
			colNum%=colors.length;	// keep it in bounds
			g.fillArc(0, 0, w, h, angle, rad);
			angle += rad;
		}
	}
	
	public Dimension getMinimumSize() {
		return new Dimension(100, 120);
	}
	public Dimension getPreferredSize() {
		return new Dimension(200, 240);
	}
}
//@@@@@@//
//ChartBean/ChartBean.java
//@@@@@@//
package com.darwinsys.charts;

import java.awt.*;

/**
 * Simple charting bean. This version just draws a Pie Chart.
 *
 * It doesn't even label the pie slices; that is left as a
 * (non-trivial) exercise for the reader. Please read the 
 * Technical Report "How Hard can it be to draw Pie Charts?" by Chris
 * van Wyck, Purdue/Bell Labs, 1989??, before you decide how easy
 * the work is going to be!
 */
public class ChartBean extends Component {

	/** The title to print on the chart */
	protected String title;

	/** the data to draw */
	protected ChartData data[];

	/** degrees in a circle */
	public static final int CIRCLE = 360;

	/** a set of colors to draw the pies in */
	protected Color[] colors = {
		Color.red, 
		Color.blue,
		Color.green,
		Color.pink,
		Color.orange
	};

	/** Construct a ChartBean with a title */
	public ChartBean(String s) {
		title = s;
		setBackground(Color.white);
	}
	/** Construct a ChartBean with no title (no-arg constructor
	 * required for Beans).
	 */
	public ChartBean() {
	 	this(null);
	}

	public void setLabel(String s) {
		title = s;
	}

	public String getLabel() {
		return title;
	}
	public void setData(ChartData[] newStuff) {
		data = newStuff;
		repaint();
	}

	public void paint(Graphics g) {
		Dimension sz = getSize();
		int w = sz.width, h = sz.width;

		if (title != null)
			g.drawString(title, w/10, (int)(h*.9));

		if (data == null || data.length == 0) {
			g.drawOval(0, 0, w, h);
			g.drawString("Please provide some data!", w/10, h/2);
			return;
		}

		int total = 0;
		int angle = 0;
		int rad = 0;	// "radians" (actually degrees) to draw
		int colNum = 0;

		for (int i=0; i<data.length; i++)
			total += data[i].value;
		for (int i=0; i<data.length; i++) {
			rad = (int)(CIRCLE * ((float)data[i].value / (float)total));
			// System.out.println("data: "+data[i].name+";"+data[i].value+
			//	",rad="+rad);
			g.setColor(colors[colNum++]);
			colNum%=colors.length;	// keep it in bounds
			g.fillArc(0, 0, w, h, angle, rad);
			angle += rad;
		}
	}
	
	public Dimension getMinimumSize() {
		return new Dimension(100, 120);
	}
	public Dimension getPreferredSize() {
		return new Dimension(200, 240);
	}
}
//@@@@@@//
//ChartBean/ChartBeanInfo.java
//@@@@@@//
package com.darwinsys.charts;

import java.beans.*;
import java.lang.reflect.*;

/** BeanInfo for our Chart Demo */
public class ChartBeanInfo extends SimpleBeanInfo {

	/** Give a descriptor for the Bean itself */
	public BeanDescriptor getBeanDescriptor() {
		return new BeanDescriptor(Chart.class);
	}

	/** Set the Icon for display in the BeanBox */
	public java.awt.Image getIcon(int kind) {
		switch(kind) {
		case ICON_COLOR_16x16:
			return loadImage("ChartIcon16.gif");
		case ICON_COLOR_32x32:
			return loadImage("ChartIcon32.gif");
		case ICON_MONO_16x16:
			return loadImage("ChartIconBW16.gif");
		case ICON_MONO_32x32:
			return loadImage("ChartIconBW32.gif");
		default:
			System.out.println("ChartBean Unsupported Icon Format " + kind);
		}
		return null;
	}

	/** Set up the method name descriptions for actions */
	public MethodDescriptor[] getMethodDescriptors() {
		try {
			// DODEMO()
			Method m = Chart.class.getMethod("doDemo", new Class[] {});
			MethodDescriptor md1 = new MethodDescriptor(m);
			md1.setShortDescription("Run a simple demonstration");

			// SETDATA(ChartData[]);
			Class argTypes[] = { Class.forName("ChartData[]") };
			m = Chart.class.getMethod("setData", argTypes);
			MethodDescriptor md2 = new MethodDescriptor(m);
			md2.setShortDescription("Provide array of ChartData to plot");

			return new MethodDescriptor[] { md1, md2 };

		} catch (Exception e) {		// if anything fails, fall back to default
			System.out.println(e);
			return super.getMethodDescriptors();
		}
	}
}
//@@@@@@//
//ChartBean/ChartData.java
//@@@@@@//
package com.darwinsys.charts;

public class ChartData {
	String name;
	int value;

	ChartData(int i, String s) {
		name = s;
		value = i;
	}
	ChartData(String s, int i) {
		this(i, s);
	}
}
//@@@@@@//
//ChartBean/ChartTest.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;

import com.darwinsys.charts.*;

/** Simple GUI driver for Chart, showing it used as a plain Component */
public class ChartTest extends Frame {
	boolean unsavedChanges = false;
	Button drawButton;
	Button quitButton;
	com.darwinsys.charts.Chart bean;

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create a ChartTest object
		ChartTest j = new ChartTest();
		// send message telling it to show up
		j.setVisible(true);
	}

	/** Construct the object including its GUI */
	public ChartTest() {
		super("ChartTest");
		setLayout(new FlowLayout());
		add(new Label("Simple demo of a Java Chart Bean"));
		add(quitButton = new Button("Exit"));
		quitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
		add(drawButton = new Button("Draw"));
		drawButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				bean.doDemo();
			}
		});

		add(bean = new com.darwinsys.charts.Chart("System Usage in 1999"));

		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
			
		pack();
	}

	public Dimension getPreferredSize() {
		return new Dimension(400, 300);
	}
}
//@@@@@@//
//Contrib/AddPopup.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.lang.*;
import java.util.Hashtable;

public class AddPopup 
    extends Frame 
    implements ActionListener, MouseListener {

  PopupMenu pm = new PopupMenu();

  public static void main (String argv[]) {
    new AddPopup();
  }

  public AddPopup() {
    MenuItem item = new MenuItem("file-1");
    item.addActionListener(this);
    Menu m = new Menu("file");
    m.add(item);
    item = new MenuItem("file-2");
    m.add(item);
    MenuBar mb = new MenuBar();
    mb.add(m);

    setMenuBar(mb);
    setSize(100, 100);
    setLayout(new BorderLayout());

    Label l = new Label("label");
    addPopup(l, "label");
    add(l, BorderLayout.NORTH);

    Panel p = new Panel();
    addPopup(p, "Panel");
    add(p, BorderLayout.Center);

    Button b = new Button("button");
    addPopup(b, "button");
    add(b, BorderLayout.SOUTH);

    setVisible(true);
  }

  public void actionPerformed(ActionEvent e) {
    System.out.println("actionPerformed, event=" + e + ", mod=" + getMods(e));
    System.out.println(" command=" + e.getActionCommand());
    System.out.println(" param=" + e.paramString());
    System.out.println(" source=" + e.getSource());
  }

  String getMods(ActionEvent e) { return getMods(e.getModifiers()); }

  String getMods(MouseEvent e) { return getMods(e.getModifiers()); }

  String getMods(int mods) {
    String modstr = "";
    if ((mods & ActionEvent.SHIFT_MASK) == ActionEvent.SHIFT_MASK)
      modstr += (" SHIFT");
    if ((mods & ActionEvent.ALT_MASK) == ActionEvent.ALT_MASK)
      modstr += (" ALT");
    if ((mods & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK)
      modstr += (" CTRL");
    if ((mods & ActionEvent.META_MASK) == ActionEvent.META_MASK)
      modstr += (" META");
    return modstr;
  }

  public void mouseClicked (MouseEvent e) {
    mouseAction("mouseClicked", e);
  }

  public void mouseEntered (MouseEvent e) {
  }

  public void mouseExited (MouseEvent e) {
  }

  public void mousePressed (MouseEvent e) {
    mouseAction("mousePressed", e);
  }

  public void mouseReleased (MouseEvent e) {
    mouseAction("mouseReleased", e);
  }

  void mouseAction (String which, MouseEvent e) {
    Component c = e.getComponent();
    System.out.println(which + "e=" + e + ", mods=" + getMods(e) +
                       ", component=" + c);
    if (e.isPopupTrigger()) {
      System.out.println("isPopup");
      PopupMenu pm = getHash(c);
      pm.show(c, c.getSize().width/2, c.getSize().height/2);
    }
  }


  void addPopup(Component c, String name) {
    PopupMenu pm = new PopupMenu();
    MenuItem mi = new MenuItem(name + "-1");
    mi.addActionListener(this);
    pm.add(mi);

    mi = new MenuItem(name + "-2");
    pm.add(mi);

    setHash(c, pm);
    c.add(pm);
    c.addMouseListener(this);
  }


  Hashtable popupTable = new Hashtable();

  void setHash(Component c, PopupMenu p) {
    popupTable.put(c, p);
  }

  PopupMenu getHash(Component c) {
    return (PopupMenu)(popupTable.get(c));
  }

}


//@@@@@@//
//Contrib/Browser.java
//@@@@@@//
//  Browser.java
//

import java.awt.*;
import java.awt.event.*;
import java.io.*;

import javax.swing.*;
import javax.swing.text.html.*;
import javax.swing.event.*;

public class Browser extends JFrame {

    static JTextField textField;
    static JEditorPane editor;

    public Browser(String s) {
        super(s);

        JPanel panel = new JPanel();
        panel.setLayout(new BorderLayout());

        editor = new JEditorPane();
        textField  = new JTextField();
        JScrollPane scrollPane = new JScrollPane(editor);

        editor.setEditable(false);

        panel.add(new JLabel("Location:  "), BorderLayout.WEST);
        panel.add(textField, BorderLayout.CENTER);

        getContentPane().add(panel, BorderLayout.NORTH);
        getContentPane().add(scrollPane, BorderLayout.CENTER);

        editor.addHyperlinkListener(new HyperListener());
        textField.addActionListener(new TextFieldListener());
    }

    public static void main(String[] args) {
        Browser frame = new Browser("Browser");
        frame.setSize(400,400);
        frame.setVisible(true);
    }

    class HyperListener implements HyperlinkListener {

        public void hyperlinkUpdate(HyperlinkEvent e) {
            if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                JEditorPane sourcePane = (JEditorPane) e.getSource();
                if (e instanceof HTMLFrameHyperlinkEvent) {
                    HTMLFrameHyperlinkEvent event=(HTMLFrameHyperlinkEvent)e;
                    HTMLDocument doc=(HTMLDocument)sourcePane.getDocument();
                    doc.processHTMLFrameHyperlinkEvent(event);
                } else {
                    try {
                        textField.setText("Contacting " +
                            e.getURL().toString() + " ...");
                        sourcePane.setPage(e.getURL()); 
                        textField.setText(e.getURL().toString());
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                }
            }
        }
    }

    class TextFieldListener implements ActionListener {

        public void actionPerformed(ActionEvent e) {
            try {
                editor.setPage(textField.getText());
            } catch (IOException ex) {
                editor.setText("Page could not be loaded");
            }
        }
    }
}
//@@@@@@//
//Contrib/c2j++/C2J++.java
//@@@@@@//
/*
 * Copyright (C) 1996,1997 Morgan Stanley & Co., Inc. 
 * Copyright (C) 1997 Ilya Tilevich
 *
 * This file is part of C2J++.
 * C2J++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation; 
 * either version 2, or (at your option) any later version.
 * C2J++ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with C2J; 
 * see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */



import java.io.*;
import java.util.Vector;

/**
 * Purpose: Encapsulates all the stages of translating C++ to Java
 * @version 1.0
 * @author Ilya Tilevich
 */
class C2J 
{

	private String m_strHeaderFile; 
	private String m_strCppFile; 
	private String m_strTempFile; 
	private String m_strOutputFile; 
	private TextOutputStream m_tos;
	private FileOutputStream m_fosFileOut; 
	private Parser m_Parser;
	static  boolean m_bDefnOnly = false;
	/**
	 * Purpose: Constructor
	 * @param strHeaderFile - an *.h file
	 * @param strCppFile - a *.cpp file
	 * @exception FileNotFoundException if either file is not found
	 */
	public C2J(String strHeaderFile, String strCppFile){
		
		   m_strHeaderFile = new String(strHeaderFile); 
	       m_strCppFile = new String(strCppFile); 
		   m_strTempFile = new String("__temp__"); 
		   m_strOutputFile = ConstructOutputFileName(strCppFile); 
		   
		   
		   try{
				m_fosFileOut  = new FileOutputStream(m_strTempFile);
				m_tos = new TextOutputStream(m_fosFileOut);
		   }
		   catch(FileNotFoundException e){
				System.out.println("File Not Found" + e);
				return;
	       }
			
		   catch(Throwable e) {
				System.out.println("Error in opening file" + e);
				return;
		   }

		   m_Parser = new Parser(false); //create a parser to parse a header file
   
	}
	
	private String ConstructOutputFileName(String strCppFile){
	   	
		String strOutputFile = new String(strCppFile); 
	    
	   	//System.out.println(strOutputFile);
		int iIndex = strOutputFile.indexOf(".");

	   
	   if(iIndex == -1){
   		  System.out.println("Invalid name for a cpp file : " + strCppFile);
		  System.exit(1);
	   }

	   strOutputFile = strOutputFile.substring(0, iIndex) + ".java";
	   return strOutputFile;

	}
	
	/**
 	 * Purpose: Returns the output file name
	 * @return String
	 */
	
	public String GetOutputFileName(){ return m_strOutputFile; }
		
	/**
	 * Purpose: parses a header file containing class definitions
	 * Note: Should be called first
	 * @exception IOException
	 */
	public void ParseHeaderFile() throws IOException{
	
	    boolean bFirstClass = true;
	    m_Parser.SetParseMethod(false);
	    m_Parser.OpenInputFile(m_strHeaderFile);

	    while(m_Parser.readClass(m_bDefnOnly));		
		
	    for(ClassRepresentation c = m_Parser.class_info; c!=null; c = c.GetNext()){
			c.print(m_tos, bFirstClass);      
	   		if(bFirstClass) bFirstClass = false; 
	    }		
	}

	/**
	 * Purpose: parses a cpp file containig the implementation of the class defined in
	 * header file
	 * @exception IOException 
	 */
	public void ParseCppFile() throws IOException{

	   m_Parser.OpenInputFile(m_strCppFile);
	   m_Parser.SetParseMethod(true);

	   while(m_Parser.readClass(m_bDefnOnly));

	   //m_Parser.m_membersArray.WriteOut();
	   m_Parser.addGlobals();
	   
	   m_Parser.CloseAllFiles();
	   
	   m_tos.close();
	   m_fosFileOut.close();
	 
		   
	   		   	
	}

	/**
	 * Purpose: Calls the preprocessor
	 */
	public void WeaveItTogether(){
	    //m_Parser.m_membersArray.WriteOut();
		PrimitivePreprocessor prep = new PrimitivePreprocessor(new String(m_strTempFile), new String(m_strOutputFile), 
		m_Parser.m_membersArray);
	    prep.ProcessFile();
	}


	/**
	 * Purpose: Reads an output file and replaces found strings as specified
	 * Note: similar to sed utility
	 */
	public void MatchAndReplace() throws IOException{
		StringPair stPair1 = new StringPair("char * ","String ");
		StringPair stPair2 = new StringPair("char* ","String ");
		StringPair stPair3 = new StringPair("const char * " ,"String ");
		StringPair stPair4 = new StringPair(" & ", " ");
		StringPair stPair5 = new StringPair("*", " ");
		StringPair stPair6 = new StringPair("->", ".");
		StringPair stPair7 = new StringPair("unsigned int " ,"int ");
		StringPair stPair8 = new StringPair("unsigned long ","int ");		
		StringPair stPair9 = new StringPair("unsigned char ", "char ");
		StringPair stPair10 = new StringPair("unsigned ","int ");
		StringPair stPair11 = new StringPair("const " , "static final ");
		StringPair stPair12 = new StringPair("BOOL ", "boolean ");	
        StringPair stPair13 = new StringPair("NULL", "null");
		
			
		Vector v = new Vector();
		v.addElement(stPair1);
		v.addElement(stPair2);
		v.addElement(stPair3);
		v.addElement(stPair4);
		v.addElement(stPair5);
		v.addElement(stPair6);
		v.addElement(stPair7);
		v.addElement(stPair8);
		v.addElement(stPair9);
		v.addElement(stPair10);
		v.addElement(stPair11);
		v.addElement(stPair12);
		v.addElement(stPair13);

		Replacer rep = new Replacer(m_strOutputFile, v);
		rep.MatchAndReplace();
		
		(new File(m_strTempFile)).delete();
	}




public static void main(String[] args) throws IOException {

	String strHeaderFile = new String();
	String strCppFile = new String();
	
	
	if(args.length >= 2){
	   strHeaderFile = new String(args[0]);
	   strCppFile = new String(args[1]);
	
	   if(args.length == 3 &&  args[2].equalsIgnoreCase("-DefnOnly"))
	      C2J.m_bDefnOnly = true;
		
	}
	else{
		System.out.println("Usage: Java C2J  Source.h  Source.cpp [-DefnOnly]");
		System.exit(1);
	}
   
	
	
	C2J trans = new C2J(strHeaderFile,  strCppFile);
	trans.ParseHeaderFile();
	trans.ParseCppFile();
	trans.WeaveItTogether();
	trans.MatchAndReplace();

	
			
			

	System.out.println(trans.GetOutputFileName() + " is created");
	System.out.println("Enjoy!");
    
	
	//Runtime run = Runtime.getRuntime(); //works only under Windows NT
	//run.exec("write " + trans.GetOutputFileName());
	
}

}//@@@@@@//
//Contrib/c2j++/copyafile.java
//@@@@@@//
/*
 * Copyright (C) 1996,1997 Morgan Stanley & Co., Inc. 
 * Copyright (C) 1997 Ilya Tilevich
 *
 * This file is part of C2J++.
 * C2J++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation; 
 * either version 2, or (at your option) any later version.
 * C2J++ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with C2J; 
 * see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

import java.io.*;

/**
 * Purpose: copies one file into another 
 * @version 1.0 December 96
 * @author Ilya Tilevich
 */

 final class CopyAFile{
	private static boolean m_bDebug = false;
	private FileInputStream fileName = null;
	//Assigns the variable bufferedInput to the class
 	//BufferedInputStream
	private BufferedInputStream bufferedInput = null;
	private DataInputStream dataIn = null;
	
	private FileOutputStream writeOut = null;
	private DataOutputStream dataWrite = null;

	/**
	 * Purpose: Constructor
	 * @param inFile - input file name
	 * @param outFile - output file name
	 * @exception IOException if there are errors during fiels opening 
	 */

	public  CopyAFile(String inFile, String outFile){
		try{
	            fileName = new FileInputStream(inFile);
		    //Creates an instance of the class BufferedInputStream
		    //named bufferedInput
		   //bufferedInput receives the stream from the fileInputStream
		   //fileName ad it is read
		   bufferedInput = new BufferedInputStream(fileName);
		   dataIn = new DataInputStream(bufferedInput);
		   
		   writeOut = new FileOutputStream(outFile);
		   dataWrite = new DataOutputStream(writeOut);
			
		}
		catch(FileNotFoundException e){
		    System.out.println("File Not Found");
		    return;
	    }
		catch(Throwable e) {
	        System.out.println("Error in opening file");
	        return;
	    }


	}

	/**
	 * Purpose: Copies a file
	 * @exception IOException if error happens
	 */
	public void DoCopy(){

		int iCh;
		try{
	        
			while((iCh = dataIn.read())!=-1){
				dataWrite.writeByte(iCh);
				if(m_bDebug)
				   System.out.println(iCh);
							
			}
				
			fileName.close();
	        dataWrite.close();
	    }
						
		catch(IOException e) {
	          System.out.println("Error in reading file");
	    }
	
				
		
		catch(Throwable e){
			System.out.println("Error in writing to file");
		}
		
		
			
	
    }
   
 }//@@@@@@//
//Contrib/c2j++/Mar.java
//@@@@@@//
/*
 * Copyright (C) 1996,1997 Morgan Stanley & Co., Inc. 
 * Copyright (C) 1997 Ilya Tilevich
 *
 * This file is part of C2J++.
 * C2J++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation; 
 * either version 2, or (at your option) any later version.
 * C2J++ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with C2J; 
 * see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

import java.util.Vector;
import java.io.*;
import java.util.StringTokenizer;


/**
 * Purpose: Encapsulates a pair of String objects
 * @version 1.0 December 96
 * @author Ilya Tilevich
 */

class StringPair
{

  protected String m_strOne;
  protected String m_strTwo;
  
  /**
   * Purpose: Constructor
   */
  public StringPair()
  {
  	  m_strOne = new String("");
	  m_strTwo = new String("");
  }
  
  
  /**
   * Purpose: Constructor
   * @param strOne - first String
   * @param strTwo - second String
   */
  
  public StringPair(String strOne, String strTwo)
  {
	  m_strOne = new String(strOne);
	  m_strTwo = new String(strTwo);
  }

  /**
   * Purpose: compares two StringPairs
   * @param StringPair
   */
  public boolean equal(StringPair stPair){
	  return (m_strOne == stPair.m_strOne && m_strTwo == stPair.m_strTwo);
  }
  
  /**
   * Purpose: returns the first string of the pair
   * @return String
   */
  public String GetFirstString() { return m_strOne; }
  
  /**
   * Purpose: returns the second string of the pair
   * @return String
   */
   public String GetSecondString() { return m_strTwo; }

  /**
  * Purpose: Sets the value for the first String
  * @param strOne
  */
  public void SetFirstString(String strOne) { m_strOne = strOne; }
  
  /**
  * Purpose: Sets the value for the second String
  * @param strTwo
  */
  public void SetSecondString(String strTwo) { m_strTwo = strTwo; }

 
}



/** 
 * Purpose: Read a text file and replace given patterns
 * Note: Doesn't support recursive replacement yet.
 * @version 1.0 December 96
 * @author Ilya Tilevich
 */ 
class Replacer
{
   	private Vector m_vect;
	private int m_iTotal;
	String m_strFileIn;
	private FileInputStream fisFileIn = null;
	private BufferedInputStream bisBufferedInput = null;
	private DataInputStream disDataIn = null;

	private FileOutputStream fosFileOut = null;
	private DataOutputStream dosDataOut = null;
	private boolean m_bDebug = false;

	/**
	* Purpose: Constructor
	* @param strFileIn - name of the source file
	* @param vect - Vector of StringPairs (key, replacement) 
	* @exception IOException if an error opening strFileIn occurs
	*/
	public Replacer(String strFileIn, Vector vect){ 
		 
		m_iTotal = 0;
		m_strFileIn = new String(strFileIn);
		
		try{
	           fisFileIn = new FileInputStream(strFileIn);
		    //Creates an instance of the class BufferedInputStream
		    //named bufferedInput
		   //bufferedInput receives the stream from the fileInputStream
		   //fileName as it is read
		   bisBufferedInput = new BufferedInputStream(fisFileIn);
		   disDataIn  = new DataInputStream(bisBufferedInput);

		   fosFileOut  = new FileOutputStream("__temp__");
		   dosDataOut = new DataOutputStream(fosFileOut);

		}
		catch(FileNotFoundException e){
		    System.out.println("File Not Found");
		    return;
	    }
		catch(Throwable e) {
	        System.out.println("Error in opening file");
	        return;
	    }

		   
		m_vect = vect;   
		
	}


/**
 * Purpose: reads the source file, matched given strings, and replaces them as
 * specified
 * @exception IOException
 */
public int MatchAndReplace() throws IOException
{
   	String str, strReplacement = new String("/** @c2j++ Replacement from ");
	int iCount = 0;
	boolean bSkip = false;
	while((str = disDataIn.readLine()) != null){
	    if(str.trim().startsWith("//")){
			dosDataOut.writeBytes(str+"\n");
			continue;
		}
		
		if(str.indexOf("/*")!=-1)
			bSkip = true;
		
		if(!bSkip){		  
			
			if(str.trim().startsWith("cout")){
				String strTemp = new String("");
				while(!str.trim().endsWith(";") && strTemp != null){
					strTemp = disDataIn.readLine();
				    str += strTemp;
				}
				
				dosDataOut.writeBytes(strReplacement + str.trim());
				str = CoutToSystemOut(str);
				dosDataOut.writeBytes(str + "*/ \n");
			}
			else if(str.trim().startsWith("cerr")){
				String strTemp = new String("");
				while(!str.trim().endsWith(";") && strTemp != null){
					strTemp = disDataIn.readLine();
				    str += strTemp;
				}
				
				dosDataOut.writeBytes(strReplacement + str.trim());
				str = CerrToSystemErr(str);
				str = CoutToSystemOut(str);
				dosDataOut.writeBytes(" */\n");
			}
			else if(str.trim().startsWith("strrev")){
				dosDataOut.writeBytes(strReplacement + str.trim()); 
				str = StrRevToReverse(str);
				str = CoutToSystemOut(str);
				dosDataOut.writeBytes(" */\n");
			} 
			else if(str.trim().startsWith("delete")){
				dosDataOut.writeBytes(strReplacement + str.trim());
				str = DeleteToNull(str);
				str = CoutToSystemOut(str);
				dosDataOut.writeBytes(" */\n");
			}
			else 
			   str = Replace(str);	
		}
		
		dosDataOut.writeBytes(str); 
		dosDataOut.writeByte('\n');
		
		if(str.indexOf("*/")!= -1)
			bSkip = false;
			
	}

	if(m_bDebug)
		System.out.println(String.valueOf(m_iTotal) + " instances replaced");
	
	
	   
   disDataIn.close();
   bisBufferedInput.close();
   fisFileIn.close();
   
   dosDataOut.close();
   fosFileOut.close();
   
   
   CopyAFile copier = new CopyAFile("__temp__", m_strFileIn);
   copier.DoCopy();
	
     	
   
	return m_iTotal;
}

private String Replace(String strLine) throws IOException
{
	
	String strToReplace = new String();
	String strReplacement = new String();
	String strStart = new String();
	String strEnd = new String();
	String strRep = new String();
	//////////////////
	int iCount = 0, iIndex = 0;
	while(iCount != m_vect.size()){
	    StringPair pair = (StringPair)(m_vect.elementAt(iCount));  
		strToReplace = pair.GetFirstString();
		strReplacement = pair.GetSecondString();
		iCount++;

		do{
			
			iIndex = strLine.indexOf(strToReplace);

				
			if(iIndex!=-1){
				strRep = strReplacement;
				
				strStart = (iIndex != 0) ? (strLine.substring(0, iIndex)) : "" ;
				
				int i =	iIndex + strToReplace.length();
				strEnd = strLine.substring(i);
				strStart+=strReplacement;
				strStart+=strEnd;
				m_iTotal ++;
				if(strReplacement.compareTo(" ")==0)
					strRep = "\" \"";
				dosDataOut.writeBytes("/* @c2j++: \"" + strLine.trim() + "\" replacement: " + strToReplace + 
					" to " + strRep + " */");
				dosDataOut.writeByte('\n');
				strLine = strStart;
				
			}
		}while(iIndex != -1);
	
	
    } //end of while
	return strLine;
}
	
   private String CoutToSystemOut(String str){
   		String strReturn = new String();
		String strParam; // = new String();
		String strPlus = new String(" + ");
		String strValueOf = new String("String.valueOf(");
		if(!str.trim().startsWith("cout")) return str;

		if(str.trim().endsWith("endl;"))
			strReturn =  " System.out.println(";
		else strReturn = " System.out.print(";

		StringTokenizer strTok = new StringTokenizer(str, "<;", false);
		boolean bFirst = true;
	    if(strTok != null){
			strParam = new String(strTok.nextToken());
			strParam = strParam.trim();
			do{
			   	if(strParam.compareTo("cout") != 0 && strParam.compareTo(" ") != 0){
					if(strParam.endsWith("\"") && strParam.startsWith("\"")){
			   		  if(!bFirst)
						  strParam = strPlus + strParam; // + "string";
					   
				   }
				   else if(strParam.compareTo("endl;")!= 0 && strParam.compareTo(";")!=0
					   && strParam.compareTo("endl")!=0){
					  
					   strParam = strValueOf + strParam + ")";
					   if(!bFirst)
						   strParam = strPlus + strParam;
				   }
					
				   strReturn += strParam;
				   if(bFirst)
						bFirst = false;
			   }

			   if(!strTok.hasMoreTokens()) break;
			   strParam = new String(strTok.nextToken());
			   strParam = strParam.trim();
			}while(strParam.compareTo(";") !=0 && strParam.compareTo("endl;") !=0 &&
				strParam.compareTo("endl")!=0 );

			
		}
		  
   		m_iTotal++;
		
		strReturn+=");";
		
		return strReturn;
   
   }

	
   private String CerrToSystemErr(String str){
   		String strReturn = new String();
		String strParam; // = new String();
		String strPlus = new String(" + ");
		String strValueOf = new String("String.valueOf(");
		if(!str.trim().startsWith("cerr")) return str;

		if(str.trim().endsWith("endl;"))
			strReturn = "System.err.println(";
		else strReturn = "System.err.print(";

		StringTokenizer strTok = new StringTokenizer(str, "<;", false);
		boolean bFirst = true;
	    if(strTok != null){
			strParam = new String(strTok.nextToken());
			strParam = strParam.trim();
			do{
			   	if(strParam.compareTo("cerr") != 0 && strParam.compareTo(" ") != 0){
					if(strParam.endsWith("\"") && strParam.startsWith("\"")){
			   		  if(!bFirst)
						  strParam = strPlus + strParam; // + "string";
					   
				   }
				   else if(strParam.compareTo("endl;")!= 0 && strParam.compareTo(";")!=0
					   && strParam.compareTo("endl")!=0){
					  
					   strParam = strValueOf + strParam + ")";
					   if(!bFirst)
						   strParam = strPlus + strParam;
				   }
					
				   strReturn += strParam;
				   if(bFirst)
						bFirst = false;
			   }

			   if(!strTok.hasMoreTokens()) break;
			   strParam = new String(strTok.nextToken());
			   strParam = strParam.trim();
			}while(strParam.compareTo(";") !=0 && strParam.compareTo("endl;") !=0 &&
				strParam.compareTo("endl")!=0 );

			
		}
		  
   		m_iTotal++;
		
		strReturn+=");";
		
		return strReturn;
   
   }

	private String DeleteToNull(String str){
		
		String strReturn = new String();
		String strParam;
		StringTokenizer strTok = new StringTokenizer(str);
		boolean bFirst = true;
	    
		if(strTok != null && strTok.countTokens() >= 2){
			if(strTok.nextToken().trim().compareTo("delete") == 0){
			    strParam = new String(strTok.nextToken());
				if(strParam.compareTo("[]") == 0) 
					strParam = new String(strTok.nextToken());

				if(strParam.endsWith(";"))
					strParam = strParam.substring(0, strParam.length() -1);
				      strReturn = strParam + " = null;";
				m_iTotal++;
				return strReturn;
			}
		}
	
		return str;
	
	}
	   	  
   	private String StrRevToReverse(String str){
	
		String strReturn = new String();
		String strParam;
		if(!str.trim().startsWith("strrev")) return str;

		
		StringTokenizer strTok = new StringTokenizer(str, "()", false);
		
	    if(strTok != null){
			strParam = new String(strTok.nextToken()); //strrev
			strParam = new String(strTok.nextToken());
			strParam = strParam.trim();
			strReturn = new String(strParam + " = new String(new StringBuffer(" + strParam + ").reverse());");
		}
		return strReturn;
}
		//Where execution begins in a stand-alone excutable
    public static void main(String[] args) throws IOException
	{
		   
		StringPair stPair1 = new StringPair("char * ","String ");
		StringPair stPair2 = new StringPair("char* ","String ");
		StringPair stPair3 = new StringPair("const char * " ,"String ");
		StringPair stPair4 = new StringPair(" & ", " ");
		StringPair stPair5 = new StringPair("*", " ");
		StringPair stPair6 = new StringPair("unsigned int " ,"int ");
		StringPair stPair7 = new StringPair("unsigned long ","int ");		
		StringPair stPair8 = new StringPair("unsigned char ", "char ");
		StringPair stPair9 = new StringPair("unsigned ","int");
		StringPair stPair10 = new StringPair("const " , "static final ");
			
				
			
		Vector v = new Vector();
		v.addElement(stPair1);
		v.addElement(stPair2);
		v.addElement(stPair3);
		v.addElement(stPair4);
		v.addElement(stPair5);
		v.addElement(stPair6);
		v.addElement(stPair7);
		v.addElement(stPair8);
		v.addElement(stPair9);
		v.addElement(stPair10);




		Replacer rep = new Replacer("c:\\c2j\\java\\makepar.java", v);
		rep.MatchAndReplace();

	}

}
//@@@@@@//
//Contrib/c2j++/par.java
//@@@@@@//
/*
 * Copyright (C) 1996,1997 Morgan Stanley & Co., Inc. 
 * Copyright (C) 1997 Ilya Tilevich
 *
 * This file is part of C2J++.
 * C2J++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation; 
 * either version 2, or (at your option) any later version.
 * C2J++ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with C2J; 
 * see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

import java.io.*;
/**
 * 
 * Purpose: encapsulates an object which only characteristic is
 * its name
 * @version 1.0
 * @author Ilya Tilevich
 * Note: This class was based on the original code written in C++ by Chris Laffra
 */

class SomethingWithAName {
/**
 * 
 * Purpose: Constructor
 * @param strName	the name for the object
 */
public  SomethingWithAName(String strName) {
        m_strName = strName;
}

/**
 * 
 * Purpose: sets name
 * @param strNewName	the name to be set
 */
public void SetName(String strNewName) {
        m_strName = strNewName;
}

/**
 * 
 * Purpose: returns the name of the object
 */

public String GetName()  { return m_strName; }

 protected  String m_strName;
}

/** 
 * 
 * Purpose:  reads, holds, and prints  a list of function
 * parameters
 * @author Ilya Tilevich
 * @version 1.0 December 96
 * Note: This class was based on the original code written in C++ by Chris Laffra
 */

class ParmList
{

private SomethingWithAName m_Name;
private SomethingWithAName m_Type;
private ParmList m_next=null;  //self-referencing data-structure

/**
 * Purpose: Constructor
 * @param strType	the parameter's type
 * @param strName	the parameter's name
 * @param next_		points to the next parameter on the list
 * 
 */

public ParmList(String strType, String strName, ParmList next_){
       m_Name = new SomethingWithAName(strName);
       m_Type = new SomethingWithAName(strType);
       m_next = next_ ;
}

/**
 * Purpose: creates a valid copy of this object
 */
public Object clone(){
	ParmList list = new ParmList(m_Type.GetName(), m_Name.GetName(), m_next);
	return list;
}

/**
 * Returns the parameter's name
 * @return	SomethingWithAName
 *
 */
public SomethingWithAName GetName() {return m_Name; }

/**
 * Returns the parameter's type
 * @return SomethingWithAName
 */
public SomethingWithAName GetType() { return m_Type;}

/**
 * Returns the next parameter on the list
 * @return ParmList
 */

public  ParmList GetNext() { return m_next; }

/**
 * Returns the lenght of the parameters list
 * @return int
 *
 */
public  int length() { return (m_next!=null)? m_next.length() + 1 : 1; }
  
/**
 * Prints the list of parameters to stdio
 */
void printNames(){ 
	if(m_Name.GetName().compareTo("") == 0 || m_Name.GetName().compareTo("void") == 0) return;
	if(m_next!=null && m_next.GetType().GetName().compareTo("") != 0)
		m_next.printNames();
	if(m_next!=null && m_next.GetType().GetName().compareTo("") != 0)
		System.out.print(", ");
	if(m_Name.GetName().compareTo("0") !=0 )
		System.out.println(m_Type.GetName() + " " + m_Name.GetName());
}
 
/**
 * Prints the list of parameters to StringArray object
 * @param lines  the StringArray object to print the parameters to
 *
 */

void printNames(StringArray lines){
if(m_Name.GetName().compareTo("") == 0 || m_Name.GetName().compareTo("void") == 0) return;
	if(m_next!=null && m_next.GetType().GetName().compareTo("") != 0)
		m_next.printNames(lines);
	if(m_next!=null && m_next.GetType().GetName().compareTo("") != 0)
		lines.appendToLastString(", ");
	if(m_Name.GetName().compareTo("0") !=0 && m_Type.GetName().length() > 0 &&
		m_Name.GetName().length() > 0)
		lines.appendToLastString(m_Type.GetName() + " " + m_Name.GetName());
}


/**
 * Prints the list of parameters to Buffer object
 * @param lines  the Buffer object to print the parameters to
 *
 */

void printNames(Buffer lines){
if(m_Name.GetName().compareTo("") == 0 || m_Name.GetName().compareTo("void") == 0) return;
	if(m_next!=null && m_next.GetType().GetName().compareTo("") != 0)
		m_next.printNames(lines);
	if(m_next!=null && m_next.GetType().GetName().compareTo("") != 0)
		lines.Concatenate(", ");
	if(m_Name.GetName().compareTo("0") !=0 && m_Type.GetName().length() > 0 &&
		m_Name.GetName().length() > 0)
		lines.Concatenate(m_Type.GetName() + " " + m_Name.GetName());
}




/**
 * Prints the list of parameters for javadoc utility to DataOutputStream object
 * @param DataOutputStream	the stream to print the list to
 *
 */


 void printAsParms(DataOutputStream dos){
	  if(m_Name.GetName().compareTo("") == 0 || m_Name.GetName().compareTo("void") == 0) return;
	  if(m_next!=null && m_next.GetType().GetName().compareTo("") != 0)
		  m_next.printAsParms(dos);
	  try{
		  if(m_Name.GetName().compareTo("0") !=0 ){
			   dos.writeBytes(" * @param " + m_Name.GetName());
			   dos.writeBytes("\r\n");
		  }
	  }catch(IOException e){}	
  }
	  
 /**
  *	Prints the list of parameters for javadoc utility to StringArray object
  *
  */
 void printAsParms(StringArray lines){
      if(m_Name.GetName().compareTo("") == 0 || m_Name.GetName().compareTo("void") == 0) return;
	  if(m_next!=null && m_next.GetType().GetName().compareTo("") != 0)
		  m_next.printAsParms(lines);
	  
	  if(m_Name.GetName().compareTo("0") !=0 )
		   lines.addElement("* @param " + m_Name.GetName());
	  
  }

 
  /**
  *	Prints the list of parameters for javadoc utility to StringArray object
  *
  */
 void printAsParms(Buffer lines){
      if(m_Name.GetName().compareTo("") == 0 || m_Name.GetName().compareTo("void") == 0) return;
	  if(m_next!=null && m_next.GetType().GetName().compareTo("") != 0)
		  m_next.printAsParms(lines);
	  
	  if(m_Name.GetName().compareTo("0") !=0 ){
		   lines.Concatenate("* @param " + m_Name.GetName());
		   lines.Concatenate("\r\n");
	  }
	  
  }

 
  
  /**
  *	Appends the list of parameters to create a unique functions name to a String object
  *	@param strBuf	a string to appen
  * @return String  the resulting string
  */
 String printTypes(String strBuf){
		
		String strTemp = new String(strBuf);
	    
		if(m_Type.GetName().compareTo("") == 0) return strTemp;
		
		if(m_next!=null)
			strTemp = m_next.printTypes(strBuf);
		
		strTemp += "_";

  		strTemp += m_Type.GetName();
		
		return strTemp;
  }

 /**
  *	Prints the list of parameters to the DataOutputStream
  * @param dos DataOutputStream
  *
  */
 
 void printTypes(DataOutputStream dos){
		if(m_Type.GetName().compareTo("") == 0) return;
		
		if(m_next!=null)
			m_next.printTypes(dos);
		try{
		dos.writeBytes("_");

  		dos.writeBytes(m_Type.GetName());
		}
		catch (IOException e){} 
  }


 /**
  *	Prints the list of parameters to stdio
  *
  */
 void printTypes(){
		if(m_Type.GetName().compareTo("") == 0) return;
		
		if(m_next!=null)
			m_next.printTypes();
		//try{
		System.out.print("_");

  		System.out.print(m_Type.GetName());
		//}
		//catch (IOException e){} 
  }

  /**
   * Prints the list of parameters to the TextOutputStream
   * @param tos		the TextOutputStream to print to
   */
  void printTypes(TextOutputStream tos){
		if(m_Type.GetName().compareTo("") == 0) return;
		
		if(m_next!=null)
			m_next.printTypes(tos);
		try{
		tos.writeBytes("_");

  		tos.writeBytes(m_Type.GetName());
		}
		catch (IOException e){} 
  }


   /**
   * Prints the list of parameters to the StringArray
   * @param lines the StringArray object to print to
   */
  void printTypes(StringArray lines){
	  if(m_Type.GetName().compareTo("") == 0) return;
		
		if(m_next!=null)
			m_next.printTypes(lines);
		
		lines.addElement("_" +  m_Type.GetName());
  }
  
}


 /**
  *	 Encapsulates C++ types  
  *	 @author Ilya Tilevich
  *  @version 1.0 December 96
  */
  class Type{
      /**
	   * Purpose: Consturctor
	   */
	  public Type(){ m_iType = -1;} //default type
	  /**
	   * Purpose: Constructor
	   * @param iType	one of the static final members of this class
	   */
	  public Type(int  iType){	//send Type's static member and iType
            switch(iType){
                case Variable:
                       m_iType = Variable;
                       break;
                case Enum:
                        m_iType = Enum;
                        break;
                case Array:
                        m_iType = Array;
                        break;
                case Method:
                        m_iType = Method;
                        break;
                case InlinedMethod:
                         m_iType = InlinedMethod;
                         break;
                case Constructor:
                         m_iType = Constructor;
                         break;
                case InlinedConstructor:
                          m_iType = InlinedConstructor;
                          break;
                case Destructor:
                          m_iType = Destructor;
                          break;
                case InlinedDestructor:
                          m_iType = InlinedDestructor;
                          break;
                case StaticMethod:
                          m_iType = StaticMethod;
                          break;
                case StaticInlinedMethod:
                          m_iType = StaticInlinedMethod;
                          break;
                default:
                           m_iType = -1;
            }
    }
	/**
	 * Purpose:	 Converts the input parameter to a String
	 * @param iType  the type to convert to a String
	 * @return String	the type's name
	 */
   
	static String toString(int iType){ //might be usefull sometime
      String strReturn;

      switch(iType){
                case Variable:
                       strReturn = "Variable";
                       break;
                case Enum:
                        strReturn = "Enum";
                        break;
                case Array:
                        strReturn = "Array";
                        break;
                case Method:
                        strReturn = "Method";
                        break;
                case InlinedMethod:
                         strReturn = "InlinedMethod";
                         break;
                case Constructor:
                         strReturn = "Constructor";
                         break;
                case InlinedConstructor:
                          strReturn = "InlinedConstuctor";
                          break;
                case Destructor:
                          strReturn = "Destructor";
                          break;
                case InlinedDestructor:
                          strReturn = "InlinedDestructor";
                          break;
                case StaticMethod:
                          strReturn = "StaticMethod";
                          break;
                case StaticInlinedMethod:
                          strReturn = "StaticInlinedMethod";
                          break;
                default:
                           strReturn = "Garbage";
      }

            return strReturn;

    }
    
    static final int Variable  = 0;
    static final int Enum = 1;
    static final int Array = 2;
    static final int Method = 3;
    static final int InlinedMethod = 4;
    static final int Constructor = 5;
    static final int InlinedConstructor = 6;
    static final int Destructor = 7;
    static final int InlinedDestructor = 8;
    static final int StaticMethod = 9;
    static final int StaticInlinedMethod = 10;

    private int m_iType;
	/**
	 * Purpose: returns the type represented by this class
	 * @return int  the type
	 */
    public int GetType() { return m_iType; }
    /**
	 * Purpose: Sets the type for this class
	 * @param iType	the type to set
	 */
	public void SetType(int iType) {m_iType = iType; }
	/**
	 * Purpose: gets a name for the type this class represents which a human can read
	 * @return String	the Stirng representation of this class
	 */
	public String GetTypeAsString() { return toString(m_iType); }
  }






/** 
 * Purpose: Encapsulates C++ member-functions 
 * @version 1.0
 * @author Ilya Tilevich
 * Note: This class was based on the original code written in C++ by Chris Laffra
 */
class ClassMemberRepresentation{

   private SomethingWithAName m_Name;
   private SomethingWithAName m_Type;
   private Type m_ctType;
   private ClassMemberRepresentation m_cmemrepNext = null;
   private ParmList m_parameters;
   private String m_strAccessor;

   /**
    * Purpose: Constructor
	* @param strType	the member-function's return type
	* @param strName	the member-function's name
	* @param member_type_	the member-function's type
	* @param next_	the next ClassMemberRepresentation on the list
	* @param parameters_	the list of parameters
	* @accessor	 the level of accessability for the member
	*/
   
   public  ClassMemberRepresentation(String strType, String strName,
			Type member_type_, ClassMemberRepresentation next_,
			ParmList parameters_,
			String accessor_){
		    m_Name = new SomethingWithAName(strName);
            m_Type = new SomethingWithAName(strType);
	        m_ctType = new Type(member_type_.GetType());
	        m_cmemrepNext = next_;
	        m_parameters = (ParmList) parameters_.clone();
	        m_strAccessor = new String(accessor_);

  }
  
  /**
   * Purpose: Returns member's name
   * @return String
   */
  public String GetName() {return m_Name.GetName();}
  
  /**
   * Purpose: Sets the member's name
   * @param strName
   */
  public void SetName(String strName){m_Name.SetName(strName);}
  
  /**
   * Purpose: Returns the next ClassMemberRepresentation on the list
   * @return ClassMemberRepresentation
   */
  public ClassMemberRepresentation GetNext() { return m_cmemrepNext; }
  
  /**
   * Purpose: Returns the length of the list which starts from the current member
   * @return int
   */
  public int length() { return (m_cmemrepNext != null) ? m_cmemrepNext.length() + 1 : 1; }
  
  /**
   * Purpose: Sets the type for this member
   *
   */
  public void SetMemberType(Type t_) { m_ctType = t_; };
  
  /**
   * Purpose: returns the type for this member
   * @return Type
   */
  public Type GetMemberType() { return m_ctType; };
  
  /**
   * Purpose: Print all the member-functions on the list starting from the current one
   * @param c	the class name to which this member-function belongs
   *
   */
  public void print(ClassRepresentation c){
	  if(m_cmemrepNext != null) m_cmemrepNext.print(c);
	  if(m_ctType.GetType() == Type.Variable || m_ctType.GetType() == Type.Enum){
		  System.out.println(m_Type.GetName() + " " + m_Name.GetName() + ";");
      }
	  else{
		  System.out.println("/**");
		  System.out.print("* ");
		  if(m_Name.GetName().charAt(0) == '~')
			  	  System.out.println("finalize");
		  else
			 System.out.println(GetName());

		  System.out.print("#include " + c.GetName() + "__" + GetName());
		  if(m_Name.GetName().charAt(0) != '~'){
			  if(m_parameters!= null)
				  m_parameters.printTypes();
			  else
				  System.out.println("_void");

			  System.out.println();
			  System.out.println(m_strAccessor);
		  }
		  else System.out.println();

		  System.out.print("#include " + c.GetName() + "__" + GetName());
		  if(m_parameters!= null)
			  m_parameters.printTypes();
		  else
			  System.out.println("void");
		  System.out.println("__body");
	  }
  }	  
  
  
  /**
   * Purpose: Print all the member-functions on the list starting from the current one
   * @param c	the class name to which this member-function belongs
   * @param tos	 TextOutputStream where the member-function is printed to
   */
   public void print(ClassRepresentation c, TextOutputStream tos) throws IOException{
	  if(m_cmemrepNext != null) m_cmemrepNext.print(c, tos);
	  if(m_ctType.GetType() == Type.Variable || m_ctType.GetType() == Type.Enum){
		  tos.writeLine(m_Type.GetName() + " " + m_Name.GetName() + ";");
      }
	  else{
		  tos.writeLine("");
		  tos.writeLine("/**");
		  tos.writeBytes("* ");
		  if(m_Name.GetName().charAt(0) == '~')
			  	  tos.writeLine("finalize");
		  else
			 tos.writeLine(GetName());

		  tos.writeBytes("#include " + c.GetName() + "__" + GetName());
		  
		  if(m_Name.GetName().charAt(0) != '~'){
			  if(m_parameters!= null)
				  m_parameters.printTypes(tos);
			  else
				  tos.writeLine("_void");

			  tos.writeLine("");
			  tos.writeLine(m_strAccessor);
		  }
		  else tos.writeLine("");
		  
		  tos.writeBytes("#include " + c.GetName() + "__" + GetName());
		  if(m_parameters!= null)
			  m_parameters.printTypes(tos);
		  else
			  tos.writeLine("void");
		  tos.writeLine("__body");
	  }
  }	  
  
  
  /**
   * Purpose: sets the level of accessobility for this member-function 
   * @param strAccessor	 public, private, or protected
   */
  public void SetAccessor(String strAccessor_) { m_strAccessor =strAccessor_; };
  
  /**
   * Purpose: Returns the level of accessobility for this member-function
   * @return String
   */
  public String  GetAccessor() { return m_strAccessor; };


}


/**
 * Purpose: Encapsulates a  class representaton
 * @version 1.0 December 96
 * @author Ilya Tilevich
 * Note: This class was based on the original code written in C++ by Chris Laffra
 */
class SuperClassRepresentation extends SomethingWithAName {

  protected  SuperClassRepresentation m_next;  //self-referencing data-structure
  
  /**
   * Purpose: Constructor
   * @param strName the class's name
   * @param next_ the next SuperClassRepresentation on the list
   */
  public SuperClassRepresentation(String strName, SuperClassRepresentation next_){
     super(strName);
     m_next = next_;
  }

  /**
   * Purpose: Returns the next SuperClassRepresentation on the list
   *
   */
  SuperClassRepresentation GetNext() { return m_next; };

}


/** 
 * Purpose: Encapsulates C++ class
 * @version 1.0 December 96
 * @author Ilya Tilevich
 * Note: This class was based on the original code written in C++ by Chris Laffra
 */
class ClassRepresentation extends SomethingWithAName
{

	/**
	 * Purpose: Constructor
	 * @param strName	the class's name
	 * @param next_     the next class on the list
	 * @param bIsSuperClass	the class's place in the hierarchy
	 */
	public ClassRepresentation(String strName, ClassRepresentation next_,
							boolean bIsSuperClass) {
	        super(strName);
	        m_next = next_;
			m_iNumMembers = 0;
			m_SuperClassRep = null;
			m_bNested = false;
			m_bIsSuper = bIsSuperClass;

	}
 
	/**
	 * Purpose: Returns the number of members for this class
	 * @return int
	 */
	public int GetNumberOfMembers() { return m_iNumMembers; }
  
	/**
	 * Purpose: Returns nth member for this class
	 * @param the index of member to get
	 * @return ClassMemberRepresentation if found, null otherwise
	 */
	ClassMemberRepresentation GetMember(int n) { //get n th member
		ClassMemberRepresentation m = m_members;
		for ( ; m!=null && n>0; n--) m = m.GetNext();
		return (m);
    }
  
	/**
	 * Purpose: Sets the members for this class
	 * @param members_	
	 */
	void SetMembers(ClassMemberRepresentation members_) {
		m_members = members_;
		m_iNumMembers = (m_members != null) ? m_members.length() : 0;
	}
  
	/**
	 * Purpose: Sets a super class for this class
	 * @param super_  ClassRepresentation of the super class
	 */
	void addSuperClass(ClassRepresentation super_) {
		m_SuperClassRep = new SuperClassRepresentation(super_.m_strName, m_SuperClassRep);
	}
  
	/**
	 * Purpose: Returns member-functions for this class
	 * @return ClassMemberRepresentation
	 *
	 */
	public ClassMemberRepresentation GetMembers() { return m_members; }
  
	/**
	 * Purpose: Gets the next class on the list
	 *
	 */
	public ClassRepresentation GetNext() { return m_next; }
  
	
	public void SetNext(ClassRepresentation nxtClass) { m_next = nxtClass; }
	/**
	 * Purpose: Gets the super class for this class
	 * @return SuperClassRepresentation
	 *
	 */
	public SuperClassRepresentation GetSuper() { return m_SuperClassRep; };
  
	/**
	 * Purpose: Prints this class to Stdio
	 *
	 */
	public void print(){
		if(m_bIsSuper) return;

		System.out.println("");
		System.out.println("/*");
		System.out.println(" * class " + GetName());
		System.out.println(" * ");
		System.out.println(" * This code has been generated using C2J++");
		System.out.println(" * C2J++ is a Java version of C2J (Courtesy of Morgan Stanley & Co., Inc. and Chris Laffra)");
        System.out.println(" * Read general disclaimer distributed with C2J++ before using this code");
        System.out.println(" * For information about C2J++, send mail to Ilya_Tilevich@ibi.com");
 		System.out.println(" */");
		System.out.println("");
		
		if(m_bNested)
			System.out.print("private ");
		System.out.println("class " + GetName());

		if(m_SuperClassRep!=null && m_SuperClassRep.GetNext()!=null){
			System.out.println(" implements " + m_SuperClassRep.GetNext().GetName());
			if(m_SuperClassRep.GetNext().GetNext()!=null)
				for(SuperClassRepresentation s = m_SuperClassRep.GetNext().GetNext(); s!=null; s=s.GetNext()){
				    System.out.println("[ " + s.GetName() + " ]");
					if(s.GetNext()!= null && s.GetName()!= null)
						System.out.println(", ");
				}
	
		}
	  
  		System.out.println(" {");
		if(m_members!=null)
			m_members.print(this);
		System.out.println("#include  __globals");
		System.out.println("}");
	}

	/**
	 * Purpose: Prints this class to the TextOutputStream
	 * @param tos  the TextOutputStream to print to
	 * @param bIncludeGlobals	tells if global functions and variables have to 
	 * be included in this class
	 */
	public void print(TextOutputStream tos, boolean bIncludeGlobals) throws IOException{
		if(m_bIsSuper) return;

		tos.writeLine("");
		tos.writeLine("/*");
		tos.writeLine(" * class " + GetName());
		tos.writeLine(" * ");
		tos.writeLine(" * This code has been generated using C2J++");
		tos.writeLine(" * C2J++ is based on Chris Laffra's C2J (laffra@ms.com)");
		tos.writeLine(" * Read general disclaimer distributed with C2J++ before using this code");
            tos.writeLine(" * For information about C2J++, send mail to Ilya_Tilevich@ibi.com");
 		tos.writeLine(" */");
		tos.writeLine("");
		
		if(m_bNested)
			tos.writeBytes("private ");
		tos.writeBytes("class " + GetName());

		if(m_SuperClassRep!=null)
			tos.writeBytes(" extends " + m_SuperClassRep.GetName());
		if(m_SuperClassRep!=null && m_SuperClassRep.GetNext()!=null){
			tos.writeBytes(" implements " + m_SuperClassRep.GetNext().GetName());
			if(m_SuperClassRep.GetNext().GetNext()!=null)
				for(SuperClassRepresentation s = m_SuperClassRep.GetNext().GetNext(); s!=null; s=s.GetNext()){
				    tos.writeBytes(" [ " + s.GetName() + " ]");
					if(s.GetNext()!= null && s.GetName()!= null)
						tos.writeBytes(", ");
				}
	
		}
	  	tos.writeLine("");
  		tos.writeLine("{");
		if(m_members!=null)
			m_members.print(this, tos);
		if(bIncludeGlobals)
			tos.writeLine("#include  __globals");
		tos.writeLine("}");
	}

		
	/**
	 * Purpoee: Tells if this class is nested inside another class
	 * @return boolean
	 */
	
	public boolean isNested() { return m_bNested; }
  
	/**
	 * Purpose: Sets the nested attribute for this class
	 * @param nested_ 
	 */
	void SetNested(boolean nested_) { m_bNested = nested_; }


  
	protected ClassMemberRepresentation m_members;  //point to the first member
  
	protected int m_iNumMembers; //num of members
  
	protected boolean m_bIsSuper;
  
	protected boolean  m_bNested;
  
	protected ClassRepresentation m_next;  //self-referencing data-structure
  
	protected SuperClassRepresentation m_SuperClassRep;	 //parent
}


/**
 * Purpose:  Provides a convenient way to write a line of text to TextOutputStream
 * @version 1.0 December 96
 * @author Ilya Tilevich
 * Note: This class was based on the original code written in C++ by Chris Laffra
 */

class TextOutputStream extends DataOutputStream
{
   	/**
	 * Purpose: Constructor
	 * @param out	
	 */
	TextOutputStream(OutputStream  out){
		super(out);
	}

	/**
	 * Purpose: writes a String on a separate line
	 * @param str
	 */
	void writeLine(String str){
	   try{
		   writeBytes(str);
		   writeBytes("\r\n");
		   
	   }catch(IOException e){System.out.println(e);}
   }
}//@@@@@@//
//Contrib/c2j++/parser.java
//@@@@@@//
/*
 * Copyright (C) 1996,1997 Morgan Stanley & Co., Inc. 
 * Copyright (C) 1997 Ilya Tilevich
 *
 * This file is part of C2J++.
 * C2J++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation; 
 * either version 2, or (at your option) any later version.
 * C2J++ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with C2J; 
 * see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

import java.io.*;
import java.util.Vector;
import java.util.Enumeration;
import java.lang.Character;


class Buffer extends Vector
{
	Buffer(int iCapacity){
		super(iCapacity);
	}
	
	public void Add(int iByte){
		addElement(new Character((char)iByte));
	}

	public void Add(char c){
		addElement(new Character(c));
	}
	
	public char At(int iLoc){
		
				
		try{
		    			
			return ((Character) elementAt(iLoc)).charValue();
		 }
		 
		 catch (Throwable e) {System.out.println(e);}
		
			return '$';
	}	

	void Concatenate(Buffer bufOther){
		int iSize = bufOther.size();
		for(int i = 0; i < iSize; i ++)
			addElement(new Character(bufOther.At(i)) );

	}	

	void Concatenate(String strBuf){
		int iLen = strBuf.length();
		for(int i = 0; i < iLen; i++)
		    Add(strBuf.charAt(i));
	}

	boolean StartsWithComment(){
		int iSize = size(), i = 0;
		char ch;
		if(iSize == 0) return false;
		
		do{
			ch = At(i++);
		}while(i < iSize && Character.isSpace(ch));

		if(ch == '/'){
			for(int j = i; j < i+2; j++)
				if(At(j)!='*')
				  return false;
			return true;
		}

		else return false;
	}

	public 	synchronized void WriteOut(){  //to stdio
		
		Enumeration enum = elements();
		
		for(;enum.hasMoreElements();){
			 Character Char = (Character)(enum.nextElement());
			 System.out.print(Char.charValue());
        }
	 
	}

	/**
	 * Purpose: Writes this object to DataOutputStream
	 */
	public 	synchronized void WriteOut(DataOutputStream  dos){
		
		int iSize = size();
		
		
		try{
		
			for(int i = 0; i < iSize; i ++){
				
				char ch = At(i);
				dos.writeByte(At(i));
				
			}
			
		} catch(IOException e){System.out.println("IO error in Buffer WriteOut(dos)");}

	   	 
	}
	   	


}


/**
 * Class Scan
 * Purpose: Scans a source files ignoring white space characters
 * @version 1.1	 January 97
 * @author Ilya Tilevich
 * Note: This class is based on the original code written in C++ by Chris Laffra
 */
class Scanner
{
    private boolean  m_bPutBack = false;		// see getByte()
	private byte m_btPutbackByte = 0;		// see getByte()
	private int  m_iLineNo  = 0;		// the current line number
	protected TokenStack m_tkStack = null;
	 
	protected FileOutputStream m_fosFileOut = null; 
	protected DataOutputStream m_dosDataOut = null;	
	
	private Buffer m_Buffer;

	
	public Buffer GetBuffer() { return m_Buffer; }
	
	protected FileInputStream m_fisFileIn = null;  //source file
	protected BufferedInputStream m_bisBufferedInput = null;
	private DataInputStream m_disDataIn = null;

	/**
	 * m_bEOF indicates if the end of file is reached
	 */
	public boolean m_bEOF = false;

	/**
	 * Scan
	 * Purpose: Constructor
	 * @exception IOException if there are problems with opening a temp file   
	 */
	
	public Scanner(){
	
		m_bPutBack = false;		// see getByte()
	    m_btPutbackByte = 0;		// see getByte()
	    m_iLineNo  = 0;		// the current line number
	    m_tkStack = new TokenStack();
	 	
		try{
			m_fosFileOut = new  FileOutputStream("__temp__");
			m_dosDataOut = new DataOutputStream(m_fosFileOut);	
		}catch(IOException e){};

			
	}

	/**
	 * OpenInputFile
	 * Purpose: opens a source file for scanning and reinitializes member variables
	 * @param strInFile		the name for the source file
	 * @exception FileNotFoundException		if strInFile doesn't exist
	 * @exception Throwable		if there are problems with opening the file
	 */
	 	
	public void OpenInputFile(String strInFile){
	
	   try{
	       
		   m_fisFileIn = new FileInputStream(strInFile);
		   m_bisBufferedInput = new BufferedInputStream(m_fisFileIn);
		   m_disDataIn  = new DataInputStream(m_bisBufferedInput);

		   
				
	   }
		catch(FileNotFoundException e){
		    System.out.println("File Not Found");
		    return;
	    }
		catch(Throwable e) {
	        System.out.println("Error in opening file");
	        return;
	    }

		

		//When open a new file for reading, reset all member variables;
		m_tkStack = new TokenStack();
		m_Buffer = new Buffer(1024);

		m_bPutBack = false;		
	    m_btPutbackByte = 0;		
	    m_iLineNo  = 0;		
		m_bEOF = false;
		

	}

	public void CloseAllFiles(){
		   
		try{	
		   m_bisBufferedInput.close();   
		   m_disDataIn.close();   
		   m_fisFileIn.close();
		   
		   
	   
		   m_dosDataOut.close();
		   m_fosFileOut.close();
		}catch(IOException e){System.out.println(e);}
	}
	
	public void FlushBuffer(){
		m_Buffer.setSize(0);
	}
	
	
	public void WriteBuffer(){
		int iSize = m_Buffer.size();
		try{

		for(int i = 0; i < iSize; i ++){
			m_dosDataOut.writeByte(m_Buffer.At(i));
			///System.out.print(m_Buffer.At(i));
		}
		
		}catch(IOException e){System.out.println("Error in WriteBuffer()");}
		FlushBuffer();	
	}
	
	public boolean BufferStartsWithComment(){
		return m_Buffer.StartsWithComment();
	}

	/**
	 * getByte()
	 * Purpose: gets a byte from the input stream or a m_btPutbackByte
	 * Ignores '\r' 
	 * @return byte read
	 * @exception IOException if  there are problems with reading the file
	 * @exception Throwable		if there are problems writing to the temp file
	 */
	
	private byte getByte()
	{
	  if(m_bPutBack){
		  m_bPutBack = false;
		  return m_btPutbackByte;
	  }

	  int iCh = 0;
	  
	  try{
		  
		  if((iCh = m_disDataIn.read())!=-1){
			  //char ch = (char) iCh;
			  if(iCh == '\r'){ 
				  m_Buffer.Add(iCh);
				  return getByte();
			  }
			  if(iCh == '\n')  m_iLineNo++;

		  }

		  else
			  m_bEOF = true;
		  

		    //if(dosDataOut != null && iCh!= -1){
			//dosDataOut.writeByte(iCh);
			 
			// if(iCh == '\n') dosDataOut.writeBytes("  ");
		    //}

	  }
	  catch(IOException e) {
	          System.out.println("Error in reading file");
	  }


	  catch(Throwable e){
			System.out.println("Error in writing to file");
	  }
	
	    if(!m_bEOF)
			m_Buffer.Add(iCh);
	    return  (byte)iCh;
	  
	
	}

	/**
	 * ungetByte
	 * Purpose: put back a byte just read by getByte() method
	 * This method is used in this class and is called from Parse
	 * @param b the byte to put back	
	 */
	protected void ungetByte(byte b)
	{
		m_bPutBack = true;
		m_btPutbackByte = b;
	}
	
	/**
	 * isIdentifier
	 * Purpose: determines if the input param is a part of a legal C identifier
	 * @param b the byte to examine
	 * @return true if b can be a part of a C identifier, false otherwise
	 */
	
	public static boolean isIdentifier(byte b) { return Character.isLetterOrDigit((char)b) || b == '_'; }
	
	public  static  boolean isOperator(byte b){
		
		return (b == '!'||
				b == '^'||
				b == '&'||
				b == '*'||
				b == '-'||
				b == '+'||
				b == '='||
				b == '|'||
				b == '<'||
				b == '>'||
				b == '~');
	}
	
	
	/**
	 * skipSpaces
	 * Purpose: reads the source file until it encounters a byte other than space
	 */
	
	private void skipSpaces()
	{
		byte b;
		do{ 
			b = getByte(); 
			}while (b == ' '|| b == 10 || b == 9);
		ungetByte(b);
	}
	
	/**
	 * ByteArrayToString 
	 * Purpose: converts an array of bytes to a Java String
	 * @param	btArray[]	the array of bytes
	 * @param	iSize	the size of the btArray[]
	 */
	
	protected String ByteArrayToString(byte btArray[], int iSize)
	{
				String str = new String();
				for(int i = 0; i< iSize; ++i)
					str += (char)btArray[i];

		  		 return str;
	}

	/**
	 * getWord
	 * Purpose: Gets a word from the input stream and pushes it 
	 * into the ParseStack
	 * @param strBuf[]	a temporary array of bytes
	 * @param iBufSize	a maximum size of the word to be gotten
	 * @return the word read
	 */
	
	public String getWord(byte strBuf[], int iBufSize)
	{

	   skipSpaces();
	   int iN;
	   for(iN = 0; iN < iBufSize && !m_bEOF; ++iN){
		   if(iN < iBufSize)  strBuf[iN] = getByte();

		   if(strBuf[iN] == '/'){        //skip comments

			   if(iN < iBufSize-1) strBuf[++iN] = getByte();

			if(strBuf[iN] == '/') { 		  //the '//' form
				 do{
					 if(iN < iBufSize) strBuf[++iN] = getByte();
				 }while(iN < iBufSize && !m_bEOF && strBuf[iN]!='\n');

				 //try{
				//	WriteBuffer(); //don't throw away comments
				 //}catch(IOException e){}
				 
				 return getWord(strBuf, iBufSize);
			}
			  else if(strBuf[iN] == '*'){           //the '/*' form
				  boolean bWatchForSlash = false;
				  while(iN < iBufSize && !m_bEOF){
					 do{
						 if(iN < iBufSize) strBuf[iN] = getByte();
						 if(bWatchForSlash && strBuf[iN] == '/') break;
						 else bWatchForSlash = false;
					 }while(iN < iBufSize && !m_bEOF && strBuf[iN] != '*');
					 if(iN < iBufSize && strBuf[iN] != '/' && !m_bEOF) strBuf[iN] = getByte();
					 if(strBuf[iN] == '/'){
						 bWatchForSlash = false;
						 break;
					 }
					 else if(strBuf[iN] == '*') bWatchForSlash = true;					 
				  }
				 
				 //try{
				 //	WriteBuffer(); //don't throw away comments
				 //}catch (IOException e) {}
				 return getWord(strBuf, iBufSize);
			  }
			  else {
				  if(iN > 0) ungetByte(strBuf[iN--]);
			  }
		   }

			if(strBuf[iN] == '#'){           //skip preprocessor
			   byte b;
			   do{
				   b = getByte();
				   if(b == '\\') { b = getByte(); b = getByte(); }
			   }while(!m_bEOF && b != '\n');
			   //try{
			   //WriteBuffer(); //don't throw away preprocessor
			   //}catch (IOException e){}
			   return getWord(strBuf, iBufSize);
			}

			if(strBuf[iN] == '\'') {         //character constant
				do{
					if(iN < iBufSize) strBuf[++iN] = getByte();
					if(strBuf[iN] == '\\'){
						if(iN < iBufSize) strBuf[++iN] = getByte();
						if(iN < iBufSize) strBuf[++iN] = getByte();
					}
				}while(iN < iBufSize && m_bEOF && strBuf[iN]!='\'');

                return ByteArrayToString(strBuf, iN + 1);

	        }

	        if(strBuf[iN] == '"'){              //string constant
	            do{
	                if(iN < iBufSize-1) strBuf[++iN] = getByte();
	                if(strBuf[iN] == '\\'){
	                    if(iN < iBufSize-1) strBuf[++iN] = getByte();
	                    if(iN < iBufSize-1) strBuf[++iN] = getByte();
					}
				}while(iN < iBufSize && !m_bEOF &&  strBuf[iN] !='"');

	            return ByteArrayToString(strBuf, iN+1);
	        }

	        
							 
			if(!isIdentifier(strBuf[iN])) break;
	} //end of for


	if(iN > 0) ungetByte(strBuf[iN--]);

	String str = ByteArrayToString(strBuf, iN+1);
	m_tkStack.push(str);
	if(m_bEOF) return (str = "");
	return str;

}

public static void main(String[] args) throws IOException {
Scanner s = new Scanner();
s.OpenInputFile("t.1");

while(!s.m_bEOF)
    byte b = s.getByte();

   s.WriteBuffer();
}



}

/**
 * class Parser
 * Purpose: parse a C++ source file(s)
 * @version 1.0 December 96
 * @author Ilya Tilevich
 *  Note: This class is based on the original code written in C++ by Chris Laffra
 */
 
class Parser
{
    
		
	static final int m_iBufSize = 516;
	
	static final boolean  m_bDebug = false;

	static final String PUBLIC = "public ";
	static final String PRIVATE = "private ";
	static final String PROTECTED = "protected";
	String m_strAccessor = "protected";
	MembersArray m_membersArray; //array of all member functions
	Scanner m_scan;
	private boolean m_bParseMethods; //if true parse Cpp file, H file otherwise
	FileOutputStream m_fosFileOut; 

	static TextOutputStream m_tos; //the output file
	//protected StringArray m_linesGlobal;	//contains all global C functions
	protected Buffer m_linesGlobal;	//contains all global C functions
	
	boolean m_bDefnOnly; //don't write function bodies
	/**
	 * Parser
	 * Purpose: Constructor
	 * @param bCppFile	specifies which parsing method to choose
	 * @exception	if temp file cannot be open
	 */
	
	public Parser(boolean bCppFile){
		  
		 m_bParseMethods = bCppFile; //if true be ready to parse C++ file
		  
		  m_membersArray = new MembersArray();
	      
		  m_scan = new Scanner();
		  
		  m_linesGlobal = new Buffer(1024);
		  
		  m_bCommaSeen = false;
        
		  m_bInsideEnum = false;

	 }

	/**
	 * SetParserMethod
	 * Purpose: unstructs the parser to parse a header or an implementation file
	 * @param bCpp	If false - parser a header, it true parse a cpp file
	 */
	
	public void SetParseMethod(boolean bCpp){
		m_bParseMethods = bCpp;
			
	}
	
	/**
	 * OpenOutputFile
	 * Purpose: opens the output file for input and resets all parse member 
	 * variables
	 * @param	strInFile the source file name
	 */
	
	public void OpenInputFile(String strInFile){
		
		String m_strAccessor = "protected";

	    ClassRepresentation cpCache = null;		   
        
		strCacheClassName = new String();	
        
		class_info = null;
		
		m_strInitializer = null;
		
		m_bCommaSeen = false;
        
		m_bInsideEnum = false;
		
		strReadName = ""; 
        
		strReadType = ""; 
        
		paramList = null;
	 	
		m_strAccessor = new String();
		
		strCacheClassName = new String(); 
		
		class_info = null;
		
		m_bCommaSeen = false;
        
		m_bInsideEnum = false;


		m_scan.OpenInputFile(strInFile);
	
	}	
	
	public void CloseAllFiles(){
		m_scan.CloseAllFiles();
	}
	
	/**
	 * isCKeyword
	 * Purpose: checks out if the input parameter is a valid C keyword
	 * @param str  a word to check out
	 * @return true is str is a valid C keyword, false otherwise
	 */
	
	public static boolean isCKeyword(String str){
		if(str.compareTo("break") == 0 || 
		   str.compareTo("case") == 0 || 
		   str.compareTo("char") == 0 || 
		   str.compareTo("const") == 0 || 
		   str.compareTo("continue") == 0 || 
		   str.compareTo("default") == 0 || 
		   str.compareTo("delete") == 0 ||
		   str.compareTo("do") == 0 || 
		   str.compareTo("double") == 0 || 
		   str.compareTo("else") == 0 || 
		   str.compareTo("enum") == 0 || 
		   str.compareTo("extern") == 0 || 
		   str.compareTo("float") == 0 || 
		   str.compareTo("for") == 0 || 
		   str.compareTo("goto") == 0 || 
		   str.compareTo("if") == 0 || 
		   str.compareTo("int") == 0 || 
		   str.compareTo("long") == 0 || 
		   str.compareTo("new") == 0 ||
		   str.compareTo("register") == 0 || 
		   str.compareTo("return") == 0 || 
		   str.compareTo("short") == 0 || 
		   str.compareTo("signed") == 0 || 
		   str.compareTo("sizeof") == 0 || 
		   str.compareTo("static") == 0 || 
		   str.compareTo("struct") == 0 || 
		   str.compareTo("switch") == 0 || 
		   str.compareTo("typedef") == 0 || 
		   str.compareTo("union") == 0 || 
		   str.compareTo("unsigned") == 0 || 
		   str.compareTo("void") == 0 || 
		   str.compareTo("volatile") == 0 || 
		   str.compareTo("while") == 0)
		   		   return true;
		return false;
	}
		   

/**
 * isConstCharOrString
 * Purpose: finds out if the input parameter is a constant char of form 'x' or
 * a quoted string
 * @param str a word to check out
 * @return true if str is a const char or str, false otherwise
 */

protected boolean isConstCharOrString(String str){
	int iSize = str.length();
	return ((str.charAt(0) == '"'	&& str.charAt(iSize-1) == '"') || 
		    (str.charAt(0) == '\'' &&  str.charAt(iSize-1) ==  '\''));
}


/**
 * skipWord
 * Purpose: reads a word from the input stream
 * @return the word read right after the skipped one
 */

private String skipWord()
{
	byte btArray[] = new byte[m_iBufSize];
	return m_scan.getWord(btArray, m_iBufSize);
}

/**
 * findWord
 * Purpose: fins a word in the source file
 * @param strToFind		word to look for
 * @return true if the word was found, false if the end of file was reached
 */

private boolean findWord(String strToFind)
{
	String str;
	if(m_bDebug) System.out.println("strToFind is " + strToFind);
	byte btArray[] = new byte[m_iBufSize];
	do{
		str = m_scan.getWord(btArray, m_iBufSize);
		if(str.compareTo("") == 0) return false;
	}while(str.compareTo(strToFind) != 0);

	return true;
}

/**
 * findAndDoNotSkipWord
 * Purpose: searches for a word in the  source file until either 
 * the word to search is found or strDontSkip is encountered
 * @param	strWordToFind	the search word
 * @param	strDontSkip		the word not to be skipped
 * @return	true if the word was found, false if the strDontSkip
 * was encountered or end of file was reached
 */

boolean findAndDoNotSkipWord(String strWordToFind, String strDontSkip)
{
	if(m_bDebug) System.out.println("findAndDontSkipWord " + strWordToFind + " ," +
		strDontSkip);
	byte btArray[] = new byte[m_iBufSize];
	String str;
	do{
		
		str = m_scan.getWord(btArray, m_iBufSize);
		if(str.compareTo("") == 0) return false;
		if(m_bDebug) System.out.println("m_scan.getWord() -> \"" + str);
		if(str.compareTo(strDontSkip) == 0) return false;
	
	}while(str.compareTo(strWordToFind) != 0);

	return true;
}

/**
 * skipMatching
 * Purpose: read the function body between strWordToSkip and strWordtoFind
 * putting the words read into strArray.
 * ; character serves as a signal to start entering a new element into strArray
 * @param strWordToSkip		the word to be skipped
 * @param strWordToFind		the word to find
 * @param strArray	array  to hold the function's body
 * @return false if the end of the file was reached, true otherwise
 */


boolean skipMatching(String strWordToSkip, String strWordToFind, StringArray strArray)
{
  
	
	if(m_bDebug) System.out.println("skipMatching( " + strWordToSkip + " , "
	                   + strWordToFind);
   byte btArray[] = new byte[m_iBufSize];
   String str;
   boolean bNewLine = true;
   do{
	   str = m_scan.getWord(btArray, m_iBufSize);
	   if(str.compareTo("") == 0) return false;
	   if(str.compareTo("for") == 0){ //take care of for loop
	      
		  strArray.addElement(str);
		  str = m_scan.getWord(btArray, m_iBufSize);
	   	  if(str.compareTo("") == 0) return false;
		  else if(str.compareTo("(") == 0){
			  strArray.appendToLastString(str);
			  while(str.compareTo(")")!= 0 && str.compareTo("") !=0){
	   			 str = m_scan.getWord(btArray, m_iBufSize);
		      	 if(isCKeyword(str))
		             str += " ";
	   	  		 strArray.appendToLastString(str);
			  }	//while
	   	  bNewLine = true;
		  }//else if
	   	  continue;
	   }
		if(str.compareTo("}") == 0 || str.compareTo("{") == 0)
		   bNewLine = true;
	   else if(isCKeyword(str))
		   str += " ";
	   if(str.compareTo(";") == 0 || str.compareTo("';") == 0){
		   bNewLine = true;
	   	   strArray.appendToLastString(str);
	   }
	   if(!bNewLine)
		   strArray.appendToLastString(str);
	   else if(bNewLine && str.compareTo(";")!=0 && str.compareTo("';")!=0  ){
	       if(str.compareTo("{") != 0  &&  str.compareTo("}") != 0)
				strArray.addElement(" " + str);
	   	   else 
			   strArray.addElement(str);
		   bNewLine = false;
	   }
	   
	   if(str.endsWith("}") || str.endsWith("{"))
		   bNewLine = true;
	   if(m_bDebug) System.out.println("    " + str);
	   if(str.compareTo(strWordToSkip) == 0)
		   skipMatching(strWordToSkip, strWordToFind, strArray);
   }while(str.compareTo(strWordToFind) !=0 );

   return true;
}

boolean skipMatching(String strWordToSkip, String strWordToFind)
{
   	
   if(m_bDebug) System.out.println("skipMatching( " + strWordToSkip + " , "
	                   + strWordToFind);
   byte btArray[] = new byte[m_iBufSize];
   
   boolean bNewLine = true;
   
   String str;
   do{
	   str = m_scan.getWord(btArray, m_iBufSize);
	   if( str.compareTo("")==0 ) 
		   return false;
	   else if(str.compareTo(strWordToSkip) == 0)
		   skipMatching(strWordToSkip, strWordToFind);
   
   }while(str.compareTo(strWordToFind) !=0 );

   
   return true;
}




private ClassRepresentation cpCache = null;		   
private String strCacheClassName;	
protected ClassRepresentation class_info = null;

/**
 * findClass
 * Purpose: determines if class with a given name already has a ClassRepresentation
 * uses strCacheClassName to hold a name of the last found class
 * @param strClassName  the class name to find
 * @param bIsSuper	specifies if the class to find is a super class
 * @return	ClassRepresentation of the found class
 *
 */
 

ClassRepresentation findClass(String strClassName, boolean bIsSuper)
{
	
	ClassRepresentation c, d;
	if(cpCache!=null && strClassName.compareTo(strCacheClassName) == 0) return cpCache;
	for(c = class_info; c!=null;c = c.GetNext())
		if(c.GetName().compareTo(strClassName) == 0){
			cpCache = c;
			strCacheClassName = strClassName;
			return c;
		}
		/*c = new ClassRepresentation(strClassName, class_info, bIsSuper);
		class_info = c;
		*/
	c = new ClassRepresentation(strClassName, null, bIsSuper);
	
	if(class_info == null) 
			class_info = c;
	else {
		for(d = class_info; d.GetNext() != null; d = d.GetNext());
		d.SetNext(c); //add to the head of the list
	}		
	
	return c;
}


/**
 * setSuperClass
 * Purpose: sets a super class for a class named strClassName
 * @param	strClass the class name to have a super class set for
 * @param	strSuperClass	the name of the super class
 *
 */
 

void setSuperClass(String strClassName, String strSuperClassName)
{
	if(strSuperClassName.compareTo(",") == 0) return;
	if(m_bDebug) System.out.println("setSuperClass( " + strClassName + " , " +
									strSuperClassName);
	ClassRepresentation c1 = findClass(strClassName, false);
	ClassRepresentation c2 = findClass(strSuperClassName, true);
	c1.addSuperClass(c2);
}

/**
 * readSuperClasses
 * Purpose: determines if the class named strClassName is a child class
 * @param	strClassName	the class to be investigated
 * @return true if class is followed by a valid class definition,
 * false otherwise
 *
 */

boolean readSuperClasses(String strClassName)
{
	if(m_bDebug) System.out.println("readSuperClasses( " + strClassName);
	byte btArray[] = new byte[m_iBufSize];
	String str;
	while(true){
		str = m_scan.getWord(btArray, m_iBufSize);
		if(str.compareTo("") == 0) return false;
		if(m_bDebug) System.out.println("m_scan.getWord() -> " + str);
		if(str.compareTo(":") == 0) continue;
		if(str.compareTo("public") == 0) continue;
		if(str.compareTo("private") == 0) continue;
		if(str.compareTo("protected") == 0) continue;
		if(str.compareTo("{") == 0) break;
		if(str.compareTo(";") == 0) return false;
		else setSuperClass(strClassName, str);
	}

	return true;

}  

/**
 * readGlobalBody
 * Purpose: read a global function and store it's body in m_linesGlobal array
 * @param strMemberName		the function name
 * @param str	the function return type
 * @param parameters	the function's parameters list
 *
 */
void readGlobalBody(String strMemberName, String strType,  ParmList parameters){
						
 	m_linesGlobal.Concatenate("\r\n/**\r\n");

	if(parameters != null)
		parameters.printAsParms(m_linesGlobal);

	if(strType.compareTo("void") != 0 &&
		strType.compareTo(":") != 0 &&
	   strType.compareTo(";") != 0 &&
	   strType.compareTo("}") != 0)
	       m_linesGlobal .Concatenate("* @return " + strType + "\r\n");
	m_linesGlobal.Concatenate("*/\r\n");
	
	
	
	if(strType.compareTo(":") !=0 && strType.compareTo(";") != 0 && strType.compareTo("}") !=0 ){
		  
		m_linesGlobal.Concatenate("static " + strType + " ");
	}
		
		
	if(parameters != null){ 
			m_linesGlobal.Concatenate(strMemberName + "(");
			parameters.printNames(m_linesGlobal);
			m_linesGlobal.Concatenate(")\r\n{");
	}
		
	else
		   m_linesGlobal.Concatenate(strMemberName + "()\r\n{");
			
		
	
	//m_strInitializer = "";
	
	
	m_scan.FlushBuffer(); //clear the buffer 
	skipMatching("{", "}");
	
	if(!m_bDefnOnly)
		m_linesGlobal.Concatenate(m_scan.GetBuffer());
    else
		m_linesGlobal.Concatenate("\n}");
	
	
}	
/**
 * addGlobals
 * Purpose: adds the array of global functions and variables to the m_membersArray
 * Note: this function should be called when the parsing if over
 *
 */


public void addGlobals(){

	MemberBody memBodies = new MemberBody("__globals",  m_linesGlobal); //the actual body
	m_membersArray.addElement(memBodies); 
}	
//////////////
private String m_strInitializer; //constructor initialize list
/**
 * readMemberBody
 * Purpose: reads the class method's body; generates comments and adds both
 * the comments and the body to m_membersArray 
 * @param strClassName		the function's class name
 * @param strMemberName		the function's name
 * @strType		the function's return type
 * @parameters	the function's parameters list
 */

void readMemberBody(String strClassName, String strMemberName, String strType,
					ParmList parameters){
						
 	Buffer lines1 = new Buffer(1024);
	Buffer lines2;

	MemberBody memBody1, memBody2;
	String strMemName = new String(); //a unique name which represents a functions
	//in m_membersArray;
	strMemName = strClassName;
	strMemName += "__";
	strMemName += strMemberName;
	if(parameters != null)
		strMemName = parameters.printTypes(strMemName);

	if(parameters != null)
		parameters.printAsParms(lines1);

	if(strType.compareTo("void") != 0 &&
		strType.compareTo(":") != 0 &&
	   strType.compareTo(";") != 0 &&
	   strType.compareTo("}") != 0 &&
	   strClassName.compareTo(strMemberName) != 0)
	   	    lines1.Concatenate("* @return " + strType + "\r\n");
	lines1.Concatenate("*/");
	memBody1 = new MemberBody(strMemName, lines1); //contains only comments
	
	
	lines2 = new Buffer(1024);

	strMemName += "__body";

	if(strType.compareTo(":") !=0 && strType.compareTo(";") != 0 && strType.compareTo("}") !=0 ){
		if(strClassName.compareTo(strMemberName) != 0)
		    lines2.Concatenate(strType + " ");
	 	else  
			lines2.Concatenate(strType);
	}
		
	if(strMemberName.charAt(0) == '~')  //destructor
		lines2.Concatenate("void finalize() {");
		
	else{
		
		if(parameters != null){ 
			lines2.Concatenate(strMemberName + "(");
			parameters.printNames(lines2);
			lines2.Concatenate(")\r\n{");
		}
		
		else
			lines2.Concatenate(strMemberName + "()\r\n{");
			
		
		
	}
	
	if(m_strInitializer != null)
		lines2.Concatenate(m_strInitializer);
	m_strInitializer = "";
	
	m_scan.FlushBuffer(); //clear the buffer 
	skipMatching("{", "}");
	
	if(!m_bDefnOnly)
		lines2.Concatenate(m_scan.GetBuffer());
    else
		lines2.Concatenate("\n}");
	///concat to lines2
	memBody2 = new MemberBody(strMemName, lines2); //the actual body
	

	m_membersArray.addElement(memBody1); 
	m_membersArray.addElement(memBody2);

}	
 
private boolean m_bCommaSeen = false;
private boolean m_bInsideEnum = false;
private int		m_iEnumValue = 0;
/**
 * readMember
 * Purpose: reads a class member either a variable or a method
 * @param strClassName  the class name
 * @param type	type of a member (constructor, variable ...)
 * @return false if the end of class defintio of the end of file was reached
 * true otherwise
 *
 */


boolean readMember(String strClassName, Type type) {
	
	byte btArray[] = new byte[m_iBufSize];
	
	if(m_bDebug) System.out.println(" readMember(" + strClassName + " " + strReadName + " " + strReadType);
	
	String strSeparator = new String();
	
	boolean bIsStatic = false;
	
	strReadName = "";
	
	if(m_bCommaSeen){
		if(m_bDebug) System.out.println("comma seen, continue with type " + strReadType);
	}
	else{
		if((strReadType = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
		if(m_bDebug) System.out.println("first word " + strReadType);
	}

	if(strReadType.compareTo("public") == 0){
		m_strAccessor = "public";
		skipWord(); return true;
    }
	else if(strReadType.compareTo("private") == 0){
		m_strAccessor = "private";
		skipWord(); return true;
	}
	else if(strReadType.compareTo("protected") == 0){
		m_strAccessor = "protected";
	    skipWord(); return true;
	}
	else if(strReadType.compareTo("enum") == 0){
		if(m_bDebug) System.out.println("enum " + strReadType);
		if(!findAndDoNotSkipWord("{", ";"))
			return false;
		if((strReadType = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
		m_bInsideEnum = true;
	}
	if(m_bInsideEnum){
		if(strReadType.compareTo("}") == 0){      //matching {
			m_bInsideEnum = false;
			return true;
		}
		strReadName = strReadType;
		if((strSeparator = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
		if(strSeparator.compareTo("=") == 0) {
			if((strSeparator = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
			strReadName += " = ";
			m_iEnumValue = new Integer(strSeparator).intValue() + 1;
			strReadName += strSeparator;
			if((strSeparator = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
		}
		
		else if(!strSeparator.equals("=")){
			strReadName += " = ";
			strReadName += String.valueOf(m_iEnumValue++);
		}
		if(strSeparator.compareTo("}") == 0) { //matching {
			m_iEnumValue = 0;
			m_bInsideEnum = false;
		}
		
		
		strReadType = "static final int";
		if(m_bDebug) System.out.println("enum " +  strReadName);
		type.SetType(Type.Variable);
		return true;
	    }

	
	StringArray lines = new StringArray();
	if(strReadType.compareTo("{") == 0) {
		lines = new StringArray();
		skipMatching(strReadType, "}"); 
		return true;
	}

	if(strReadType.compareTo("}") == 0) {
		m_scan.ungetByte((byte)strReadType.charAt(0));
		m_bCommaSeen = false;
		return false;
	}
	if(strReadType.compareTo(";") == 0) return true;
	if(strReadType.compareTo("class") == 0 ||
		strReadType.compareTo("struct") == 0){
		String strName = new String();
		String strNestedClassName;
		if((strNestedClassName = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0)
			return true;
		if(m_bDebug) System.out.println("nested_class_name " + strNestedClassName);
		if(readSuperClasses(strName)){
			strName = strClassName;
			strName += strNestedClassName;
			readClassBody(strName);
			findClass(strName, false).SetNested(true);
			skipMatching("{", "}");
			if((strSeparator = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0)
				return false;
			return true;
		}
	}

	if((strReadName = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0)
		return false;
	if(m_bDebug) System.out.println("name = " + strReadName);

	if(strReadName.compareTo("(") == 0){
		strReadName = strReadType;
		if(m_bDebug) System.out.println("Before Constuructor");
		paramList = readParmList();

		if(findAndDoNotSkipWord("{", ";")){
			if(strReadName.compareTo(strClassName) == 0){
				type.SetType(Type.InlinedConstructor);
				readMemberBody(strReadName, strReadName, "", paramList);
			} 
			else{
				readMemberBody(strReadName, strReadName, "", paramList);
				return true;
			}
		}
		else
			type.SetType(Type.Constructor);
		if(m_bDebug)System.out.println("found constructor");
		return true;
	}
	

	if(strReadType.compareTo("~") == 0){
		strReadType += strReadName;
		strReadName = strReadType;
		strReadType = "";
		paramList = readParmList();
		if(findAndDoNotSkipWord("{", ";")){
			type.SetType(Type.InlinedDestructor);
			readMemberBody(strReadName.substring(1),strReadName, "", paramList);
		}
		else
			type.SetType(Type.Destructor);
			 if(m_bDebug) System.out.println("found destructor");
			 return true;
	}
	if(strReadName.compareTo("{") == 0) {skipMatching("{", "}"); return true;}
	if(strReadName.compareTo("}") == 0) {m_scan.ungetByte((byte)'}'); m_bCommaSeen = false; return false;}
	if(strReadName.compareTo(";") == 0) {m_scan.ungetByte((byte)';'); return true;}

	type.SetType(Type.Variable);

	for(;;){
		if(strReadType.compareTo("static") == 0) bIsStatic = true;
		if((strSeparator=m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
		if(m_bDebug) System.out.println("separator= " + strSeparator);

		if(strSeparator.compareTo("}") == 0) { m_scan.ungetByte((byte)'}'); m_bCommaSeen = false; return false;}
		if(strSeparator.compareTo("{") == 0){
			skipMatching("{", "}");
		}
		if(strSeparator.compareTo("[") == 0){
			skipMatching("[", "]");
			type.SetType(Type.Array);
			break;
		}
		if(strSeparator.compareTo("(") == 0){          //read member parameters
			if(m_bDebug){ System.out.println("Seen start of function");
			              System.out.println("before readParmList"); }
			paramList  = readParmList();
			if(m_bDebug)
			System.out.println("after read parmList found a method "); 

			if(findAndDoNotSkipWord("{", ";")) { //}
				if(strReadName.compareTo("=") == 0 ||
				   strReadName.compareTo("!=") == 0 || 
				   strReadName.compareTo("==") == 0 ||
				   strReadName.compareTo("new") == 0 ||
				   strReadName.compareTo("delete") == 0)
						bIsStatic = true;
				readMemberBody(strClassName, strReadName, strReadType, paramList);
				if(bIsStatic)type.SetType(Type.StaticInlinedMethod);
				else type.SetType(Type.InlinedMethod);
			}
			else{
				if(bIsStatic)
					type.SetType(Type.StaticMethod);
				else type.SetType(Type.Method);
			}

			if(m_bDebug)System.out.println("end of function");
			break;
		}

		if(strSeparator.compareTo(";") == 0){
			m_bCommaSeen = false;
			break;
		}
		if(strSeparator.compareTo(",") == 0){
			m_bCommaSeen = true;
			return true;
		}

		else if(strReadName.compareTo("*") == 0)  //Replacer will take care of it
			strReadType += " " + strReadName;
		else if(strReadName.compareTo("&") == 0) 
			strReadType += " " + strReadName;
		else  strReadType = strReadName;        //.substring(0, m_iBufSize -1);
		
		strReadName = strSeparator;  //strType.substring(0, m_iBufSize -1);
	
	} 

	if(strReadType.compareTo(":") == 0) strReadType = "";
	return true;


}	

/**
 * findMember
 * Purpose: finds a class member which was previously read
 * @param strClassName	the class name
 * @param strMethodName	the name of the member to be found
 * @return ClassMemberRepresentation of the found member, or null if 
 * the member was not found
 *
 */

ClassMemberRepresentation findMember(String strClassName, String strMethodName)
{

   ClassRepresentation c = findClass(strClassName, false);
   if(c!=null)
	  for(ClassMemberRepresentation m = c.GetMembers(); m!=null; m = m.GetNext())
	      if(m.GetName().compareTo(strMethodName) == 0) return m;
   return null;


}	

/**
 * isStaticMethod
 * not being used
 *
 */
boolean isStaticMethod(String strClassName, String strMethodName)
{
	if(strMethodName.compareTo("=") == 0 ||
	   strMethodName.compareTo("!=") == 0 ||
	   strMethodName.compareTo("==") == 0 ||
	   strMethodName.compareTo("new") == 0 ||
	   strMethodName.compareTo("delete") == 0)
	    return true;
	ClassMemberRepresentation m = findMember(strClassName, strMethodName);
    if(m == null)
		return true;

	return (m.GetMemberType().GetType() == Type.StaticMethod || 
		m.GetMemberType().GetType() == Type.StaticInlinedMethod);

}

/**
 * isAValidName
 * Purpose: determines if the strName is a valid token
 * @param strName the word to be checked
 * @return boolean
 *
 */

boolean isAValidName(String strName)
{

   return(strName!=null && strName.length() > 0 && strName.charAt(0)!=';');
}


String strReadName; //Since it is not possible to  pass Strings by reference for modifications
String strReadType; 
ParmList paramList;
/**
 * readClassBody
 * Purpose: parse the class definition
 * @param strClassName	the class name
 */

void readClassBody(String strClassName) 
{
	if(m_bDebug) System.out.println("readClassBody " + strClassName);
	ClassRepresentation c = findClass(strClassName, false);
	strReadName = new String();
	strReadType = new String();
	Type type = new Type();
	ClassMemberRepresentation mdouble = null;
	ClassMemberRepresentation m = null;
	paramList = new ParmList("", "" ,null);  //?????????? check it out
	while(readMember(strClassName, type))
		if(isAValidName(strReadName)){
			m = new ClassMemberRepresentation(strReadType, strReadName, type, m, paramList, m_strAccessor); 
			c.SetMembers(m);
			if(m.GetMemberType().GetType() == Type.Method)
				for(mdouble = c.GetMembers(); mdouble!=null; mdouble = mdouble.GetNext())
					if((m.GetMemberType().GetType() == Type.StaticMethod || 
					   m.GetMemberType().GetType()  == Type.Method) &&
					   m.GetName().compareTo(mdouble.GetName()) == 0 &&
					   m.GetMemberType().GetType() == mdouble.GetMemberType().GetType()){
					//cannot cope with overloaded functions yet.
					m.SetMemberType(new Type(Type.StaticMethod));
				}

	    }
}

   /**
    * readParmList
	* Purpose: read a list of function parameters and put them into ParmList
	* @return ParmList
	*
	*/

 
   ParmList readParmList()
   {
   
		if(m_bDebug)System.out.println("enter readParmList()");

		byte []btArray = new byte[m_iBufSize];
		String strToken;
		ParmList list = new ParmList("", "", null);
		String strType = new String();
		String strName = new String();
		do{
		   if((strToken = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return null;

		   if(strToken.compareTo(",") == 0 || strToken.compareTo(")") == 0){
				strType = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-3);
				strName = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-2);
				if(strType.compareTo(",") == 0 || strType.compareTo("(") == 0 || strType.compareTo(":") == 0){
					strType = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-2);
					strName = "";
				}

				if(strType.compareTo("*") == 0 || strType.compareTo("&") == 0){
					for(int i = 0; i < 30 ; i++){
						String str = new String(m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-(4 +i)));
						strType = str + strType;
						if(str.compareTo("*") !=0 && str.compareTo("&") !=0)
							   break;
						
					}
					//strType = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-4) + strType;
					strName = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-2);
				}

				if(strType.compareTo("=") == 0){
					strType = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-5);
					strName = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-4);
				}

				if(strName.compareTo("&") == 0){
					strName = "dummy_";
					strType += "&";
				}
				if(strName.compareTo("*") == 0){
					strName = "dummy_";
					strType += "*";
				}
				if( ((m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-4)).compareTo("unsigned") == 0) &&
					(strType.compareTo("long") == 0 || strType.compareTo("short") == 0 || strType.compareTo("int") == 0 ||
					strType.compareTo("char") == 0)){

					strType = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-4);
					strType += "_";
					strType += m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-3);
				}


				if( (strType.compareTo("unsigned") == 0) &&
					(strName.compareTo("long") == 0 || strName.compareTo("short") == 0 || strName.compareTo("int") == 0 ||
					strName.compareTo("char") == 0)){
					strType+="_";
					strType+=strName;
					strName = "";
					list = new ParmList(strType, "", list);
				}
				else if(strName.compareTo("void") == 0)
					list = new ParmList(strName, "", list);
				else if(strName.length() > 0 && Scanner.isIdentifier( (byte)(strName.charAt(0)) ) )
					list = new ParmList(strType, strName, list);
				else if(strName.length() > 0 && strName.charAt(0) == '(')
					list = new ParmList("", "", list);
				else
					list = new ParmList(strType, "0", list);
		   }
		}while(strToken.compareTo("{") != 0 && strToken.compareTo(";") != 0 && strToken.compareTo(")") != 0);
   
		if(m_bDebug){
			System.out.println("strType is " + strType);
			System.out.println("strName is " + strName);
		}

		if(strToken.compareTo(")") == 0){
			if((strToken = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return null;
			if(strToken.compareTo("const") == 0)
				if((strToken = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return null;
		}

		//read initializer list
		if(strToken.compareTo(":") == 0){
			if((strToken = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return null;
			  m_strInitializer = "\n ";
			  boolean bSuperConstructorCall = false;
			  while(strToken.compareTo("{") != 0 && strToken.compareTo(";") !=0){
				  if(strToken.charAt(0) >='A' && strToken.charAt(0) <= 'Z'){ //traditionally class names 
					   m_strInitializer += "super";		   //are capitalized
					   bSuperConstructorCall = true;
				  }
				  else if(bSuperConstructorCall){
					  if(strToken.compareTo("(") == 0)	 m_strInitializer += "(";
					  else if(strToken.compareTo(")") == 0){
						  m_strInitializer+=");\n\t";
						  bSuperConstructorCall = false;
					  }
					  else if(strToken.compareTo(",") == 0) m_strInitializer += ",";
					  else m_strInitializer+=strToken;
				  }
					  
				  else{ 
					   if(strToken.compareTo("(") == 0) m_strInitializer += " = ";
					   else if(strToken.compareTo(")") == 0) m_strInitializer += ";\n\t";
					   else if(strToken.compareTo("')") == 0)m_strInitializer += "';\n\t";  
					   else if(strToken.compareTo(",") == 0) m_strInitializer += "";
					   else m_strInitializer += strToken;
				  }

				  if((strToken = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return null;
			  }	//while

		}  //if

		 m_scan.ungetByte((byte)(strToken.charAt(0)));
		 if(m_bDebug) System.out.println("leave readParmList()");
		 return list;	 
}
   
/**
 * readClass
 * Purpose: read a class or not a class
 * @return boolean false if the end of file has been reached
 * true otherwise
 *
 */


boolean readClass(boolean bDefnOnly)	throws IOException
{
    m_bDefnOnly = bDefnOnly;
	if(m_bDebug)System.out.println("readClass() {");
	byte [] btArray = new byte[m_iBufSize];
	StringArray lines = new StringArray();
	String strToken = new String();
	String strClassName = new String();
	int iWordsRead = 0;
	String strConst = new String();

	for(;;){
		
		if((strToken=m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
		if(isConstCharOrString(strToken))
			strConst = new String(strToken);
		iWordsRead++;
		//boolean bTest = (strToken.compareTo("class") == 0);
		if(strToken.compareTo("class") == 0 ||
			strToken.compareTo("struct") == 0){	//start of class definition
			if((strClassName=m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
			if(readSuperClasses(strClassName)){
				readClassBody(strClassName); //will read unto }
				if(m_bDebug) System.out.println("}");
				m_scan.ungetByte((byte)' '); //clear scan buffer
				iWordsRead = 0;
				return true;
			}

			continue;
		}

		String strType = new String();
		strClassName = "";
	 	String strMethodName = new String();
		if(strToken.compareTo("(") == 0){   //beginning of formal parameter list?
			if(m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-3).compareTo(":") == 0 &&
				m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-4).compareTo(":") == 0) {
				
				iWordsRead = 0;
				strClassName = m_scan.m_tkStack.getClassNameFromStack(5);
				strMethodName = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-2);
				strType = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-6);
				if(strType.compareTo("*") == 0 || strType.compareTo("&") == 0){
					for(int i = 0; i < 32; i++){
						String str = new String(m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-(7 + i))); 
						strType = str + strType;
						if(str.compareTo("*") !=0  &&  str.compareTo("&") != 0)
				    		  break;
							//strType = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-7);
					}
				}
			}

			else if(m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-3).compareTo("~") == 0 &&
				m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-4).compareTo(":") == 0 &&
				m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-5).compareTo(":") == 0){
				strClassName = m_scan.m_tkStack.getClassNameFromStack(6);
				strType = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-7);
				if(strType.compareTo("*") == 0 || strType.compareTo("&") == 0)
					   strType = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-8);
				strMethodName = "~";
				strMethodName+=m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-2);
			}

			if(strClassName.compareTo("") != 0) { //start of class method
				
				iWordsRead = 0;
				if(m_bDebug)System.out.println("start of class method");
				ParmList p = readParmList();
				//String strToken;
				if((strToken = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
				    iWordsRead ++;
				if(p!=null && strToken.compareTo("{") == 0){ //found a body
					if(m_bParseMethods){
						readMemberBody(strClassName, strMethodName, strType, p);
						if((strToken=m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
					}

					else{
						iWordsRead = 0;
						skipMatching("{", "}");
					}
				}
				if(m_bDebug)System.out.println("end of class method");
			}	
					
				else{ //start of global function
					if(m_bDebug)System.out.println("start of global function");
					strMethodName = m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-2);
					for(int i = 0; i< 30; i++){
						  String str = new String(m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize() - (3+i) ) );
						  strType = str+strType;
						  if(str.compareTo("*") !=0 && str.compareTo("&") != 0)
							 break;
					}
					    
					ParmList p = readParmList();
					//String strToken;
					if((strToken = m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
					    iWordsRead ++;
					if(strToken.compareTo("{") == 0){
						if(m_bDebug)
						 if(p!=null){
							p.printNames();
						 }
					
						if(m_bDebug){
							System.out.println("Before calling readGlobalBody, type is " + strType);
							m_scan.m_tkStack.printStack(7);
						}
						readGlobalBody(strMethodName, strType, p);
						iWordsRead = 0; 
						if((strToken=m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
				
					
					}

					else if(strToken.compareTo(";") == 0){
						iWordsRead = 0;   
						continue;
					}
					else if((strToken=m_scan.getWord(btArray, m_iBufSize)).compareTo("") == 0) return false;
				}	     iWordsRead++;
			}

			
			if(/*m_bParseMethods && */m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-2).compareTo("}") !=0 &&
				strToken.compareTo(";") == 0){	 //end of declaration
				if(m_bDebug)System.out.println("start of static declaration");
				if(m_bDebug)m_scan.m_tkStack.printStack(10);
				m_linesGlobal.Concatenate("\n");
				m_linesGlobal.Concatenate("/*@c2j++ The following variable used to be declared global */");
				m_linesGlobal.Concatenate("\n");
				for(int i = m_scan.m_tkStack.GetSize() - iWordsRead; i < m_scan.m_tkStack.GetSize(); i++){
					if(m_scan.m_tkStack.TokenAt(i).compareTo("static") == 0)
						m_linesGlobal.Concatenate("final "); //?????
					else if(m_scan.m_tkStack.TokenAt(i).compareTo("const") == 0){
						m_linesGlobal.Concatenate("static final ");
					   continue;
					}
					
					if(i == m_scan.m_tkStack.GetSize() -1){
					  if(m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-2).compareTo("=") == 0) 
						 m_linesGlobal.Concatenate(strConst);
					}
					if(i!= m_scan.m_tkStack.GetSize() - iWordsRead || m_scan.m_tkStack.TokenAt(i).compareTo(";") != 0)    
					   m_linesGlobal.Concatenate(m_scan.m_tkStack.TokenAt(i) + " ");
					/*
						   for(int j = i; j >=0; j--){
							m_tos.writeBytes(m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-j));
							if(m_bDebug)System.out.println(m_scan.m_tkStack.TokenAt(m_scan.m_tkStack.GetSize()-j));
						} */
				}
				
				m_linesGlobal.Concatenate("\n");
				iWordsRead = 0;	
				
				if(m_bDebug)System.out.println("end of declaration");
			}  //end of declaration

		} //end of for
			
		 
 }
 
}//@@@@@@//
//Contrib/c2j++/Preproc.java
//@@@@@@//
/*
 * Copyright (C) 1996,1997 Morgan Stanley & Co., Inc. 
 * Copyright (C) 1997 Ilya Tilevich
 *
 * This file is part of C2J++.
 * C2J++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation; 
 * either version 2, or (at your option) any later version.
 * C2J++ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with C2J; 
 * see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

import java.io.*;
import java.util.StringTokenizer;

/**
* Purpose: Scan source file and substitute all instances of #include with
* function names
*/
class PrimitivePreprocessor{
    private FileInputStream fis = null;
    private DataInputStream dis = null;
    private FileOutputStream writeOut = null;
	private DataOutputStream dataWrite = null;
	private boolean m_bDebug = false;

	private MembersArray m_MembersVector;
    
	/**
	 * Purpose: Constructor
	 * @param strInFile - source file
	 * @param strOutFile - output files
	 * @param vec - vector of MemberBodies
	 * @exception IOException
	 */
	public PrimitivePreprocessor(String strInFile, String strOutFile, MembersArray vect){
            m_MembersVector = vect;
            
			try{

                fis = new FileInputStream(strInFile);
				writeOut = new FileOutputStream(strOutFile);

            }catch(FileNotFoundException eFnf){
		        System.out.println("Unable to open " + strInFile);
		        System.exit(1);
            }

			catch(Throwable e) {
				System.out.println("Error in opening file");
				return;
			}



              dis = new DataInputStream(fis);

    		  
		      dataWrite = new DataOutputStream(writeOut);
		
			  
		  	
	}

    /**
	 * Purpose: preprocesses the file
	 */
	
	public void ProcessFile(){
          int iBadData = 0;
          String strLine;
          String strTry;

		  try{
          
			  while((strLine = dis.readLine())!=null){
			  	  //System.out.println(strLine);
				  strTry = new String(strLine);
				  if(strLine.trim().startsWith("#include")){
					  ProcessInclude(strLine);
				  	  dataWrite.writeByte('\n');
				  }
				  else{
					  dataWrite.writeBytes(strLine);
				  	  dataWrite.writeByte('\n');
				  }
		      
				}
		  
		  
		  }catch(Exception e){
             System.out.println("Error occurred reading file");
             System.exit(1);
          }
          

		  try{
			  dis.close();
			  fis.close();
				  
			  dataWrite.close();
			  writeOut.close();
		  
		  }catch(IOException e){System.out.println(e);}	  	     
	}

	  private void ProcessInclude(String strLine){
		   
		  if(strLine.compareTo("") == 0) return;
		  String strMemName, strInclude;
		  
		  StringTokenizer strTok = new StringTokenizer(strLine);

		   if(strTok != null && strTok.countTokens() == 2){
					strInclude = new String(strTok.nextToken()); //who cares
					strMemName = new String(strTok.nextToken());
					if(!m_MembersVector.FindAndWriteOut(dataWrite, strMemName))
						if(m_bDebug)System.out.println(strMemName + " not found!");
 		   }
		   else
					System.out.println("Bad Line" + strTok);
					
		   
	}

	/*
    public static void main(String[] args) { 
	  MembersArray mArray = new MembersArray();

	  StringArray sArray1 = new StringArray();
	  StringArray sArray2 = new StringArray();
	  StringArray sArray3 = new StringArray();
	  
	  MemberBody memBody1;
	  MemberBody memBody2;
	  MemberBody memBody3;


	  String name1 = new String("function_1");
	  
	  String line11 = new String("{ 1 This is ");
	  String line12 = new String(" 1 a body of ");
	  String line13 = new String("1 function # 1 }");
	  
	  sArray1.addElement(line11); 
	  sArray1.addElement(line12); 
	  sArray1.addElement(line13); 

	  memBody1 = new MemberBody(name1, sArray1);
	  

	  String name2 = new String("function_2");
	  
	  String line21 = new String("{ 2 This is ");
	  String line22 = new String(" 2 a body of ");
	  String line23 = new String("2 function # 2 }");
	  
	  
	  sArray2.addElement(line21); 
	  sArray2.addElement(line22); 
	  sArray2.addElement(line23); 

	  memBody2 = new MemberBody(name2, sArray2);
	  
	  
	  String name3 = new String("function_3");
	  
	  String line31 = new String("{ 3 This is ");
	  String line32 = new String(" 3 a body of ");
	  String line33 = new String(" 3 function # 3 }");
	  
	  
	  sArray3.addElement(line31); 
	  sArray3.addElement(line32); 
	  sArray3.addElement(line33); 

	  memBody3 = new MemberBody(name3, sArray3);

	 mArray.addElement(memBody1); 
	 mArray.addElement(memBody2); 
 	 mArray.addElement(memBody3); 

	 PrimitivePreprocessor p =
	 new PrimitivePreprocessor("Prep.txt", "Prep.don", mArray);
	 p.ProcessFile();
	
	
	
	
	}

	 */

	  
}

      
//@@@@@@//
//Contrib/c2j++/sample1.java
//@@@@@@//

/*
 * class sample1
 * 
 * This code has been generated using C2J++
 * C2J++ is based on Chris Laffra's C2J (laffra@ms.com)
 * Read general disclaimer distributed with C2J++ before using this code
 * For information about C2J++, send mail to Ilya_Tilevich@ibi.com
 */

class sample1
{
int num;

/**
* sample1
* @param n
*/
public
sample1(int n)
{
	num = n;
}

/**
* getNum
* @return int
*/
public
int getNum()
{
	return num;
}

/**
* @return int
*/
static int main()
{
	sample1 obj(2112);
/** @c2j++ Replacement from cout << obj.getNum(); System.out.print(String.valueOf(obj.getNum()));*/ 
 System.out.print(String.valueOf(obj.getNum()));
	return 0;
}
}
//@@@@@@//
//Contrib/c2j++/stack.java
//@@@@@@//
/*
 * Copyright (C) 1996,1997 Morgan Stanley & Co., Inc. 
 * Copyright (C) 1997 Ilya Tilevich
 *
 * This file is part of C2J++.
 * C2J++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation; 
 * either version 2, or (at your option) any later version.
 * C2J++ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with C2J; 
 * see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

import java.util.Vector;

/**
 * A stack which can hold only m_iMaxSize elements
 * Purpose: Stack used by Parser
 *	 
 */
class TokenStack
{

	private int m_iInsertLoc;
    private int m_iSize;
    private int m_iMask; 

	final static int m_iMaxSize = 32;
	private static boolean m_bDebug = false;
/** 
 * Purpose: 
 * @return int
 */
	
	private int GetStartPos(){ return (m_iInsertLoc -1) & m_iMask; }
/** 
 * Purpose: 
 * @return int
 * @param iCurrent
 */
	private int GetNext(int iCurrent) { return (iCurrent & m_iMask); }
	Vector 	m_Vector;

	/**
	 * Purpose: Constructor
	 */
	public TokenStack(){ 
		int iTest = m_iMaxSize;
	
	while((iTest & 1) != 1)	
		iTest = iTest >> 1;
		
	
		if((iTest>>1)!=0){ 
			System.out.println("m_iMaxSize should be a power of two");
		
			System.exit(1);
		}
	
		
		m_Vector = new Vector(m_iMaxSize);
		
	
		m_iSize = 0;
	    m_iInsertLoc = 0;
	    m_iMask = m_iMaxSize -1;
		initialize();
	
	}
/** 
 * Purpose: 
 */

		 
	private	void initialize(){
		for(int i = 0; i < m_iMaxSize; i++)
			m_Vector.addElement("");
	
	}
	
	
	/**
	 * Purpose: Returns the constant size of the stack 
	 * @return int
	 */
	
	public int GetSize(){ return  m_iMaxSize; }
	/**
	 * Purpose: pushes the stack
	 * Note: if there m_iMaxSize elements on the stack, the bottom most element is
	 * removed
	 * 
	 */
	public void push(String obj) {
		m_Vector.setElementAt(obj, m_iInsertLoc);
		m_iSize ++;
		m_iInsertLoc = m_iSize % m_iMaxSize;
		if(m_iSize == m_iMaxSize)
		   m_iSize = 0;
	}
	
	
	/**
	 * Purpose: Gets a token from the top of the stack
	 * Note: This function was written to maintain the compatability
	 * with ParseStack class that uses GetSize() to call TokenAt()
	 * Later, Parser should be modified to call ElementFromTopOfTheStack()
	 */
	
	public String TokenAt(int iIndex) { 
	    
		if(iIndex < 0 || iIndex > m_iMaxSize-1) 
			return "";
		
		iIndex = m_iMaxSize-iIndex-1;
		return 	ElementFromTopOfTheStack(iIndex);
	}
	
	
	/**
	 * Purpose: gets an element from the top of the stack 
	 * using zero-based iIndex
	 * @param iIndex
	 * @return String
	 */
	public String ElementFromTopOfTheStack(int iIndex){
	
		
		if(iIndex < 0 || iIndex > (GetSize()-1) )
			return "";
		iIndex = (GetStartPos() - iIndex) & m_iMask;
		return (String)m_Vector.elementAt(iIndex);
	}
	

	/**
	 * Purpose: prints the contents of the stack up the iDepth
	 * @param iDepth
	 */
	public void printStack(int iDepth){
		
		int iSize = GetSize();
		if( iDepth > iSize -1 )	System.out.println("Unable to print stack to " + String.valueOf(iDepth) + " depth");

		else{
			
			System.out.println("Printing the TokenStack: ");
			
			for(int n = 0; n < iDepth; n++){
				System.out.print(n + "th element from the top of the stack -  ");
				System.out.println(ElementFromTopOfTheStack(n));
			}
		}

	
	}					

	/**
	 * Purpose: searches stack up to iDepth for a class name
	 * @param iDepth
	 * @return String
	 */
	public String getClassNameFromStack(int iDepth)
	{
		String strClassName = new String();
		int iSize = GetSize(), n;
		for(n = iDepth; n < iSize - iDepth -2; n+=3){
			if( TokenAt(iSize-(n+1)).compareTo(":") != 0  ||
			    TokenAt(iSize-(n+2)).compareTo(":")!= 0 )
				break;
		}
	
		if(m_bDebug)printStack(n);
	
		for(; n > iDepth; n-=3)
			strClassName += TokenAt(iSize-n);
		strClassName+=TokenAt(iSize-iDepth);
		
		return strClassName;

	}
/** 
 * Purpose: 
 */
	
	



 public static void main(String[] args){
	 TokenStack stack = new TokenStack();
	 stack.push("A");
	 stack.push("B");
	 stack.push("C");
	 stack.push("D");
	 stack.push("E");
	 stack.push("F");
	 stack.push("G");
	 stack.push("H");
	 stack.push("I");
	 stack.push("J");
	 stack.push("K");
	 stack.push("L");

	 stack.printStack(5);
 	 System.out.println(stack.TokenAt(stack.GetSize() - 1));
	 System.out.println(stack.TokenAt(stack.GetSize() -2));
	 System.out.println(stack.TokenAt(stack.GetSize() -3));
 	 System.out.println(stack.ElementFromTopOfTheStack(0));
	 System.out.println(stack.ElementFromTopOfTheStack(1));
	 System.out.println(stack.ElementFromTopOfTheStack(2));

 
 
 
 }



}


//@@@@@@//
//Contrib/c2j++/StringArray.java
//@@@@@@//
/*
 * Copyright (C) 1996,1997 Morgan Stanley & Co., Inc. 
 * Copyright (C) 1997 Ilya Tilevich
 *
 * This file is part of C2J++.
 * C2J++ is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation; 
 * either version 2, or (at your option) any later version.
 * C2J++ is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with C2J; 
 * see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

import java.util.Vector;
import java.util.Enumeration;
import java.util.Stack;
import java.io.*;

/**
 * Purpose: A vector of Strings
 * @version 1.0	 December 96
 * @author Ilya Tilevich
 *
 */
class StringArray
{
	 	
      private Vector m_Vector;
	  
	  /**
	   * Purpose: Constructor
	   * @param iCapacity the initial capacity
	   * @param iIncr	the increment
	   */
	  public StringArray (int iCapacity, int iIncr){
               m_Vector = new Vector(iCapacity, iIncr);
      }

	   /**
	   * Purpose: Constructor
	   * @param iCapacity the initial capacity
	   */
	  public StringArray (int iCapacity){
                m_Vector = new Vector(iCapacity);
       }

      
	   /**
	   * Purpose: Constructor
	   */
	  public StringArray (){
		m_Vector = new Vector();
       }

	/**
	 * Purpose: adds an element to the array
	 * @param obj the Stirng to add
	 */
	public synchronized void addElement(String obj){
              m_Vector.addElement(obj);
 	}

    /**
	 * Purpose: appends strToAppend to the last String added to the array
	 * if no string were added works like addElement()
	 * @param strToAppend
	 */
	public synchronized void appendToLastString(String strToAppend){
		if(size() <= 0)
			addElement(strToAppend);
		else{
			String str = new String (elementAt(size()-1));
			str += strToAppend;
			setElementAt(str, m_Vector.size()-1);
		}
	}
	
	/**
	 * Purpose: Returns the size for the array
	 * @return int
	 */
	public int size() { return m_Vector.size(); }

	/**
	 * Purpose: clones the array
	 */
	public synchronized Object clone(){
              return m_Vector.clone();
	}

	/**
	 * Purpose: searches the array for a given String
	 * @param elem
	 */
	public boolean contains(String elem){
              return m_Vector.contains((Object) elem);
	}

	/**
	 * Purpose: Returns the String at a given index
	 * @param iIndex
	 */
    public String elementAt(int iIndex){

		return (String) m_Vector.elementAt(iIndex);
	}

    /**
	 * Purpose: sets an element of the array at a given index to a given value
	 * @param obj
	 * @param iIndex
	 */
	public void  setElementAt(String obj, int iIndex){
		   m_Vector.setElementAt((Object) obj, iIndex);
	}

	/**
	 * Purpose: Copies this object into a given strArray[]
	 * @param strArray the String array to copy the current object to
	 */
	protected synchronized void copyInto(String strArray[]){
		strArray = new String[size()];
		for(int i = 0; i < size(); i++)
		     strArray[i] = elementAt(i);
	}


	/**
	 * Purpose: Returns the enumeration object for this object
	 * @return Enumeration
	 */
	public synchronized Enumeration elements(){
		return m_Vector.elements();
	}

	/**
	 * Purpose: Removes the specified element
	 * @param obj 
	 */
	
	public synchronized boolean removeElement(String obj){
		return m_Vector.removeElement((Object) obj);
	}

	/**
	 * Purpose: Converts this object to a String
	 * @return String
	 */
	public synchronized String toString(){
 		return m_Vector.toString();
	}

	
	/**
	 * Purpose: Writes this object to DataOutputStream
	 */
	public 	synchronized void WriteOut(DataOutputStream  dos){
		
		Enumeration enum = elements();
		
		try{
			for(;enum.hasMoreElements();){
				 String str = (String)(enum.nextElement());
				 dos.writeBytes(str);
				 dos.writeByte('\n');
			}
		}
		catch(IOException e){System.out.println("IO error in StringArray WriteOut"); }
	
	}

	 /**
	  *purpose: Writes this object to stdio
	  */
	public 	synchronized void WriteOut(){  //to stdio
		
		Enumeration enum = elements();
		
		for(;enum.hasMoreElements();){
			 String str = (String)(enum.nextElement());
			 System.out.println(str);
        }
	 
	}




}


/**
 *Purpose: Encapsulates the function body
 * @version 1.1 January 97
 * @author Ilya Tilevich
 */
class MemberBody{
	
	//StringArray m_strArrayBody;
	Buffer m_Buffer;
	String m_strMemberName;

	/**
	 *Purpose: Constructor
	 *@param strName member name
	 *@param strArrayBody
	 */
	public MemberBody(String strName, Buffer buffer)
	{
		m_strMemberName = strName;
		//m_strArrayBody = strArrayBody;
		m_Buffer = (Buffer)buffer.clone();
	}

	/**
	 * Purpose: Returns member's name
	 * @return String
	 */
	public String getName() { return m_strMemberName; }
	
	/**
	 * Purpose: Sets member's name
	 * @param strName
	 */
	public void setName(String strName) { m_strMemberName = strName; }
	
	/**
	 * Purpose: Returns everything between {} 
	 * @return StringArray
	 */
	public Buffer getBody() { return m_Buffer; }
	
	/**
	 * Purpose: Sets body for this member body
	 * @param StringArray
	 */
	public void setBody(Buffer buffer) { m_Buffer = buffer; }
	
	/**
	 * Purpose: writes this fuction to DataOutputStream
	 * @exception IOException if problems occur during writing
	 */
	public void WriteOutBody(DataOutputStream  dos) throws IOException
	{
		m_Buffer.WriteOut(dos);	
	
	}

	/**
	 * Purpose: writes this fuction to stdio
	 * @exception IOException if problems occur during writing
	 */
	public void WriteOutBody()throws IOException
	{
		m_Buffer.WriteOut();
	}

}


/**
 * Purpose: Stores and handles an array of functions
 * @version 1.0 December 96
 * @author Ilya Tilevich
 *
 */

class MembersArray
{
	 	
      private Vector m_Vector;

	  /**
	  * Purpose: Constructor
	  * @param iCapacit the initial capacity
	  * @param iIncr the increment
	  *
	  */
	  public MembersArray (int iCapacity, int iIncr){
               m_Vector = new Vector(iCapacity, iIncr);
      }

	  /**
	  * Purpose: Constructor
	  * @param iCapacit the initial capacity
	  *
	  */
	   public MembersArray (int iCapacity){
                m_Vector = new Vector(iCapacity);
       }

       /**
	  * Purpose: Constructor
	  */
	   public MembersArray (){
		m_Vector = new Vector();
       }

	 /**
	  * Purpose: adds an element to the array
	  * @param obj the MemberArray to add
	  */
		
	   public synchronized void addElement(MemberBody obj){
              m_Vector.addElement(obj);
 	    }

	   /**
	    * Purpose: returns the size of the array
		* @return int
	    */
	   
	   public int size() { return m_Vector.size(); }

	   /**
	    * Purpose: clones the object
		* @return Object
		*/
		public synchronized Object clone(){
              return m_Vector.clone();
		}

		/**
		 * Purpose: Searches the array for a given element
		 * @return boolean
		 */
		public boolean contains(MemberBody elem){
              return m_Vector.contains((Object) elem);
		}

		/**
		 * Purpose: Returns the element at a given index
		 *
		 */
		public MemberBody elementAt(int iIndex){

			return (MemberBody) m_Vector.elementAt(iIndex);
		}

		/**
		 * Purpose: Sets an element at a given index
		 * @param obj
		 * @param iIndex
		 */
		
		public void  setElementAt(MemberBody obj, int iIndex){
		   m_Vector.setElementAt((Object) obj, iIndex);
		}

	
		/**
		 * Purpose: Returns Enumeration for this object
		 * @return Enumeration
		 *
		 */
		public synchronized Enumeration elements(){
	 	     return m_Vector.elements();
		}

		/**
		 * Purpose: Removes the given MemberBody
		 * @param obj 
		 * @return boolean true if the obj was found, false otherwise  
		 *
		 */
		public synchronized boolean removeElement(MemberBody obj){
			return m_Vector.removeElement((Object) obj);
		}

		/**
		 * Purpose: converts this object to a String
		 * @return String
		 */
		public synchronized String toString(){
 			return m_Vector.toString();
		}

		/**
		 * Purpose: write this object to DataOutputStream
		 * @param dos
		 * @exception IOException
		 */
		public 	synchronized void WriteOut(DataOutputStream  dos){
		
			Enumeration enum = elements();
		
		 try{
			for(;enum.hasMoreElements();){
				 MemberBody member = (MemberBody)(enum.nextElement());
				 dos.writeChars(member.getName());
				 dos.writeByte('\n');
				 member.getBody().WriteOut(dos);
			}
		 }
		 catch(IOException e){System.out.println("IO error in WriteOut"); }
	
		}


		/**
		 * Purpose: write this object to stdio
		 */
		
		public 	synchronized void WriteOut(){
		
			Enumeration enum = elements();
		
			for(;enum.hasMoreElements();){
				 MemberBody member = (MemberBody)(enum.nextElement());
				 System.out.println("Member Name:");
				 System.out.println(member.getName());
				 System.out.println("Function Body:");
				 member.getBody().WriteOut();
			}

		}

		
		/**
		 * Purpose: Find a given member body in the array and write it out to DataOutputStream
		 * @param dos	DataOutputStream
		 * @param strName  String
		 * @return boolean true if the method was found, false otherwise
		 * @exception IOException if error happened during writting
		 */
		
		public synchronized boolean FindAndWriteOut(DataOutputStream  dos, String strName){
		
			Enumeration enum = elements();
		
		// try{
			for(;enum.hasMoreElements();){
				 MemberBody member = (MemberBody)(enum.nextElement());
				 String str = new String(member.getName());
				 if(str.compareTo(strName)	== 0){
					 member.getBody().WriteOut(dos);
					 return true;
				 }	 
					 
			}
		 //}
		 //catch(IOException e){System.out.println(e+"IO error in FindAndWriteOut"); }
	
		 return false;
		
		}


		/**
		 * Purpose: Find a given member body in the array and write it out to stdio
		 * @param strName  String
		 * @return boolean true if the method was found, false otherwise
		 * @exception IOException if error happened during writting
		 */
		public synchronized boolean FindAndWriteOut(String strName){
		
			Enumeration enum = elements();
		
		 
			for(;enum.hasMoreElements();){
				 MemberBody member = (MemberBody)(enum.nextElement());
				 if(member.getName().compareTo(strName)	== 0){
					 member.getBody().WriteOut();
					 return true;
				 }	 
					 
			}
		 
		 return false;
		
		}



}


//@@@@@@//
//Contrib/c2j++/test.java
//@@@@@@//

/*
 * class Rectangle
 * 
 * This code has been generated using C2J++
 * C2J++ is based on Chris Laffra's C2J (laffra@ms.com)
 * Read general disclaimer distributed with C2J++ before using this code
 * For information about C2J++, send mail to Ilya_Tilevich@ibi.com
 */

class Rectangle
{
static final int FALSE = 0;
static final int TRUE = 1;
static final int MAYBE = 2;

/**
* Rectangle
* @param x_
* @param y_
* @param w_
* @param h_
*/
public
/* @c2j++: "Rectangle(int x_, int y_, unsigned w_, unsigned h_)" replacement: unsigned  to int  */
/* @c2j++: "Rectangle(int x_, int y_, int w_, unsigned h_)" replacement: unsigned  to int  */
Rectangle(int x_, int y_, int w_, int h_)
{
 x = x_;
	y = y_;
	w = w_;
	h = h_;
	}

/**
* move
* @param x_
* @param y_
*/
public
void move(int x_, int y_)
{
   //This is the first comment
   //This is the second comment
   x = x_;
   y = y_;
}

/**
* resize
* @param w_
* @param h_
*/
public
/* @c2j++: "void resize(unsigned w_, unsigned h_)" replacement: unsigned  to int  */
/* @c2j++: "void resize(int w_, unsigned h_)" replacement: unsigned  to int  */
void resize(int w_, int h_)
{
   w = w_;
   h = h_;
}

/**
* print
*/
public
void print()
{
/** @c2j++ Replacement from cout << "Rectangle " << " " << y <<		" " << w << " " << h << endl; System.out.println("Rectangle " + " " + String.valueOf(y) + " " + String.valueOf(w) + " " + String.valueOf(h));*/ 
 System.out.println("Rectangle " + " " + String.valueOf(y) + " " + String.valueOf(w) + " " + String.valueOf(h));
}
int x;
int y;
/* @c2j++: "unsigned w;" replacement: unsigned  to int  */
int w;
/* @c2j++: "unsigned h;" replacement: unsigned  to int  */
int h;

/**
*/
static void main()
{
/* @c2j++: "Rectangle * rect = new Rectangle(10,10,100,100);" replacement: * to " " */
  Rectangle   rect = new Rectangle(10,10,100,100);
/* @c2j++: "rect->print();" replacement: -> to . */
  rect.print();
}
}
//@@@@@@//
//Contrib/coffee/CoffeeMachine/_SupplyImplBase.java
//@@@@@@//
/*
 * File: ./COFFEEMACHINE/_SUPPLYIMPLBASE.JAVA
 * From: COFFEEMACHINE1.IDL
 * Date: Fri Apr 23 00:24:52 1999
 *   By: C:\BIN\IDLTOJ~1.EXE Java IDL 1.2 Aug 18 1998 16:25:34
 */

package CoffeeMachine;
public abstract class _SupplyImplBase extends org.omg.CORBA.DynamicImplementation implements CoffeeMachine.Supply {
    // Constructor
    public _SupplyImplBase() {
         super();
    }
    // Type strings for this class and its superclases
    private static final String _type_ids[] = {
        "IDL:CoffeeMachine/Supply:1.0"
    };

    public String[] _ids() { return (String[]) _type_ids.clone(); }

    private static java.util.Dictionary _methods = new java.util.Hashtable();
    static {
      _methods.put("dispenseCup", new java.lang.Integer(0));
     }
    // DSI Dispatch call
    public void invoke(org.omg.CORBA.ServerRequest r) {
       switch (((java.lang.Integer) _methods.get(r.op_name())).intValue()) {
           case 0: // CoffeeMachine.Supply.dispenseCup
              {
              org.omg.CORBA.NVList _list = _orb().create_list(0);
              r.params(_list);
              int ___result;
                            ___result = this.dispenseCup();
              org.omg.CORBA.Any __result = _orb().create_any();
              __result.insert_long(___result);
              r.result(__result);
              }
              break;
            default:
              throw new org.omg.CORBA.BAD_OPERATION(0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);
       }
 }
}
//@@@@@@//
//Contrib/coffee/CoffeeMachine/_SupplyStub.java
//@@@@@@//
/*
 * File: ./COFFEEMACHINE/_SUPPLYSTUB.JAVA
 * From: COFFEEMACHINE1.IDL
 * Date: Fri Apr 23 00:24:52 1999
 *   By: C:\BIN\IDLTOJ~1.EXE Java IDL 1.2 Aug 18 1998 16:25:34
 */

package CoffeeMachine;
public class _SupplyStub
	extends org.omg.CORBA.portable.ObjectImpl
    	implements CoffeeMachine.Supply {

    public _SupplyStub(org.omg.CORBA.portable.Delegate d) {
          super();
          _set_delegate(d);
    }

    private static final String _type_ids[] = {
        "IDL:CoffeeMachine/Supply:1.0"
    };

    public String[] _ids() { return (String[]) _type_ids.clone(); }

    //	IDL operations
    //	    Implementation of ::CoffeeMachine::Supply::dispenseCup
    public int dispenseCup()
 {
           org.omg.CORBA.Request r = _request("dispenseCup");
           r.set_return_type(org.omg.CORBA.ORB.init().get_primitive_tc(org.omg.CORBA.TCKind.tk_long));
           r.invoke();
           int __result;
           __result = r.return_value().extract_long();
           return __result;
   }

};
//@@@@@@//
//Contrib/coffee/CoffeeMachine/Supply.java
//@@@@@@//
/*
 * File: ./COFFEEMACHINE/SUPPLY.JAVA
 * From: COFFEEMACHINE1.IDL
 * Date: Fri Apr 23 00:24:52 1999
 *   By: C:\BIN\IDLTOJ~1.EXE Java IDL 1.2 Aug 18 1998 16:25:34
 */

package CoffeeMachine;
public interface Supply
    extends org.omg.CORBA.Object, org.omg.CORBA.portable.IDLEntity {
    int dispenseCup()
;
}
//@@@@@@//
//Contrib/coffee/CoffeeMachine/SupplyHelper.java
//@@@@@@//
/*
 * File: ./COFFEEMACHINE/SUPPLYHELPER.JAVA
 * From: COFFEEMACHINE1.IDL
 * Date: Fri Apr 23 00:24:52 1999
 *   By: C:\BIN\IDLTOJ~1.EXE Java IDL 1.2 Aug 18 1998 16:25:34
 */

package CoffeeMachine;
public class SupplyHelper {
     // It is useless to have instances of this class
     private SupplyHelper() { }

    public static void write(org.omg.CORBA.portable.OutputStream out, CoffeeMachine.Supply that) {
        out.write_Object(that);
    }
    public static CoffeeMachine.Supply read(org.omg.CORBA.portable.InputStream in) {
        return CoffeeMachine.SupplyHelper.narrow(in.read_Object());
    }
   public static CoffeeMachine.Supply extract(org.omg.CORBA.Any a) {
     org.omg.CORBA.portable.InputStream in = a.create_input_stream();
     return read(in);
   }
   public static void insert(org.omg.CORBA.Any a, CoffeeMachine.Supply that) {
     org.omg.CORBA.portable.OutputStream out = a.create_output_stream();
     write(out, that);
     a.read_value(out.create_input_stream(), type());
   }
   private static org.omg.CORBA.TypeCode _tc;
   synchronized public static org.omg.CORBA.TypeCode type() {
          if (_tc == null)
             _tc = org.omg.CORBA.ORB.init().create_interface_tc(id(), "Supply");
      return _tc;
   }
   public static String id() {
       return "IDL:CoffeeMachine/Supply:1.0";
   }
   public static CoffeeMachine.Supply narrow(org.omg.CORBA.Object that)
	    throws org.omg.CORBA.BAD_PARAM {
        if (that == null)
            return null;
        if (that instanceof CoffeeMachine.Supply)
            return (CoffeeMachine.Supply) that;
	if (!that._is_a(id())) {
	    throw new org.omg.CORBA.BAD_PARAM();
	}
        org.omg.CORBA.portable.Delegate dup = ((org.omg.CORBA.portable.ObjectImpl)that)._get_delegate();
        CoffeeMachine.Supply result = new CoffeeMachine._SupplyStub(dup);
        return result;
   }
}
//@@@@@@//
//Contrib/coffee/CoffeeMachine/SupplyHolder.java
//@@@@@@//
/*
 * File: ./COFFEEMACHINE/SUPPLYHOLDER.JAVA
 * From: COFFEEMACHINE1.IDL
 * Date: Fri Apr 23 00:24:52 1999
 *   By: C:\BIN\IDLTOJ~1.EXE Java IDL 1.2 Aug 18 1998 16:25:34
 */

package CoffeeMachine;
public final class SupplyHolder
     implements org.omg.CORBA.portable.Streamable{
    //	instance variable 
    public CoffeeMachine.Supply value;
    //	constructors 
    public SupplyHolder() {
	this(null);
    }
    public SupplyHolder(CoffeeMachine.Supply __arg) {
	value = __arg;
    }

    public void _write(org.omg.CORBA.portable.OutputStream out) {
        CoffeeMachine.SupplyHelper.write(out, value);
    }

    public void _read(org.omg.CORBA.portable.InputStream in) {
        value = CoffeeMachine.SupplyHelper.read(in);
    }

    public org.omg.CORBA.TypeCode _type() {
        return CoffeeMachine.SupplyHelper.type();
    }
}
//@@@@@@//
//Contrib/coffee/SupplyClient.java
//@@@@@@//
import CoffeeMachine.*;		// The package created from the IDL module
import org.omg.CosNaming.*;
import org.omg.CORBA.*;

/** This is a simple client that just lists the CDs and tracks. */
public class SupplyClient {
	public static void main(String[] argv) {
		try {
			// Initialize the ORB
			ORB orb = ORB.init(argv, null);

			// Get the root naming context. Do NOT use "bind",
			// which is a VisiBroker non-standard extension.
			// (but a very convenient one!)
			org.omg.CORBA.Object objRef =
				orb.resolve_initial_references("NameService");
			NamingContext ncRef = NamingContextHelper.narrow(objRef);

			// Find an object that supports Supply
			NameComponent nc = new NameComponent("Supply", "");
			NameComponent path[] = {nc};
			Supply mySupply = SupplyHelper.narrow(ncRef.resolve(path));

			// Interact with Object
			int x = mySupply.dispenseCup();
		} catch (Exception e) {			// Any CORBA Exceptions?
			System.out.println("Error: " + e) ;
			e.printStackTrace(System.err);
		}
	}
}
//@@@@@@//
//Contrib/coffee/SupplyServer.java
//@@@@@@//
import CoffeeMachine.*;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;

/** 
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: SupplyServer.java,v 1.4 2004/02/09 03:33:40 ian Exp $
 */
public class SupplyServer {

	// Implementation. Extend the skeleton to get CORBA functionality.
	protected class SupplyImpl extends _SupplyImplBase {
		SupplyImpl(String name) {
			super();
		}

		// Implement all the functionality of the interface
		public int dispenseCup() {
			return 12;
		}
	}

	/** Execution of Java programs starts at main() */
	public static void main(String[] argv)
	{
		new SupplyServer().runServer(argv);
	}

	/** Do the work of contacting the ORB, registering with it,
	 * binding the Object, and waiting for clients. 
	 */
	protected void runServer(String[] argv) {
		try {
			// Create and initialize the ORB
			ORB orb = ORB.init(argv, null);

			// create servant and register it with the ORB
			SupplyImpl imp = new SupplyImpl("Fred");
			orb.connect(imp);

			// get the root naming context
			org.omg.CORBA.Object objRef = 
				orb.resolve_initial_references("NameService");
			NamingContext ncRef = NamingContextHelper.narrow(objRef);

			// bind the Object Reference in Naming
			NameComponent nc = new NameComponent("Supply", "");
			NameComponent path[] = {nc};
			ncRef.rebind(path, imp);

			// Wait for clients to invoke us. This use of Object
			// (fully-qualified because of ORG.OMG.CORBA.Object)
			// is equivalent to a UNIX pause() system call, that is,
			// an indefinite wait.
			System.out.println("Server: Waiting for clients...");
			java.lang.Object sync = new java.lang.Object();
			synchronized (sync) {
				sync.wait();
			}

		} catch (Exception e) {
			System.err.println("ERROR: " + e);
			e.printStackTrace(System.out);
		}
    }
}
//@@@@@@//
//Contrib/EtchedLabel/EtchedLabel.java
//@@@@@@//
import java.awt.*;
import java.io.Serializable;
/*
 *
 * EtchedLabel
 *
 */
public class EtchedLabel extends Canvas	implements Serializable 
{
   public EtchedLabel ()
    {
	   setSize (350,150);
    }

   public void paint (Graphics g)
    {
	   g.setFont (new Font ("Times", Font.ITALIC+Font.BOLD, 28));

	   g.setColor (Color.red);
	   g.drawString ("Etched Label", 100, 100);

	   g.setColor (Color.black);
	   g.drawString ("Etched Label", 101, 101);
    }
     
   public Dimension getPreferredSize()
    {
	return new Dimension (350, 150);
    }

   public Dimension getMinimumSize()
    {
	return new Dimension (50, 70);
    }
}

//@@@@@@//
//Contrib/EtchedLabel/MyFrame.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
/*
 *
 * MyFrame
 *
 */
public class MyFrame extends Frame 
		implements WindowListener, 
		           ActionListener
{
   private Button btnClose;
   private Button btnOk;

   public MyFrame ()
	{
	   setTitle ("This is my Frame");
	   setBackground (Color.lightGray);

	     //Create a toolbar Panel object and add the buttons
	   Panel panToolbar = new Panel ();
		 panToolbar.setLayout (new FlowLayout (FlowLayout.LEFT));
	       btnClose = new Button ("Close");
		   btnOk = new Button ("OK");
	     panToolbar.add ( btnClose );
		 panToolbar.add ( btnOk );
	   add ( panToolbar, "North");

	   add (new EtchedLabel (), "Center" );

	   addWindowListener (this);
	   btnClose.addActionListener (this);
	   btnOk.addActionListener (this);
	}

   public void actionPerformed(ActionEvent e)
    {
	   if ( e.getSource() == btnClose )
	     {
	     System.out.println ("Action ");
	     System.exit(0);
	     }

	   if ( e.getSource() == btnOk )
	     {
	     System.out.println ("Action on BtnOk");
	     }
    }

   public void windowActivated(WindowEvent e)
    {
	   System.out.println ("Window Activated");
    }

   public void windowDeactivated(WindowEvent e)
    {
	   System.out.println ("Window Deactivated");
    }

   public void windowIconified(WindowEvent e)
    {
	   System.out.println ("Window Iconified");
    }

   public void windowDeiconified(WindowEvent e)
    {
	   System.out.println ("Window Deiconified");
    }

   public void windowOpened(WindowEvent e)
    {
	   System.out.println ("Window Opened");
    }

   public void windowClosed(WindowEvent e)
    {
	   System.out.println ("Window Closed");
	   System.exit(0);
    }

   public void windowClosing(WindowEvent e)
    {
	   System.out.println ("Window Closing");
	   dispose();
    }

}

//@@@@@@//
//Contrib/EtchedLabel/MyGuiApp.java
//@@@@@@//

/*
 *
 * MyGuiApp
 *
 */
class MyGuiApp 
{
  public static void main (String argv[])
    {
	  MyFrame myF = new MyFrame ();
	  myF.pack();
	  myF.show();
    }

}

//@@@@@@//
//Contrib/GridBagEx1.java
//@@@@@@//
/*
 * This example of using GridBagLayout is from Sun/JavaSoft documentation,
 * extended slightly and reformatted.
 *
 * It can be run as an Applet or as an Application.
 */

import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.applet.Applet;

public class GridBagEx1 extends Applet implements ActionListener {

	protected void makebutton(String name,
			GridBagLayout gridbag,
			GridBagConstraints c) {
		Button button = new Button(name);
		button.addActionListener(this);
		add(button, c);
	}

	public void init() {
		GridBagLayout gridbag = new GridBagLayout();
		GridBagConstraints c = new GridBagConstraints();
		setFont(new Font("Helvetica", Font.PLAIN, 14));
		setLayout(gridbag);
		c.fill = GridBagConstraints.BOTH;
		c.weightx = 1.0;
		makebutton("Button1", gridbag, c);
		makebutton("Button2", gridbag, c);
		makebutton("Button3", gridbag, c);
		c.gridwidth = GridBagConstraints.REMAINDER; //end row
		makebutton("Button4", gridbag, c);
		c.weightx = 0.0;                   //reset to the default
		makebutton("Button5", gridbag, c); //another row
		c.gridwidth = GridBagConstraints.RELATIVE; //next-to-last in row
		makebutton("Button6", gridbag, c);
		c.gridwidth = GridBagConstraints.REMAINDER; //end row
		makebutton("Button7", gridbag, c);
		c.gridwidth = 1;                   //reset to the default
		c.gridheight = 2;
		c.weighty = 1.0;
		makebutton("Button8", gridbag, c);
		c.weighty = 0.0;                   //reset to the default
		c.gridwidth = GridBagConstraints.REMAINDER; //end row
		c.gridheight = 1;                  //reset to the default
		makebutton("Button9", gridbag, c);
		makebutton("Button10", gridbag, c);
		setSize(300, 100);
	}

	public void actionPerformed(ActionEvent e) {
		System.out.println("You pressed " + e.getActionCommand());
	}

	/** If invoked as an application, start things up */
	public static void main(String[] args) {
		Frame f = new Frame("GridBag Layout Example");
		GridBagEx1 ex1 = new GridBagEx1();
		ex1.init();
		f.add("Center", ex1);
		f.pack();
		f.setSize(f.getPreferredSize());
		f.setVisible(true);
		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent we) {
				System.exit(0);
			}
		});
	}
}
//@@@@@@//
//Contrib/Ismap.java
//@@@@@@//
import java.net.URL;
import java.io.*;

/** A class to allow use of the ncsa ISMAP format in java applets. **/
/** version 1.0 writen for Beta2 on 12/27/95 by Dan Cohn, cohnd@rpi.edu **/
/** code for n-sided polygons based on ncsa httpd code by Eric Haines **/
/** usage example: 
      Ismap zones = new Ismap();
      zones.addrect("AreaA",10,10,20,20); //AreaA a rect from (10,10) to (20,20)
      zones.addcirc("AreaB",40,45,5); //AreaB a circle at (40,45) radius 5
      zones.addrect("AreaC",25,30,27,32); //AreaC another rectangle
      zones.addzone("poly AreaD 40,60 45,60 50,65 50,70 35,70")// AreaD a blob
      zones.adddefault("OtherArea");
      zones.lookup(15,15) will return "AreaA" as (15,15) falls in that region.
      zones.lookup(100,100) will return "OtherArea", as an undefined point. **/
/** ISMAP compliant map files may also be loaded by url reference in the 
    constructor or by loadmap() or addmap(). Note that files must not have .map
    extensions to be passed by the server. **/

public final class Ismap {
   /** rather than consulting the server, we will buffer file locally **/
   private String mapdetail[];
   /** default case if all else fails **/
   private String Default;
   /** position to offset from given values when computing area **/
   private int xoffset, yoffset;
   /** keep track of number of lines in our definitions file **/
   private int numlines;
   /** result string when match is found **/
   protected String result;
   /** number of lines available per map file. reduce for memory conservancy **/
   protected int MAXLINES=512;
   protected int MAXVERTS=128;

   /** generic constructor allocates mapdetail and sets offsets to 0 **/
   public Ismap() {
      this.mapdetail = new String[MAXLINES];
      this.xoffset = this.yoffset = 0;
      this.numlines = 0;
   }

   /** constructs a new Ismap which starts off by loading a url as map data **/
   public Ismap(String mapurl) {
      this.mapdetail = new String[MAXLINES];
      this.xoffset = this.yoffset = 0;
      this.loadmap(mapurl);
   }
      
   /** and one more constructor to start off with a url map and an x,y offset */
   public Ismap(String mapurl, int xoffset, int yoffset) {
      this.mapdetail = new String[MAXLINES];
      this.xoffset=xoffset;
      this.yoffset=yoffset;
      this.loadmap(mapurl);
   }

   public void clearmap() {
      this.numlines = 0;
   }
      
   public boolean loadmap(String mapurl) {
      this.numlines=0;
      return(this.addmap(mapurl));
   }

   public boolean addmap(String mapurl) {
      int linepos = 1;
      int streambyte;
      char localln[]=new char[80];
      try {
         URL remotemap = new URL(mapurl);
         InputStream mapis = remotemap.openStream();
         do {
            streambyte=mapis.read();
            localln[linepos-1]=(char)streambyte;
            if (localln[linepos-1]=='\n') {
               this.mapdetail[numlines]=String.copyValueOf(localln,0,linepos-1);
               numlines++;
               linepos=0;
            }
            linepos++;
         } while (streambyte!=-1);
      }
      catch(java.net.MalformedURLException e) {
         System.out.println("Malformed URL! exception");
         return(false);
      }
      catch(java.io.IOException e) {
         System.out.println("Error reading from URL! exception");
         return(false);
      }
      return true;
   }

   public void offset(int x, int y) {
      this.xoffset=x;
      this.yoffset=y;
   }

   private boolean checkline(int testx, int testy, String thisstr) {
      int i1,i2,coordnum;
      String type, name, scoordpair;
      int coordpair[][] = new int[MAXVERTS][2];
      thisstr.trim(); /* cut any excess whitspace */
      if ((!thisstr.startsWith("#"))&&(thisstr.length()>1)) {
         i1=thisstr.indexOf(" ");
         type=thisstr.substring(0,i1);
         if (!type.equals("default")) 
            i2=thisstr.indexOf(' ',i1+1);
         else { /* default case */
            this.Default=thisstr.substring(i1+1);
            return false;
         }
         name=thisstr.substring(i1+1,i2);
         i1=i2;
         i2=thisstr.indexOf(' ',i1+1);
         for (coordnum=0;i2!=-1;coordnum++) {
            scoordpair=thisstr.substring(i1+1,i2);
            coordpair[coordnum][0]=
               Integer.valueOf(scoordpair.substring
                              (0, scoordpair.indexOf(","))).intValue();
            coordpair[coordnum][1]=
               Integer.valueOf(scoordpair.substring
                              (scoordpair.indexOf(",")+1)).intValue();
            i1=i2;
            i2=thisstr.indexOf(' ',i1+1);
            if ((i2==-1)&&(i1!=thisstr.length())) i2=thisstr.length();
         }
         coordpair[coordnum][0]=-1; // end of pairs sentinel for polygon code
         if (type.equals("rect")) 
            if (pointinrect(testx,testy,coordpair)) {
               this.result=name;
               return true;
            }
         if (type.equals("circ"))
            if (pointincirc(testx,testy,coordpair)) {
               this.result=name;
               return true;
            }
         if (type.equals("poly"))
            if (pointinpoly(testx,testy,coordpair)) {
               this.result=name;
               return true;
            }
      }
      return false; // not within boundaries of this line
   }

   public String lookup (int xcoord, int ycoord) {
      int linecount=0;
      xcoord+=this.xoffset;
      ycoord+=this.yoffset;
      for (linecount=0;linecount<numlines;linecount++) {
         if (checkline(xcoord,ycoord,String.valueOf(this.mapdetail[linecount])))
            return (this.result);
      }
      if (this.Default.length()>0)
         return (this.Default);
      System.out.println ("The point ("+xcoord+","+ycoord+") has not been "+
                          "accounted for and no default was defined.");
      return("");
   }

   public void dumpmap() {
      int linecount=0;
      for (linecount=0;linecount<numlines;linecount++) {
         System.out.println(String.valueOf(mapdetail[linecount]));
      }
   }

   public void addzone(String mapinfo) {
      this.mapdetail[numlines++]=mapinfo;
   }

   public void adddefault(String regionname) {
      this.mapdetail[numlines++]="default "+regionname;
   }

   public void addrect(String regionname, int x1, int y1, int x2, int y2) {
      this.mapdetail[numlines++]="rect "+regionname+" "+x1+","+y1+" "+x2+","+y2;
   }

   public void addcirc(String regionname, int x1, int y1, int r) {
      int outerpt=x1+r;
      this.mapdetail[numlines++]="circ "+regionname+" "+x1+","+
                                  y1+" "+outerpt+","+y1;
   }

   private boolean pointinrect(int x, int y, int coords[][]){
      return ((x>=coords[0][0]&&x<=coords[1][1])&&
              (y>=coords[0][1]&&y<=coords[1][1]));
   }

   private boolean pointincirc(int x, int y, int coords[][]) {
      int radius1, radius2;
      radius1=((coords[0][1]-coords[1][1])*(coords[0][1]-coords[1][1])) +
              ((coords[0][0]-coords[1][0])*(coords[0][0]-coords[1][0]));
      radius2=((coords[0][1]-y)*(coords[0][1]-y)) +
              ((coords[0][0]-x)*(coords[0][0]-x));
      return (radius2<=radius1);
   }

   private boolean pointinpoly(int tx, int ty, int pgon[][]) {
      int i, numverts, inside_flag, crossings;
      boolean xflag0;
      double  stop, y;

      for (i=0; pgon[i][0]!=-1 && i < MAXVERTS; i++);
      numverts=i;
      crossings=0;

      y=pgon[numverts-1][1];

      if ((y>=ty)!=(pgon[0][1]>=ty)) {
         if ((xflag0=(pgon[numverts-1][0]>=tx))==
         (pgon[0][0]>=tx)) {
            if (xflag0)
               crossings++;
         }
         else {
            if ((pgon[numverts-1][0]-(y-ty)*
            (pgon[0][0]-pgon[numverts-1][0])/
            (pgon[0][1]-y)) >= tx)
               crossings++;
         }
      }

      stop=numverts;

      for (int index=1; index<stop; y=pgon[index][1],index++) {
         if (y >= ty ) {
            while ((index<stop)&&(pgon[index][1]>=ty))
               index++;
            if (index>=stop)
               break;
            if ((xflag0=(pgon[index-1][0]>=tx))==(pgon[index][0]>=tx)) {
               if (xflag0)
                  crossings++;
            }
            else {
               if((pgon[index-1][0]-(pgon[index-1][1]-ty)*
               (pgon[index][0]-pgon[index-1][0])/
               (pgon[index][1]-pgon[index-1][1]))>=tx)
                  crossings++;
            }
         }
         else {
            while ((index<stop)&&(pgon[index][1]<ty))
               index++;
            if (index>=stop)
               break;
            if ((xflag0 = (pgon[index-1][0]>=tx))==(pgon[index][0]>=tx)) {
               if (xflag0)
                  crossings++;
            }
            else {
               if ((pgon[index-1][0]-(pgon[index-1][1]-ty)*
               (pgon[index][0]-pgon[index-1][0])/
               (pgon[index][1]-pgon[index-1][1]))>=tx)
                  crossings++;
            }
         }
      }
      inside_flag = crossings & 0x01;
      return (inside_flag>0);
   }
}
//@@@@@@//
//Contrib/JavaLookup.java
//@@@@@@//
import java.net.*;
import java.io.*;

/** An "nslookup" clone in Java.
 * @author Elliot Rusty Harold, O'Reilly & Associates
 */
public class JavaLookup {

   public static void main (String args[]) {

   if (args.length > 0) { // use command line
     for (int i = 0; i < args.length; i++) {
        lookup(args[i]);
     }
   }
   else {
     DataInputStream myInputStream = new DataInputStream(System.in);
     System.out.println
       ("Enter names and IP addresses. Enter \"exit\" to quit.");
     while (true) {
       String s;
       try {
         s = myInputStream.readLine();
       }
       catch (IOException e) {
         break;
       }
       if (s.equals("exit")) break;
       if (s.equals("quit")) break;
	   if (s.charAt(0) == '\004') break;	// unix ^D
       lookup(s);
     }

   }

  } /* end main */


  private static void lookup(String s) {

    InetAddress thisComputer;
    byte[] address;

    // get the bytes of the IP address
    try {
      thisComputer = InetAddress.getByName(s);
      address = thisComputer.getAddress();
    }
    catch (UnknownHostException ue) {
       System.out.println("Cannot find host " + s);
       return;
    }

    if (isHostname(s)) {
      // Print the IP address
      for (int i = 0; i < address.length; i++) {
        int unsignedByte = address[i] < 0 ? address[i] + 256 : address[i];
        System.out.print(unsignedByte + ".");
      }
      System.out.println();
    }
    else {  // this is an IP address
      try {
        System.out.println(InetAddress.getByName(s));
      }
      catch (UnknownHostException e) {
        System.out.println("Could not lookup the address " + s);
      }
    }

  }  // end lookup

   private static boolean isHostname(String s) {

     char[] ca = s.toCharArray();
     // if we see a character that is neither a digit nor a period
     // then s is probably a hostname
     for (int i = 0; i < ca.length; i++) {
       if (!Character.isDigit(ca[i])) {
         if (ca[i] != '.') {
           return true;
         }
       }
     }

     // Everything was either a digit or a period
     // so s looks like an IP address in dotted quad format
     return false;

   }  // end isHostName

 } // end javalookup
//@@@@@@//
//Contrib/JDBCDriver-Moss/CommonValue.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      CommonValue.java
//
// Description: Object that represents a single data value.  All data
//              coercion is handled here
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

import java.sql.*;

public class CommonValue
    extends         Object
{
    //------------------------------------------------------------------------
    // Constructors
    //------------------------------------------------------------------------

    public CommonValue()
    {
        data = null;
    }

    public CommonValue(String s)
    {
        data = (Object) s;
        internalType = Types.VARCHAR;
    }

    public CommonValue(int i)
    {
        data = (Object) new Integer(i);
        internalType = Types.INTEGER;
    }

    public CommonValue(Integer i)
    {
        data = (Object) i;
        internalType = Types.INTEGER;
    }

    public CommonValue(byte b[])
    {
        data = (Object) b;
        internalType = Types.VARBINARY;
    }

    //------------------------------------------------------------------------
    // isNull
    // returns true if the value is null
    //------------------------------------------------------------------------

    public boolean isNull()
    {
        return (data == null);
    }

    //------------------------------------------------------------------------
    // getMethods
    //------------------------------------------------------------------------

    // Attempt to convert the data into a String.  All data types
    // should be able to be converted

    public String getString()
        throws SQLException
    {
        String s;

        // A null value always returns null

        if (data == null) {
            return null;
        }

        switch(internalType) {

        case Types.VARCHAR:
            s = (String) data;
            break;

        case Types.INTEGER:
            s = ((Integer) data).toString();
            break;

        case Types.VARBINARY:
            {
                // Convert a byte array into a String of hex digits

                byte b[] = (byte[]) data;
                int len = b.length;
                String digits = "0123456789ABCDEF";
                char c[] = new char[len * 2];

                for (int i = 0; i < len; i++) {
                    c[i * 2] = digits.charAt((b[i] >> 4) & 0x0F);
                    c[(i * 2) + 1] = digits.charAt(b[i] & 0x0F);
                }
                s = new String(c);
            }


            break;

        default:
            throw new SQLException("Unable to convert data type to String: " +
                                internalType);
        }

        return s;
    }

    // Attempt to convert the data into an int

    public int getInt()
        throws SQLException
    {
        int i = 0;

        // A null value always returns zero

        if (data == null) {
            return 0;
        }

        switch(internalType) {

        case Types.VARCHAR:
            i = (Integer.valueOf((String) data)).intValue();
            break;

        case Types.INTEGER:
            i = ((Integer) data).intValue();
            break;

        default:
            throw new SQLException("Unable to convert data type to String: " +
                                internalType);
        }

        return i;
    }

    // Attempt to convert the data into a byte array

    public byte[] getBytes()
        throws SQLException
    {
        byte b[] = null;

        // A null value always returns null

        if (data == null) {
            return null;
        }

        switch(internalType) {

        case Types.VARCHAR:
            {
                // Convert the String into a byte array.  The String must
                // contain an even number of hex digits

                String s = ((String) data).toUpperCase();
                String digits = "0123456789ABCDEF";
                int len = s.length();
                int index;

                if ((len % 2) != 0) {
                    throw new SQLException(
                            "Data must have a even number of hex digits");
                }

                b = new byte[len / 2];

                for (int i = 0; i < (len / 2); i++) {
                    index = digits.indexOf(s.charAt(i * 2));

                    if (index < 0) {
                        throw new SQLException("Invalid hex digit");
                    }

                    b[i] = (byte) (index << 4);

                    index = digits.indexOf(s.charAt((i * 2) + 1));

                    if (index < 0) {
                        throw new SQLException("Invalid hex digit");
                    }

                    b[i] += (byte) index;

                }
            }
            break;

        case Types.VARBINARY:
            b = (byte[]) data;
            break;

        default:
            throw new SQLException("Unable to convert data type to byte[]: " +
                                internalType);
        }

        return b;
    }

    protected Object data;
    protected int internalType;

}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextColumn.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextColumn.java
//
// Description: Object that represents a single result set column
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

public class SimpleTextColumn
    extends        Object
{
    //------------------------------------------------------------------------
    // Constructor
    //------------------------------------------------------------------------

    public SimpleTextColumn(
        String name,
        int type,
        int precision)
    {
        this.name = name;
        this.type = type;
        this.precision = precision;
    }

    public SimpleTextColumn(
        String name,
        int type)
    {
        this.name = name;
        this.type = type;
        this.precision = 0;
    }

    public SimpleTextColumn(
        String name)
    {
        this.name = name;
        this.type = 0;
        this.precision = 0;
    }


    public String name;
    public int type;
    public int precision;
    public boolean searchable;
    public int colNo;
    public int displaySize;
    public String typeName;
}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextConnection.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextConnection.java
//
// Description: Implementation of the JDBC Connection interface
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

//----------------------------------------------------------------------------
// A Connection represents a session with a specific
// database. Within the context of a Connection, SQL statements are
// executed and results are returned.
//
// A Connection's database is able to provide information
// describing its tables, its supported SQL grammar, its stored
// procedures, the capabilities of this connection, etc. This
// information is obtained with the getMetaData method.
//
// Note: By default the Connection automatically commits
// changes after executing each statement. If auto commit has been
// disabled an explicit commit must be done or database changes will
// not be saved.
//----------------------------------------------------------------------------
// NOTE - this is an implementation of the JDBC API version 1.20
//---------------------------------------------------------------------------

import java.sql.*;
import java.io.*;
import java.util.Hashtable;
import java.util.StringTokenizer;

public class SimpleTextConnection
    extends       SimpleTextObject
    implements    SimpleTextIConnection
{

    //------------------------------------------------------------------------
    // initialize
    // Initialize the Connection object
    //------------------------------------------------------------------------

    public void initialize (
        SimpleTextIDriver driver,
        java.util.Properties info)
        throws SQLException
    {

        // Save the owning driver object

        ownerDriver = driver;

        // Get the security manager and see if we can write to a file.
        // If no security manager is present, assume that we are a trusted
        // application and have read/write privileges.

        canWrite = false;

        SecurityManager securityManager = System.getSecurityManager ();

        if (securityManager != null) {
            try {
                // Use some arbitrary file to check for file write privileges

                securityManager.checkWrite ("SimpleText_Foo");

                // Flag is set if no exception is thrown

                canWrite = true;
            }

            // If we can't write, an exception is thrown.  We'll catch
            // it and do nothing

            catch (SecurityException ex) {
            }
        }
        else {
            canWrite = true;
        }

        // Set our initial read-only flag

        setReadOnly(!canWrite);

        // Get the directory.  It will either be supplied with the URL, in
        //  the property list, or we'll use our current default

        String s = ownerDriver.getSubname();
        int slen = 0;

        if (s != null) {
            slen = s.length();
        }

        if (slen == 0) {
            s = info.getProperty("Directory");
        }

        if (s == null) {
            s = System.getProperty("user.dir");
        }

        setCatalog(s);
    }

    //------------------------------------------------------------------------
    // createStatement - JDBC API
    //
    // SQL statements without parameters are normally
    // executed using Statement objects. If the same SQL statement
    // is executed many times it is more efficient to use a
    // PreparedStatement
    //
    // Returns a new Statement object
    //------------------------------------------------------------------------

    public Statement createStatement()
        throws SQLException
    {
        if (traceOn()) {
            trace("Creating new SimpleTextStatement");
        }

        // Create a new Statement object

        SimpleTextStatement stmt = new SimpleTextStatement();

        // Initialize the statement

        stmt.initialize (this);

        return stmt;
    }

    //------------------------------------------------------------------------
    // prepareStatement - JDBC API
    //
    // A SQL statement with or without IN parameters can be
    // pre-compiled and stored in a PreparedStatement object. This
    // object can then be used to efficiently execute this statement
    // multiple times.
    //
    // Note: This method is optimized for handling
    // parametric SQL statements that benefit from precompilation. If
    // the driver supports precompilation, prepareStatement will send
    // the statement to the database for precompilation. Some drivers
    // may not support precompilation. In this case, the statement may
    // not be sent to the database until the PreparedStatement is
    // executed.  This has no direct affect on users; however, it does
    // affect which method throws certain SQLExceptions.
    //
    //    sql        a SQL statement that may contain one or more '?' IN
    //            parameter placeholders
    //
    // Returns a new PreparedStatement object containing the
    //            pre-compiled statement
    //------------------------------------------------------------------------

    public PreparedStatement prepareStatement(
        String sql)
        throws SQLException
    {
        if (traceOn()) {
            trace("@prepareStatement (sql=" + sql + ")");
        }

        // Create a new PreparedStatement object

        SimpleTextPreparedStatement ps = new SimpleTextPreparedStatement();

        // Initialize the PreparedStatement

        ps.initialize(this, sql);

        return ps;
    }

    //------------------------------------------------------------------------
    // prepareCall - JDBC API
    //
    // A SQL stored procedure call statement is handled by creating a
    // CallableStatement for it. The CallableStatement provides
    // methods for setting up its IN and OUT parameters, and
    // methods for executing it.
    //
    // Note: This method is optimized for handling stored
    // procedure call statements. Some drivers may send the call
    // statement to the database when the prepareCall is done; others
    // may wait until the CallableStatement is executed. This has no
    // direct affect on users; however, it does affect which method
    // throws certain SQLExceptions.
    //
    //    sql        a SQL statement that may contain one or more '?'
    //            parameter placeholders
    //
    // Returns a new CallableStatement object containing the
    //            pre-compiled SQL statement
    //------------------------------------------------------------------------

    public CallableStatement prepareCall(
        String sql)
        throws SQLException
    {
        if (traceOn()) {
            trace("@prepareCall (sql=" + sql + ")");
        }

        // The SimpleText driver does not support callable statements

        throw new SQLException("Driver does not support this function");
    }

    //------------------------------------------------------------------------
    // nativeSQL - JDBC API
    //
    // A driver may convert the JDBC sql grammar into its system's
    // native SQL grammar prior to sending it; nativeSQL returns the
    // native form of the statement that the driver would have sent.
    //
    //    sql        a SQL statement that may contain one or more '?'
    //            parameter placeholders
    //
    // Returns the native form of this statement
    //------------------------------------------------------------------------

    public String nativeSQL(
        String sql)
        throws SQLException
    {

        // For the SimpleText driver, simply return the original
        // sql statement.  Other drivers will need to expand escape
        // sequences here.

        return sql;
    }

    //------------------------------------------------------------------------
    // setAutoCommit - JDBC API
    //
    // If a connection is in auto-commit mode, then all its SQL
    // statements will be executed and committed as individual
    // transactions.  Otherwise, its SQL statements are grouped into
    // transactions that are terminated by either commit() or
    // rollback().  By default, new connections are in auto-commit
    // mode.
    //
    //    autoCommit    true enables auto-commit; false disables
    //                auto-commit.
    //------------------------------------------------------------------------

    public void setAutoCommit(
        boolean autoCommit)
        throws SQLException
    {
        if (traceOn()) {
            trace("@setAutoCommit (autoCommit=" + autoCommit + ")");
        }

        // The SimpleText driver is always in auto-commit mode (it does
        // not support transactions).  Throw an exception if an attempt
        // is made to change the mode

        if (autoCommit == false) {
            throw DriverNotCapable();
        }
    }

    //------------------------------------------------------------------------
    // getAutoCommit - JDBC API
    //
    // Get the current auto-commit state.
    // Returns the current state of auto-commit mode.
    //------------------------------------------------------------------------

    public boolean getAutoCommit()
        throws SQLException
    {
        // The SimpleText driver is always in auto-commit mode (it does
        // not support transactions)

        return true;
    }

    //------------------------------------------------------------------------
    // commit - JDBC API
    //
    // Commit makes all changes made since the previous
    // commit/rollback permanent and releases any database locks
    // currently held by the Connection.
    //------------------------------------------------------------------------

    public void commit()
        throws SQLException
    {
        // No-op for the SimpleText driver
    }

    //------------------------------------------------------------------------
    // rollback - JDBC API
    //
    // Rollback drops all changes made since the previous
    // commit/rollback and releases any database locks currently held
    // by the Connection.
    //------------------------------------------------------------------------

    public void rollback()
        throws SQLException
    {
        // No-op for the SimpleText driver
    }

    //------------------------------------------------------------------------
    // close - JDBC API
    //
    // In some cases, it is desirable to immediately release a
    // Connection's database and JDBC resources instead of waiting for
    // them to be automatically released; the close method provides this
    // immediate release.
    //------------------------------------------------------------------------

    public void close()
        throws SQLException
    {
        connectionClosed = true;
    }

    //------------------------------------------------------------------------
    // isClosed - JDBC API
    //
    // Check if a Connection is closed
    //------------------------------------------------------------------------

    public boolean isClosed()
        throws SQLException
    {
        return connectionClosed;
    }

    //------------------------------------------------------------------------
    // getMetaData - JDBC API
    //
    // A Connection's database is able to provide information
    // describing its tables, its supported SQL grammar, its stored
    // procedures, the capabilities of this connection, etc. This
    // information is made available through a DatabaseMetaData
    // object.
    //
    // Returns a DatabaseMetaData object for this Connection
    //------------------------------------------------------------------------

    public DatabaseMetaData getMetaData()
        throws SQLException
    {
        SimpleTextDatabaseMetaData dbmd = new SimpleTextDatabaseMetaData ();

        dbmd.initialize(this);

        return dbmd;
    }

    //------------------------------------------------------------------------
    // setReadOnly - JDBC API
    //
    // You can put a connection in read-only mode as a hint to enable
    // database optimizations.
    //
    // Note: setReadOnly cannot be called while in the
    // middle of a transaction.
    //------------------------------------------------------------------------

    public void setReadOnly(
        boolean readOnly)
        throws SQLException
    {

        // If we are trying to set the connection not read only (allowing
        // writes), and this connection does not allow writes, throw
        // an exception

        if ((readOnly == false) &&
            (canWrite == false)) {
            throw DriverNotCapable();
        }

        // Set the readOnly attribute for the SimpleText driver.  If set,
        // the driver will not allow updates or deletes to any text file

        this.readOnly = readOnly;
    }

    //------------------------------------------------------------------------
    // isReadOnly - JDBC API
    //
    // Test if the connection is in read-only mode
    //------------------------------------------------------------------------

    public boolean isReadOnly()
        throws SQLException
    {
        return readOnly;
    }

    //------------------------------------------------------------------------
    // setCatalog - JDBC API
    //
    // A sub-space of this Connection's database may be selected by setting a
    // catalog name. If the driver does not support catalogs it will
    // silently ignore this request.
    //------------------------------------------------------------------------

    public void setCatalog(String catalog)
        throws SQLException
    {
        if (traceOn()) {
            trace("@setCatalog(" + catalog + ")");
        }

        // If the last character is a separator, remove it

        if (catalog.endsWith("/") ||
            catalog.endsWith("\\")) {
            catalog = catalog.substring(0, catalog.length());
        }

        // Make sure this is a directory

        File dir = new File(catalog);

        if (!dir.isDirectory()) {
            throw new SQLException("Invalid directory: " + catalog);
        }

        this.catalog = catalog;
    }

    //------------------------------------------------------------------------
    // getCatalog
    // Returns the Connection's current catalog name
    //------------------------------------------------------------------------

    public String getCatalog()
        throws SQLException
    {
        return catalog;
    }

    //------------------------------------------------------------------------
    // setTransactionIsolation - JDBC API
    //
    // You can call this method to try to change the transaction
    // isolation level on a newly opened connection, using one of the
    // TRANSACTION_* values.
    //
    //    level    one of the TRANSACTION_* isolation values with the
    //            exception of TRANSACTION_NONE; some databases may not support
    //            other values
    //------------------------------------------------------------------------

    public void setTransactionIsolation(
        int level)
        throws SQLException
    {
        if (traceOn()) {
            trace("@setTransactionIsolation (level=" + level + ")");
        }

        // Throw an exception if the transaction isolation is being
        // changed to something different

        if (level != TRANSACTION_NONE) {
            throw DriverNotCapable();
        }
    }

    //------------------------------------------------------------------------
    // getTransactionIsolation - JDBC API
    //
    // Get this Connection's current transaction isolation mode
    //------------------------------------------------------------------------

    public int getTransactionIsolation()
        throws SQLException
    {
        // The SimpleText driver does not support transactions

        return TRANSACTION_NONE;
    }

    //------------------------------------------------------------------------
    // getWarnings - JDBC API
    //
    // The first warning reported by calls on this Connection is
    // returned.
    //
    // Note: Subsequent warnings will be chained to this SQLWarning.
    //------------------------------------------------------------------------

    public SQLWarning getWarnings()
        throws SQLException
    {
        // No warnings exist for the SimpleText driver.  Always return
        // null

        return null;
    }

    //------------------------------------------------------------------------
    // clearWarnings - JDBC API
    //
    // After this call getWarnings returns null until a new warning is
    // reported for this Connection.
    //------------------------------------------------------------------------

    public void clearWarnings()
        throws SQLException
    {
        // No-op
    }

    //------------------------------------------------------------------------
    // parseSQL
    // Given a sql statement, parse it and return a String array with each
    // keyword.  This is a VERY simple parser.
    //------------------------------------------------------------------------

    public String[] parseSQL(
        String sql)
    {
        String keywords[] = null;

        // Create a new Hashtable to keep our words in.  This way, we can
        // build the Hashtable as we go, then create a String array
        // once we know how may words are present

        java.util.Hashtable table = new java.util.Hashtable();
        int count = 0;

        // Current offset in the sql string

        int offset = 0;

        // Get the first word from the sql statement

        String word = parseWord(sql.substring(offset));

        // Loop while more words exist in the sql string

        while (word.length() > 0) {

            // Increment the offset pointer

            offset += word.length();

            // Trim all leading and trailing spaces

            word = word.trim();

            if (word.length() > 0) {

                // Put the word in our hashtable

                table.put(new Integer(count), word);
                count++;
            }

            // Get the next word

            word = parseWord(sql.substring(offset));
        }

        // Create our new String array with the proper number of elements

        keywords = new String[count];

        // Copy the words from the Hashtable to the String array

        for (int i = 0; i < count; i++) {
            keywords[i] = (String) table.get(new Integer(i));
        }
        return keywords;
    }

    //------------------------------------------------------------------------
    // getTables
    // Given a directory and table pattern, return a Hashtable containing
    // SimpleTextTable entries
    //------------------------------------------------------------------------

    public Hashtable getTables(
        String dir,
        String table)
    {
        Hashtable list = new Hashtable();

        // Create a FilenameFilter object.  This object will only allow
        // files with the .SDF extension to be seen

        FilenameFilter filter = new SimpleTextEndsWith(
                    SimpleTextDefine.DATA_FILE_EXT);


        File file = new File(dir);

        if (file.isDirectory()) {

            // List all of the files in the directory with the .SDF extension

            String entries[] = file.list(filter);
            SimpleTextTable tableEntry;

            // Create a SimpleTextTable entry for each, and put in
            // the Hashtable

            for (int i = 0; i < entries.length; i++) {

                // A complete driver needs to further filter the table
                // name here

                tableEntry = new SimpleTextTable(dir, entries[i]);
                list.put(new Integer(i), tableEntry);
            }
        }

        return list;
    }

    //------------------------------------------------------------------------
    // getColumns
    // Given a directory and table name, return a Hashtable containing
    // SimpleTextColumn entries.  Returns null if the table is not found
    //------------------------------------------------------------------------

    public Hashtable getColumns(
        String dir,
        String table)
    {
        Hashtable list = new Hashtable();

        // Create the full path to the table

        String fullPath = dir + "/" + table + SimpleTextDefine.DATA_FILE_EXT;

        File f = new File (fullPath);

        // If the file does not exist, return null

        if (!f.exists()) {
            if (traceOn()) {
                trace("File does not exist: " + fullPath);
            }
            return null;
        }

        String line = "";

        // Create a random access object and read the first line
        // Create the table

        try {
            RandomAccessFile raf = new RandomAccessFile(f, "r");

            // Read the first line, which is the column definitions

            line = raf.readLine();
			raf.close();

        }
        catch (IOException ex) {
            if (traceOn()) {
                trace("Unable to read file: " + fullPath);
            }
            return null;
        }

        // Now, parse the line.  First, check for the branding

        if (!line.startsWith(SimpleTextDefine.DATA_FILE_EXT)) {
            if (traceOn()) {
                trace("Invalid file format: " + fullPath);
            }
            return null;
        }

        line = line.substring(SimpleTextDefine.DATA_FILE_EXT.length());

        // Now we can use the StringTokenizer, since we know that the
        // column names can't contain data within quotes (this is why
        // we can't use the StringTokenizer with SQL statements)

        StringTokenizer st = new StringTokenizer(line, ",");

        String columnName;
        int columnType;
        int precision;
        SimpleTextColumn column;
        int count = 0;
        boolean searchable;
        int displaySize;
        String typeName;

        // Loop while more tokens exist

        while (st.hasMoreTokens()) {
            columnName = (st.nextToken()).trim();

            if (columnName.length() == 0) {
                continue;
            }

            if (columnName.startsWith(SimpleTextDefine.COL_TYPE_NUMBER)) {
                columnType = Types.INTEGER;
                precision = SimpleTextDefine.MAX_INTEGER_LEN;
                columnName = columnName.substring(
                            SimpleTextDefine.COL_TYPE_NUMBER.length());
                displaySize = precision;
                typeName = "VARCHAR";
                searchable = true;
            }
            else if (columnName.startsWith(SimpleTextDefine.COL_TYPE_BINARY)) {
                columnType = Types.VARBINARY;
                precision = SimpleTextDefine.MAX_VARBINARY_LEN;
                columnName = columnName.substring(
                            SimpleTextDefine.COL_TYPE_BINARY.length());
                displaySize = precision * 2;
                typeName = "BINARY";
                searchable = false;
            } else {
                columnType = Types.VARCHAR;
                precision = SimpleTextDefine.MAX_VARCHAR_LEN;
                searchable = true;
                displaySize = precision;
                typeName = "NUMBER";
            }

            // Create a new column object and add to the Hashtable

            column = new SimpleTextColumn(columnName, columnType, precision);
            column.searchable = searchable;
            column.displaySize = displaySize;
            column.typeName = typeName;

            // The column number will be 1-based

            count++;

            // Save the absolute column number

            column.colNo = count;

            list.put(new Integer(count), column);
        }

        return list;
    }

    //------------------------------------------------------------------------
    // getDirectory
    // Given a directory filter (which may be null), format the directory
    // to use in a search.  The default connection directory may be returned
    //------------------------------------------------------------------------

    public String getDirectory(
        String directory)
    {
        String dir;

        if (directory == null) {
            dir = catalog;
        }
        else if (directory.length() == 0) {
            dir = catalog;
        }
        else {
            dir = directory;
            if (dir.endsWith("/") ||
                dir.endsWith("\\")) {
                dir = dir.substring(0, dir.length());
            }
        }

        return dir;
    }


    protected SimpleTextIDriver ownerDriver;// Pointer to the owning
                                            // Driver object

    protected boolean connectionClosed;        // true if the connection is
                                            // currently closed

    protected boolean readOnly;                // true if the connection is
                                            // read-only

    protected boolean canWrite;                // true if we are able to write
                                            // to files

    protected String catalog;                // Current catalog (qualifier)
                                            // for text files

}

//----------------------------------------------------------------------------
// This class is a simple FilenameFilter.  It defines the required accept()
// method to determine whether a specified file should be listed.  A file
// will be listed if its name ends with the specified extension.
//----------------------------------------------------------------------------

class SimpleTextEndsWith
    implements FilenameFilter
{
    public SimpleTextEndsWith(
        String extension)
    {
        ext = extension;
    }

    public boolean accept(
        File dir,
        String name)
    {
        if (name.endsWith(ext)) {
            return true;
        }
        return false;
    }

    protected String ext;
}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextDatabaseMetaData.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextDatabaseMetaData.java
//
// Description: Implementation of the JDBC DatabaseMetaData interface
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

//---------------------------------------------------------------------------
// This class provides information about the database as a whole.
//
// Many of the methods here return lists of information in ResultSets.
// You can use the normal ResultSet methods such as getString and getInt
// to retrieve the data from these ResultSets.  If a given form of
// metadata is not available, these methods show throw a SQLException.
//
// Some of these methods take arguments that are String patterns.  These
// methods all have names such as fooPattern.  Within a pattern String "%"
// means match any substring of 0 or more characters and "_" means match
// any one character.
//---------------------------------------------------------------------------
// NOTE - this is an implementation of the JDBC API version 1.20
//---------------------------------------------------------------------------

import java.sql.*;
import java.util.Hashtable;

public class SimpleTextDatabaseMetaData
    extends        SimpleTextObject
    implements    DatabaseMetaData
{

    //------------------------------------------------------------------------
    // initialize
    //------------------------------------------------------------------------

    public void initialize(
        SimpleTextIConnection con)
        throws SQLException
    {
        // Save the owning connection object

        ownerConnection = con;
    }

    //-----------------------------------------------------------------------
    // allProceduresAreCallable - JDBC API
    // Can all the procedures returned by getProcedures be called by the
    // current user?
    //-----------------------------------------------------------------------

    public boolean allProceduresAreCallable()
        throws SQLException
    {
        // The SimpleText driver does not support callable statements, so
        // none are callable

        return false;
    }

    //-----------------------------------------------------------------------
    // allTablesAreSelectable - JDBC API
    // Can all the tables returned by getTable be SELECTed by the
    // current user?
    //-----------------------------------------------------------------------

    public boolean allTablesAreSelectable()
        throws SQLException
    {
        // The SimpleText driver allows all tables returned by getTables
        // to be selected

        return true;
    }

    //-----------------------------------------------------------------------
    // getURL - JDBC API
    // What's the url for this database?
    // Return the url or null if it can't be generated
    //-----------------------------------------------------------------------

    public String getURL()
        throws SQLException
    {
        // Can't generate a URL

        return null;
    }

    //-----------------------------------------------------------------------
    // getUserName - JDBC API
    // What's our user name as known to the database?
    //-----------------------------------------------------------------------

    public String getUserName()
        throws SQLException
    {
        // The SimpleText driver does not support user names

        return "";
    }

    //-----------------------------------------------------------------------
    // isReadOnly - JDBC API
    // Is the database in read-only mode?
    //-----------------------------------------------------------------------

    public boolean isReadOnly()
        throws SQLException
    {
        return ownerConnection.isReadOnly();
    }

    //-----------------------------------------------------------------------
    // nullsAreSortedHigh - JDBC API
    // Are NULL values sorted high?
    //-----------------------------------------------------------------------

    public boolean nullsAreSortedHigh()
        throws SQLException
    {
        // The SimpleText driver does not support nulls (or sorting, for
        // that matter)

        return false;
    }

    //-----------------------------------------------------------------------
    // nullsAreSortedLow - JDBC API
    // Are NULL values sorted low?
    //-----------------------------------------------------------------------

    public boolean nullsAreSortedLow()
        throws SQLException
    {
        // The SimpleText driver does not support nulls (or sorting, for
        // that matter)

        return false;
    }

    //-----------------------------------------------------------------------
    // nullsAreSortedAtStart - JDBC API
    // Are NULL values sorted at the start regardless of sort order?
    //-----------------------------------------------------------------------

    public boolean nullsAreSortedAtStart()
        throws SQLException
    {
        // The SimpleText driver does not support nulls (or sorting, for
        // that matter)

        return false;
    }

    //-----------------------------------------------------------------------
    // nullsAreSortedAtEnd - JDBC API
    // Are NULL values sorted at the end regardless of sort order?
    //-----------------------------------------------------------------------

    public boolean nullsAreSortedAtEnd()
        throws SQLException
    {
        // The SimpleText driver does not support nulls (or sorting, for
        // that matter)

        return false;
    }

    //-----------------------------------------------------------------------
    // getDatabaseProductName - JDBC API
    // What's the name of this database product?
    //-----------------------------------------------------------------------

    public String getDatabaseProductName()
        throws SQLException
    {
        return "Simple Text JDBC Driver";
    }

    //-----------------------------------------------------------------------
    // getDatabaseProductVersion - JDBC API
    // What's the version of this database product?
    //-----------------------------------------------------------------------

    public String getDatabaseProductVersion()
        throws SQLException
    {
        return "1.00";
    }

    //-----------------------------------------------------------------------
    // getDriverName - JDBC API
    // What's the name of this JDBC driver?
    //-----------------------------------------------------------------------

    public String getDriverName()
        throws SQLException
    {
        return "SimpleText";
    }

    //-----------------------------------------------------------------------
    // getDriverVersion - JDBC API
    // What's the version of this JDBC driver?
    //-----------------------------------------------------------------------

    public String getDriverVersion()
        throws SQLException
    {
        String s = "";
        int minorVersion = getDriverMinorVersion();

        // Format the minor version to have 4 places, with leading 0's

        if (minorVersion < 1000) s += "0";
        if (minorVersion < 100) s += "0";
        if (minorVersion < 10) s += "0";
        s += "" + minorVersion;

        return "" + getDriverMajorVersion() + "." + s;
    }

    //-----------------------------------------------------------------------
    // getDriverMajorVersion - JDBC API
    // What's this JDBC driver's major version number?
    //-----------------------------------------------------------------------

    public int getDriverMajorVersion()
    {
        return SimpleTextDefine.MAJOR_VERSION;
    }

    //-----------------------------------------------------------------------
    // getDriverMinorVersion - JDBC API
    // What's this JDBC driver's minor version number?
    //-----------------------------------------------------------------------

    public int getDriverMinorVersion()
    {
        return SimpleTextDefine.MINOR_VERSION;
    }

    //-----------------------------------------------------------------------
    // usesLocalFiles - JDBC API
    // Does the database store tables in a local file?
    //-----------------------------------------------------------------------

    public boolean usesLocalFiles()
        throws SQLException
    {
        // The SimpleText driver stores all database data in files

        return true;
    }

    //-----------------------------------------------------------------------
    // usesLocalFilePerTable - JDBC API
    // Does the database use a file for each table?
    //-----------------------------------------------------------------------

    public boolean usesLocalFilePerTable()
        throws SQLException
    {
        // The SimpleText driver uses a file for each table

        return true;
    }

    //-----------------------------------------------------------------------
    // supportsMixedCaseIdentifiers - JDBC API
    // Does the database support mixed case unquoted SQL identifiers?
    //-----------------------------------------------------------------------

    public boolean supportsMixedCaseIdentifiers()
        throws SQLException
    {
        return true;
    }

    //-----------------------------------------------------------------------
    // storesUpperCaseIdentifiers - JDBC API
    // Does the database store mixed case unquoted SQL identifiers in
    // upper case?
    //-----------------------------------------------------------------------

    public boolean storesUpperCaseIdentifiers()
        throws SQLException
    {
        return true;
    }

    //-----------------------------------------------------------------------
    // storesLowerCaseIdentifiers - JDBC API
    // Does the database store mixed case unquoted SQL identifiers in
    // lower case?
    //-----------------------------------------------------------------------

    public boolean storesLowerCaseIdentifiers()
        throws SQLException
    {
        return false;
    }

    //-----------------------------------------------------------------------
    // storesMixedCaseIdentifiers - JDBC API
    // Does the database store mixed case unquoted SQL identifiers in
    // mixed case?
    //-----------------------------------------------------------------------

    public boolean storesMixedCaseIdentifiers()
        throws SQLException
    {
        return false;
    }

    //-----------------------------------------------------------------------
    // supportsMixedCaseQuotedIdentifiers - JDBC API
    // Does the database support mixed case quoted SQL identifiers?
    //
    // A JDBC compliant driver will always return true.
    //-----------------------------------------------------------------------

    public boolean supportsMixedCaseQuotedIdentifiers()
        throws SQLException
    {
        return true;
    }

    //-----------------------------------------------------------------------
    // storesUpperCaseQuotedIdentifiers - JDBC API
    // Does the database store mixed case quoted SQL identifiers in
    // upper case?
    //
    // A JDBC compliant driver will always return true.
    //-----------------------------------------------------------------------

    public boolean storesUpperCaseQuotedIdentifiers()
        throws SQLException
    {
        return true;
    }

    //-----------------------------------------------------------------------
    // storesLowerCaseQuotedIdentifiers - JDBC API
    // Does the database store mixed case quoted SQL identifiers in
    // lower case?
    //
    // A JDBC compliant driver will always return false.
    //-----------------------------------------------------------------------

    public boolean storesLowerCaseQuotedIdentifiers()
        throws SQLException
    {
        return false;
    }

    //-----------------------------------------------------------------------
    // storesMixedCaseQuotedIdentifiers - JDBC API
    // Does the database store mixed case quoted SQL identifiers in
    // mixed case?
    //
    // A JDBC compliant driver will always return false.
    //-----------------------------------------------------------------------

    public boolean storesMixedCaseQuotedIdentifiers()
        throws SQLException
    {
        return false;
    }

    //-----------------------------------------------------------------------
    // getIdentifierQuoteString - JDBC API
    // What's the string used to quote SQL identifiers?
    // This returns a space " " if identifier quoting isn't supported.
    //
    // A JDBC compliant driver always uses a double quote character.
    //-----------------------------------------------------------------------

    public String getIdentifierQuoteString()
        throws SQLException
    {
        // The SimpleText driver does not support quoting

        return " ";
    }

    //-----------------------------------------------------------------------
    // getSQLKeywords - JDBC API
    // Get a comma separated list of all a database's SQL keywords
    // that are NOT also SQL92 keywords.
    //-----------------------------------------------------------------------

    public String getSQLKeywords()
        throws SQLException
    {
        return "";
    }

    //-----------------------------------------------------------------------
    // getNumericFunctions - JDBC API
    // Get a comma separated list of math functions.
    //-----------------------------------------------------------------------

    public String getNumericFunctions()
        throws SQLException
    {
        // The SimpleText driver does not support any math functions

        return "";
    }

    //-----------------------------------------------------------------------
    // getStringFunctions - JDBC API
    // Get a comma separated list of string functions.
    //-----------------------------------------------------------------------

    public String getStringFunctions()
        throws SQLException
    {
        // The SimpleText driver does not support any String functions

        return "";
    }

    //-----------------------------------------------------------------------
    // getSystemFunctions - JDBC API
    // Get a comma separated list of system functions.
    //-----------------------------------------------------------------------

    public String getSystemFunctions()
        throws SQLException
    {
        // The SimpleText driver does not support any System functions

        return "";
    }

    //-----------------------------------------------------------------------
    // getTimeDateFunctions - JDBC API
    // Get a comma separated list of time and date functions.
    //-----------------------------------------------------------------------

    public String getTimeDateFunctions()
        throws SQLException
    {
        // The SimpleText driver does not support any Time or Date functions

        return "";
    }

    //-----------------------------------------------------------------------
    // getSearchStringEscape - JDBC API
    // This is the string that can be used to escape '_' or '%' in
    // the string pattern style catalog search parameters.
    //
    // The '_' character represents any single character.
    // The '%' character represents any sequence of zero or
    // more characters.
    //-----------------------------------------------------------------------

    public String getSearchStringEscape()
        throws SQLException
    {
        // The SimpleText driver does not support search patterns, so
        // return an empty string

        return "";
    }

    //-----------------------------------------------------------------------
    // getExtraNameCharacters - JDBC API
    // Get all the "extra" characters that can be used in unquoted
    // identifier names (those beyond a-z, 0-9 and _).
    //-----------------------------------------------------------------------

    public String getExtraNameCharacters()
        throws SQLException
    {
        // The SimpleText driver does not allow any special characters
        // in indentifier names

        return "";
    }


    //-----------------------------------------------------------------------
    // supportsAlterTableWithAddColumn - JDBC API
    // Is "ALTER TABLE" with add column supported?
    //-----------------------------------------------------------------------

    public boolean supportsAlterTableWithAddColumn()
        throws SQLException
    {
        // The SimpleText driver does not support ALTER TABLE at all

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsAlterTableWithDropColumn - JDBC API
    // Is "ALTER TABLE" with drop column supported?
    //-----------------------------------------------------------------------

    public boolean supportsAlterTableWithDropColumn()
        throws SQLException
    {
        // The SimpleText driver does not support ALTER TABLE at all

        return false;
    }


    //-----------------------------------------------------------------------
    // supportsColumnAliasing - JDBC API
    // Is column aliasing supported?
    //
    // If so, the SQL AS clause can be used to provide names for
    // computed columns or to provide alias names for columns as
    // required.
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsColumnAliasing()
        throws SQLException
    {
        // The SimpleText driver does not support column alias names

        return false;
    }

    //-----------------------------------------------------------------------
    // nullPlusNonNullIsNull - JDBC API
    // Are concatenations between NULL and non-NULL values NULL?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean nullPlusNonNullIsNull()
        throws SQLException
    {
        // The SimpleText driver does not support nulls

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsConvert - JDBC API
    // Is the CONVERT function between SQL types supported?
    //-----------------------------------------------------------------------

    public boolean supportsConvert()
        throws SQLException
    {
        // The SimpleText driver does not support the CONVERT function

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsConvert - JDBC API
    // Is CONVERT between the given SQL types supported?
    //
    //    fromType    the type to convert from
    //    param        toType the type to convert to
    //-----------------------------------------------------------------------

    public boolean supportsConvert(
        int fromType,
        int toType)
        throws SQLException
    {
        // The SimpleText driver does not support the CONVERT function

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsTableCorrelationNames - JDBC API
    // Are table correlation names supported?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsTableCorrelationNames()
        throws SQLException
    {
        // The SimpleText driver does not support table correlation names

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsDifferentTableCorrelationNames - JDBC API
    // If table correlation names are supported, are they restricted
    // to be different from the names of the tables?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsDifferentTableCorrelationNames()
        throws SQLException
    {
        // The SimpleText driver does not support table correlation names

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsExpressionsInOrderBy - JDBC API
    // Are expressions in "ORDER BY" lists supported?
    //-----------------------------------------------------------------------

    public boolean supportsExpressionsInOrderBy()
        throws SQLException
    {
        // The SimpleText driver does not support ORDER BY

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsOrderByUnrelated - JDBC API
    // Can an "ORDER BY" clause use columns not in the SELECT?
    //-----------------------------------------------------------------------

    public boolean supportsOrderByUnrelated()
        throws SQLException
    {
        // The SimpleText driver does not support ORDER BY

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsGroupBy - JDBC API
    // Is some form of "GROUP BY" clause supported?
    //-----------------------------------------------------------------------

    public boolean supportsGroupBy()
        throws SQLException
    {
        // The SimpleText driver does not support GROUP BY

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsGroupByUnrelated - JDBC API
    // Can a "GROUP BY" clause use columns not in the SELECT?
    //-----------------------------------------------------------------------

    public boolean supportsGroupByUnrelated()
        throws SQLException
    {
        // The SimpleText driver does not support GROUP BY

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsGroupByBeyondSelect - JDBC API
    // Can a "GROUP BY" clause add columns not in the SELECT
    // provided it specifies all the columns in the SELECT?
    //-----------------------------------------------------------------------

    public boolean supportsGroupByBeyondSelect()
        throws SQLException
    {
        // The SimpleText driver does not support GROUP BY

        return false;
    }


    //-----------------------------------------------------------------------
    // supportsLikeEscapeClause - JDBC API
    // Is the escape character in "LIKE" clauses supported?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsLikeEscapeClause()
        throws SQLException
    {
        // The SimpleText driver does not support the LIKE clause

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsMultipleResultSets - JDBC API
    // Are multiple ResultSets from a single execute supported?
    //-----------------------------------------------------------------------

    public boolean supportsMultipleResultSets()
        throws SQLException
    {
        // The SimpleText driver does not support multiple result sets

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsMultipleTransactions - JDBC API
    // Can we have multiple transactions open at once (on different
    // connections)?
    //-----------------------------------------------------------------------

    public boolean supportsMultipleTransactions()
        throws SQLException
    {
        // The SimpleText driver does not support transactions

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsNonNullableColumns - JDBC API
    // Can columns be defined as non-nullable?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsNonNullableColumns()
        throws SQLException
    {
        // The SimpleText driver does not support nulls, so all columns by
        // default are non-nullable.  This, however, specifies whether the
        // column can be defined as NON NULL in the DDL (Data Definition
        // Language) statement, which is not supported.

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsMinimumSQLGrammar - JDBC API
    // Is the ODBC Minimum SQL grammar supported?
    //
    // All JDBC compliant drivers must return true.
    //-----------------------------------------------------------------------

    public boolean supportsMinimumSQLGrammar()
        throws SQLException
    {
        // The SimpleText driver does not even support the most minimum
        // SQL grammar

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsCoreSQLGrammar - JDBC API
    // Is the ODBC Core SQL grammar supported?
    //-----------------------------------------------------------------------

    public boolean supportsCoreSQLGrammar()
        throws SQLException
    {
        // The SimpleText driver does not even support the most minimum
        // SQL grammar

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsExtendedSQLGrammar - JDBC API
    // Is the ODBC Extended SQL grammar supported?
    //-----------------------------------------------------------------------

    public boolean supportsExtendedSQLGrammar()
        throws SQLException
    {
        // The SimpleText driver does not even support the most minimum
        // SQL grammar

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsANSI92EntryLevelSQL - JDBC API
    // Is the ANSI92 entry level SQL grammar supported?
    //
    // All JDBC compliant drivers must return true.
    //-----------------------------------------------------------------------

    public boolean supportsANSI92EntryLevelSQL()
        throws SQLException
    {
        // The SimpleText driver does not even support the most minimum
        // SQL grammar

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsANSI92IntermediateSQL - JDBC API
    // Is the ANSI92 intermediate SQL grammar supported?
    //-----------------------------------------------------------------------

    public boolean supportsANSI92IntermediateSQL()
        throws SQLException
    {
        // The SimpleText driver does not even support the most minimum
        // SQL grammar

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsANSI92FullSQL - JDBC API
    // Is the ANSI92 full SQL grammar supported?
    //-----------------------------------------------------------------------

    public boolean supportsANSI92FullSQL()
        throws SQLException
    {
        // The SimpleText driver does not even support the most minimum
        // SQL grammar

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsIntegrityEnhancementFacility - JDBC API
    // Is the SQL Integrity Enhancement Facility supported?
    //-----------------------------------------------------------------------

    public boolean supportsIntegrityEnhancementFacility()
        throws SQLException
    {
        // The SimpleText driver does support referential integrity

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsOuterJoins - JDBC API
    // Is some form of outer join supported?
    //-----------------------------------------------------------------------

    public boolean supportsOuterJoins()
        throws SQLException
    {
        // The SimpleText driver does not support outer joins

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsFullOuterJoins - JDBC API
    // Are full nested outer joins supported?
    //-----------------------------------------------------------------------

    public boolean supportsFullOuterJoins()
        throws SQLException
    {
        // The SimpleText driver does not support outer joins

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsLimitedOuterJoins - JDBC API
    // Is there limited support for outer joins?  (This will be true
    // if supportFullOuterJoins is true.)
    //-----------------------------------------------------------------------

    public boolean supportsLimitedOuterJoins()
        throws SQLException
    {
        // The SimpleText driver does not support outer joins

        return false;
    }

    //-----------------------------------------------------------------------
    // getSchemaTerm - JDBC API
    // What's the database vendor's preferred term for "schema"?
    //-----------------------------------------------------------------------

    public String getSchemaTerm()
        throws SQLException
    {
        return "SCHEMA";
    }

    //-----------------------------------------------------------------------
    // getProcedureTerm - JDBC API
    // What's the database vendor's preferred term for "procedure"?
    //-----------------------------------------------------------------------

    public String getProcedureTerm()
        throws SQLException
    {
        return "PROCEDURE";
    }

    //-----------------------------------------------------------------------
    // getCatalogTerm - JDBC API
    // What's the database vendor's preferred term for "catalog"?
    //-----------------------------------------------------------------------

    public String getCatalogTerm()
        throws SQLException
    {
        return "CATALOG";
    }

    //-----------------------------------------------------------------------
    // isCatalogAtStart - JDBC API
    // Does a catalog appear at the start of a qualified table name?
    // (Otherwise it appears at the end)
    //-----------------------------------------------------------------------

    public boolean isCatalogAtStart()
        throws SQLException
    {
        // The SimpleText driver supports specifying fully qualified
        // file names, so the catalog (directory) is specified first

        return true;
    }

    //-----------------------------------------------------------------------
    // getCatalogSeparator - JDBC API
    // What's the separator between catalog and table name?
    //-----------------------------------------------------------------------

    public String getCatalogSeparator()
        throws SQLException
    {
        // The SimpleText driver supports specifying fully qualified
        // file names, so the catalog separator is the directory
        // separator

        return "/";
    }

    //-----------------------------------------------------------------------
    // supportsSchemasInDataManipulation - JDBC API
    // Can a schema name be used in a data manipulation statement?
    //-----------------------------------------------------------------------

    public boolean supportsSchemasInDataManipulation()
        throws SQLException
    {
        // The SimpleText driver does not support schemas

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsSchemasInProcedureCalls - JDBC API
    // Can a schema name be used in a procedure call statement?
    //-----------------------------------------------------------------------

    public boolean supportsSchemasInProcedureCalls()
        throws SQLException
    {
        // The SimpleText driver does not support schemas

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsSchemasInTableDefinitions - JDBC API
    // Can a schema name be used in a table definition statement?
    //-----------------------------------------------------------------------

    public boolean supportsSchemasInTableDefinitions()
        throws SQLException
    {
        // The SimpleText driver does not support schemas

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsSchemasInIndexDefinitions - JDBC API
    // Can a schema name be used in an index definition statement?
    //-----------------------------------------------------------------------

    public boolean supportsSchemasInIndexDefinitions()
        throws SQLException
    {
        // The SimpleText driver does not support schemas

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsSchemasInPrivilegeDefinitions - JDBC API
    // Can a schema name be used in a privilege definition statement?
    //-----------------------------------------------------------------------

    public boolean supportsSchemasInPrivilegeDefinitions()
        throws SQLException
    {
        // The SimpleText driver does not support schemas

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsCatalogsInDataManipulation - JDBC API
    // Can a catalog name be used in a data manipulation statement?
    //-----------------------------------------------------------------------

    public boolean supportsCatalogsInDataManipulation()
        throws SQLException
    {
        // The SimpleText driver does support catalogs (path names)

        return true;
    }

    //-----------------------------------------------------------------------
    // supportsCatalogsInProcedureCalls - JDBC API
    // Can a catalog name be used in a procedure call statement?
    //-----------------------------------------------------------------------

    public boolean supportsCatalogsInProcedureCalls()
        throws SQLException
    {
        // The SimpleText driver does not support stored procedures

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsCatalogsInTableDefintions - JDBC API
    // Can a catalog name be used in a table definition statement?
    //-----------------------------------------------------------------------

    public boolean supportsCatalogsInTableDefinitions()
        throws SQLException
    {
        // The SimpleText driver does support catalogs (path names)

        return true;
    }

    //-----------------------------------------------------------------------
    // supportsCatalogsInIndexDefinitions - JDBC API
    // Can a catalog name be used in a index definition statement?
    //-----------------------------------------------------------------------

    public boolean supportsCatalogsInIndexDefinitions()
        throws SQLException
    {
        // The SimpleText driver does not support indexes

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsCatalogsInPrivilegeDefinitions - JDBC API
    // Can a catalog name be used in a privilege definition statement?
    //-----------------------------------------------------------------------

    public boolean supportsCatalogsInPrivilegeDefinitions()
        throws SQLException
    {
        // The SimpleText driver does not support privileges

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsPositionedDelete - JDBC API
    // Is positioned DELETE supported?
    //-----------------------------------------------------------------------

    public boolean supportsPositionedDelete()
        throws SQLException
    {
        // The SimpleText driver does not support positioned deletes

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsPositionedUpdate - JDBC API
    // Is positioned UPDATE supported?
    //-----------------------------------------------------------------------

    public boolean supportsPositionedUpdate()
        throws SQLException
    {
        // The SimpleText driver does not support positioned updates

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsSelectForUpdate - JDBC API
    // Is SELECT for UPDATE supported?
    //-----------------------------------------------------------------------

    public boolean supportsSelectForUpdate()
        throws SQLException
    {
        // The SimpleText driver does not support the FOR UPDATE clause

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsStoredProcedures - JDBC API
    // Are stored procedure calls using the stored procedure escape
    // syntax supported?
    //-----------------------------------------------------------------------

    public boolean supportsStoredProcedures()
        throws SQLException
    {
        // The SimpleText driver does not support stored procedures

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsSubqueriesInComparisons - JDBC API
    // Are subqueries in comparison expressions supported?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsSubqueriesInComparisons()
        throws SQLException
    {
        // The SimpleText driver does not support subqueries

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsSubqueriesInExists - JDBC API
    // Are subqueries in exists expressions supported?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsSubqueriesInExists()
        throws SQLException
    {
        // The SimpleText driver does not support subqueries

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsSubqueriesInIns - JDBC API
    // Are subqueries in "in" statements supported?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsSubqueriesInIns()
        throws SQLException
    {
        // The SimpleText driver does not support subqueries

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsSubqueriesInQuantifieds - JDBC API
    // Are subqueries in quantified expressions supported?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsSubqueriesInQuantifieds()
        throws SQLException
    {
        // The SimpleText driver does not support subqueries

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsCorrelatedSubqueries - JDBC API
    // Are correlated subqueries supported?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsCorrelatedSubqueries()
        throws SQLException
    {
        // The SimpleText driver does not support subqueries

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsUnion - JDBC API
    // Is SQL UNION supported?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsUnion()
        throws SQLException
    {
        // The SimpleText driver does not support unions

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsUnionAll - JDBC API
    // Is SQL UNION ALL supported?
    //
    // A JDBC compliant driver always returns true.
    //-----------------------------------------------------------------------

    public boolean supportsUnionAll()
        throws SQLException
    {
        // The SimpleText driver does not support unions

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsOpenCursorsAcrossCommit - JDBC API
    // Can cursors remain open across commits?
    //-----------------------------------------------------------------------

    public boolean supportsOpenCursorsAcrossCommit()
        throws SQLException
    {
        // The SimpleText driver does not support transactions; it is
        // always in auto-commit mode.  The cursor remains open after
        // a transaction is auto-committed

        return true;
    }

    //-----------------------------------------------------------------------
    // supportsOpenCursorsAcrossRollback - JDBC API
    // Can cursors remain open across rollbacks?
    //-----------------------------------------------------------------------

    public boolean supportsOpenCursorsAcrossRollback()
        throws SQLException
    {
        // The SimpleText driver does not support transactions; it is
        // always in auto-commit mode.  The cursor remains open after
        // a transaction is auto-committed.  A rollback has no effect.

        return true;
    }

    //-----------------------------------------------------------------------
    // supportsOpenStatementsAcrossCommit - JDBC API
    // Can statements remain open across commits?
    //-----------------------------------------------------------------------

    public boolean supportsOpenStatementsAcrossCommit()
        throws SQLException
    {
        // The SimpleText driver does not support transactions; it is
        // always in auto-commit mode.  The statement remains open after
        // a transaction is auto-committed

        return true;
    }


    //-----------------------------------------------------------------------
    // supportsOpenStatementsAcrossRollback - JDBC API
    // Can statements remain open across rollbacks?
    //-----------------------------------------------------------------------

    public boolean supportsOpenStatementsAcrossRollback()
        throws SQLException
    {
        // The SimpleText driver does not support transactions; it is
        // always in auto-commit mode.  The statement remains open after
        // a transaction is auto-committed.  A rollback has no effect.

        return true;
    }

    //-----------------------------------------------------------------------
    // getMaxBinaryLiteralLength - JDBC API
    // How many hex characters can you have in an inline binary literal?
    //-----------------------------------------------------------------------

    public int getMaxBinaryLiteralLength()
        throws SQLException
    {
        // The SimpleText driver does not have a limit.  0 indicates no
        // limit, or the limit is not known.

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxCharLiteralLength - JDBC API
    // What's the max length for a character literal?
    //-----------------------------------------------------------------------

    public int getMaxCharLiteralLength()
        throws SQLException
    {
        // The SimpleText driver does not have a limit.  0 indicates no
        // limit, or the limit is not known.

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxColumnNameLength - JDBC API
    // What's the limit on column name length?
    //-----------------------------------------------------------------------

    public int getMaxColumnNameLength()
        throws SQLException
    {
        return SimpleTextDefine.MAX_COLUMN_NAME_LEN;
    }

    //-----------------------------------------------------------------------
    // getMaxColumnsInGroupBy - JDBC API
    // What's the maximum number of columns in a "GROUP BY" clause?
    //-----------------------------------------------------------------------

    public int getMaxColumnsInGroupBy()
        throws SQLException
    {
        // The SimpleText driver does not support GROUP BY

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxColumnsInIndex - JDBC API
    // What's the maximum number of columns allowed in an index?
    //-----------------------------------------------------------------------

    public int getMaxColumnsInIndex()
        throws SQLException
    {
        // The SimpleText driver does not support indexes

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxColumnsInOrderBy - JDBC API
    // What's the maximum number of columns in an "ORDER BY" clause?
    //-----------------------------------------------------------------------

    public int getMaxColumnsInOrderBy()
        throws SQLException
    {
        // The SimpleText driver does not support ORDER BY

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxColumnsInSelect - JDBC API
    // What's the maximum number of columns in a "SELECT" list?
    //-----------------------------------------------------------------------

    public int getMaxColumnsInSelect()
        throws SQLException
    {
        // The SimpleText driver does not have a limit.  0 indicates no
        // limit, or the limit is not known.

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxColumnsInTable - JDBC API
    // What's maximum number of columns in a table?
    //-----------------------------------------------------------------------

    public int getMaxColumnsInTable()
        throws SQLException
    {
        return SimpleTextDefine.MAX_COLUMNS_IN_TABLE;
    }

    //-----------------------------------------------------------------------
    // getMaxConnections - JDBC API
    // How many active connections can we have at a time to this database?
    //-----------------------------------------------------------------------

    public int getMaxConnections()
        throws SQLException
    {
        // The SimpleText driver does not have a limit.  0 indicates no
        // limit, or the limit is not known.

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxCursorNameLength - JDBC API
    // What's the maximum cursor name length?
    //-----------------------------------------------------------------------

    public int getMaxCursorNameLength()
        throws SQLException
    {
        // The SimpleText driver does not support named cursors

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxIndexLength - JDBC API
    // What's the maximum length of an index (in bytes)?
    //-----------------------------------------------------------------------

    public int getMaxIndexLength()
        throws SQLException
    {
        // The SimpleText driver does not support indexes

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxSchemaNameLength - JDBC API
    // What's the maximum length allowed for a schema name?
    //-----------------------------------------------------------------------

    public int getMaxSchemaNameLength()
        throws SQLException
    {
        // The SimpleText driver does not support schemas

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxProcedureNameLength - JDBC API
    // What's the maximum length of a procedure name?
    //-----------------------------------------------------------------------

    public int getMaxProcedureNameLength()
        throws SQLException
    {
        // The SimpleText driver does not support stored procedures

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxCatalogNameLength - JDBC API
    // What's the maximum length of a catalog name?
    //-----------------------------------------------------------------------

    public int getMaxCatalogNameLength()
        throws SQLException
    {
        return SimpleTextDefine.MAX_CATALOG_NAME_LEN;
    }

    //-----------------------------------------------------------------------
    // getMaxRowSize - JDBC API
    // What's the maximum length of a single row?
    //-----------------------------------------------------------------------

    public int getMaxRowSize()
        throws SQLException
    {
        // The SimpleText driver does not have a limit.  0 indicates no
        // limit, or the limit is not known.

        return 0;
    }

    //-----------------------------------------------------------------------
    // doesMaxRowSizeIncludeBlobs - JDBC API
    // Did getMaxRowSize() include LONGVARCHAR and LONGVARBINARY
    // blobs?
    //-----------------------------------------------------------------------

    public boolean doesMaxRowSizeIncludeBlobs()
        throws SQLException
    {
        return false;
    }

    //-----------------------------------------------------------------------
    // getMaxStatementLength - JDBC API
    // What's the maximum length of a SQL statement?
    //-----------------------------------------------------------------------

    public int getMaxStatementLength()
        throws SQLException
    {
        // The SimpleText driver does not have a limit.  0 indicates no
        // limit, or the limit is not known.

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxStatements - JDBC API
    // How many active statements can we have open at one time to this
    // database?
    //-----------------------------------------------------------------------

    public int getMaxStatements()
        throws SQLException
    {
        // The SimpleText driver does not have a limit.  0 indicates no
        // limit, or the limit is not known.

        return 0;
    }

    //-----------------------------------------------------------------------
    // getMaxTableNameLength - JDBC API
    // What's the maximum length of a table name?
    //-----------------------------------------------------------------------

    public int getMaxTableNameLength()
        throws SQLException
    {
        return SimpleTextDefine.MAX_TABLE_NAME_LEN;
    }

    //-----------------------------------------------------------------------
    // getMaxTablesInSelect - JDBC API
    // What's the maximum number of tables in a SELECT?
    //-----------------------------------------------------------------------

    public int getMaxTablesInSelect()
        throws SQLException
    {
        // The SimpleText driver does not support joins, so only 1 table
        // is allowed to be specified in a SELECT statement

        return 1;
    }

    //-----------------------------------------------------------------------
    // getMaxUserNameLength - JDBC API
    // What's the maximum length of a user name?
    //-----------------------------------------------------------------------

    public int getMaxUserNameLength()
        throws SQLException
    {
        // The SimpleText driver does not support users

        return 0;
    }

    //-----------------------------------------------------------------------
    // getDefaultTransactionIsolation - JDBC API
    // What's the database's default transaction isolation level?  The
    // values are defined in java.sql.Connection.
    //-----------------------------------------------------------------------

    public int getDefaultTransactionIsolation()
        throws SQLException
    {
        // The SimpleText driver does not support transactions

        return Connection.TRANSACTION_NONE;
    }

    //-----------------------------------------------------------------------
    // supportsTransactions - JDBC API
    // Are transactions supported? If not, commit is a noop and the
    // isolation level is TRANSACTION_NONE.
    //-----------------------------------------------------------------------

    public boolean supportsTransactions()
        throws SQLException
    {
        // The SimpleText driver does not support transactions

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsTransactionIsolationLevel - JDBC API
    // Does the database support the given transaction isolation level?
    //
    //    level    the values are defined in java.sql.Connection
    //-----------------------------------------------------------------------

    public boolean supportsTransactionIsolationLevel(
        int level)
        throws SQLException
    {
        // The SimpleText driver does not support transaction.  Return
        // false for any level except for TRANSACTION_NONE

        boolean rc = false;
        if (level == Connection.TRANSACTION_NONE) {
            rc = true;
        }
        return rc;
    }

    //-----------------------------------------------------------------------
    // supportsDataDefinitionAndDataManipulationTransactions - JDBC API
    // Are both data definition and data manipulation statements
    // within a transaction supported?
    //-----------------------------------------------------------------------

    public boolean supportsDataDefinitionAndDataManipulationTransactions()
        throws SQLException
    {
        // The SimpleText driver does not support transactions

        return false;
    }

    //-----------------------------------------------------------------------
    // supportsDataManipulationTransactionsOnly
    // Are only data manipulation statements within a transaction
    // supported?
    //-----------------------------------------------------------------------

    public boolean supportsDataManipulationTransactionsOnly()
        throws SQLException
    {
        // The SimpleText driver does not support transactions

        return false;
    }

    //-----------------------------------------------------------------------
    // dataDefinitionsCausesTransactionCommit - JDBC API
    // Does a data definition statement within a transaction force the
    // transaction to commit?
    //-----------------------------------------------------------------------

    public boolean dataDefinitionCausesTransactionCommit()
        throws SQLException
    {
        // The SimpleText driver does not support transactions

        return false;
    }

    //-----------------------------------------------------------------------
    // dataDefinitionIgnoredInTransactions - JDBC API
    // Is a data definition statement within a transaction ignored?
    //-----------------------------------------------------------------------

    public boolean dataDefinitionIgnoredInTransactions()
        throws SQLException
    {
        // The SimpleText driver does not support transactions

        return false;
    }


    //-----------------------------------------------------------------------
    // getProcedures - JDBC API
    // Get a description of stored procedures available in a
    // catalog.
    //
    // Only procedure descriptions matching the schema and
    // procedure name criteria are returned.  They are ordered by
    // PROCEDURE_SCHEM, and PROCEDURE_NAME.
    //
    // Each procedure description has the the following columns:
    //
    //    (1) PROCEDURE_CAT    String => procedure catalog (may be null)
    //    (2) PROCEDURE_SCHEM    String => procedure schema (may be null)
    //    (3) PROCEDURE_NAME    String => procedure name
    //    (4) REMARKS            String => explanatory comment on the procedure
    //    (5) PROCEDURE_TYPE    short => kind of procedure:
    //            procedureResultUnknown - May return a result
    //            procedureNoResult - Does not return a result
    //            procedureReturnsResult - Returns a result
    //
    //    catalog            a catalog name; "" retrieves those without a catalog
    //    schemaPattern    a schema name pattern; "" retrieves those
    //                    without a schema
    //    procedureNamePattern    a procedure name pattern
    //
    // Returns a ResultSet.  Each row is a procedure description
    //-----------------------------------------------------------------------

    public ResultSet getProcedures(
        String catalog,
        String schemaPattern,
        String procedureNamePattern)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getProcedures(" + catalog + ", " + schemaPattern + ", " +
                    procedureNamePattern + ")");
        }

        // The SimpleText driver does not support procedures.  Instead of
        // throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "PROCEDURE_CAT", Types.VARCHAR);
        add(columns, 2, "PROCEDURE_SCHEM", Types.VARCHAR);
        add(columns, 3, "PROCEDURE_NAME", Types.VARCHAR);
        add(columns, 4, "REMARKS", Types.VARCHAR);
        add(columns, 5, "PROCEDURE_TYPE", Types.SMALLINT);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getProcedureColumns - JDBC API
    // Get a description of a catalog's stored procedure parameters
    // and result columns.
    //
    // Only descriptions matching the schema, procedure and
    // parameter name criteria are returned.  They are ordered by
    // PROCEDURE_SCHEM and PROCEDURE_NAME. Within this, the return value,
    // if any, is first. Next are the parameter descriptions in call
    // order. The column descriptions follow in column number order.
    //
    // Each row in the ResultSet is a parameter desription or
    // column description with the following fields:
    //
    //    (1) PROCEDURE_CAT    String => procedure catalog (may be null)
    //    (2) PROCEDURE_SCHEM    String => procedure schema (may be null)
    //    (3) PROCEDURE_NAME    String => procedure name
    //    (4) COLUMN_NAME        String => column/parameter name
    //    (5) COLUMN_TYPE        Short => kind of column/parameter:
    //            procedureColumnUnknown - nobody knows
    //            procedureColumnIn - IN parameter
    //            procedureColumnInOut - INOUT parameter
    //            procedureColumnOut - OUT parameter
    //            procedureColumnReturn - procedure return value
    //            procedureColumnResult - result column in ResultSet
    //    (6) DATA_TYPE        short => SQL type from java.sql.Types
    //    (7) TYPE_NAME        String => SQL type name
    //  (8) PRECISION        int => precision
    //    (9) LENGTH            int => length in bytes of data
    //    (10) SCALE            short => scale
    //    (11) RADIX            short => radix
    //    (12) NULLABLE        short => can it contain NULL?
    //            procedureNoNulls - does not allow NULL values
    //            procedureNullable - allows NULL values
    //            procedureNullableUnknown - nullability unknown
    //    (13) REMARKS        String => comment describing parameter/column
    //
    // Note: Some databases may not return the column
    // descriptions for a procedure. Additional columns beyond
    // REMARKS can be defined by the database.
    //
    //    catalog            a catalog name; "" retrieves those without a catalog
    //    schemaPattern    a schema name pattern; "" retrieves those
    //                    without a schema
    //    procedureNamePattern    a procedure name pattern
    //    columnNamePattern        a column name pattern
    //
    // Returns a ResultSet.  Each row is a stored procedure parameter or
    // column description
    //-----------------------------------------------------------------------

    public ResultSet getProcedureColumns(
        String catalog,
        String schemaPattern,
        String procedureNamePattern,
        String columnNamePattern)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getProcedureColumns(" + catalog + ", " + schemaPattern +
                    ", " + procedureNamePattern + ", " +
                    columnNamePattern + ")");
        }

        // The SimpleText driver does not support procedures.  Instead of
        // throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "PROCEDURE_CAT", Types.VARCHAR);
        add(columns, 2, "PROCEDURE_SCHEM", Types.VARCHAR);
        add(columns, 3, "PROCEDURE_NAME", Types.VARCHAR);
        add(columns, 4, "COLUMN_NAME", Types.VARCHAR);
        add(columns, 5, "COLUMN_TYPE", Types.SMALLINT);
        add(columns, 6, "DATA_TYPE", Types.SMALLINT);
        add(columns, 7, "TYPE_NAME", Types.VARCHAR);
        add(columns, 8, "PRECISION", Types.INTEGER);
        add(columns, 9, "LENGTH", Types.INTEGER);
        add(columns, 10, "LENGTH", Types.SMALLINT);
        add(columns, 11, "RADIX", Types.SMALLINT);
        add(columns, 12, "NULLABLE", Types.SMALLINT);
        add(columns, 13, "REMARKS", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getTables - JDBC API
    // Get a description of tables available in a catalog.
    //
    // Only table descriptions matching the catalog, schema, table
    // name and type criteria are returned.  They are ordered by
    // TABLE_TYPE, TABLE_SCHEM and TABLE_NAME.
    //
    // Each table description has the following columns:
    //
    //    (1) TABLE_CAT    String => table catalog (may be null)
    //    (2) TABLE_SCHEM    String => table schema (may be null)
    //    (3) TABLE_NAME    String => table name
    //    (4) TABLE_TYPE    String => table type.
    //            Typical types are "TABLE", "VIEW", "SYSTEM TABLE",
    //            "GLOBAL TEMPORARY", "LOCAL TEMPORARY", "ALIAS", "SYNONYM"
    //    (5) REMARKS    String => explanatory comment on the table
    //
    // Note: Some databases may not return information for
    // all tables.
    //
    //    catalog            a catalog name; "" retrieves those without a catalog
    //    schemaPattern    a schema name pattern; "" retrieves those
    //                    without a schema
    //    tableNamePattern    a table name pattern
    //    types            a list of table types to include; null returns all
    //                    types
    //
    // Returns a ResultSet.  Each row is a table description
    //-----------------------------------------------------------------------

    public ResultSet getTables(
        String catalog,
        String schemaPattern,
        String tableNamePattern,
        String types[])
        throws SQLException
    {
        if (traceOn()) {
            trace("@getTables(" + catalog + ", " + schemaPattern +
                    ", " + tableNamePattern + ")");
        }

        // Create a statement object

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "TABLE_CAT", Types.VARCHAR);
        add(columns, 2, "TABLE_SCHEM", Types.VARCHAR);
        add(columns, 3, "TABLE_NAME", Types.VARCHAR);
        add(columns, 4, "TABLE_TYPE", Types.VARCHAR);
        add(columns, 5, "REMARKS", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // If any of the parameters will return an empty result set, do so

        boolean willBeEmpty = false;

        // If table types are specified, make sure that 'TABLE' is
        // included.  If not, no rows will be returned

        if (types != null) {
            willBeEmpty = true;
            for (int ii = 0; ii < types.length; ii++) {
                if (types[ii].equalsIgnoreCase("TABLE")) {
                    willBeEmpty = false;
                    break;
                }
            }
        }

        if (!willBeEmpty) {

            // Get a Hashtable will all tables

            Hashtable tables = ownerConnection.getTables(
                    ownerConnection.getDirectory(catalog), tableNamePattern);

            Hashtable singleRow;
            SimpleTextTable table;

            // Create a row for each table in the Hashtable

            for (int i = 0; i < tables.size(); i++) {
                table = (SimpleTextTable) tables.get(new Integer(i));

                // Create a new Hashtable for a single row

                singleRow = new Hashtable();

                // Build the row
                singleRow.put(new Integer(1), new CommonValue(table.dir));
                singleRow.put(new Integer(3), new CommonValue(table.name));
                singleRow.put(new Integer(4), new CommonValue("TABLE"));

                // Add it to the row list
                rows.put(new Integer(i + 1), singleRow);
            }
        }

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getSchemas - JDBC API
    // Get the schema names available in this database.  The results
    // are ordered by schema name.
    //
    // The schema column is:
    //
    //    (1) TABLE_SCHEM        String => schema name
    //
    // Returns a ResultSet.  Each row has a single String column that is a
    // schema name
    //-----------------------------------------------------------------------

    public ResultSet getSchemas()
        throws SQLException
    {
        if (traceOn()) {
            trace("@getSchemas");
        }

        // The SimpleText driver does not support schemas.  Instead of
        // throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "TABLE_SCHEM", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getCatalogs - JDBC API
    // Get the catalog names available in this database.  The results
    // are ordered by catalog name.
    //
    // The catalog column is:
    //
    //    (1) TABLE_CAT    String => catalog name
    //
    // Returns a ResultSet.  Each row has a single String column that is a
    // catalog name
    //-----------------------------------------------------------------------

    public ResultSet getCatalogs()
        throws SQLException
    {
        if (traceOn()) {
            trace("@getCatalogs");
        }

        // The SimpleText driver only supports one catalog - the current
        // directory for the connection

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "TABLE_CAT", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create a Hashtable for a single row

        Hashtable singleRow = new Hashtable();

        // Set the value for column 1, which is the directory for the
        // connection

        singleRow.put (new Integer(1),
                new CommonValue(ownerConnection.getDirectory(null)));

        rows.put (new Integer(1), singleRow);

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getTableTypes - JDBC API
    // Get the table types available in this database.  The results
    // are ordered by table type.
    //
    // The table type is:
    //
    //    (1) TABLE_TYPE    String => table type.
    //            Typical types are "TABLE", "VIEW", "SYSTEM TABLE",
    //            "GLOBAL TEMPORARY", "LOCAL TEMPORARY", "ALIAS", "SYNONYM".
    //
    // Return a ResultSet.  Each row has a single String column that is a
    // table type
    //-----------------------------------------------------------------------

    public ResultSet getTableTypes()
        throws SQLException
    {
        if (traceOn()) {
            trace("@getTableTypes");
        }

        // The SimpleText driver only supports one table type - TABLE

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "TABLE_TYPE", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create a Hashtable for a single row

        Hashtable singleRow = new Hashtable();

        // Set the value for column 1, which is the only table type - TABLE

        singleRow.put (new Integer(1), new CommonValue("TABLE"));

        rows.put (new Integer(1), singleRow);

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getColumns - JDBC API
    // Get a description of table columns available in a catalog.
    //
    // Only column descriptions matching the catalog, schema, table
    // and column name criteria are returned.  They are ordered by
    // TABLE_SCHEM, TABLE_NAME and ORDINAL_POSITION.
    //
    // Each column description has the following columns:
    //
    //    (1) TABLE_CAT        String => table catalog (may be null)
    //    (2) TABLE_SCHEM        String => table schema (may be null)
    //    (3) TABLE_NAME        String => table name
    //    (4) COLUMN_NAME        String => column name
    //    (5) DATA_TYPE        short => SQL type from java.sql.Types
    //    (6) TYPE_NAME        String => Data source dependent type name
    //    (7) COLUMN_SIZE        int => column size.  For char or date
    //            types this is the maximum number of characters, for numeric or
    //            decimal types this is precision.
    //    (8) BUFFER_LENGTH    int => is not used.
    //    (9) DECIMAL_DIGITS    int => the number of fractional digits
    //    (10) NUM_PREC_RADIX    int => Radix (typically either 10 or 2)
    //    (11) NULLABLE        int => is NULL allowed?
    //            columnNoNulls - might not allow NULL values
    //            columnNullable - definitely allows NULL values
    //            columnNullableUnknown - nullability unknown
    //    (12) REMARKS        String => comment describing column (may be null)
    //    (13) COLUMN_DEF        String => default value (may be null)
    //    (14) SQL_DATA_TYPE    int => unused
    //    (15) SQL_DATETIME_SUB    int => unused
    //    (16) CHAR_OCTET_LENGTH    int => for char types the
    //            maximum number of bytes in the column
    //    (17) ORDINAL_POSITION    int    => index of column in table
    //            (starting at 1)
    //    (18) IS_NULLABLE    String => "NO" means column definitely
    //            does not allow NULL values; "YES" means the column might
    //            allow NULL values.  An empty string means nobody knows.
    //
    //    catalog            a catalog name; "" retrieves those without a catalog
    //    schemaPattern    a schema name pattern; "" retrieves those
    //                    without a schema
    //    tableNamePattern    a table name pattern
    //    columnNamePattern    a column name pattern
    //
    // Returns a ResultSet.  Each row is a column description
    //-----------------------------------------------------------------------

    public ResultSet getColumns(
        String catalog,
        String schemaPattern,
        String tableNamePattern,
        String columnNamePattern)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getColumns(" + catalog + ", " + schemaPattern +
                    ", " + tableNamePattern + ", " + columnNamePattern + ")");
        }

        // Create a statement object

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "TABLE_CAT", Types.VARCHAR);
        add(columns, 2, "TABLE_SCHEM", Types.VARCHAR);
        add(columns, 3, "TABLE_NAME", Types.VARCHAR);
        add(columns, 4, "COLUMN_NAME", Types.VARCHAR);
        add(columns, 5, "DATA_TYPE", Types.SMALLINT);
        add(columns, 6, "TYPE_NAME", Types.VARCHAR);
        add(columns, 7, "COLUMN_SIZE", Types.INTEGER);
        add(columns, 8, "BUFFER_LENGTH", Types.INTEGER);
        add(columns, 9, "DECIMAL_DIGITS", Types.INTEGER);
        add(columns, 10, "NUM_PREC_RADIX", Types.INTEGER);
        add(columns, 11, "NULLABLE", Types.INTEGER);
        add(columns, 12, "REMARKS", Types.VARCHAR);
        add(columns, 13, "COLUMN_DEF", Types.VARCHAR);
        add(columns, 14, "SQL_DATA_TYPE", Types.INTEGER);
        add(columns, 15, "SQL_DATETIME_SUB", Types.INTEGER);
        add(columns, 16, "CHAR_OCTET_LENGTH", Types.INTEGER);
        add(columns, 17, "ORDINAL_POSITION", Types.INTEGER);
        add(columns, 18, "IS_NULLABLE", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Get a Hashtable will all tables

        Hashtable tables = ownerConnection.getTables(
                    ownerConnection.getDirectory(catalog), tableNamePattern);

        Hashtable singleRow;
        Hashtable columnList;
        SimpleTextTable table;
        SimpleTextColumn column;

        int count = 0;

        // Create a row for each column in each table in the Hashtable

        for (int i = 0; i < tables.size(); i++) {
            table = (SimpleTextTable) tables.get(new Integer(i));

            // Get the columns

            columnList = ownerConnection.getColumns(table.dir, table.name);

            if (columnList == null) {
                continue;
            }

            for (int ii = 1; ii <= columnList.size(); ii++) {

                column = (SimpleTextColumn) columnList.get(new Integer(ii));

                // Create a new Hashtable for a single row

                singleRow = new Hashtable();

                // Build the row
                singleRow.put(new Integer(1), new CommonValue(table.dir));
                singleRow.put(new Integer(3), new CommonValue(table.name));
                singleRow.put(new Integer(4), new CommonValue(column.name));
                singleRow.put(new Integer(5), new CommonValue(column.type));
                singleRow.put(new Integer(6),
                            new CommonValue(typeToName(column.type)));
                singleRow.put(new Integer(7),
                                    new CommonValue(column.precision));

                // Add it to the row list (column numbers are 1-based)
                count++;
                rows.put(new Integer(count), singleRow);
            }

        }

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getColumnPriviledges - JDBC API
    // Get a description of the access rights for a table's columns.
    //
    // Only privileges matching the column name criteria are
    // returned.  They are ordered by COLUMN_NAME and PRIVILEGE.
    //
    // Each privilige description has the following columns:
    //
    //    (1) TABLE_CAT    String => table catalog (may be null)
    //    (2) TABLE_SCHEM    String => table schema (may be null)
    //    (3) TABLE_NAME    String => table name
    //    (4) COLUMN_NAME    String => column name
    //    (5) GRANTOR        String => grantor of access (may be null)
    //    (6) GRANTEE        String => grantee of access
    //    (7) PRIVILEGE    String => name of access (SELECT,
    //            INSERT, UPDATE, REFRENCES, ...)
    //    (8) IS_GRANTABLE    String => "YES" if grantee is permitted
    //            to grant to others; "NO" if not; null if unknown
    //
    //    catalog        a catalog name; "" retrieves those without a catalog
    //    schema        a schema name; "" retrieves those without a schema
    //    table        a table name
    //    columnNamePattern    a column name pattern
    //
    // Returns a ResultSet.  Each row is a column privilege description
    //-----------------------------------------------------------------------

    public ResultSet getColumnPrivileges(
        String catalog,
        String schema,
        String table,
        String columnNamePattern)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getColumnPrivileges(" + catalog + ", " + schema + ", " +
                            table + ", " + columnNamePattern + ")");
        }

        // The SimpleText driver does not support column privileges.  Instead
        // of throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "TABLE_CAT", Types.VARCHAR);
        add(columns, 2, "TABLE_SCHEM", Types.VARCHAR);
        add(columns, 3, "TABLE_NAME", Types.VARCHAR);
        add(columns, 4, "COLUMN_NAME", Types.VARCHAR);
        add(columns, 5, "GRANTOR", Types.VARCHAR);
        add(columns, 6, "GRANTEE", Types.VARCHAR);
        add(columns, 7, "PRIVILEGE", Types.VARCHAR);
        add(columns, 8, "IS_GRANTABLE", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getTablePrivileges - JDBC API
    // Get a description of the access rights for each table available
    // in a catalog.
    //
    // Only privileges matching the schema and table name
    // criteria are returned.  They are ordered by TABLE_SCHEM,
    // TABLE_NAME, and PRIVILEGE.
    //
    // Each privilige description has the following columns:
    //
    //    (1) TABLE_CAT    String => table catalog (may be null)
    //    (2) TABLE_SCHEM    String => table schema (may be null)
    //    (3) TABLE_NAME    String => table name
    //    (4) COLUMN_NAME    String => column name
    //    (5) GRANTOR        String => grantor of access (may be null)
    //    (6) GRANTEE        String => grantee of access
    //    (7) PRIVILEGE    String => name of access (SELECT,
    //            INSERT, UPDATE, REFRENCES, ...)
    //    (8) IS_GRANTABLE    String => "YES" if grantee is permitted
    //            to grant to others; "NO" if not; null if unknown
    //
    //    catalog            a catalog name; "" retrieves those without a catalog
    //    schemaPattern    a schema name pattern; "" retrieves those
    //                    without a schema
    //    tableNamePattern    a table name pattern
    //
    // Returns a ResultSet.  Each row is a table privilege description
    //-----------------------------------------------------------------------

    public ResultSet getTablePrivileges(
        String catalog,
        String schemaPattern,
        String tableNamePattern)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getTablePrivileges(" + catalog + ", " + schemaPattern +
                            ", " + tableNamePattern + ")");
        }

        // The SimpleText driver does not support table privileges.  Instead
        // of throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "TABLE_CAT", Types.VARCHAR);
        add(columns, 2, "TABLE_SCHEM", Types.VARCHAR);
        add(columns, 3, "TABLE_NAME", Types.VARCHAR);
        add(columns, 4, "COLUMN_NAME", Types.VARCHAR);
        add(columns, 5, "GRANTOR", Types.VARCHAR);
        add(columns, 6, "GRANTEE", Types.VARCHAR);
        add(columns, 7, "PRIVILEGE", Types.VARCHAR);
        add(columns, 8, "IS_GRANTABLE", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getBestRowIdentifier - JDBC API
    // Get a description of a table's optimal set of columns that
    // uniquely identifies a row. They are ordered by SCOPE.
    //
    // Each column description has the following columns:
    //
    //    (1) SCOPE            short => actual scope of result
    //            bestRowTemporary - very temporary, while using row
    //            bestRowTransaction - valid for remainder of current transaction
    //            bestRowSession - valid for remainder of current session
    //    (2) COLUMN_NAME        String => column name
    //    (3) DATA_TYPE        short => SQL data type from java.sql.Types
    //    (4) TYPE_NAME        String => Data source dependent type name
    //    (5) COLUMN_SIZE        int => precision
    //    (6) BUFFER_LENGTH    int => not used
    //    (7) DECIMAL_DIGITS    short => scale
    //    (8) PSEUDO_COLUMN    short => is this a pseudo column
    //                                 like an Oracle ROWID
    //            bestRowUnknown - may or may not be pseudo column
    //            bestRowNotPseudo - is NOT a pseudo column
    //            bestRowPseudo - is a pseudo column
    //
    //    catalog        a catalog name; "" retrieves those without a catalog
    //    schema        a schema name; "" retrieves those without a schema
    //    table        a table name
    //    scope        the scope of interest; use same values as SCOPE
    //    nullable    include columns that are nullable?
    //
    // Returns a ResultSet.  Each row is a column description
    //-----------------------------------------------------------------------

    public ResultSet getBestRowIdentifier(
        String catalog,
        String schema,
        String table,
        int scope,
        boolean nullable)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getBestRowIdentifier(" + catalog + ", " + schema + ", " +
                            table + ", " + scope + ", " + nullable + ")");
        }

        // The SimpleText driver does not support row identifiers.  Instead
        // of throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "SCOPE", Types.SMALLINT);
        add(columns, 2, "COLUMN_NAME", Types.VARCHAR);
        add(columns, 3, "DATA_TYPE", Types.SMALLINT);
        add(columns, 4, "TYPE_NAME", Types.VARCHAR);
        add(columns, 5, "COLUMN_SIZE", Types.INTEGER);
        add(columns, 6, "BUFFER_LENGTH", Types.INTEGER);
        add(columns, 7, "DECIMAL_DIGITS", Types.SMALLINT);
        add(columns, 8, "PSEUDO_COLUMN", Types.SMALLINT);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }


    //-----------------------------------------------------------------------
    // getVersionColumns - JDBC API
    // Get a description of a table's columns that are automatically
    // updated when any value in a row is updated.  They are
    // unordered.
    //
    // Each column description has the following columns:
    //
    //    (1) SCOPE            short => is not used
    //    (2) COLUMN_NAME        String => column name
    //    (3) DATA_TYPE        short => SQL data type from java.sql.Types
    //    (4) TYPE_NAME        String => Data source dependent type name
    //    (5) COLUMN_SIZE        int => precision
    //    (6) BUFFER_LENGTH    int => length of column value in bytes
    //    (7) DECIMAL_DIGITS    short => scale
    //    (8) PSEUDO_COLUMN    short => is this a pseudo column
    //                        like an Oracle ROWID
    //            versionColumnUnknown - may or may not be pseudo column
    //            versionColumnNotPseudo - is NOT a pseudo column
    //            versionColumnPseudo - is a pseudo column
    //
    //    catalog    a catalog name; "" retrieves those without a catalog
    //    schema    a schema name; "" retrieves those without a schema
    //    table    a table name
    //
    // Returns a ResultSet.  Each row is a column description
    //-----------------------------------------------------------------------

    public ResultSet getVersionColumns(
        String catalog,
        String schema,
        String table)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getVersionColumns(" + catalog + ", " + schema + ", " +
                            table + ")");
        }

        // The SimpleText driver does not support version columns.  Instead
        // of throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "SCOPE", Types.SMALLINT);
        add(columns, 2, "COLUMN_NAME", Types.VARCHAR);
        add(columns, 3, "DATA_TYPE", Types.SMALLINT);
        add(columns, 4, "TYPE_NAME", Types.VARCHAR);
        add(columns, 5, "COLUMN_SIZE", Types.INTEGER);
        add(columns, 6, "BUFFER_LENGTH", Types.INTEGER);
        add(columns, 7, "DECIMAL_DIGITS", Types.SMALLINT);
        add(columns, 8, "PSEUDO_COLUMN", Types.SMALLINT);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getPrimaryKeys - JDBC API
    // Get a description of a table's primary key columns.  They
    // are ordered by COLUMN_NAME.
    //
    // Each column description has the following columns:
    //
    //    (1) TABLE_CAT        String => table catalog (may be null)
    //    (2) TABLE_SCHEM        String => table schema (may be null)
    //    (3) TABLE_NAME        String => table name
    //    (4) COLUMN_NAME        String => column name
    //    (5) KEY_SEQ            short => sequence number within primary key
    //    (6) PK_NAME            String => primary key name (may be null)
    //
    //    catalog    a catalog name; "" retrieves those without a catalog
    //    schema    a schema name pattern; "" retrieves those
    //            without a schema
    //    table    a table name
    //
    // Returns a ResultSet.  Each row is a primary key column description
    //-----------------------------------------------------------------------

    public ResultSet getPrimaryKeys(
        String catalog,
        String schema,
        String table)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getPrimaryKeys(" + catalog + ", " + schema + ", " +
                            table + ")");
        }

        // The SimpleText driver does not support indexes.  Instead
        // of throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "TABLE_CAT", Types.VARCHAR);
        add(columns, 2, "TABLE_SCHEM", Types.VARCHAR);
        add(columns, 3, "TABLE_NAME", Types.VARCHAR);
        add(columns, 4, "COLUMN_NAME", Types.VARCHAR);
        add(columns, 5, "KEY_SEQ", Types.SMALLINT);
        add(columns, 6, "PK_NAME", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getImportedKeys - JDBC API
    // Get a description of the primary key columns that are
    // referenced by a table's foreign key columns (the primary keys
    // imported by a table).  They are ordered by PKTABLE_CAT,
    // PKTABLE_SCHEM, PKTABLE_NAME, and KEY_SEQ.
    //
    // Each primary key column description has the following columns:
    //
    //    (1) PKTABLE_CAT        String => primary key table catalog
    //                            being imported (may be null)
    //    (2) PKTABLE_SCHEM    String => primary key table schema
    //                            being imported (may be null)
    //    (3) PKTABLE_NAME    String => primary key table name
    //                            being imported
    //    (4) PKCOLUMN_NAME    String => primary key column name
    //                            being imported
    //    (5) FKTABLE_CAT        String => foreign key table catalog (may be null)
    //    (6) FKTABLE_SCHEM    String => foreign key table schema (may be null)
    //    (7) FKTABLE_NAME    String => foreign key table name
    //    (8) FKCOLUMN_NAME    String => foreign key column name
    //    (9) KEY_SEQ            short => sequence number within foreign key
    //    (10) UPDATE_RULE    short => What happens to
    //                            foreign key when primary is updated:
    //            importedKeyCascade - change imported key to agree
    //                 with primary key update
    //            importedKeyRestrict - do not allow update of primary
    //                key if it has been imported
    //            importedKeySetNull - change imported key to NULL if
    //                its primary key has been updated
    //    (11) DELETE_RULE    short => What happens to
    //                            the foreign key when primary is deleted.
    //            importedKeyCascade - delete rows that import a deleted key
    //            importedKeyRestrict - do not allow delete of primary
    //                key if it has been imported
    //            importedKeySetNull - change imported key to NULL if
    //                its primary key has been deleted
    //    (12) FK_NAME        String => foreign key name (may be null)
    //    (13) PK_NAME        String => primary key name (may be null)
    //
    //    catalog    a catalog name; "" retrieves those without a catalog
    //    schema    a schema name pattern; "" retrieves those without a schema
    //    table    a table name
    //
    // Returns a ResultSet.  Each row is a primary key column description
    //-----------------------------------------------------------------------

    public ResultSet getImportedKeys(
        String catalog,
        String schema,
        String table)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getImportedKeys(" + catalog + ", " + schema + ", " +
                            table + ")");
        }

        // The SimpleText driver does not support indexes.  Instead
        // of throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "PKTABLE_CAT", Types.VARCHAR);
        add(columns, 2, "PKTABLE_SCHEM", Types.VARCHAR);
        add(columns, 3, "PKTABLE_NAME", Types.VARCHAR);
        add(columns, 4, "PKCOLUMN_NAME", Types.VARCHAR);
        add(columns, 5, "FKTABLE_CAT", Types.VARCHAR);
        add(columns, 6, "FKTABLE_SCHEM", Types.VARCHAR);
        add(columns, 7, "FKTABLE_NAME", Types.VARCHAR);
        add(columns, 8, "FKCOLUMN_NAME", Types.VARCHAR);
        add(columns, 9, "KEY_SEQ", Types.SMALLINT);
        add(columns, 10, "UPDATE_RULE", Types.SMALLINT);
        add(columns, 11, "DELETE_RULE", Types.SMALLINT);
        add(columns, 12, "FK_NAME", Types.VARCHAR);
        add(columns, 13, "PK_NAME", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }


    //-----------------------------------------------------------------------
    // getExportedKeys - JDBC API
    // Get a description of a foreign key columns that reference a
    // table's primary key columns (the foreign keys exported by a
    // table).  They are ordered by FKTABLE_CAT, FKTABLE_SCHEM,
    // FKTABLE_NAME, and KEY_SEQ.
    //
    // Column definitions are the same as getImportedKeys.
    //
    // Returns a ResultSet.  Each row is a foreign key column description
    //-----------------------------------------------------------------------

    public ResultSet getExportedKeys(
        String catalog,
        String schema,
        String table)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getExportedKeys(" + catalog + ", " + schema + ", " +
                            table + ")");
        }

        // The SimpleText driver does not support indexes.  Instead
        // of throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "PKTABLE_CAT", Types.VARCHAR);
        add(columns, 2, "PKTABLE_SCHEM", Types.VARCHAR);
        add(columns, 3, "PKTABLE_NAME", Types.VARCHAR);
        add(columns, 4, "PKCOLUMN_NAME", Types.VARCHAR);
        add(columns, 5, "FKTABLE_CAT", Types.VARCHAR);
        add(columns, 6, "FKTABLE_SCHEM", Types.VARCHAR);
        add(columns, 7, "FKTABLE_NAME", Types.VARCHAR);
        add(columns, 8, "FKCOLUMN_NAME", Types.VARCHAR);
        add(columns, 9, "KEY_SEQ", Types.SMALLINT);
        add(columns, 10, "UPDATE_RULE", Types.SMALLINT);
        add(columns, 11, "DELETE_RULE", Types.SMALLINT);
        add(columns, 12, "FK_NAME", Types.VARCHAR);
        add(columns, 13, "PK_NAME", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getCrossReference - JDBC API
    // Get a description of the foreign key columns in the foreign key
    // table that reference the primary key columns of the primary key
    // table (describe how one table imports another's key.) This
    // should normally return a single foreign key/primary key pair
    // (most tables only import a foreign key from a table once.)  They
    // are ordered by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, and
    // KEY_SEQ.
    //
    // Column definitions are the same as getImportedKeys.
    //
    // Returns a ResultSet.  Each row is a foreign key column description
    //-----------------------------------------------------------------------

    public ResultSet getCrossReference(
        String primaryCatalog,
        String primarySchema,
        String primaryTable,
        String foreignCatalog,
        String foreignSchema,
        String foreignTable)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getCrossReference(" + primaryCatalog + ", " +
                    primarySchema + ", " + primaryTable + ", " +
                    foreignCatalog + ", " +    foreignSchema + ", " +
                    foreignTable + ")");
        }

        // The SimpleText driver does not support indexes.  Instead
        // of throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "PKTABLE_CAT", Types.VARCHAR);
        add(columns, 2, "PKTABLE_SCHEM", Types.VARCHAR);
        add(columns, 3, "PKTABLE_NAME", Types.VARCHAR);
        add(columns, 4, "PKCOLUMN_NAME", Types.VARCHAR);
        add(columns, 5, "FKTABLE_CAT", Types.VARCHAR);
        add(columns, 6, "FKTABLE_SCHEM", Types.VARCHAR);
        add(columns, 7, "FKTABLE_NAME", Types.VARCHAR);
        add(columns, 8, "FKCOLUMN_NAME", Types.VARCHAR);
        add(columns, 9, "KEY_SEQ", Types.SMALLINT);
        add(columns, 10, "UPDATE_RULE", Types.SMALLINT);
        add(columns, 11, "DELETE_RULE", Types.SMALLINT);
        add(columns, 12, "FK_NAME", Types.VARCHAR);
        add(columns, 13, "PK_NAME", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // getTypeInfo - JDBC API
    // Get a description of all the standard SQL types supported by
    // this database. They are ordered by DATA_TYPE and then by how
    // closely the data type maps to the corresponding JDBC SQL type.
    //
    //    Each type description has the following columns:
    //
    //    (1) TYPE_NAME        String => Type name
    //    (2) DATA_TYPE        short => SQL data type from java.sql.Types
    //    (3) PRECISION        int => maximum precision
    //    (4) LITERAL_PREFIX    String => prefix used to quote a literal
    //                            (may be null)
    //    (5) LITERAL_SUFFIX    String => suffix used to quote a literal
    //                            (may be null)
    //    (6) CREATE_PARAMS    String => parameters used in creating
    //                            the type (may be null)
    //    (7) NULLABLE        short => can you use NULL for this type?
    //            typeNoNulls - does not allow NULL values
    //            typeNullable - allows NULL values
    //            typeNullableUnknown - nullability unknown
    //    (8) CASE_SENSITIVE    boolean=> is it case sensitive?
    //    (9) SEARCHABLE        short => can you use "WHERE" based on this type:
    //            typePredNone - No support
    //            typePredChar - Only supported with WHERE .. LIKE
    //            typePredBasic - Supported except for WHERE .. LIKE
    //            typeSearchable - Supported for all WHERE ..
    //    (10) UNSIGNED_ATTRIBUTE    boolean => is it unsigned?
    //    (11) FIXED_PREC_SCALE    boolean => can it be a money value?
    //    (12) AUTO_INCREMENT        boolean => can it be used for an
    //                                auto-increment value?
    //    (13) LOCAL_TYPE_NAME    String => localized version of type name
    //                                (may be null)
    //    (14) MINIMUM_SCALE        short => minimum scale supported
    //    (15) MAXIMUM_SCALE        short => maximum scale supported
    //    (16) SQL_DATA_TYPE        int => unused
    //    (17) SQL_DATETIME_SUB    int => unused
    //    (18) NUM_PREC_RADIX        int => usually 2 or 10
    //
    // Returns a ResultSet.  Each row is a SQL type description
    //-----------------------------------------------------------------------

    public ResultSet getTypeInfo()
        throws SQLException
    {
        if (traceOn()) {
            trace("@getTableTypes");
        }

        // The SimpleText driver only supports the following data types:
        //
        //    VARCHAR
        //    INTEGER
        //    VARBINARY

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "TYPE_NAME", Types.VARCHAR);
        add(columns, 2, "DATA_TYPE", Types.SMALLINT);
        add(columns, 3, "PRECISION", Types.INTEGER);
        add(columns, 4, "LITERAL_PREFIX", Types.VARCHAR);
        add(columns, 5, "LITERAL_SUFFIX", Types.VARCHAR);
        add(columns, 6, "CREATE_PARAMS", Types.VARCHAR);
        add(columns, 7, "NULLABLE", Types.SMALLINT);
        add(columns, 8, "CASE_SENSITIVE", Types.BIT);
        add(columns, 9, "SEARCHABLE", Types.SMALLINT);
        add(columns, 10, "UNSIGNED_ATTRIBUTE", Types.BIT);
        add(columns, 11, "FIXED_PREC_SCALE", Types.BIT);
        add(columns, 12, "AUTO_INCREMENT", Types.BIT);
        add(columns, 13, "LOCAL_TYPE_NAME", Types.VARCHAR);
        add(columns, 14, "MINIMUM_SCALE", Types.SMALLINT);
        add(columns, 15, "MAXIMUM_SCALE", Types.SMALLINT);
        add(columns, 16, "SQL_DATA_TYPE", Types.INTEGER);
        add(columns, 17, "SQL_DATETIME_SUB", Types.INTEGER);
        add(columns, 18, "NUM_PREC_RADIX", Types.INTEGER);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create a Hashtable for a single row

        Hashtable singleRow;

        // Create the VARCHAR entry

        singleRow = new Hashtable();
        singleRow.put(new Integer(1),
                    new CommonValue(typeToName(Types.VARCHAR)));
        singleRow.put(new Integer(2), new CommonValue(Types.VARCHAR));
        singleRow.put(new Integer(3),
                    new CommonValue(SimpleTextDefine.MAX_VARCHAR_LEN));
        singleRow.put(new Integer(4), new CommonValue("'"));
        singleRow.put(new Integer(5), new CommonValue("'"));
        singleRow.put(new Integer(7), new CommonValue(typeNoNulls));
        singleRow.put(new Integer(9), new CommonValue(typePredBasic));
        singleRow.put(new Integer(13),
                    new CommonValue(typeToName(Types.VARCHAR)));
        rows.put (new Integer(1), singleRow);

        // Create the INTEGER entry

        singleRow = new Hashtable();
        singleRow.put(new Integer(1),
                    new CommonValue(typeToName(Types.INTEGER)));
        singleRow.put(new Integer(2), new CommonValue(Types.INTEGER));
        singleRow.put(new Integer(3),
                    new CommonValue(SimpleTextDefine.MAX_INTEGER_LEN));
        singleRow.put(new Integer(7), new CommonValue(typeNoNulls));
        singleRow.put(new Integer(9), new CommonValue(typePredBasic));
        singleRow.put(new Integer(13),
                    new CommonValue(typeToName(Types.INTEGER)));
        rows.put (new Integer(2), singleRow);

        // Create the VARBINARY entry

        singleRow = new Hashtable();
        singleRow.put(new Integer(1),
                    new CommonValue(typeToName(Types.VARBINARY)));
        singleRow.put(new Integer(2), new CommonValue(Types.VARBINARY));
        singleRow.put(new Integer(3),
                    new CommonValue(SimpleTextDefine.MAX_VARBINARY_LEN));
        singleRow.put(new Integer(4), new CommonValue("'"));
        singleRow.put(new Integer(5), new CommonValue("'"));
        singleRow.put(new Integer(7), new CommonValue(typeNoNulls));
        singleRow.put(new Integer(9), new CommonValue(typePredNone));
        singleRow.put(new Integer(13),
                    new CommonValue(typeToName(Types.VARBINARY)));
        rows.put (new Integer(3), singleRow);

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // typeToName
    // Return the type name for the given type
    //-----------------------------------------------------------------------

    protected String typeToName(
        int type)
    {
        String s = "";

        switch(type) {
        case Types.VARCHAR:
            s = "VARCHAR";
            break;
        case Types.INTEGER:
            s = "INTEGER";
            break;
        case Types.VARBINARY:
            s = "BINARY";
            break;
        }
        return s;
    }


    //-----------------------------------------------------------------------
    // getIndexInfo - JDBC API
    // Get a description of a table's indices and statistics. They are
    // ordered by NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION.
    //
    // Each index column description has the following columns:
    //
    //    (1) TABLE_CAT        String => table catalog (may be null)
    //    (2) TABLE_SCHEM        String => table schema (may be null)
    //    (3) TABLE_NAME        String => table name
    //    (4) NON_UNIQUE        boolean => Can index values be non-unique?
    //                            false when TYPE is tableIndexStatistic
    //    (5) INDEX_QUALIFIER    String => index catalog (may be null);
    //                            null when TYPE is tableIndexStatistic
    //    (6) INDEX_NAME        String => index name; null when TYPE is
    //                            tableIndexStatistic
    //    (7) TYPE            short => index type:
    //            tableIndexStatistic - this identifies table statistics that are
    //                returned in conjuction with a table's index descriptions
    //            tableIndexClustered - this is a clustered index
    //            tableIndexHashed - this is a hashed index
    //            tableIndexOther - this is some other style of index
    //    (8) ORDINAL_POSITION    short => column sequence number
    //                            within index; zero when TYPE is
    //                            tableIndexStatistic
    //    (9) COLUMN_NAME        String => column name; null when TYPE is
    //                            tableIndexStatistic
    //    (10) ASC_OR_DESC    String => column sort sequence, "A" => ascending,
    //                            "D" => descending, may be null if sort
    //                            sequence is not supported;  null when TYPE
    //                            is tableIndexStatistic
    //    (11) CARDINALITY    int => When TYPE is tableIndexStatisic then
    //                            this is the number of rows in the table;
    //                            otherwise it is the number of unique values
    //                            in the index.
    //    (12) PAGES            int => When TYPE is  tableIndexStatisic then
    //                            this is the number of pages used for the
    //                            table, otherwise it is the number of pages
    //                            used for the current index.
    //    (13) FILTER_CONDITION    String => Filter condition, if any.
    //                            (may be null)
    //
    //    catalog    a catalog name; "" retrieves those without a catalog
    //    schema    a schema name pattern; "" retrieves those without a schema
    //    table    a table name
    //    unique    when true, return only indices for unique values; when false,
    //            return indices regardless of whether unique or not
    //    approximate    when true, result is allowed to reflect approximate
    //            or out of data values; when false, results are requested
    //            to be accurate
    //
    // Returns a ResultSet.  Each row is an index column description
    //-----------------------------------------------------------------------

    public ResultSet getIndexInfo(
        String catalog,
        String schema,
        String table,
        boolean unique,
        boolean approximate)
        throws SQLException
    {
        if (traceOn()) {
            trace("@getIndexInfo(" + catalog + ", " + schema + ", " +
                    table + ", " + unique + ", " + approximate + ")");
        }

        // The SimpleText driver does not support indexes.  Instead
        // of throwing a 'Driver not capable' SQLException, we'll be
        // graceful and return an empty result set

        SimpleTextStatement stmt =
                (SimpleTextStatement) ownerConnection.createStatement();

        // Create a Hashtable for all of the columns

        Hashtable columns = new Hashtable();

        add(columns, 1, "TABLE_CAT", Types.VARCHAR);
        add(columns, 2, "TABLE_SCHEM", Types.VARCHAR);
        add(columns, 3, "TABLE_NAME", Types.VARCHAR);
        add(columns, 4, "NON_UNIQUE", Types.BIT);
        add(columns, 5, "INDEX_CAT", Types.VARCHAR);
        add(columns, 6, "INDEX_NAME", Types.VARCHAR);
        add(columns, 7, "TYPE", Types.SMALLINT);
        add(columns, 8, "ORDINAL_POSITION", Types.SMALLINT);
        add(columns, 9, "COLUMN_NAME", Types.VARCHAR);
        add(columns, 10, "ASC_OR_DESC", Types.VARCHAR);
        add(columns, 11, "CARDINALITY", Types.INTEGER);
        add(columns, 12, "PAGES", Types.INTEGER);
        add(columns, 13, "FILTER_CONDITION", Types.VARCHAR);

        // Create an empty Hashtable for the rows

        Hashtable rows = new Hashtable();

        // Create the ResultSet object and return it

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(stmt, columns, rows);

        return rs;
    }

    //-----------------------------------------------------------------------
    // add
    // Helper function used to create an in-memory column Hashtable
    //-----------------------------------------------------------------------

    protected void add(
        Hashtable h,
        int col,
        String name,
        int type)
    {
        h.put(new Integer(col), new SimpleTextColumn(name,type));
    }

    // Owning connection object

    protected SimpleTextIConnection ownerConnection;

}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextDefine.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextDefine.java
//
// Description: Static defines for all SimpleSelect classes
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

import java.sql.*;

public class SimpleTextDefine
{
    //------------------------------------------------------------------------
    // Version numbers
    //------------------------------------------------------------------------

    public final static int MAJOR_VERSION = 1;
    public final static int MINOR_VERSION = 0200;

    //------------------------------------------------------------------------
    // Maximums
    //------------------------------------------------------------------------


    public final static int MAX_COLUMN_NAME_LEN        = 18;
    public final static int MAX_COLUMNS_IN_TABLE    = 80;
    public final static int MAX_CATALOG_NAME_LEN    = 128;
    public final static int MAX_TABLE_NAME_LEN        = 40;
    public final static int MAX_VARCHAR_LEN            = 5120;
    public final static int MAX_INTEGER_LEN            = 9;
    public final static int MAX_VARBINARY_LEN        = 1048576;

    //------------------------------------------------------------------------
    // SQL statement types
    //------------------------------------------------------------------------

    public final static int SQL_SELECT    = 1;
    public final static int SQL_INSERT    = 2;
    public final static int SQL_CREATE    = 3;
    public final static int SQL_DROP    = 4;

    //------------------------------------------------------------------------
    // Column name prefixes indicating type
    //------------------------------------------------------------------------

    public final static String COL_TYPE_NUMBER = "#";
    public final static String COL_TYPE_BINARY = "@";

    //------------------------------------------------------------------------
    // File extensions
    //------------------------------------------------------------------------

    public final static String DATA_FILE_EXT    = ".SDF";
    public final static String BINARY_FILE_EXT    = ".SBF";
}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextDriver.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextDriver.java
//
// Description: Implementation of the JDBC Driver interface
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;


//----------------------------------------------------------------------------
// The Java SQL framework allows for multiple database drivers.
//
// Each driver should supply a driver class that implements
// the Driver interface.
//
// The DriverManager will try to load as many drivers as it can
// find and then for any given connection request it will ask each
// driver in turn to try to connect to the target URL.
//
// It is strongly recommended that each Driver class should be
// small and standalone so that the Driver class can be loaded and
// queried without bringing in vast quantities of supporting code.
//
// When a Driver object is instantiated it should register itself
// with the SQL framework by calling DriverManager.registerDriver
//
// Note: Each driver must support a null constructor so it can be
// instantiated by doing:
//
//    java.sql.Driver d = Class.forName("foo.bah.Driver").newInstance();
//----------------------------------------------------------------------------
// NOTE - this is an implementation of the JDBC API version 1.20
//---------------------------------------------------------------------------

import java.sql.*;

public class SimpleTextDriver
    extends       SimpleTextObject
    implements    SimpleTextIDriver
{

    //------------------------------------------------------------------------
    // SimpleTextDriver
    // Constructor.  Attempt to register the JDBC driver
    //------------------------------------------------------------------------

    public SimpleTextDriver()
        throws SQLException
    {
        // Attempt to register this driver with the JDBC DriverManager.
        // If it fails, an exception will be thrown.

        DriverManager.registerDriver (this);
    }

    //------------------------------------------------------------------------
    // connect - JDBC API
    //
    // Try to make a database connection to the given URL.
    // The driver should return "null" if it realizes it is the wrong kind
    // of driver to connect to the given URL.  This will be common, as when
    // the JDBC driver manager is asked to connect to a given URL it passes
    // the URL to each loaded driver in turn.
    //
    // The driver should raise a SQLException if it is the right
    // driver to connect to the given URL, but has trouble connecting to
    // the database.
    //
    // The java.util.Properties argument can be used to passed arbitrary
    // string tag/value pairs as connection arguments.
    // Normally at least a "user" and "password" properties should be
    // included in the Properties.
    //
    //    url        The URL of the database to connect to
    //
    //    info    a list of arbitrary string tag/value pairs as
    //            connection arguments; normally at least a "user" and
    //            "password" property should be included
    //
    // Returns a Connection to the URL
    //------------------------------------------------------------------------

    public Connection connect(
        String url,
        java.util.Properties info)
        throws SQLException
    {
        if (traceOn()) {
            trace("@connect (url=" + url + ")");
        }

        // Ensure that we can understand the given url

        if (!acceptsURL(url)) {
            return null;
        }

        // Set the url for the driver

        driverURL = url;

        // For typical JDBC drivers, it would be appropriate to check
        // for a secure environment before connecting, and deny access
        // to the driver if it is deemed to be unsecure.  For the
        // SimpleText driver, if the environment is not secure we will
        // turn into a read-only driver.


        // Create a new SimpleTextConnection object

        SimpleTextConnection con = new SimpleTextConnection();


        // Initialize the new object

        con.initialize (this, info);

        return con;
    }

    //------------------------------------------------------------------------
    // acceptsURL - JDBC API
    //
    // Returns true if the driver thinks that it can open a connection
    // to the given URL.  Typically drivers will return true if they
    // understand the subprotocol specified in the URL and false if
    // they don't.
    //
    //    url        The URL of the database.
    //
    // Returns true if this driver can connect to the given URL.
    //------------------------------------------------------------------------

    public boolean acceptsURL(
        String url)
        throws SQLException
    {
        if (traceOn()) {
            trace("@acceptsURL (url=" + url + ")");
        }

        boolean rc = false;

        // Get the subname from the url.  If the url is not valid for
        // this driver, a null will be returned.

        if (getSubname(url) != null) {
            rc = true;
        }

        if (traceOn()) {
            trace(" " + rc);
        }
        return rc;
    }


    //------------------------------------------------------------------------
    // getPropertyInfo - JDBC API
    //
    // The getPropertyInfo method is intended to allow a generic GUI tool to
    // discover what properties it should prompt a human for in order to get
    // enough information to connect to a database.  Note that depending on
    // the values the human has supplied so far, additional values may become
    // necessary, so it may be necessary to iterate though several calls
    // to getPropertyInfo.
    //
    //    url        The URL of the database to connect to.
    //
    //    info    A proposed list of tag/value pairs that will be sent on
    //            connect open.
    //
    // Returns an array of DriverPropertyInfo objects describing possible
    //            properties.  This array may be an empty array if no properties
    //            are required.
    //------------------------------------------------------------------------

    public DriverPropertyInfo[] getPropertyInfo(
        String url,
        java.util.Properties info)
        throws SQLException
    {
        DriverPropertyInfo prop[];

        // Only one property required for the SimpleText driver; the
        // directory.  Check the property list coming in.  If the
        // directory is specified, return an empty list.

        if (info.getProperty("Directory") == null) {

            // Setup the DriverPropertyInfo entry

            prop = new DriverPropertyInfo[1];
            prop[0] = new DriverPropertyInfo("Directory", null);
            prop[0].description = "Initial text file directory";
            prop[0].required = false;

        }
        else {

            // Create an empty list

            prop = new DriverPropertyInfo[0];
        }

        return prop;
    }


    //------------------------------------------------------------------------
    // getMajorVersion - JDBC API
    //
    // Get the driver's major version number. Initially this should be 1.
    //------------------------------------------------------------------------

    public int getMajorVersion()
    {
        return SimpleTextDefine.MAJOR_VERSION;
    }

    //------------------------------------------------------------------------
    // getMinorVersion - JDBC API
    //
    // Get the driver's minor version number. Initially this should be 0.
    //------------------------------------------------------------------------

    public int getMinorVersion()
    {
        return SimpleTextDefine.MINOR_VERSION;
    }


    //------------------------------------------------------------------------
    // jdbcCompliant - JDBC API
    //
    // Report whether the Driver is a genuine JDBC COMPLIANT (tm) driver.
    // A driver may only report "true" here if it passes the JDBC compliance
    // tests, otherwise it is required to return false.
    //
    // JDBC compliance requires full support for the JDBC API and full support
    // for SQL 92 Entry Level.  It is expected that JDBC compliant drivers will
    // be available for all the major commercial databases.
    //
    // This method is not intended to encourage the development of non-JDBC
    // compliant drivers, but is a recognition of the fact that some vendors
    // are interested in using the JDBC API and framework for lightweight
    // databases that do not support full database functionality, or for
    // special databases such as document information retrieval where a SQL
    // implementation may not be feasible.
    //------------------------------------------------------------------------

    public boolean jdbcCompliant()
    {

        // The SimpleText driver is not JDBC compliant

        return false;
    }

    //------------------------------------------------------------------------
    // getSubname
    // Given a URL, return the subname.  Returns null if the protocol is
    // not 'jdbc' or the subprotocol is not 'simpletext'
    //------------------------------------------------------------------------

    public String getSubname()
    {
        return getSubname(driverURL);
    }

    public String getSubname(
        String url)
    {
        String subname = null;
        String protocol = "JDBC";
        String subProtocol = "SIMPLETEXT";

        // Convert to upper case and trim all leading and trailing
        // blanks

        url = (url.toUpperCase()).trim();

        // Make sure the protocol is jdbc:

        if (url.startsWith(protocol)) {

            // Strip off the protocol

            url = url.substring (protocol.length());

            // Look for the colon

            if (url.startsWith(":")) {
                url = url.substring(1);

                // Check the subprotocol

                if (url.startsWith (subProtocol)) {

                    // Strip off the subprotocol, leaving the subname

                    url = url.substring(subProtocol.length());

                    // Look for the colon that separates the subname
                    // from the subprotocol (or the fact that there
                    // is no subprotocol at all)

                    if (url.startsWith(":")) {
                        subname = url.substring(1);
                    }
                    else if (url.length() == 0) {
                        subname = "";
                    }
                }
            }
        }
        return subname;
    }


    //------------------------------------------------------------------------
    // getURL
    //
    // Get the URL specified for the driver
    //------------------------------------------------------------------------

    public String getURL()
    {
        return driverURL;
    }


    private String driverURL;
}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextIConnection.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextIConnection.java
//
// Description: Interface of the SimpleTextConnection class.  This class
//              resolves circular dependancies.
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

import java.util.Hashtable;

public interface SimpleTextIConnection
    extends        java.sql.Connection
{
    String[] parseSQL(String sql);
    Hashtable getTables(String directory, String table);
    Hashtable getColumns(String directory, String table);
    String getDirectory(String directory);
}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextIDriver.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextIDriver.java
//
// Description: Interface of the SimpleTextDriver class.  This class
//              resolves circular dependancies.
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

import java.util.Hashtable;

public interface SimpleTextIDriver
    extends java.sql.Driver
{
    String getSubname();
}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextInputStream.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextInputStream.java
//
// Description: InputStream wrapper for CommonValue objects
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

import java.sql.*;
import java.io.*;

public class SimpleTextInputStream
    extends        InputStream
{

    //--------------------------------------------------------------------
    // Constructor
    // Perform any necessary initialization
    //--------------------------------------------------------------------

    public SimpleTextInputStream(
        CommonValue value,
        int type,
        int length)
    {
        this.value = value;
        this.type = type;
        this.length = length;
    }

    //--------------------------------------------------------------------
    // read
    // Read a single byte of data.  Returns the byte read, or -1 when the
    // end of the stream is reached
    //--------------------------------------------------------------------

    public int read()
        throws IOException
    {
        int  singleByte;
        byte buffer[];

        // Allocate a single byte buffer

        buffer = new byte[1];

        // Read a single byte of data

        singleByte = read(buffer);

        // If not end of data, return the byte read

        if (singleByte != -1) {
            singleByte = buffer[0];
        }

        return singleByte;
    }

    //--------------------------------------------------------------------
    // read
    // Reads data into an array of bytes.  Returns the number of bytes
    // read, or -1 when end of data is reached
    //--------------------------------------------------------------------

    public synchronized int read(
        byte b[])
        throws IOException
    {
        int toRead = b.length;

        // If the value given is null, return end of data

        if (value == null) {
            return -1;
        }

        if (value.isNull()) {
            return -1;
        }

        // Calculate the number of bytes to return

        int copyBytes = length - currentOffset;

        // Is there more data to get?

        if (copyBytes <= 0) {
            return -1;
        }

        // Only copy up to the size of the given buffer

        if (copyBytes > toRead) {
            copyBytes = toRead;
        }

        // Get the data as a byte array

        byte data[];

        try {
            data = value.getBytes();
        }
        catch (SQLException ex) {
            return -1;
        }

        // Copy the data.  The type of InputStream should be checked.
        // We'll assume binary data for the SimpleText driver

        System.arraycopy(data, currentOffset, b, 0, copyBytes);

        // Increment our offset

        currentOffset += copyBytes;

        // Return the number of bytes copied

        return copyBytes;
    }

    //--------------------------------------------------------------------
    // available
    // Returns the number of bytes that can be read without blocking.
    //--------------------------------------------------------------------

    public int available()
        throws IOException
    {
        int bytes = 0;

        if (length > 0) {
            bytes = length - currentOffset;
        }
        return bytes;
    }


    // CommonValue object containing the data

    protected CommonValue value;

    // InputStream type

    protected int type;

        public final static int STREAM_TYPE_ASCII    = 1;
        public final static int STREAM_TYPE_UNICODE    = 2;
        public final static int STREAM_TYPE_BINARY    = 3;

    // Total length of data, or -1 if not known

    protected int length;

    // Current offset in the value

    protected int currentOffset;
}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextIStatement.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextIStatement.java
//
// Description: Interface of the SimpleTextStatement class.  This class
//              resolves circular dependancies.
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;
import java.sql.*;
import java.util.Hashtable;

public interface SimpleTextIStatement
    extends        java.sql.Statement
{
    Connection getConnection();

    int buildList(String sql[], int pos, String endWord, Hashtable list)
                    throws SQLException;
}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextObject.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextObject.java
//
// Description: Common Object base for all SimpleSelect classes
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

import java.sql.*;

public class SimpleTextObject
    extends        Object
{

    //--------------------------------------------------------------------
    // traceOn
    // Returns true if tracing (logging) is currently enabled
    //--------------------------------------------------------------------

    protected static boolean traceOn()
    {
        return (DriverManager.getLogStream() != null);
    }

    //--------------------------------------------------------------------
    // trace
    // Logs the given text to the logging stream provided by the
    // DriverManager
    //--------------------------------------------------------------------

    protected static void trace(
        String text)
    {
        if (traceOn()) {
            (DriverManager.getLogStream()).println(text);
        }
    }

    //--------------------------------------------------------------------
    // DriverNotCapable
    // Create a new SQLException 'Driver not capable'
    //--------------------------------------------------------------------

    public SQLException DriverNotCapable()
    {
        return new SQLException ("Driver not capable");
    }

    //--------------------------------------------------------------------
    // DataTypeNotSupported
    // Create a new SQLException 'Data type not supported'
    //--------------------------------------------------------------------

    public SQLException DataTypeNotSupported()
    {
        return new SQLException ("Data type not supported");
    }

    //--------------------------------------------------------------------
    // parseWord
    // Given a String, get the next word from the string.  Any leading blanks
    // will be returned
    //--------------------------------------------------------------------

    public String parseWord(
        String s)
    {
        if (s.length() == 0) {
            return "";
        }

        // Flags to determine if we are in quotes

        boolean inSingle = false;
        boolean inDouble = false;
        boolean found = false;

        // Current offset in string

        int offset = 0;

        char c;

        // Special characters.  If the string starts with any of these
        // characters, it will be considered a word.  Otherwise, if any
        // of the characters are found outside quoted strings, it will
        // signify the end of a word

        String special = "()*=,? <>";

        // Skip any leading blanks

        while (s.charAt(offset) == ' ') {
            offset++;

            // No more string left.

            if (offset > s.length()) {
                return "";
            }
        }

        int si;

        // Look for special characters
        c = s.charAt(offset);

        for (si = 0; si < special.length(); si++) {
            if (c == special.charAt(si)) {
                return s.substring(0, offset + 1);
            }
        }

        // Loop while more characters exist in the string

        while (offset < s.length()) {
            c = s.charAt(offset);

            // Look for single or double quotes

            if (c == '\'') {
                if (!inDouble) {
                    if (inSingle) {
                        offset++;
                        break;
                    }
                    inSingle = true;
                }
            }

            if (c == '"') {
                if (!inSingle) {
                    if (inDouble) {
                        offset++;
                        break;
                    }
                    inDouble = true;
                }
            }


            // If not inside a double or single quote, examine the next
            // character

            if ((!inDouble) && (!inSingle)) {

                // If a special character exists, it terminates this word

                for (si = 0; si < special.length(); si++) {
                    if (c == special.charAt(si)) {
                        found = true;
                        break;
                    }
                }
                if (found) {
                    break;
                }
            }

            offset++;
        }

        return s.substring(0, offset);
    }

}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextPreparedStatement.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextPreparedStatement.java
//
// Description: Implementation of the JDBC PreparedStatement interface
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

//----------------------------------------------------------------------------
// A SQL statement is pre-compiled and stored in a
// PreparedStatement object. This object can then be used to
// efficiently execute this statement multiple times.
//
// Note:  The setXXX methods for setting IN parameter values
// must specify types that are compatible with the defined SQL type of
// the input parameter. For instance, if the IN parameter has SQL type
// Integer then setInt should be used.
//
// If arbitrary parameter type conversions are required then the
// setObject method should be used with a target SQL type.
//----------------------------------------------------------------------------
// NOTE - this is an implementation of the JDBC API version 1.20
//---------------------------------------------------------------------------

import java.sql.*;
import java.io.*;
import java.util.Hashtable;
import java.util.StringTokenizer;

public class SimpleTextPreparedStatement
    extends        SimpleTextStatement
    implements    PreparedStatement
{
    //------------------------------------------------------------------------
    // initialize
    //------------------------------------------------------------------------

    public void initialize(
        SimpleTextIConnection con,
        String sql)
        throws SQLException
    {
        super.initialize(con);

        // Save the SQL statement

        sqlStatement = sql;

        // To prepare the statement, we must parse and validate.  The act
        // of preparing does nothing more than validate the statement; it
        // does not save an execution plan.  When the prepared statement is
        // executed, it is re-parsed and re-validated each time.

        parsedSQL = ownerConnection.parseSQL(sql);

        // Prepare the statement, indicating the we are only preparing

        prepare(true);

        // Create a new boundParams Hashtable

        boundParams = new Hashtable();
    }

    //-----------------------------------------------------------------------
    // executeQuery - JDBC API
    // A prepared SQL query is executed and its ResultSet is returned.
    //
    // Returns a ResultSet that contains the data produced by the query
    //-----------------------------------------------------------------------

    public ResultSet executeQuery()
        throws SQLException
    {
        if (traceOn()) {
            trace("@executeQuery()");
        }

        java.sql.ResultSet rs = null;

        // Execute the query.  If execute returns true, then a result set
        // exists

        if (execute()) {
            rs = getResultSet();
        }

        return rs;
    }

    // The overloaded executeQuery on the Statement object (which we
    // extend) is not valid for PreparedStatement or CallableStatement
    // objects.

    public ResultSet executeQuery(
        String sql)
        throws SQLException
    {
        throw new SQLException("Method is not valid");
    }

    //-----------------------------------------------------------------------
    // executeUpdate - JDBC API
    // Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
    // SQL statements that return nothing such as SQL DDL statements
    // can be executed.
    //
    // Returns either the row count for INSERT, UPDATE or DELETE; or 0
    // for SQL statements that return nothing
    //-----------------------------------------------------------------------

    public int executeUpdate()
        throws SQLException
    {
        if (traceOn()) {
            trace("@executeUpdate()");
        }

        int count = -1;

        // Execute the query.  If execute returns false, then an update
        // count exists.

        if (execute() == false) {
            count = getUpdateCount();
        }

        return count;
    }

    // The overloaded executeUpdate on the Statement object (which we
    // extend) is not valid for PreparedStatement or CallableStatement
    // objects.

    public int executeUpdate(
        String sql)
        throws SQLException
    {
        throw new SQLException("Method is not valid");
    }

    //-----------------------------------------------------------------------
    // setNull - JDBC API
    // Set a parameter to SQL NULL.
    //
    // Note: You must specify the parameter's SQL type.
    //
    // @param parameterIndex the first parameter is 1, the second is 2, ...
    // @param sqlType SQL type code defined by java.sql.Types
    //-----------------------------------------------------------------------

    public void setNull(
        int parameterIndex,
        int sqlType)
        throws SQLException
    {
        // The SimpleText driver does not support null values

        throw DriverNotCapable();
    }

    //-----------------------------------------------------------------------
    // setBoolean - JDBC API
    // Set a parameter to a Java boolean value.  The driver converts this
    // to a SQL BIT value when it sends it to the database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setBoolean(
        int parameterIndex,
        boolean x)
        throws SQLException
    {
        // The SimpleText driver does not support this data type.  We could
        // coerce the data, but an exception is will be thrown for now.

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setByte - JDBC API
    // Set a parameter to a Java byte value.  The driver converts this
    // to a SQL TINYINT value when it sends it to the database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setByte(
        int parameterIndex,
        byte x)
        throws SQLException
    {
        // The SimpleText driver does not support this data type.  We could
        // coerce the data, but an exception is will be thrown for now.

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setShort - JDBC API
    // Set a parameter to a Java short value.  The driver converts this
    // to a SQL SMALLINT value when it sends it to the database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setShort(
        int parameterIndex,
        short x)
        throws SQLException
    {
        // The SimpleText driver does not support this data type.  We could
        // coerce the data, but an exception is will be thrown for now.

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setInt - JDBC API
    // Set a parameter to a Java int value.  The driver converts this
    // to a SQL INTEGER value when it sends it to the database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setInt(
        int parameterIndex,
        int x)
        throws SQLException
    {
        // Validate the parameter index

        verify(parameterIndex);

        // Put the parameter into the boundParams Hashtable.  Coerce the
        // data into a String

        boundParams.put(new Integer(parameterIndex),
                                    (new CommonValue(x)).getString());
    }

    //-----------------------------------------------------------------------
    // setLong - JDBC API
    // Set a parameter to a Java long value.  The driver converts this
    // to a SQL BIGINT value when it sends it to the database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setLong(
        int parameterIndex,
        long x)
        throws SQLException
    {
        // The SimpleText driver does not support this data type.  We could
        // coerce the data, but an exception is will be thrown for now.

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setFloat - JDBC API
    // Set a parameter to a Java float value.  The driver converts this
    // to a SQL FLOAT value when it sends it to the database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setFloat(
        int parameterIndex,
        float x)
        throws SQLException
    {
        // The SimpleText driver does not support this data type.  We could
        // coerce the data, but an exception is will be thrown for now.

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setDouble - JDBC API
    // Set a parameter to a Java double value.  The driver converts this
    // to a SQL DOUBLE value when it sends it to the database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setDouble(
        int parameterIndex,
        double x)
        throws SQLException
    {
        // The SimpleText driver does not support this data type.  We could
        // coerce the data, but an exception is will be thrown for now.

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setBigDecimal - JDBC API
    // Set a parameter to a java.math.BigDecimal value.  The driver converts this
    // to a SQL NUMERIC value when it sends it to the database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setBigDecimal(
        int parameterIndex,
        java.math.BigDecimal x)
        throws SQLException
    {
        // The SimpleText driver does not support this data type.  We could
        // coerce the data, but an exception is will be thrown for now.

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setString - JDBC API
    // Set a parameter to a Java String value.  The driver converts this
    // to a SQL VARCHAR or LONGVARCHAR value (depending on the arguments
    // size relative to the driver's limits on VARCHARs) when it sends
    // it to the database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setString(
        int parameterIndex,
        String x)
        throws SQLException
    {
        // Validate the parameter index

        verify(parameterIndex);

        // Put the parameter into the boundParams Hashtable

        boundParams.put(new Integer(parameterIndex), x);
    }

    //-----------------------------------------------------------------------
    // setBytes - JDBC API
    // Set a parameter to a Java array of bytes.  The driver converts this
    // to a SQL VARBINARY or LONGVARBINARY (depending on the arguments
    // size relative to the driver's limits on VARBINARYs) when it sends
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setBytes(
        int parameterIndex,
        byte x[])
        throws SQLException
    {
        // Validate the parameter index

        verify(parameterIndex);

        // Put the parameter into the boundParams Hashtable.  Coerce the
        // data into a String

        boundParams.put(new Integer(parameterIndex),
                                    (new CommonValue(x)).getString());
    }

    //-----------------------------------------------------------------------
    // setDate - JDBC API
    // Set a parameter to a java.sql.Date value.  The driver converts this
    // to a SQL DATE value when it sends it to the database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setDate(
        int parameterIndex,
        java.sql.Date x)
        throws SQLException
    {
        // The SimpleText driver does not support this data type.  We could
        // coerce the data, but an exception is will be thrown for now.

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setTime - JDBC API
    // Set a parameter to a java.sql.Time value.  The driver converts this
    // to a SQL TIME value when it sends it to the database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setTime(
        int parameterIndex,
        java.sql.Time x)
        throws SQLException
    {
        // The SimpleText driver does not support this data type.  We could
        // coerce the data, but an exception is will be thrown for now.

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setTimestamp - JDBC API
    // Set a parameter to a java.sql.Timestamp value.  The driver
    // converts this to a SQL TIMESTAMP value when it sends it to the
    // database.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the parameter value
    //-----------------------------------------------------------------------

    public void setTimestamp(
        int parameterIndex,
        java.sql.Timestamp x)
        throws SQLException
    {
        // The SimpleText driver does not support this data type.  We could
        // coerce the data, but an exception is will be thrown for now.

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setAsciiStream - JDBC API
    // When a very large ASCII value is input to a LONGVARCHAR
    // parameter it may be more practical to send it via a
    // java.io.InputStream. JDBC will read the data from the stream
    // as needed, until it reaches end-of-file.  The JDBC driver will
    // do any necessary conversion from ASCII to the database char format.
    //
    // Note: this stream object can either be a standard
    // Java stream object, or your own subclass that implements the
    // standard interface.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the java input stream which contains the ASCII
    //                    parameter value
    //    length            the number of bytes in the stream
    //-----------------------------------------------------------------------

    public void setAsciiStream(
        int parameterIndex,
        java.io.InputStream x,
        int length)
        throws SQLException
    {
        // Only binary InputStreams are current supported

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setUnicodeStream - JDBC API
    // When a very large UNICODE value is input to a LONGVARCHAR
    // parameter it may be more practical to send it via a
    // java.io.InputStream. JDBC will read the data from the stream
    // as needed, until it reaches end-of-file.  The JDBC driver will
    // do any necessary conversion from UNICODE to the database char format.
    //
    // Note: this stream object can either be a standard
    // Java stream object, or your own subclass that implements the
    // standard interface.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the java input stream which contains the
    //                    UNICODE parameter value
    //    length            the number of bytes in the stream
    //-----------------------------------------------------------------------

    public void setUnicodeStream(
        int parameterIndex,
        java.io.InputStream x,
        int length)
        throws SQLException
    {
        // Only binary InputStreams are current supported

        throw DataTypeNotSupported();
    }

    //-----------------------------------------------------------------------
    // setBinaryStream - JDBC API
    // When a very large binary value is input to a LONGVARBINARY
    // parameter it may be more practical to send it via a
    // java.io.InputStream. JDBC will read the data from the stream
    // as needed, until it reaches end-of-file.
    //
    // Note: this stream object can either be a standard
    // Java stream object, or your own subclass that implements the
    // standard interface.
    //
    //     parameterIndex    the first parameter is 1, the second is 2, ...
    //     x                the java input stream which contains the binary
    //                    parameter value
    //     length            the number of bytes in the stream
    //-----------------------------------------------------------------------

    public void setBinaryStream(
        int parameterIndex,
        java.io.InputStream x,
        int length)
        throws SQLException
    {
        // Validate the parameter index

        verify(parameterIndex);

        // Read in the entire InputStream all at once.  A more optimal
        // way of handling this would be to defer the read until execute
        // time, and only read in chunks at a time.

        byte b[] = new byte[length];

        try {
            x.read(b);
        }
        catch (Exception ex) {
            throw new SQLException("Unable to read InputStream: " +
                                ex.getMessage());
        }

        // Set the data as a byte array

        setBytes(parameterIndex, b);
    }

    //-----------------------------------------------------------------------
    // clearParameters - JDBC API
    // In general parameter values remain in force for repeated use of a
    // Statement. Setting a parameter value automatically clears its
    // previous value.  However In some cases it is useful to immediately
    // release the resources used by the current parameter values; this can
    // be done by calling clearParameters.
    //-----------------------------------------------------------------------

    public void clearParameters()
        throws SQLException
    {
        // Clear all the bound parameters

        boundParams.clear();
    }

    //-----------------------------------------------------------------------
    // setObject - JDBC API
    // Set the value of a parameter using an object; use the
    // java.lang equivalent objects for integral values.
    //
    // The given Java object will be converted to the targetSqlType
    // before being sent to the database.
    //
    // Note that this method may be used to pass datatabase
    // specific abstract data types, by using a Driver specific Java
    // type and using a targetSqlType of java.sql.types.OTHER.
    //
    //     parameterIndex    The first parameter is 1, the second is 2, ...
    //     x                The object containing the input parameter value
    //     targetSqlType    The SQL type (as defined in java.sql.Types) to be
    //                    sent to the database. The scale argument may further
    //                    qualify this type.
    //     scale            For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC
    //                    types this is the number of digits after the decimal.
    //                    For all other types this value will be ignored,
    //-----------------------------------------------------------------------

    public void setObject(
        int parameterIndex,
        Object x,
        int targetSqlType,
        int scale)
        throws SQLException
    {
//TODO
    }

    //-----------------------------------------------------------------------
    // setObject - JDBC API
     // This method is like setObject above, but assumes scale of zero.
     //-----------------------------------------------------------------------

    public void setObject(
        int parameterIndex,
        Object x,
        int targetSqlType)
        throws SQLException
    {
        setObject(parameterIndex, x, targetSqlType, 0);
    }

    //-----------------------------------------------------------------------
    // setObject - JDBC API
    // Set the value of a parameter using an object; use the
    // java.lang equivalent objects for integral values.
    //
    // The JDBC specification specifies a standard mapping from
    // Java Object types to SQL types.  The given argument java object
    // will be converted to the corresponding SQL type before being
    // sent to the database.
    //
    // Note that this method may be used to pass datatabase
    // specific abstract data types, by using a Driver specific Java
    // type.
    //
    //     parameterIndex    The first parameter is 1, the second is 2, ...
    //     x                The object containing the input parameter value
    //-----------------------------------------------------------------------

    public void setObject(
        int parameterIndex,
        Object x)
        throws SQLException
    {
        // We don't handle nulls

        if (x == null) {
            throw new SQLException("Null values are not supported");
        }

        // Determine the data type of the object.  We'll do this by attempting
        // to cast the given Object to the data types that are supported.

        int type = getObjectType(x);

        setObject(parameterIndex, x, type);
    }

    //-----------------------------------------------------------------------
    // execute - JDBC API
    // Some prepared statements return multiple results; the execute
    // method handles these complex statements as well as the simpler
    // form of statements handled by executeQuery and executeUpdate.
    //-----------------------------------------------------------------------

    public boolean execute()
        throws SQLException
    {
        resultSetColumns = null;

        // First, parse the sql statement into a String array

        parsedSQL = ownerConnection.parseSQL(sqlStatement);

        // Now validate the SQL statement and execute it.
        // Returns true if a result set exists.

        boolean rc = prepare(false);

        return rc;
    }

    // The overloaded execute on the Statement object (which we
    // extend) is not valid for PreparedStatement or CallableStatement
    // objects.

    public boolean execute(
        String sql)
        throws SQLException
    {
        throw new SQLException("Method is not valid");
    }

    //------------------------------------------------------------------------
    // verify
    // Verifies the parameter number given is valid, and resets the warnings.
    // If the parameter was previously set, clear it now.
    //------------------------------------------------------------------------

    protected void verify(
        int parameterIndex)
        throws SQLException
    {
        clearWarnings();

        // The paramCount was set when the statement was prepared

        if ((parameterIndex <= 0) ||
            (parameterIndex > paramCount)) {
            throw new SQLException("Invalid parameter number: " +
                                        parameterIndex);
        }

        // If the parameter has already been set, clear it

        if (boundParams.get(new Integer(parameterIndex)) != null) {
            boundParams.remove(new Integer(parameterIndex));
        }
    }

    //------------------------------------------------------------------------
    // getObjectType
    // Given an Object, return the corresponding SQL type.
    //------------------------------------------------------------------------

    protected int getObjectType(
        Object x)
        throws SQLException
    {

        // Determine the data type of the Object by attempting to cast
        // the object.  An exception will be thrown if an invalid casting
        // is attempted.

        try {
            if ((String) x != null) {
                return Types.VARCHAR;
            }
        }
        catch (Exception ex) {
        }

        try {
            if ((Integer) x != null) {
                return Types.INTEGER;
            }
        }
        catch (Exception ex) {
        }

        try {
            if ((byte[]) x != null) {
                return Types.VARBINARY;
            }
        }
        catch (Exception ex) {
        }

        throw new SQLException("Unknown object type");
    }


}
//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextResultSet.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextResultSet.java
//
// Description: Implementation of the JDBC ResultSet interface
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

//----------------------------------------------------------------------------
// A ResultSet provides access to a table of data generated by
// executing a Statement. The table rows are retrieved in
// sequence. Within a row its column values can be accessed in any
// order.
//
// A ResultSet maintains a cursor pointing to its current row of
// data.  Initially the cursor is positioned before the first row.
// The 'next' method moves the cursor to the next row.
//
// The getXXX methods retrieve column values for the current
// row.  You can retrieve values either using the index number of the
// column, or by using the name of the column.  In general using the
// column index will be more efficient.  Columns are numbered from 1.
//
// For maximum portability, ResultSet columns within each row should be
// read in left-to-right order and each column should be read only once.
//
// For the getXXX methods, the JDBC driver attempts to convert the
// underlying data to the specified Java type and returns a suitable
// Java value.  See the JDBC specification for allowable mappings
// from SQL types to Java types with the ResultSet.getXXX methods.
//
// Column names used as input to getXXX methods are case insensitive.
// When performing a getXXX using a column name if several columns have
// the same name then the value of the first matching column will be
// returned.
//
// A ResultSet is automatically closed by the Statement that
// generated it when that Statement is closed, re-executed, or is used
// to retrieve the next result from a sequence of multiple results.
//
// The number, types and properties of a ResultSet's columns are
// provided by the ResulSetMetaData object returned by the getMetaData
// method.
//----------------------------------------------------------------------------
// NOTE - this is an implementation of the JDBC API version 1.20
//---------------------------------------------------------------------------

import java.sql.*;
import java.util.Hashtable;
import java.io.*;

public class SimpleTextResultSet
    extends        SimpleTextObject
    implements    ResultSet
{

    //------------------------------------------------------------------------
    // initialize
    //------------------------------------------------------------------------

    public void initialize(
        SimpleTextIStatement statement,
        String catalog,
        String table,
        Hashtable columns,
        SimpleTextFilter filter)
        throws SQLException
    {
        // Save the owning statement object

        ownerStatement = statement;
        ownerConnection = ownerStatement.getConnection();

        // Save the in-memory column definitions

        inMemoryColumns = columns;

        // Save the select WHERE filter

        selectFilter = filter;

        // If a table was given, open it now

        if (table != null) {
            openSDF(catalog, table);
        }
    }

    public void initialize(
        SimpleTextIStatement statement,
        Hashtable columns,
        Hashtable rows)
        throws SQLException
    {
        // Save the in-memory rows (used for catalog functions)

        inMemoryRows = rows;
        rowNum = 0;

        initialize(statement, null, null, columns, null);
    }

    //------------------------------------------------------------------------
    // next - JDBC API
    // A ResultSet is initially positioned before its first row; the
    // first call to next makes the first row the current row; the
    // second call makes the second row the current row, etc.
    //
    // If an input stream from the previous row is open it is
    // implicitly closed. The ResultSet's warning chain is cleared
    // when a new row is read.
    //
    // Returns true if the new current row is valid; false if there
    // are no more rows
    //------------------------------------------------------------------------

    public boolean next()
        throws SQLException
    {
        boolean rc = true;
        boolean validRow = false;

        // In memory result set, get the next row

        if (inMemoryRows != null) {
            rowNum++;

            // No more rows, return end-of-file

            if (rowNum > inMemoryRows.size()) {
                rc = false;
            }
        }
        else {

            // Not in-memory, read the next line from the file until a
            // valid row has been found

            while (!validRow) {

                currentLine = readLine(rafSDF);

                if (currentLine == null) {
                    rc = false;
                    break;
                }

                // We'll cheat a little bit here.  We'll use the SQL
                // parser to break the line up, then treat it as a
                // comma separated list (much like a select list)

                String data[] = ownerConnection.parseSQL(currentLine);

                Hashtable dataList = new Hashtable();

                ownerStatement.buildList(data, 0, "", dataList);

                // Now go through each data element and create a
                // CommonValue object.  Then, put the CommonValue object
                // on our columnValues list

                SimpleTextColumn column;
                columnValues = new Hashtable();
                String s;
                CommonValue value;

                for (int i = 1; i <= dataList.size(); i++) {
                    column = (SimpleTextColumn) dataList.get(new Integer(i));

                    // Get the data item

                    s = column.name;

                    // Remove any quotes
                    if (s.startsWith("'") &&
                        s.endsWith("'")) {
                        s = s.substring(1, s.length() - 1);
                    }

                    // Create a CommonValue object using the string

                    value = new CommonValue(s);

                    // Create a CommonValue object

                    columnValues.put(new Integer(i), value);

                }

                // Filter the row, if necessary

                validRow = filterRow(columnValues, selectFilter);

            }
        }
        return rc;
    }


    //------------------------------------------------------------------------
    // close - JDBC API
    // In some cases, it is desirable to immediately release a
    // ResultSet's database and JDBC resources instead of waiting for
    // this to happen when it is automatically closed; the close
    // method provides this immediate release.
    //
    // Note:  A ResultSet is automatically closed by the
    // Statement that generated it when that Statement is closed,
    // re-executed, or is used to retrieve the next result from a
    // sequence of multiple results. A ResultSet is also automatically
    // closed when it is garbage collected.
    //------------------------------------------------------------------------

    public void close()
        throws SQLException
    {
        try {
            if (rafSDF != null) {
                rafSDF.close();
            }
            if (rafSBF != null) {
                rafSBF.close();
            }
        }
        catch (Exception ex) {
        }
    }

    //------------------------------------------------------------------------
    // wasNull - JDBC API
    // A column may have the value of SQL NULL; wasNull reports whether
    // the last column read had this special value.
    // Note that you must first call getXXX on a column to try to read
    // its value and then call wasNull() to find if the value was
    // the SQL NULL.
    //
    // Returns true if last column read was SQL NULL
    //------------------------------------------------------------------------

    public boolean wasNull()
        throws SQLException
    {
        return lastNull;
    }

    //------------------------------------------------------------------------
    // getString - JDBC API
    // Get the value of a column in the current row as a Java String.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public String getString(
        int columnIndex)
        throws SQLException
    {

        // Verify the column

        verify(columnIndex);

        String s = null;

        if (inMemoryRows != null) {
            s = (getColumn(rowNum, columnIndex)).getString();
        }
        else {
            CommonValue value = getValue(columnIndex);

            if (value != null) {
                s = value.getString();
            }
        }

        if (s == null) {
            lastNull = true;
        }

        return s;
    }

    //------------------------------------------------------------------------
    // getBoolean - JDBC API
    // Get the value of a column in the current row as a Java boolean.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns the column value; if the value is SQL NULL the result is false
    //------------------------------------------------------------------------

    public boolean getBoolean(
        int columnIndex)
        throws SQLException
    {
        // We could coerce the data, but for now an exception is thrown

        throw DataTypeNotSupported();
    }

    //------------------------------------------------------------------------
    // getByte - JDBC API
    // Get the value of a column in the current row as a Java byte.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public byte getByte(
        int columnIndex)
        throws SQLException
    {
        // We could coerce the data, but for now an exception is thrown

        throw DataTypeNotSupported();
    }

    //------------------------------------------------------------------------
    // getShort - JDBC API
    // Get the value of a column in the current row as a Java short.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public short getShort(
        int columnIndex)
        throws SQLException
    {
        // We could coerce the data, but for now an exception is thrown

        throw DataTypeNotSupported();
    }

    //------------------------------------------------------------------------
    // getInt - JDBC API
    // Get the value of a column in the current row as a Java int.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public int getInt(
        int columnIndex)
        throws SQLException
    {
        // Verify the column

        verify(columnIndex);

        CommonValue value;

        if (inMemoryRows != null) {
            value = getColumn(rowNum, columnIndex);
        }
        else {
            value = getValue(columnIndex);
        }

        // Check for a null value

        if (value == null) {
            lastNull = true;
            return 0;
        }

        if (value.isNull()) {
            lastNull = true;
            return 0;
        }

        return value.getInt();
    }

    //------------------------------------------------------------------------
    // getLong - JDBC API
    // Get the value of a column in the current row as a Java long.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public long getLong(
        int columnIndex)
        throws SQLException
    {
        // We could coerce the data, but for now an exception is thrown

        throw DataTypeNotSupported();
    }

    //------------------------------------------------------------------------
    // getFloat - JDBC API
    // Get the value of a column in the current row as a Java float.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public float getFloat(
        int columnIndex)
        throws SQLException
    {
        // We could coerce the data, but for now an exception is thrown

        throw DataTypeNotSupported();
    }

    //------------------------------------------------------------------------
    // getDouble - JDBC API
    // Get the value of a column in the current row as a Java double.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public double getDouble(
        int columnIndex)
        throws SQLException
    {
        // We could coerce the data, but for now an exception is thrown

        throw DataTypeNotSupported();
    }

    //------------------------------------------------------------------------
    // getBigDecimal - JDBC API
    // Get the value of a column in the current row as a java.math.BigDecimal
    // object.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //    scale            the number of digits to the right of the decimal
    //
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public java.math.BigDecimal getBigDecimal(
        int columnIndex,
        int scale)
        throws SQLException
    {
        String s = getString(columnIndex);
        java.math.BigDecimal d = null;

        if (s != null) {
            java.math.BigInteger i = new java.math.BigInteger(s);
            d = new java.math.BigDecimal (i, scale);
        }
        return d;
    }

    //------------------------------------------------------------------------
    // getBytes - JDBC API
    // Get the value of a column in the current row as a Java byte array.
    // The bytes represent the raw values returned by the driver.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public byte[] getBytes(
        int columnIndex)
        throws SQLException
    {
        // Verify the column

        verify(columnIndex);

        byte b[] = null;

        if (inMemoryRows != null) {
            b = (getColumn(rowNum, columnIndex)).getBytes();
        }
        else {
            CommonValue value = getValue(columnIndex);

            if (value != null) {
                b = value.getBytes();
            }
        }

        if (b == null) {
            lastNull = true;
        }

        return b;
    }

    //------------------------------------------------------------------------
    // getDate - JDBC API
    // Get the value of a column in the current row as a java.sql.Date object.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public java.sql.Date getDate(
        int columnIndex)
        throws SQLException
    {
        // We could coerce the data, but for now an exception is thrown

        throw DataTypeNotSupported();
    }

    //------------------------------------------------------------------------
    // getTime - JDBC API
    // Get the value of a column in the current row as a java.sql.Time object.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public java.sql.Time getTime(
        int columnIndex)
        throws SQLException
    {
        // We could coerce the data, but for now an exception is thrown

        throw DataTypeNotSupported();
    }

    //------------------------------------------------------------------------
    // getTimestamp - JDBC API
    // Get the value of a column in the current row as a java.sql.Timestamp
    // object.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public java.sql.Timestamp getTimestamp(
        int columnIndex)
        throws SQLException
    {
        // We could coerce the data, but for now an exception is thrown

        throw DataTypeNotSupported();
    }

    //------------------------------------------------------------------------
    // A column value can be retrieved as a stream of ASCII characters
    // and then read in chunks from the stream.  This method is particularly
    // suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
    // do any necessary conversion from the database format into ASCII.
    //
    // Note:  All the data in the returned stream must
    // be read prior to getting the value of any other column. The
    // next call to a get method implicitly closes the stream.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns a Java input stream that delivers the database column value
    // as a stream of one byte ASCII characters.  If the value is SQL NULL
    // then the result is null.
    //------------------------------------------------------------------------

    public java.io.InputStream getAsciiStream(
        int columnIndex)
        throws SQLException
    {
        // Binary InputStreams are the only InputStream types supported

        throw DataTypeNotSupported();
    }

    //------------------------------------------------------------------------
    // getUnicodeStream - JDBC API
    // A column value can be retrieved as a stream of Unicode characters
    // and then read in chunks from the stream.  This method is particularly
    // suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
    // do any necessary conversion from the database format into Unicode.
    //
    // Note:  All the data in the returned stream must
    // be read prior to getting the value of any other column. The
    // next call to a get method implicitly closes the stream.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns a Java input stream that delivers the database column value
    // as a stream of two byte Unicode characters.  If the value is SQL NULL
    // then the result is null.
    //------------------------------------------------------------------------

    public java.io.InputStream getUnicodeStream(
        int columnIndex)
        throws SQLException
    {
        // Binary InputStreams are the only InputStream types supported

        throw DataTypeNotSupported();
    }

    //------------------------------------------------------------------------
    // getBinaryStream - JDBC API
    // A column value can be retrieved as a stream of uninterpreted bytes
    // and then read in chunks from the stream.  This method is particularly
    // suitable for retrieving large LONGVARBINARY values.
    //
    // Note:  All the data in the returned stream must
    // be read prior to getting the value of any other column. The
    // next call to a get method implicitly closes the stream.
    //
    //    columnIndex        the first column is 1, the second is 2, ...
    //
    // Returns a Java input stream that delivers the database column value
    // as a stream of uninterpreted bytes.  If the value is SQL NULL
    // then the result is null.
    //------------------------------------------------------------------------

    public java.io.InputStream getBinaryStream(
        int columnIndex)
        throws SQLException
    {
        // Verify the column

        verify(columnIndex);

        CommonValue value = null;

        if (inMemoryRows != null) {
            value = getColumn(rowNum, columnIndex);
        }
        else {
            value = getValue(columnIndex);
        }

        int length = -1;

        // Get the length, if possible

        if (value != null) {
            byte b[] = value.getBytes();
            if (b != null) {
                length = b.length;
            }
        }

        SimpleTextInputStream inputStream = new SimpleTextInputStream(
                    value, SimpleTextInputStream.STREAM_TYPE_BINARY,
                    length);

        return inputStream;
    }


    //======================================================================
    // Methods for accessing results by column name
    //======================================================================

    //------------------------------------------------------------------------
    // getString - JDBC API
    // Get the value of a column in the current row as a Java String.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public String getString(
        String columnName)
        throws SQLException
    {
        return getString(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getBoolean - JDBC API
    // Get the value of a column in the current row as a Java boolean.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns the column value; if the value is SQL NULL the result is false
    //------------------------------------------------------------------------

    public boolean getBoolean(
        String columnName)
        throws SQLException
    {
        return getBoolean(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getByte - JDBC API
    // Get the value of a column in the current row as a Java byte.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public byte getByte(
        String columnName)
        throws SQLException
    {
        return getByte(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getShort - JDBC API
    // Get the value of a column in the current row as a Java short.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public short getShort(
        String columnName)
        throws SQLException
    {
        return getShort(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getInt - JDBC API
    // Get the value of a column in the current row as a Java int.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public int getInt(
        String columnName)
        throws SQLException
    {
        return getInt(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getLong - JDBC API
    // Get the value of a column in the current row as a Java long.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public long getLong(
        String columnName)
        throws SQLException
    {
        return getLong(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getFloat - JDBC API
    // Get the value of a column in the current row as a Java float.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public float getFloat(
        String columnName)
        throws SQLException
    {
        return getFloat(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getDouble - JDBC API
    // Get the value of a column in the current row as a Java double.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns the column value; if the value is SQL NULL the result is 0
    //------------------------------------------------------------------------

    public double getDouble(
        String columnName)
        throws SQLException
    {
        return getDouble(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getBigDecimal - JDBC API
    // Get the value of a column in the current row as a java.math.BigDecimal
    // object.
    //
    //    columnName        is the SQL name of the column
    //    scale            the number of digits to the right of the decimal
    //
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public java.math.BigDecimal getBigDecimal(
        String columnName,
        int scale)
        throws SQLException
    {
        return getBigDecimal(findColumn(columnName), scale);
    }

    //------------------------------------------------------------------------
    // getBytes - JDBC API
    // Get the value of a column in the current row as a Java byte array.
    // The bytes represent the raw values returned by the driver.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public byte[] getBytes(
        String columnName)
        throws SQLException
    {
        return getBytes(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getDate - JDBC API
    // Get the value of a column in the current row as a java.sql.Date object.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public java.sql.Date getDate(
        String columnName)
        throws SQLException
    {
        return getDate(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getTime - JDBC API
    // Get the value of a column in the current row as a java.sql.Time object.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public java.sql.Time getTime(
        String columnName)
        throws SQLException
    {
        return getTime(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getTimestamp - JDBC API
    // Get the value of a column in the current row as a java.sql.Timestamp
    // object.
    //
    //    columnName        is the SQL name of the column
    // Returns the column value; if the value is SQL NULL the result is null
    //------------------------------------------------------------------------

    public java.sql.Timestamp getTimestamp(
        String columnName)
        throws SQLException
    {
        return getTimestamp(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getAsciiStream
    // A column value can be retrieved as a stream of ASCII characters
    // and then read in chunks from the stream.  This method is particularly
    // suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
    // do any necessary conversion from the database format into ASCII.
    //
    // Note:  All the data in the returned stream must
    // be read prior to getting the value of any other column. The
    // next call to a get method implicitly closes the stream.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns a Java input stream that delivers the database column value
    // as a stream of one byte ASCII characters.  If the value is SQL NULL
    // then the result is null.
    //------------------------------------------------------------------------

    public java.io.InputStream getAsciiStream(
        String columnName)
        throws SQLException
    {
        return getAsciiStream(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getUnicodeStream - JDBC API
    // A column value can be retrieved as a stream of Unicode characters
    // and then read in chunks from the stream.  This method is particularly
    // suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
    // do any necessary conversion from the database format into Unicode.
    //
    // Note:  All the data in the returned stream must
    // be read prior to getting the value of any other column. The
    // next call to a get method implicitly closes the stream.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns a Java input stream that delivers the database column value
    // as a stream of two byte Unicode characters.  If the value is SQL NULL
    // then the result is null.
    //------------------------------------------------------------------------

    public java.io.InputStream getUnicodeStream(
        String columnName)
        throws SQLException
    {
        return getUnicodeStream(findColumn(columnName));
    }

    //------------------------------------------------------------------------
    // getBinaryStream - JDBC API
    // A column value can be retrieved as a stream of uninterpreted bytes
    // and then read in chunks from the stream.  This method is particularly
    // suitable for retrieving large LONGVARBINARY values.
    //
    // Note:  All the data in the returned stream must
    // be read prior to getting the value of any other column. The
    // next call to a get method implicitly closes the stream.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns a Java input stream that delivers the database column value
    // as a stream of uninterpreted bytes.  If the value is SQL NULL
    // then the result is null.
    //------------------------------------------------------------------------

    public java.io.InputStream getBinaryStream(
        String columnName)
        throws SQLException
    {
        return getBinaryStream(findColumn(columnName));
    }


    //=====================================================================
    // Advanced features:
    //=====================================================================

    //------------------------------------------------------------------------
    // getWarnings - JDBC API
    // The first warning reported by calls on this ResultSet is
    // returned. Subsequent ResultSet warnings will be chained to this
    // SQLWarning.
    //
    // The warning chain is automatically cleared each time a new
    // row is read.
    //
    // Note:  This warning chain only covers warnings caused
    // by ResultSet methods.  Any warning caused by statement methods
    // (such as reading OUT parameters) will be chained on the
    // Statement object.
    //
    // Returns the first SQLWarning or null
    //------------------------------------------------------------------------

    public SQLWarning getWarnings()
        throws SQLException
    {
        return lastWarning;
    }

    //------------------------------------------------------------------------
    // clearWarnings - JDBC API
    // After this call getWarnings returns null until a new warning is
    // reported for this ResultSet.
    //------------------------------------------------------------------------

    public void clearWarnings()
        throws SQLException
    {
        setWarning(null);
    }

    //------------------------------------------------------------------------
    // setWarning
    // Sets the given SQLWarning in the warning chain.  If null, the
    // chain is reset
    //------------------------------------------------------------------------

    protected void setWarning(
        SQLWarning warning)
    {
        if (warning == null) {
            lastWarning = null;
        }
        else {
            SQLWarning chain = lastWarning;

            // Find the end of the chain

            while (chain.getNextWarning() != null) {
                chain = chain.getNextWarning();
            }

            // We're at the end of the chain.  Add the new warning

            chain.setNextWarning(warning);
        }
    }

    //------------------------------------------------------------------------
    // getCursorName - JDBC API
    // Get the name of the SQL cursor used by this ResultSet.
    //
    // In SQL, a result table is retrieved through a cursor that is
    // named. The current row of a result can be updated or deleted
    // using a positioned update/delete statement that references the
    // cursor name.
    //
    // JDBC supports this SQL feature by providing the name of the
    // SQL cursor used by a ResultSet. The current row of a ResultSet
    // is also the current row of this SQL cursor.
    //
    // Note:  If positioned update is not supported a
    // SQLException is thrown
    //
    // Returns the ResultSet's SQL cursor name
    //------------------------------------------------------------------------

    public String getCursorName()
        throws SQLException
    {
        // The SimpleText driver does not support positioned updates

        throw DriverNotCapable();
    }

    //------------------------------------------------------------------------
    // getMetaData - JDBC API
    // The number, types and properties of a ResultSet's columns
    // are provided by the getMetaData method.
    //
    // Returns the description of a ResultSet's columns
    //------------------------------------------------------------------------

    public ResultSetMetaData getMetaData()
        throws SQLException
    {
        SimpleTextResultSetMetaData md = new SimpleTextResultSetMetaData();

        md.initialize(inMemoryColumns, ownerConnection.isReadOnly());

        return md;
    }

    //------------------------------------------------------------------------
    // getObject - JDBC API
    // Get the value of a column as a Java object.
    //
    // This method will return the value of the given column as a Java
    // object.  The type of the Java object will be default Java Object type
    // corresponding to the column's SQL type, following the mapping
    // specified in the JDBC spec.
    //
    // This method may also be used to read datatabase specific abstract
    // data types.
    //
    //    columnIndex the first column is 1, the second is 2, ...
    //
    // Returns A java.lang.Object holding the column value.
    //------------------------------------------------------------------------

    public Object getObject(
        int columnIndex)
        throws SQLException
    {

        // Verify the column

        verify(columnIndex);

        // Get the data type of the column

        int type = (getColumn(columnIndex)).type;

        // The CommonValue for the column

        CommonValue value;

        if (inMemoryRows != null) {
            value = getColumn(rowNum, columnIndex);
        }
        else {
            value = getValue(columnIndex);
        }

        // Check for a null value

        if (value == null) {
            lastNull = true;
            return null;
        }

        if (value.isNull()) {
            lastNull = true;
            return null;
        }

        Object o = null;

        // Return the appropriate object for the given type

        switch(type) {
        case Types.VARCHAR:
            o = value.getString();
            break;
        case Types.INTEGER:
            o = new Integer(value.getInt());
            break;
        case Types.VARBINARY:
            o = value.getBytes();
            break;
        default:
            throw DataTypeNotSupported();
        }
        return o;
    }

    //------------------------------------------------------------------------
    // getObject - JDBC API
    // Get the value of a parameter as a Java object.
    //
    // This method will return the value of the given column as a Java
    // object.  The type of the Java object will be default Java Object type
    // corresponding to the column's SQL type, following the mapping
    // specified in the JDBC spec.
    //
    // This method may also be used to read datatabase specific abstract
    // data types.
    //
    //    columnName        is the SQL name of the column
    //
    // Returns A java.lang.Object holding the column value.
    //------------------------------------------------------------------------

    public Object getObject(
        String columnName)
        throws SQLException
    {
        return getObject(findColumn(columnName));
    }


    //------------------------------------------------------------------------
    // findColumn - JDBC API
    // Map a Resultset column name to a ResultSet column index.
    //
    //    columnName    the name of the column
    //
    // Returns the column index
    //
    // Note:  The code implemented here comes from appendix C of the
    // JDBC API.
    //------------------------------------------------------------------------

    public int findColumn(
        String columnName)
        throws SQLException
    {
        // Make a mapping cache if we don't already have one.

        if (md == null) {
            md = getMetaData();
            s2c = new Hashtable();
        }

        // Look for the mapping in our cache

        Integer x = (Integer) s2c.get(columnName);

        if (x != null) {
            return (x.intValue());
        }

        // OK, we'll have to use metadata

        for (int i = 1; i <= md.getColumnCount(); i++) {
            if (md.getColumnName(i).equalsIgnoreCase(columnName)) {

                // Success!  Add an entry to the cache

                s2c.put(columnName, new Integer(i));
                return (i);
            }
        }

        throw new SQLException("Column name not found: " + columnName,
                            "S0022");
    }

    //------------------------------------------------------------------------
    // verify
    // Verifies the column number given is valid, and resets the warnings
    // and null indicator.  Returns the absolute column number.
    //------------------------------------------------------------------------

    protected int verify(
        int column)
        throws SQLException
    {
        clearWarnings();
        lastNull = false;

        SimpleTextColumn col = (SimpleTextColumn) inMemoryColumns.get(
                                    new Integer(column));

        if (col == null) {
            throw new SQLException("Invalid column number: " + column);
        }
            return col.colNo;
    }

    //------------------------------------------------------------------------
    // getColumn
    // Given a row and column number, return the CommonValue object from
    // the inMemoryRows
    //------------------------------------------------------------------------

    protected CommonValue getColumn(
        int rowNum,
        int column)
        throws SQLException
    {

        // First, get the row

        Hashtable row = (Hashtable) inMemoryRows.get(new Integer(rowNum));

        if (row == null) {
            throw new SQLException("Invalid row number: " + rowNum);
        }

        // Get the value

        CommonValue value = (CommonValue) row.get(new Integer(column));

        if (value == null) {

            // Column wasn't found.  Return a null value

            value = new CommonValue();
        }

        return value;
    }

    private Hashtable s2c;                    // Maps strings to column indexes
    private ResultSetMetaData md;            // Our metadata object

    //------------------------------------------------------------------------
    // openSDF
    // Opens the simple data file
    //------------------------------------------------------------------------

    protected void openSDF(
        String catalog,
        String table)
        throws SQLException
    {
        String fullName = catalog + "/" + table +
                    SimpleTextDefine.DATA_FILE_EXT;

        String sbfName = catalog + "/" + table +
                    SimpleTextDefine.BINARY_FILE_EXT;

        // Make sure the file exists

        SDF = new File(fullName);
        SBF = new File(sbfName);

        if (!SDF.exists()) {
            throw new SQLException("Text file does not exist: " + fullName);
        }

        try {
            // Create our random access object (read only)

            rafSDF = new RandomAccessFile(SDF, "r");
        }
        catch (Exception ex) {
            throw new SQLException("Unable to access file: " +ex.getMessage());
        }

        // Read past the first line (the column definitions).  Before
        // we got to this point, the Statement object verified that
        // it is a valid file

        readLine(rafSDF);
    }

    //------------------------------------------------------------------------
    // readLine
    // Given a random access file object, read the next line.  Returns null
    // if eof
    //------------------------------------------------------------------------

    protected String readLine(
        RandomAccessFile f)
        throws SQLException
    {
        String s = null;

        try {
            if (f.getFilePointer() >= f.length()) {
                return null;
            }

            s = f.readLine();
        }
        catch (Exception ex) {
            throw new SQLException("Error reading file: " + ex.getMessage());
        }
        return s;
    }

    //------------------------------------------------------------------------
    // readSBF
    // Given an offset, read the binary file and return a byte array
    //------------------------------------------------------------------------

    protected byte[] readSBF(
        int offset)
        throws SQLException
    {

        // Invalid offset, return null

        if (offset < 0) {
            return null;
        }

        byte b[] = null;

        // First time, check to make sure it exists

        if (rafSBF == null) {
            if (!SBF.exists()) {
                throw new SQLException("Binary file does not exist");
            }
        }

        try {

            // First time, create random access file object

            if (rafSBF == null) {
                rafSBF = new RandomAccessFile(SBF, "r");
            }

            // Position to the given offset

            rafSBF.seek(offset);

            // Make sure there is enough file to read an int

            if ((rafSBF.getFilePointer() + 4) > rafSBF.length()) {
                throw new SQLException("Attempt to read beyond end-of-file");
            }

            // Read the length of the data

            int len = rafSBF.readInt();

            // Make sure there's enough data to read

            if ((rafSBF.getFilePointer() + len) > rafSBF.length()) {
                throw new SQLException("Attempt to read beyond end-of-file");
            }

            b = new byte[len];
            rafSBF.read(b);

        }
        catch (Exception ex) {
            throw new SQLException("Unable to access SBF: " + ex.getMessage());
        }

        return b;
    }

    //------------------------------------------------------------------------
    // getValue
    // Returns a CommonValue object for the given column
    //------------------------------------------------------------------------

    protected CommonValue getValue(
        int column)
        throws SQLException
    {
        CommonValue value;

        // Get the column definition (we already know it's there)

        SimpleTextColumn col = (SimpleTextColumn) inMemoryColumns.get(
                                    new Integer(column));

//        value = (CommonValue) columnValues.get(new Integer(column));
        value = (CommonValue) columnValues.get(new Integer(col.colNo));

        if (value == null) {
            return null;
        }

        switch(col.type) {

        // For binary types, read the binary file

        case Types.VARBINARY:
            {
                byte b[] = readSBF(value.getInt());
                value = new CommonValue(b);
            }
            break;
        }

        return value;

    }

    //------------------------------------------------------------------------
    // filter
    // Given a Hashtable of column values and a select filter, determine if
    // the data is valid.  Returns true if the row is valid.
    //------------------------------------------------------------------------

    protected boolean filterRow(
        Hashtable values,
        SimpleTextFilter filter)
        throws SQLException
    {
        if (filter == null) {
            return true;
        }

        boolean valid = false;

        // Get the column number

        int column = filter.column.colNo;

        // Get the data for the column

        CommonValue value = (CommonValue) values.get(new Integer(column));

        // If we didn't find the column, invalidate the column

        if (value == null) {
            return false;
        }

        switch(filter.column.type) {

        // Perform integer comparisions

        case Types.INTEGER:
            {
                int icol = value.getInt();
                int ifilter = filter.value.getInt();
                switch (filter.operator) {
                case SimpleTextFilter.OP_EQ:
                    valid = (icol == ifilter);
                    break;
                case SimpleTextFilter.OP_GT:
                    valid = (icol > ifilter);
                    break;
                case SimpleTextFilter.OP_LT:
                    valid = (icol < ifilter);
                    break;
                case SimpleTextFilter.OP_NE:
                    valid = (icol != ifilter);
                    break;
                }
            }
            break;

        // By default, compare as a string

        default:
            {
                String scol = value.getString();
                String sfilter = filter.value.getString();
                switch (filter.operator) {
                case SimpleTextFilter.OP_EQ:
                    valid = (scol.equals(sfilter));
                    break;
                case SimpleTextFilter.OP_GT:
                    valid = (scol.compareTo(sfilter) > 0);
                    break;
                case SimpleTextFilter.OP_LT:
                    valid = (scol.compareTo(sfilter) < 0);
                    break;
                case SimpleTextFilter.OP_NE:
                    valid = (!scol.equals(sfilter));
                    break;
                }
            }

            break;
        }

        return valid;
    }

    //------------------------------------------------------------------------
    // getColumn
    // Returns the SimpleTextColumn object for the given column number.
    // If not found, an exception is thrown
    //------------------------------------------------------------------------

    protected SimpleTextColumn getColumn(
        int col)
        throws SQLException
    {
        SimpleTextColumn column = (SimpleTextColumn)
                        inMemoryColumns.get(new Integer(col));

        if (column == null) {
            throw new SQLException("Invalid column number: " + col);
        }

        return column;
    }



    // SQLWarning chain

    protected SQLWarning lastWarning;

    // Owning statement object

    protected SimpleTextIStatement ownerStatement;

    // Owning connection object

    protected SimpleTextIConnection ownerConnection;

    // Hashtable containing a SimpleTextColumn object for each column
    // in the result set.  Used for catalog functions as well as normal
    // tables

    protected Hashtable inMemoryColumns;

    // Hashtable containing another Hashtable for each row.  Used for
    // catalog functions

    protected Hashtable inMemoryRows;

    // Current row number (for in-memory result sets)

    protected int rowNum;

    // true if the last row accessed was null

    protected boolean lastNull;

    // File objects for the simple data file and simple binary file

    File SDF;
    File SBF;
    RandomAccessFile rafSDF;
    RandomAccessFile rafSBF;

    // Current text line

    String currentLine;

    // Current data values (CommonValue objects)

    Hashtable columnValues;

    // SimpleTextFilter object for select WHERE clause

    SimpleTextFilter selectFilter;
}

//----------------------------------------------------------------------------
// SimpleTextFilter
// Class to represent a filter for a SELECT statement (i.e. the WHERE clause).
// This class is package-private
//----------------------------------------------------------------------------

class SimpleTextFilter
{
    SimpleTextColumn    column;
    int                    operator;

        public final static int OP_EQ    = 1;
        public final static int OP_GT    = 2;
        public final static int OP_LT    = 3;
        public final static int    OP_NE    = 4;

    CommonValue            value;
}
//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextResultSetMetaData.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextResultSetMetaData.java
//
// Description: Implementation of the JDBC ResultSetMetaData interface
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;


//----------------------------------------------------------------------------
// A ResultSetMetaData object can be used to find out about the types
// and properties of the columns in a ResultSet.
//----------------------------------------------------------------------------
// NOTE - this is an implementation of the JDBC API version 1.20
//---------------------------------------------------------------------------

import java.sql.*;
import java.util.Hashtable;

public class SimpleTextResultSetMetaData
    extends        SimpleTextObject
    implements    ResultSetMetaData
{
    //------------------------------------------------------------------------
    // initialize
    //------------------------------------------------------------------------

    public void initialize(
        Hashtable columns,
        boolean readOnly)
    {
        inMemoryColumns = columns;
    }

    //------------------------------------------------------------------------
    // getColumnCount - JDBC API
    // What's the number of columns in the ResultSet?
    //
    // Returns the number
    //------------------------------------------------------------------------

    public int getColumnCount()
        throws SQLException
    {
        return inMemoryColumns.size();
    }

    //------------------------------------------------------------------------
    // isAutoIncrement - JDBC API
    // Is the column automatically numbered, thus read-only?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns true if so
    //------------------------------------------------------------------------

    public boolean isAutoIncrement(
        int column)
        throws SQLException
    {
        // The SimpleText driver does not support auto increment columns

        return false;
    }

    //------------------------------------------------------------------------
    // isCaseSensitive - JDBC API
    // Does a column's case matter?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns true if so
    //------------------------------------------------------------------------

    public boolean isCaseSensitive(
        int column)
        throws SQLException
    {
        // Case never matters

        return false;
    }

    //------------------------------------------------------------------------
    // isSearchable - JDBC API
    // Can the column be used in a where clause?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns true if so
    //------------------------------------------------------------------------

    public boolean isSearchable(
        int column)
        throws SQLException
    {
        // The SimpleText driver does not support searching

        return false;
    }

    //------------------------------------------------------------------------
    // isCurrency - JDBC API
    // Is the column a cash value?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns true if so
    //------------------------------------------------------------------------

    public boolean isCurrency(
        int column)
        throws SQLException
    {
        // The SimpleText driver does not support any currency data types

        return false;
    }

    //------------------------------------------------------------------------
    // isNullable - JDBC API
    // Can you put a NULL in this column?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns columnNoNulls, columnNullable or columnNullableUnknown
    //------------------------------------------------------------------------

    public int isNullable(
        int column)
        throws SQLException
    {
        // The SimpleText driver does not support nullable columns

        return columnNoNulls;
    }

    //------------------------------------------------------------------------
    // isSigned - JDBC API
    // Is the column a signed number?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns true if so
    //------------------------------------------------------------------------

    public boolean isSigned(
        int column)
        throws SQLException
    {
        // The SimpleText driver does not support signed columns

        return false;
    }

    //------------------------------------------------------------------------
    // getColumnDisplaySize
    // What's the column's normal max width in chars?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns max width
    //------------------------------------------------------------------------

    public int getColumnDisplaySize(
        int column)
        throws SQLException
    {
        return (getColumn(column)).displaySize;
    }

    //------------------------------------------------------------------------
    // getColumnLabel - JDBC API
    // What's the suggested column title for use in printouts and
    // displays?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns the column label
    //------------------------------------------------------------------------

    public String getColumnLabel(
        int column)
        throws SQLException
    {
        // Use the column name

        return getColumnName(column);
    }

    //------------------------------------------------------------------------
    // getColumnName - JDBC API
    // What's a column's name?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns column name
    //------------------------------------------------------------------------

    public String getColumnName(
        int column)
        throws SQLException
    {
        return (getColumn(column)).name;
    }

    //------------------------------------------------------------------------
    // getSchemaName - JDBC API
    // What's a column's table's schema?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns schema name or "" if not applicable
    //------------------------------------------------------------------------

    public String getSchemaName(
        int column)
        throws SQLException
    {
        // The SimpleText driver does not support schemas

        return "";
    }

    //------------------------------------------------------------------------
    // getPrecision - JDBC API
    // What's a column's number of decimal digits?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns precision
    //------------------------------------------------------------------------

    public int getPrecision(
        int column)
        throws SQLException
    {
        return (getColumn(column)).precision;
    }

    //------------------------------------------------------------------------
    // getScale - JDBC API
    // What's a column's number of digits to right of decimal?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns scale
    //------------------------------------------------------------------------

    public int getScale(
        int column)
        throws SQLException
    {
        // The SimpleText driver does not support any data types with scale

        return 0;
    }

    //------------------------------------------------------------------------
    // getTableName - JDBC API
    // What's a column's table name?
    //
    // Returns table name or "" if not applicable
    //------------------------------------------------------------------------

    public String getTableName(
        int column)
        throws SQLException
    {
        return "";
    }

    //------------------------------------------------------------------------
    // getCatalogName - JDBC API
    // What's a column's table's catalog name?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns column name or "" if not applicable.
    //------------------------------------------------------------------------

    public String getCatalogName(
        int column)
        throws SQLException
    {
        return "";
    }

    //------------------------------------------------------------------------
    // getColumnType - JDBC API
    // What's a column's SQL type?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns SQL type
    //------------------------------------------------------------------------

    public int getColumnType(
        int column)
        throws SQLException
    {
        return (getColumn(column)).type;
    }

    //------------------------------------------------------------------------
    // getColumnTypeName - JDBC API
    // What's a column's data source specific type name?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns type name
    //------------------------------------------------------------------------

    public String getColumnTypeName(
        int column)
        throws SQLException
    {
        return (getColumn(column)).typeName;
    }

    //------------------------------------------------------------------------
    // isReadOnly - JDBC API
    // Is a column definitely not writable?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns true if so
    //------------------------------------------------------------------------

    public boolean isReadOnly(
        int column)
        throws SQLException
    {
        return readOnly;
    }

    //------------------------------------------------------------------------
    // isWritable - JDBC API
    // Is it possible for a write on the column to succeed?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns true if so
    //------------------------------------------------------------------------

    public boolean isWritable(
        int column)
        throws SQLException
    {
        return !isReadOnly(column);
    }

    //------------------------------------------------------------------------
    // isDefinitelyWritable - JDBC API
    // Will a write on the column definitely succeed?
    //
    //    column    the first column is 1, the second is 2, ...
    //
    // Returns true if so
    //------------------------------------------------------------------------

    public boolean isDefinitelyWritable(
        int column)
        throws SQLException
    {
        return !isReadOnly(column);
    }

    //------------------------------------------------------------------------
    // getColumn
    // Returns the SimpleTextColumn object for the given column number.
    // If not found, an exception is thrown
    //------------------------------------------------------------------------

    protected SimpleTextColumn getColumn(
        int col)
        throws SQLException
    {
        SimpleTextColumn column = (SimpleTextColumn)
                        inMemoryColumns.get(new Integer(col));

        if (column == null) {
            throw new SQLException("Invalid column number: " + col);
        }

        return column;
    }

    // All column information is kept in a Hashtable.  This hashtable
    // is keyed by the column number, and contains a SimpleTextColumn
    // object

    protected Hashtable inMemoryColumns;

    // Flag indicating whether the connection is read-only

    protected boolean readOnly;
}
//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextStatement.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextStatement.java
//
// Description: Implementation of the JDBC Statement interface
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

//----------------------------------------------------------------------------
// A Statement object is used for executing a static SQL statement
// and obtaining the results produced by it.
//
// Only one ResultSet per Statement can be open at any point in
// time. Therefore, if the reading of one ResultSet is interleaved with
// the reading of another, each must have been generated by different
// Statements.
//----------------------------------------------------------------------------
// NOTE - this is an implementation of the JDBC API version 1.20
//---------------------------------------------------------------------------

import java.sql.*;
import java.util.Hashtable;
import java.io.*;

public class SimpleTextStatement
    extends        SimpleTextObject
    implements    SimpleTextIStatement
{

    //------------------------------------------------------------------------
    // initialize
    //------------------------------------------------------------------------

    public void initialize(
        SimpleTextIConnection con)
        throws SQLException
    {
        // Save the owning connection object

        ownerConnection = con;
    }


    //------------------------------------------------------------------------
    // executeQuery - JDBC API
    // Execute a SQL statement that returns a single ResultSet.
    //
    //    sql    typically this is a static SQL SELECT statement
    //
    // Returns the table of data produced by the SQL statement
    //------------------------------------------------------------------------

    public ResultSet executeQuery(
        String sql)
        throws SQLException
    {
        if (traceOn()) {
            trace("@executeQuery(" + sql + ")");
        }

        java.sql.ResultSet rs = null;

        // Execute the query.  If execute returns true, then a result set
        // exists

        if (execute(sql)) {
            rs = getResultSet();
        }

        return rs;
    }

    //------------------------------------------------------------------------
    // executeUpdate - JDBC API
    // Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
    // SQL statements that return nothing such as SQL DDL statements
    // can be executed.
    //
    //    sql    a SQL INSERT, UPDATE or DELETE statement or a SQL
    //        statement that returns nothing
    //
    // Returns either the row count for INSERT, UPDATE or DELETE; or 0
    // for SQL statements that return nothing
    //------------------------------------------------------------------------

    public int executeUpdate(
        String sql)
        throws SQLException
    {
        if (traceOn()) {
            trace("@executeUpdate(" + sql + ")");
        }

        int count = -1;

        // Execute the query.  If execute returns false, then an update
        // count exists.

        if (execute(sql) == false) {
            count = getUpdateCount();
        }

        return count;
    }

    //------------------------------------------------------------------------
    // close - JDBC API
    // In many cases, it is desirable to immediately release a
    // Statements's database and JDBC resources instead of waiting for
    // this to happen when it is automatically closed; the close
    // method provides this immediate release.
    //
    // Note: A Statement is automatically closed when it is
    // garbage collected. When a Statement is closed its current
    // ResultSet, if one exists, is also closed.
    //------------------------------------------------------------------------

    public void close()
        throws SQLException
    {
        // If we have a current result set, close it

        if (currentResultSet != null) {
            currentResultSet.close();
            currentResultSet = null;
        }
    }


    //------------------------------------------------------------------------
    // getMaxFieldSize - JDBC API
    // The maxFieldSize limit (in bytes) is the maximum amount of data
    // returned for any column value; it only applies to BINARY,
    // VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR
    // columns.  If the limit is exceeded, the excess data is silently
    // discarded.
    //
    // Returns the current max column size limit; zero means unlimited
    //------------------------------------------------------------------------

    public int getMaxFieldSize()
        throws SQLException
    {
        // The SimpleText driver does not have a limit on size

        return 0;
    }

    //------------------------------------------------------------------------
    // setMaxFieldSize - JDBC API
    // The maxFieldSize limit (in bytes) is set to limit the size of
    // data that can be returned for any column value; it only applies
    // to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
    // LONGVARCHAR fields.  If the limit is exceeded, the excess data
    // is silently discarded.
    //
    //    max    the new max column size limit; zero means unlimited
    //------------------------------------------------------------------------

    public void setMaxFieldSize(
        int max)
        throws SQLException
    {
        // The SimpleText driver does not allow the maximum field size to
        // be set

        if (max != 0) {
            throw DriverNotCapable();
        }
    }

    //------------------------------------------------------------------------
    // getMaxRows - JDBC API
    // The maxRows limit is the maximum number of rows that a
    // ResultSet can contain.  If the limit is exceeded, the excess
    // rows are silently dropped.
    //
    // Returns the current max row limit; zero means unlimited
    //------------------------------------------------------------------------

    public int getMaxRows()
        throws SQLException
    {
        // The SimpleText driver does not have a limit on the number
        // of rows that can be returned

        return 0;
    }

    //------------------------------------------------------------------------
    // setMaxRows - JDBC API
    // The maxRows limit is set to limit the number of rows that any
    // ResultSet can contain.  If the limit is exceeded, the excess
    // rows are silently dropped.
    //
    //    max    the new max rows limit; zero means unlimited
    //------------------------------------------------------------------------

    public void setMaxRows(
        int max)
        throws SQLException
    {
        // The SimpleText driver does not allow the maximum number of rows
        // to be set

        if (max != 0) {
            throw DriverNotCapable();
        }
    }

    //------------------------------------------------------------------------
    // setEscapeProcessing - JDBC API
    // If escape scanning is on (the default) the driver will do
    // escape substitution before sending the SQL to the database.
    //
    //    enable    true to enable; false to disable
    //------------------------------------------------------------------------

    public void setEscapeProcessing(
        boolean enable)
        throws SQLException
    {
        // The SimpleText driver does not support escape sequence expansion

        if (enable) {
            throw DriverNotCapable();
        }
    }

    //------------------------------------------------------------------------
    // getQueryTimeout - JDBC API
    // The queryTimeout limit is the number of seconds the driver will
    // wait for a Statement to execute. If the limit is exceeded a
    // SQLException is thrown.
    //
    // Returns the current query timeout limit in seconds; zero means
    // unlimited
    //------------------------------------------------------------------------

    public int getQueryTimeout()
        throws SQLException
    {
        // The SimpleText driver does not have a query timeout

        return 0;
    }

    //------------------------------------------------------------------------
    // setQueryTimeout - JDBC API
    // The queryTimeout limit is the number of seconds the driver will
    // wait for a Statement to execute. If the limit is exceeded a
    // SQLException is thrown.
    //
    //    seconds    the new query timeout limit in seconds; zero means unlimited
    //------------------------------------------------------------------------

    public void setQueryTimeout(
        int seconds)
        throws SQLException
    {
        // The SimpleText driver does not support query timeouts

        if (seconds != 0) {
            throw DriverNotCapable();
        }
    }

    //------------------------------------------------------------------------
    // cancel - JDBC API
    // Cancel can be used by one thread to cancel a statement that
    // is being executed by another thread.
    //------------------------------------------------------------------------

    public void cancel()
        throws SQLException
    {
        // No-op for the SimpleText driver
    }

    //------------------------------------------------------------------------
    // getWarnings - JDBC API
    // The first warning reported by calls on this Statement is
    // returned.  A Statment's execute methods clear its SQLWarning
    // chain. Subsequent Statement warnings will be chained to this
    // SQLWarning.
    //
    // Note:  The warning chain is automatically cleared each time
    // a statement is (re)executed.
    //
    // Note:  If you are processing a ResultSet then any
    // warnings associated with ResultSet reads will be chained on the
    // ResultSet object.
    //
    // Returns the first SQLWarning or null
    //------------------------------------------------------------------------

    public SQLWarning getWarnings()
        throws SQLException
    {
        return lastWarning;
    }

    //------------------------------------------------------------------------
    // clearWarnings - JDBC API
    // After this call getWarnings returns null until a new warning is
    // reported for this Statement.
    //------------------------------------------------------------------------

    public void clearWarnings()
        throws SQLException
    {
        setWarning(null);
    }

    //------------------------------------------------------------------------
    // setWarning
    // Sets the given SQLWarning in the warning chain.  If null, the
    // chain is reset
    //------------------------------------------------------------------------

    protected void setWarning(
        SQLWarning warning)
    {
        if (warning == null) {
            lastWarning = null;
        }
        else {
            SQLWarning chain = lastWarning;

            // Find the end of the chain

            while (chain.getNextWarning() != null) {
                chain = chain.getNextWarning();
            }

            // We're at the end of the chain.  Add the new warning

            chain.setNextWarning(warning);
        }
    }

    //------------------------------------------------------------------------
    // setCursorName - JDBC API
    // setCursorname defines the SQL cursor name that will be used by
    // subsequent Statement execute methods. This name can then be
    // used in SQL positioned update/delete statements to identify the
    // current row in the ResultSet generated by this statement.  If
    // the database doesn't support positioned update/delete, this
    // method is a noop.
    //
    // Note:  By definition, positioned update/delete
    // execution must be done by a different Statement than the one
    // which generated the ResultSet being used for positioning. Also,
    // cursor names must be unique within a Connection.
    //
    //    name    the new cursor name.
    //------------------------------------------------------------------------

    public void setCursorName(
        String name)
        throws SQLException
    {
        // The SimpleText driver does not support positioned updates.  Per
        // the spec, this is a no-op
    }


    //------------------------------------------------------------------------
    // execute - JDBC API
    // Execute a SQL statement that may return multiple results.
    // Under some (uncommon) situations a single SQL statement may return
    // multiple result sets and/or update counts.  Normally you can ignore
    // this, unless you're executing a stored procedure that you know may
    // return multiple results, or unless you're dynamically executing an
    // unknown SQL string.  The "execute", "getMoreResults", "getResultSet"
    // and "getUpdateCount" methods let you navigate through multiple results.
    //
    // The "execute" method executes a SQL statement and indicates the
    // form of the first result.  You can then use getResultSet or
    // getUpdateCount to retrieve the result, and getMoreResults to
    // move to any subsequent result(s).
    //
    //    sql    any SQL statement
    // Returns true if the first result is a ResultSet; false if it is an
    // integer
    //------------------------------------------------------------------------

    public boolean execute(
        String sql)
        throws SQLException
    {
        resultSetColumns = null;

        // Convert the SQL statement into native syntax

        sql = ownerConnection.nativeSQL(sql);
        // Save the SQL statement

        sqlStatement = sql;

        // First, parse the sql statement into a String array

        parsedSQL = ownerConnection.parseSQL(sql);

        // Now validate the SQL statement and execute it.
        // Returns true if a result set exists.

        boolean rc = prepare(false);

        return rc;
    }

    //------------------------------------------------------------------------
    // getResultSet - JDBC API
    // Returns the current result as a ResultSet.  It
    // should only be called once per result.
    //
    // Returns the current result as a ResultSet; null if it is an integer
    //------------------------------------------------------------------------

    public ResultSet getResultSet()
        throws SQLException
    {
        // If there are no column to be returned, return null

        if (resultSetColumns == null) {
            return null;
        }

        SimpleTextResultSet rs = new SimpleTextResultSet();

        rs.initialize(this, resultSetCatalog, resultSetTable,
                    resultSetColumns, resultSetFilter);

        // Save our current result set

        currentResultSet = rs;

        return rs;
    }


    //------------------------------------------------------------------------
    // getUpdateCount - JDBC API
    // getUpdateCount returns the current result, which should be an
    // integer value.  It should only be called once per result.
    //
    // The only way to tell for sure that the result is an update
    // count is to first test to see if it is a ResultSet. If it is
    // not a ResultSet it is an update count.
    //
    // Returns the current result as an integer; zero if it is a ResultSet
    //------------------------------------------------------------------------

    public int getUpdateCount()
        throws SQLException
    {
        return updateCount;
    }

    //------------------------------------------------------------------------
    // getMoreResults - JDBC API
    // getMoreResults moves to a Statement's next result.  It returns true if
    // this result is a ResultSet.  getMoreResults also implicitly
    // closes any current ResultSet obtained with getResultSet.
    //
    // Returns true if the next result is a ResultSet; false if it is an
    // integer
    //------------------------------------------------------------------------

    public boolean getMoreResults()
        throws SQLException
    {
        // The SimpleText driver does not support multiple result sets

        throw DriverNotCapable();
    }

    //------------------------------------------------------------------------
    // getStatementType
    // Given a parsed SQL statement (in a String array), determine the
    // type of sql statement present.  If the sql statement is not known,
    // an exception is raised
    //------------------------------------------------------------------------

    public int getStatementType(
        String sql[])
        throws SQLException
    {
        int type = 0;

        // There are no sql statements with less than 2 words

        if (sql.length < 2) {
            throw new SQLException("Invalid SQL statement");
        }

        if (sql[0].equalsIgnoreCase("SELECT")) {
            type = SimpleTextDefine.SQL_SELECT;
        }
        else if (sql[0].equalsIgnoreCase("INSERT")) {
            type = SimpleTextDefine.SQL_INSERT;
        }
        else if (sql[0].equalsIgnoreCase("CREATE")) {
            type = SimpleTextDefine.SQL_CREATE;
        }
        else if (sql[0].equalsIgnoreCase("DROP")) {
            type = SimpleTextDefine.SQL_DROP;
        }
        else {
            throw new SQLException("Invalid SQL statement: " + sql[0]);
        }
        return type;
    }

    //------------------------------------------------------------------------
    // prepare
    // Prepare the already parsed SQL statement.
    // Returns true if a result set exists.
    //------------------------------------------------------------------------

    protected boolean prepare(
        boolean prepareOnly)
        throws SQLException
    {
        boolean resultSet = false;

        // Determine the type of statement present

        statementType = getStatementType(parsedSQL);


        // Perform action depending upon the SQL statement type

        switch (statementType) {

        // CREATE statement

        case SimpleTextDefine.SQL_CREATE:

            // If attempting to prepare a DDL (Data Definition Language)
            // statement, raise an exception

            if (prepareOnly) {
                throw new SQLException("DDL statements cannot be prepared");
            }

            // Create the table

            createTable();

            updateCount = 0;
            break;

        // DROP statement

        case SimpleTextDefine.SQL_DROP:

            // If attempting to prepare a DDL (Data Definition Language)
            // statement, raise an exception

            if (prepareOnly) {
                throw new SQLException("DDL statements cannot be prepared");
            }

            // Drop the table

            dropTable();

            updateCount = 0;
            break;

        // INSERT statement

        case SimpleTextDefine.SQL_INSERT:

            // Insert data into the table

            insert(prepareOnly);

            updateCount = 1;
            break;

        // SELECT statement

        case SimpleTextDefine.SQL_SELECT:

            // Select data from the table

            select(prepareOnly);

            resultSet = true;
            updateCount = -1;
            break;

        default:
            throw new SQLException("Unknown SQL statement type: " +
                    statementType);
        }

        return resultSet;
    }

    //------------------------------------------------------------------------
    // createTable
    // Attempt to create the table from the parsed SQL statement.
    //
    // Grammar:
    //
    // create-statement ::= CREATE TABLE table-name
    //                            (column-element [,column-element] ...)
    //
    // column-element ::= column-identifier data-type
    //
    //------------------------------------------------------------------------

    protected void createTable()
        throws SQLException
    {
        // The minimum SQL statement must have 7 elements:
        //
        // CREATE TABLE foo (COL VARCHAR)

        if (parsedSQL.length < 7) {
            throw new SQLException ("Invalid CREATE statement");
        }

        // The next word must be TABLE; this is the only type of
        // CREATE that the SimpleText driver supports

        if (!parsedSQL[1].equalsIgnoreCase("TABLE")) {
            throw new SQLException("CREATE must be followed by TABLE");
        }

        // Make sure we are not in read-only mode

        if (ownerConnection.isReadOnly()) {
            throw new SQLException(
                "Unable to CREATE TABLE: connection is read-only");
        }

        // The next word is the table name.  Verify that it does not
        // contain any invalid characters

        validateName(parsedSQL[2], "table");

        // The next word should be an open paren

        if (!parsedSQL[3].equals("(")) {
            throw new SQLException(
                    "Invalid CREATE TABLE statement: missing paren '('");
        }

        // Now we can step through the other parameters.  The format should
        // be:
        //
        //    ( column type [, column type] ... )
        //
        // We will build a text line that describes each of the columns.
        // This line will be the first line in our simple text file.
        //
        //    Numeric column names start with '#'
        //    Binary column names start with '@'
        //    All other names are considered to be varchar

        String line = "";
        String columnName;
        String typeName;
        int word = 4;
        boolean gotCloseParen = false;
        int numCols = 0;
        boolean hasBinary = false;

        // Keep a Hashtable of all of the column names so we can check
        // for duplicates

        Hashtable names = new Hashtable();

        while ((word < parsedSQL.length) &&
            (!gotCloseParen)) {

            // Get the column name to create and validate

            columnName = parsedSQL[word].toUpperCase();
            validateName(columnName, "column");

            if (names.get(columnName) != null) {
                throw new SQLException("Duplicate column name: " + columnName);
            }

            names.put(columnName, "");

            word++;

            // The next column should be the type

            if (word == parsedSQL.length) {
                throw new SQLException("Missing column type");
            }

            typeName = parsedSQL[word];

            if (numCols > 0) {
                line += ",";
            }

            numCols++;

            // Validate the type

            if (typeName.equalsIgnoreCase("VARCHAR")) {
                line += columnName;
            }
            else if (typeName.equalsIgnoreCase("NUMBER")) {
                line += SimpleTextDefine.COL_TYPE_NUMBER + columnName;
            }
            else if (typeName.equalsIgnoreCase("BINARY")) {
                line += SimpleTextDefine.COL_TYPE_BINARY + columnName;
                hasBinary = true;
            }
            else {
                throw new SQLException("Invalid column type: " + typeName);
            }

            word++;

            if (word == parsedSQL.length) {
                throw new SQLException("Missing close paren");
            }

            // The next word must either be a comma, indicating more
            // columns, or the closing paren

            if (parsedSQL[word].equals(")")) {
                gotCloseParen = true;
                word++;
                break;
            }
            else if (!parsedSQL[word].equals(",")) {
                throw new SQLException("Invalid character near: " +
                            columnName + " " + typeName);
            }
            word++;
        }

        // If we got here and did not find a closing paren, raise an error

        if (!gotCloseParen) {
            throw new SQLException("Missing close paren");
        }

        // We could check for extra junk at the end of the statement, but
        // we'll just ignore it

        // Verify that the file does not already exist

        String fileName = parsedSQL[2].toUpperCase();
        String fullFile = fileName + SimpleTextDefine.DATA_FILE_EXT;
        String fullPath = ownerConnection.getCatalog() + "/" + fullFile;

        File f = new File (fullPath);
        if (f.exists()) {
            throw new SQLException("Table already exists: " + fileName);
        }

        // Create the table

        try {
            RandomAccessFile raf = new RandomAccessFile(f, "rw");

            // Brand the file

            raf.writeBytes(SimpleTextDefine.DATA_FILE_EXT);

            // Write the column info

            raf.writeBytes(line);
            raf.writeBytes("\n");
            raf.close();
        }
        catch (IOException ex) {
            throw new SQLException("Error accessing file " + fullPath +
                        ": " + ex.getMessage());
        }

        // If a binary data type existed, create the binary data file now

        fullFile = fileName + SimpleTextDefine.BINARY_FILE_EXT;
        fullPath = ownerConnection.getCatalog() + "/" + fullFile;

        f = new File (fullPath);

        // Create the binary table

        try {
            RandomAccessFile raf = new RandomAccessFile(f, "rw");
            raf.close();
        }
        catch (IOException ex) {
            throw new SQLException("Error accessing file " + fullPath +
                        ": " + ex.getMessage());
        }

    }

    //------------------------------------------------------------------------
    // dropTable
    // Attempt to drop a table
    //
    // Grammar:
    //
    // drop-statement ::= DROP TABLE table-name
    //
    //------------------------------------------------------------------------

    protected void dropTable()
        throws SQLException
    {
        // The SQL statement must have 3 elements:
        //
        // DROP TABLE table

        if (parsedSQL.length != 3) {
            throw new SQLException ("Invalid DROP statement");
        }

        // The next word must be TABLE; this is the only type of
        // DROP that the SimpleText driver supports

        if (!parsedSQL[1].equalsIgnoreCase("TABLE")) {
            throw new SQLException("DROP must be followed by TABLE");
        }

        // Make sure we are not in read-only mode

        if (ownerConnection.isReadOnly()) {
            throw new SQLException(
                "Unable to DROP TABLE: connection is read-only");
        }

        // The next word is the table name.  Verify that it does not
        // contain any invalid characters

        validateName(parsedSQL[2], "table");

        // Verify that the file exists

        String fileName = parsedSQL[2].toUpperCase();
        String fullFile = fileName + SimpleTextDefine.DATA_FILE_EXT;
        String fullPath = ownerConnection.getCatalog() + "/" + fullFile;

        File f = new File (fullPath);
        if (!f.exists()) {
            throw new SQLException("Table does not exist: " + fileName);
        }

        // Delete the file

        f.delete();

        // If a binary data file exists, delete it now

        fullFile = fileName + SimpleTextDefine.BINARY_FILE_EXT;
        fullPath = ownerConnection.getCatalog() + "/" + fullFile;

        f = new File (fullPath);

        if (f.exists()) {
            f.delete();
        }
    }

    //------------------------------------------------------------------------
    // insert
    // Attempt to insert data into a table
    //
    // Grammar:
    //
    // insert-statement ::= INSERT INTO table-name
    //                            [(column-identifier [,column-identifier]...)]
    //                            VALUES (insert-value [,insert-value]...)
    //
    //------------------------------------------------------------------------

    synchronized protected void insert(
        boolean prepareOnly)
        throws SQLException
    {
        // The SQL statement must have at least 7 elements:
        //
        // INSERT INTO table VALUES (value)

        if (parsedSQL.length <= 7) {
            throw new SQLException ("Invalid INSERT statement");
        }

        // The next word must be INTO

        if (!parsedSQL[1].equalsIgnoreCase("INTO")) {
            throw new SQLException("INSERT must be followed by INTO");
        }

        // Make sure we are not in read-only mode

        if (ownerConnection.isReadOnly()) {
            throw new SQLException(
                "Unable to INSERT: connection is read-only");
        }

        // The next word is the table name.  Verify that it does not
        // contain any invalid characters

        String tableName = parsedSQL[2];
        validateName(tableName, "table");

        // Verify that the file exists.  If getColumns returns null,
        // the table does not exist

        Hashtable columnList = ownerConnection.getColumns(
                                ownerConnection.getCatalog(), tableName);

        if (columnList == null) {
            throw new SQLException("Table does not exist: " + tableName);
        }

        int pos = 3;
        Hashtable insertList = null;
        Hashtable valueList = null;
        int colNo = 1;
        SimpleTextColumn column;
        SimpleTextColumn column2;
        String name;

        // If the next word is a paren '(', the column names are being
        // specified.  Build a list of columns that will have data
        // inserted

        if (parsedSQL[pos].equals("(")) {
            insertList = new Hashtable();
            pos++;

            if (pos >= parsedSQL.length) {
                throw new SQLException ("Invalid INSERT statement");
            }

            // Build our insert list.  Get each comma separated name until
            // we read a close paren

            pos = buildList(parsedSQL, pos, ")", insertList);

            // Make sure at least one column was given

            if (insertList.size() == 0) {
                throw new SQLException ("No columns given");
            }

            // Now that we have the insert list, verify each name is in
            // our target table and get the type and precision

            for (int i = 1; i <= insertList.size(); i++) {
                column = (SimpleTextColumn) insertList.get(new Integer(i));
                column2 = findColumn(columnList, column.name);
                if (column2 == null) {
                    throw new SQLException("Column does not exist: " +
                                column.name);
                }
                column.type = column2.type;
                column.precision = column2.precision;
            }

            // Position to the next word after the closing paren

            pos++;
            if (pos >= parsedSQL.length) {
                throw new SQLException(
                        "Invalid INSERT statement; missing VALUES clause");
            }
        }

        // The next word is VALUES; no column list was given, so assume
        // all columns in the table

        else if (parsedSQL[pos].equalsIgnoreCase("VALUES")) {
            insertList = new Hashtable();

            // Build the insertList with all columns in the table

            for (colNo = 1; colNo <= columnList.size(); colNo++) {
                column2 = (SimpleTextColumn)columnList.get(new Integer(colNo));

                if (column2 == null) {
                    throw new SQLException("Invalid column number: " + colNo);
                }
                column = new SimpleTextColumn(column2.name);
                column.type = column2.type;
                column.precision = column2.precision;
                insertList.put(new Integer(colNo), column);
            }
        }
        else {
            // Invalid SQL statement

            throw new SQLException(
                            "Invalid INSERT statement, no VALUES clause");

        }

        // The next word must be VALUES.  If there was an insert list,
        // we have positioned past it.

        if (!parsedSQL[pos].equalsIgnoreCase("VALUES")) {
            throw new SQLException(
                    "Invalid INSERT statement; missing VALUES clause");
        }

        pos++;
        if (pos >= parsedSQL.length) {
            throw new SQLException (
                    "Invalid INSERT statement, missing values");
        }

        // The next word must be the open paren that starts the values

        if (!parsedSQL[pos].equals("(")) {
            throw new SQLException (
                    "Invalid INSERT statement, missing values");
        }

        pos++;
        if (pos >= parsedSQL.length) {
            throw new SQLException (
                    "Invalid INSERT statement, missing values");
        }

        // Build our value list.  Get each comma separated value until
        // we read a close paren

        valueList = new Hashtable();

        pos = buildList(parsedSQL, pos, ")", valueList);

        // We could check for junk after the INSERT statement, but we won't

        // Verify the the number of insert items matches the number
        // of data items

        if (insertList.size() != valueList.size()) {
            throw new SQLException("Number of values does not equal the number of items in the insert list");
        }

        // Verify the data is correct

        validateData(insertList, valueList, prepareOnly);

        // If we are just preparing the statement, exit now

        if (prepareOnly) {
            return;
        }

        // Now we can build the line that will get written to the
        // simple text file.  If there is any binary data, write it first
        // so that we know what the offset will be.

        String sdfPath = ownerConnection.getCatalog() + "/" + tableName +
                                SimpleTextDefine.DATA_FILE_EXT;
        String sbfPath = ownerConnection.getCatalog() + "/" + tableName +
                                SimpleTextDefine.BINARY_FILE_EXT;

        File sdf = new File(sdfPath);
        File sbf = new File(sbfPath);
        RandomAccessFile rafsdf = null;
        RandomAccessFile rafsbf = null;

        if (!sdf.exists()) {
            throw new SQLException("Text file does not exist: " + sdfPath);
        }

        String line = "";
        long binaryPos = 0;

        for (int i = 1; i <= columnList.size(); i++) {
            column2 = (SimpleTextColumn) columnList.get(new Integer(i));

            // Separate the data by a comma

            if (i > 1) {
                line += ",";
            }

            // If there is no data for this column, skip it

            colNo = findColumnNumber(insertList, column2.name);

            if (colNo == 0) {

                // No data, put in defaults

                switch(column2.type) {
                case Types.VARCHAR:
                    line += "''";
                    break;
                case Types.VARBINARY:
                    line += "-1";
                    break;
                default:
                    line += "0";
                    break;
                }
                continue;
            }

            column = (SimpleTextColumn) valueList.get(new Integer(colNo));

            if (column2.type == Types.VARBINARY) {
                if (rafsbf == null) {
                    if (!sbf.exists()) {
                        throw new SQLException("Binary file does not exist: "
                                    + sbfPath);
                    }
                    try {
                        rafsbf = new RandomAccessFile(sbf, "rw");

                        // Position to the end of file

                        rafsbf.seek(rafsbf.length());

                    }
                    catch (Exception ex) {
                        throw new SQLException("Unable to access " +
                                sbfPath + ": " + ex.getMessage());
                    }
                }

                try {

                    // Get the current position

                    binaryPos = rafsbf.getFilePointer();

                    // Create a new CommonValue with the hex digits (remove
                    // the quotes.

                    CommonValue value = new CommonValue(
                        column.name.substring(1, column.name.length() - 1));

                    // Now let CommonValue convert the hex string into
                    // a byte array

                    byte b[] = value.getBytes();

                    // Write the length first

                    rafsbf.writeInt(b.length);

                    // Write the data

                    rafsbf.write(b);

                }
                catch (Exception ex) {
                    throw new SQLException("Unable to access " +
                            sbfPath + " for column " + i + 
                            ": " + ex.getMessage());
                }

                // Put the offset pointer in the line

                line += binaryPos;
            }

            // Else some kind of text data, put directly in the line

            else {
                line += column.name;
            }
        }


        // If the binary file was opened, close it now

        if (rafsbf != null) {
            try {
                rafsbf.close();
            }
            catch (Exception ex) {
                throw new SQLException("Unable to close " +
                            sbfPath + ": " + ex.getMessage());
            }
        }


        // Now that we have the data line, write it out to the text
        // file

        long seekPos;
		String msg = "";
        try {
		    msg = "open";
            rafsdf = new RandomAccessFile(sdf, "rw");
			msg = "get length";
			seekPos = rafsdf.length();

            // Position to the end of file

			msg = "seek";
            rafsdf.seek(seekPos);

			// Write the data

            msg = "write";
            rafsdf.writeBytes(line);
            rafsdf.writeBytes("\n");
			msg = "close";
            rafsdf.close();

        }
        catch (Exception ex) {
		    ex.printStackTrace();
            throw new SQLException("Unable to " + msg + " " +
                    sdfPath + ": " + ex.getMessage());
        }
    }

    //------------------------------------------------------------------------
    // select
    // Select data from a table
    //
    // Grammar:
    //
    // select-statement ::= SELECT select-list FROM table-name
    //                            [WHERE search-condition]
    //
    // select-list ::= * | column-identifier [,column-identifier]...
    // search-condition ::= column-identifier comparison-operator literal
    // comparison-operator ::= < | > | = | <>
    //
    //------------------------------------------------------------------------

    protected void select(
        boolean prepareOnly)
        throws SQLException
    {

        // Initialize the filter object

        resultSetFilter = null;

        // The SQL statement must have at least 4 elements:
        //
        // SELECT * FROM table

        if (parsedSQL.length < 4) {
            throw new SQLException ("Invalid SELECT statement");
        }


        Hashtable selectList = new Hashtable();
        int pos = 1;

        // Build our select list.  Get each comma separated name until
        // we read a 'FROM'

        pos = buildList(parsedSQL, pos, "FROM", selectList);


        // There must be at least one column

        if (selectList.size() == 0) {
            throw new SQLException("Select list must be specified");
        }

        // Increment past the 'FROM' word. This is the table name

        pos++;

        if (pos >= parsedSQL.length) {
            throw new SQLException("Missing table name");
        }

        // The next word is the table name.  Verify that it does not
        // contain any invalid characters

        String tableName = parsedSQL[pos];
        validateName(tableName, "table");

        // Verify that the file exists.  If getColumns returns null,
        // the table does not exist

        Hashtable columnList = ownerConnection.getColumns(
                                ownerConnection.getCatalog(), tableName);

        if (columnList == null) {
            throw new SQLException("Table does not exist: " + tableName);
        }


        // No go back through the select list and verify that each
        // column specified is contained in the table.  Also expand
        // any * to be all columns

        Hashtable validList = new Hashtable();
        int validCount = 0;
        SimpleTextColumn column;
        SimpleTextColumn column2;

        for (int i = 1; i <= selectList.size(); i++) {

            // Get the next column from the select list

            column = (SimpleTextColumn) selectList.get(new Integer(i));

            // If it's an *, expand it to all columns in the table

            if (column.name.equals("*")) {
                for (int j = 1; j <= columnList.size(); j++) {
                    column2 = (SimpleTextColumn)columnList.get(new Integer(j));

                    validCount++;
                    validList.put(new Integer(validCount), column2);
                }
            }
            else {

                // Make sure the column exists in the table

                column2 = findColumn(columnList, column.name);

                if (column2 == null) {
                    throw new SQLException("Column not found: " + column.name);
                }

                // Put column on our valid list

                validCount++;
                validList.put(new Integer(validCount), column2);
            }
        }

        // Now we know the table exists and have a list of valid columns.
        // Process the WHERE clause if one exists

        pos++;

        if (pos < parsedSQL.length) {

            // The next word should be WHERE

            if (!parsedSQL[pos].equalsIgnoreCase ("WHERE")) {
                throw new SQLException("WHERE clause expected");
            }

            // Create a filter object

            resultSetFilter = new SimpleTextFilter();

            pos++;

            if (pos >= parsedSQL.length) {
                throw new SQLException(
                        "Column name expected after WHERE clause");
            }

            // The next word is a column name.  Make sure it exists in
            // the table

            resultSetFilter.column = findColumn(columnList, parsedSQL[pos]);

            if (resultSetFilter.column == null) {
                throw new SQLException("Column not found: " + parsedSQL[pos]);

            }

            // Make sure the column is searchable

            if (!resultSetFilter.column.searchable) {
                throw new SQLException(
                        "Column is not searchable: " + parsedSQL[pos]);
            }

            pos++;

            // The next word is the operator.  Some operators may take
            // 2 words (i.e <>)

            if (pos >= parsedSQL.length) {
                throw new SQLException("Operator expected in WHERE clause");
            }

            if (parsedSQL[pos].equals("=")) {
                resultSetFilter.operator = SimpleTextFilter.OP_EQ;
            }
            else if (parsedSQL[pos].equals("<")) {
                resultSetFilter.operator = SimpleTextFilter.OP_LT;
            }
            else if (parsedSQL[pos].equals(">")) {
                resultSetFilter.operator = SimpleTextFilter.OP_GT;
            }
            else {
                throw new SQLException("Invalid operator: " + parsedSQL[pos]);
            }

            // The next word may be our value, or it may be the second part
            // of an operator.

            pos++;

            if (pos >= parsedSQL.length) {
                throw new SQLException("Value expected in WHERE clause");
            }

            if ((resultSetFilter.operator == SimpleTextFilter.OP_LT) &&
                (parsedSQL[pos].equals(">"))) {
                resultSetFilter.operator = SimpleTextFilter.OP_NE;
                pos++;
                if (pos >= parsedSQL.length) {
                    throw new SQLException("Value expected in WHERE clause");
                }
            }

            // Get the data value and validate

            Hashtable whereList = new Hashtable();
            Hashtable dataList = new Hashtable();
            column = new SimpleTextColumn(parsedSQL[pos]);

            whereList.put(new Integer(1), resultSetFilter.column);
            dataList.put(new Integer(1), column);

            validateData(whereList, dataList, prepareOnly);

            String s = parsedSQL[pos];

            // validateData could have massaged the data value (such as
            // in executing a prepared statement with parameters).  Get
            // the value back

            s = ((SimpleTextColumn) dataList.get(new Integer(1))).name;

            // Strip off any quotes

            if (s.startsWith("'") &&
                s.endsWith("'")) {
                s = s.substring(1,s.length() - 1);
            }

            resultSetFilter.value = new CommonValue(s);

            pos++;

            // Check for extra junk at the end of the statement

            if (pos < parsedSQL.length) {
                throw new SQLException(
                        "Invalid characters following WHERE clause");
            }
        }

        // Set the catalog name, table name, and column Hashtable for
        // the result set

        resultSetCatalog = ownerConnection.getCatalog();
        resultSetTable = tableName;
        resultSetColumns = validList;
    }

    //------------------------------------------------------------------------
    // findColumn
    // Given a SimpleTextColumn Hashtable and a column name, return
    // the SimpleTextColumn that matches.  Null if no match.  The column
    // numbers are 1-based
    //------------------------------------------------------------------------

    protected SimpleTextColumn findColumn(
        Hashtable list,
        String name)
    {
        SimpleTextColumn column;

        for (int i = 1; i <= list.size(); i++) {
            column = (SimpleTextColumn) list.get(new Integer(i));
            if (column != null) {
                if (column.name.equalsIgnoreCase(name)) {
                    return column;
                }
            }
        }
        return null;
    }

    //------------------------------------------------------------------------
    // findColumnNumber
    // Given a SimpleTextColumn Hashtable and a column name, return
    // the column number that matches.  0 if no match.  The column
    // numbers are 1-based
    //------------------------------------------------------------------------

    protected int findColumnNumber(
        Hashtable list,
        String name)
    {
        SimpleTextColumn column;

        for (int i = 1; i <= list.size(); i++) {
            column = (SimpleTextColumn) list.get(new Integer(i));
            if (column != null) {
                if (column.name.equalsIgnoreCase(name)) {
                    return i;
                }
            }
        }
        return 0;
    }

    //------------------------------------------------------------------------
    // buildList
    // Given a parsed SQL statement, the current position, and the ending
    // word, build a list of the comma separated words from the SQL
    // statement.  This is used for the insert column list, insert values,
    // and select list.  Returns the new position in the parsed SQL
    //------------------------------------------------------------------------

    public int buildList(
        String sql[],
        int pos,
        String endWord,
        Hashtable list)
        throws SQLException
    {
        SimpleTextColumn column;
        boolean done = false;
        String name;
        int colNo = 1;

        // Loop while more data is present

        while (!done) {

            // Get the next column

            name = sql[pos];

            column = new SimpleTextColumn(name);
            list.put(new Integer(colNo), column);
            colNo++;

            pos++;
            if (pos >= sql.length) {
                if (endWord.length() > 0) {
                    throw new SQLException (
                        "Invalid statement after " + name);
                }
                else {
                    done = true;
                    break;
                }
            }

            // If the next word is not a comma, it must be our ending
            // word

            if (!sql[pos].equals(",")) {

                // Found the ending word?  exit the loop

                if (sql[pos].equalsIgnoreCase(endWord)) {
                    done = true;
                    break;
                }
                if (endWord.length() == 0) {
                    throw new SQLException("Invalid data format");
                }

                throw new SQLException (
                        "Invalid statement after " + name);
            }

            pos++;
            if (pos >= sql.length) {
                if (endWord.length() > 0) {
                    throw new SQLException (
                        "Invalid statement after " + name);
                }
                else {
                    done = true;
                    break;
                }
            }
        }
        return pos;
    }

    //------------------------------------------------------------------------
    // validateData
    // Given an insert list and a data list, verify the each data element
    // is proper for the given type and precision
    //------------------------------------------------------------------------

    protected void validateData(
        Hashtable insertList,
        Hashtable dataList,
        boolean prepareOnly)
        throws SQLException
    {
        SimpleTextColumn insert;
        SimpleTextColumn data;
        int precision = 0;
        int paramNum = 0;

        // Init number of parameters if we are preparing

        if (prepareOnly) {
            paramCount = 0;
        }

        for (int i = 1; i <= insertList.size(); i++) {
            insert = (SimpleTextColumn) insertList.get(new Integer(i));
            data = (SimpleTextColumn) dataList.get(new Integer(i));

            // If a parameter marker is found, either continue to the
            // next list item because we are preparing, or replace it
            // with a bound parameter value

            if (data.name.equals("?")) {

                if (prepareOnly) {

                    // Increment number of parameter markers

                    paramCount++;
                    continue;
                }

                // Increment current parameter number

                paramNum++;

                // Get String value for the bound parameter from the
                // boundParams Hashtable.  If it is not found, throw
                // an exception indicating that not all of the parameters
                // have been set.

                if (boundParams != null) {
                    String s = (String) boundParams.get(new Integer(paramNum));

                    if (s == null) {
                        throw new SQLException(
                                "Not all parameters have been set");
                    }

                    // Set the value into the SimpleTextColumn entry
                    // If the data is a string or binary type, enclose it
                    // in quotes

                    switch(insert.type) {
                    case Types.VARCHAR:
                    case Types.VARBINARY:
                        data.name = "'" + s + "'";
                        break;
                    default:
                        data.name = s;
                        break;
                    }

                }
            }

            switch(insert.type) {
            case Types.VARCHAR:
                if (!data.name.startsWith("'") ||
                    (data.name.length() < 2) ||
                    !data.name.endsWith("'")) {
                    throw new SQLException(
                        "String data must be enclosed in single quotes: " +
                                data.name);
                }
                precision = data.name.length() - 2;
                break;
            case Types.INTEGER:
                try {
                    Integer.valueOf(data.name);
                }
                catch (Exception ex) {
                    throw new SQLException("Invalid numeric data: " +
                                data.name);
                }
                precision = data.name.length();
                break;
            case Types.BINARY:
                if (!data.name.startsWith("'") ||
                    (data.name.length() < 2) ||
                    !data.name.endsWith("'")) {
                    throw new SQLException(
                        "Binary data must be enclosed in single quotes: " +
                                data.name);
                }
                if ((data.name.length() % 2) != 0) {
                    throw new SQLException(
                        "Binary data must have even number of hex digits:" +
                                data.name);
                }
                precision = (data.name.length() - 2) / 2;
                break;
            }

            if (precision > insert.precision) {
                throw new SQLException("Invalid data precision for " +
                            insert.name);
            }
        }
    }

    //------------------------------------------------------------------------
    // validateName
    // Verify that the given name does not contain any invalid characters.
    // This will be used for both table names and column names
    //------------------------------------------------------------------------

    protected void validateName(
        String name,
        String type)
        throws SQLException
    {
        // Invalid characters other than a-z, 0-9, and A-Z

        String invalid = "@#./\\()";

        char c;
        int j;

        for (int i = 0; i < name.length(); i++) {
            c = name.charAt(i);

            // If it's not an alpha numeric or numeric character,
            // check the list of invalid characters

            if (!((c >= 'a') && (c <= 'z')) &&
                !((c >= '0') && (c <= '9')) &&
                !((c >= 'A') && (c <= 'Z'))) {
                for (j = 0; j < invalid.length(); j++) {
                    if (c == invalid.charAt(j)) {
                        throw new SQLException("Invalid " + type + " name: " +
                                    name);
                    }
                }
            }
        }

    }

    //------------------------------------------------------------------------
    // getConnection
    // Returns the owner connection object
    //------------------------------------------------------------------------

    public SimpleTextIConnection getConnection()
    {
        return ownerConnection;
    }

    // Owning connection object

    protected SimpleTextIConnection ownerConnection;

    // SQLWarning chain

    protected SQLWarning lastWarning;

    // The current SQL statement

    protected String sqlStatement;

    // The String array of parsed SQL words

    protected String parsedSQL[];

    // The current SQL statement type (i.e. SQL_SELECT, SQL_CREATE, etc.)

    protected int statementType;

    // Update count for the last statement that executed

    protected int updateCount;

    // Attributes used for creating a result set

    String resultSetCatalog;
    String resultSetTable;
    Hashtable resultSetColumns;

    // If a filter exists for a select statement, a SimpleTextFilter object
    // will be created

    SimpleTextFilter resultSetFilter;

    // Our current result set

    ResultSet currentResultSet;

    // A Hashtable for each bound parameter.  Only valid for PreparedStatements

    Hashtable boundParams;

    // The count of parameter markers.  Only valid for PreparedStatements

    int paramCount;
}

//@@@@@@//
//Contrib/JDBCDriver-Moss/SimpleTextTable.java
//@@@@@@//
//----------------------------------------------------------------------------
//
// Module:      SimpleTextTable.java
//
// Description: Object that represents a single table
//
// Author:      Karl Moss
//
// Copyright:   (C) 1996,1997 Karl Moss.  All rights reserved.
//              You may study, use, modify and distribute this example
//              for any purpose, provided that this copyright notice
//              appears in all copies.  This example is provided WITHOUT
//              WARRANTY either expressed or implied.
//----------------------------------------------------------------------------

package jdbc.SimpleText;

public class SimpleTextTable
    extends        Object
{
    //------------------------------------------------------------------------
    // Constructor
    //------------------------------------------------------------------------

    public SimpleTextTable(
        String dir,
        String file)
    {
        this.dir = dir;
        this.file = file;

        // If the filename has the .SDF extension, get rid of it

        if (file.endsWith(SimpleTextDefine.DATA_FILE_EXT)) {
            name = file.substring(0, file.length() -
                        SimpleTextDefine.DATA_FILE_EXT.length());
        }
        else {
            name = file;
        }
    }

    public String dir;
    public String file;
    public String name;
}

//@@@@@@//
//Contrib/jotp/jotp.java
//@@@@@@//
/* applet to serve as an s/key calculator application wrapper 
 * around otp class.
 *
 * Copyright 1996, Harry Mantakos, harry@cs.umd.edu
 */

import java.awt.*;
import java.util.StringTokenizer;

public class jotp extends java.applet.Applet {
    TextField otptf, chaltf, pwtf;
    final String md4label = "compute with MD4";
    final String md5label = "compute with MD5";
    final String version = "jotp 0.8";

    /* Just takes challenge info and passphrase info on the 
     * command line (ick) and spits out the resulting otp "words".
     *
     * Mainly for testing.
     */
    public static void main(String[] argv) {
	String seed, passphrase;
	int seq;
	otp otpwd;
	int hashalg;
	String hashtype;

	if ((argv.length < 3) || (argv.length > 4)) {
	    System.err.println("usage: jotp sequence seed passphrase" + 
			       "[md4|md5]");
	    return;
	}
	seq = new Integer(argv[0]).intValue();
	seed = new String(argv[1]);
	passphrase = new String(argv[2]);
	if ((argv.length == 3) || argv[3].equals("4") ||
	    argv[3].equals("md4") || argv[3].equals("MD4")) {
	    hashtype = "md4";
	    hashalg = otp.MD4;
	} else if (argv[3].equals("5") || argv[3].equals("md5") ||
		   argv[3].equals("MD5")) {
	    hashtype = "md5";
	    hashalg = otp.MD5;
	} else {
	    System.err.println("usage: jotp sequence seed passphrase " +
			       "[4|md4|5|md5]");
	    return;
	}

	otpwd = new otp(seq, seed, passphrase, hashalg);
	System.out.println("Using " + hashtype + ". Thinking...");
	otpwd.calc();
	System.out.println(otpwd);
    }

    public void init() {

	setBackground(Color.white);
	setLayout(new GridLayout(6,1));

	Panel panel1 = new Panel();
	add (panel1);
	Font titlefont = new Font("TimesRoman", Font.BOLD, 14);
	panel1.setFont(titlefont);
	panel1.add(new Label(String.valueOf(version) + 
			     ": The Java OTP (aka S/Key) calculator!"));
	Panel panel2 = new Panel();
	panel2.setLayout(new FlowLayout());
	add (panel2);
	panel2.add(new Label("Challenge (e.g. \"55 latour1\"):"));
        chaltf = new TextField(24);
	panel2.add(chaltf);

	Panel panel3 = new Panel();
	panel3.setLayout(new FlowLayout());
	add(panel3);
	panel3.add(new Label("Secret Password:"));
	pwtf = new TextField(24);
	pwtf.setEchoCharacter('*');
	panel3.add(pwtf);

	Panel panel4 = new Panel();
	panel4.setLayout(new FlowLayout());
	add(panel4);

	panel4.add (new Button(String.valueOf(md4label)));
	panel4.add (new Button(String.valueOf(md5label)));

	Panel panel6 = new Panel();
	panel6.setLayout(new FlowLayout());
	add(panel6);
	panel6.add(new Label("One-Time Password:", Label.LEFT));
	otptf = new TextField(40);
	panel6.add(otptf);

	Panel panel7 = new Panel();
	add(panel7);
	panel7.add(new Label("jotp by Harry Mantakos, " + 
			     "http://www.cs.umd.edu/~harry/jotp"));
    }
    public boolean action(Event evt, Object arg) {
	String tmpstr, tmpstr2, seed, passphrase;
	int seq, hashalg;
	otp otpwd;

	if (evt.target instanceof Button) {
	    if (arg.equals(md5label)) {
		hashalg = otp.MD5;
	    } else {
		hashalg = otp.MD4;
	    }

	    /* Split up challenge */
	    tmpstr = chaltf.getText();
	    StringTokenizer st = new StringTokenizer(tmpstr);
	    if (st.countTokens() != 2) {
		otptf.setText("bogus challenge");
		return true;
	    }
	    tmpstr2 = st.nextToken();
	    try {
		seq = (Integer.parseInt(tmpstr2));
	    } catch (NumberFormatException e) {
		otptf.setText("bogus sequence number '" + tmpstr2 + "'");
		return true;
	    }
	    seed = st.nextToken();
	    passphrase = pwtf.getText();
/*	    passphrase = "eat me";*/
            System.out.println("passphrase = " + passphrase);
	    otptf.setText("Okay, thinking...");
	    otpwd = new otp(seq, seed, passphrase, hashalg);
	    otpwd.calc();
	    otptf.setText(otpwd.toString());
	}
	return true;
    }
}
//@@@@@@//
//Contrib/jotp/md.java
//@@@@@@//

/* Class for implementing md4 hash algorithm (and hopefully md5 eventually).
 * There are constructors for prepping the hash algorithm (doing the
 * padding, mainly) for a String or a byte[], and an mdcalc() method 
 * for generating the hash. The results can be accessed as an int array 
 * by getregs(), or as a String of hex digits with toString().
 *
 * Copyright 1996 Harry Mantakos, harry@cs.umd.edu
 */

class md4 extends md {
    md4(String s) {
	super(s);
    }
    md4(byte in[]) {
	super(in);
    }
    static int F(int x, int y, int z) {
	return((x & y) | (~x & z));
    }
    static int G(int x, int y, int z) {
	return((x & y) | (x & z) | (y & z));
    }
    static int H(int x, int y, int z) {
	return(x ^ y ^ z);
    }
    void round1(int blk) {
	A = rotintlft((A + F(B, C, D) + d[0 + 16 * blk]), 3);
	D = rotintlft((D + F(A, B, C) + d[1 + 16 * blk]), 7);
	C = rotintlft((C + F(D, A, B) + d[2 + 16 * blk]), 11);
	B = rotintlft((B + F(C, D, A) + d[3 + 16 * blk]), 19);

	A = rotintlft((A + F(B, C, D) + d[4 + 16 * blk]), 3);
	D = rotintlft((D + F(A, B, C) + d[5 + 16 * blk]), 7);
	C = rotintlft((C + F(D, A, B) + d[6 + 16 * blk]), 11);
	B = rotintlft((B + F(C, D, A) + d[7 + 16 * blk]), 19);

	A = rotintlft((A + F(B, C, D) + d[8 + 16 * blk]), 3);
	D = rotintlft((D + F(A, B, C) + d[9 + 16 * blk]), 7);
	C = rotintlft((C + F(D, A, B) + d[10 + 16 * blk]), 11);
	B = rotintlft((B + F(C, D, A) + d[11 + 16 * blk]), 19);

	A = rotintlft((A + F(B, C, D) + d[12 + 16 * blk]), 3);
	D = rotintlft((D + F(A, B, C) + d[13 + 16 * blk]), 7);
	C = rotintlft((C + F(D, A, B) + d[14 + 16 * blk]), 11);
	B = rotintlft((B + F(C, D, A) + d[15 + 16 * blk]), 19);
    }
    void round2(int blk) {
	A = rotintlft((A + G(B, C, D) + d[0 + 16 * blk] + 0x5a827999), 3);
	D = rotintlft((D + G(A, B, C) + d[4 + 16 * blk] + 0x5a827999), 5);
	C = rotintlft((C + G(D, A, B) + d[8 + 16 * blk] + 0x5a827999), 9);
	B = rotintlft((B + G(C, D, A) + d[12 + 16 * blk] + 0x5a827999), 13);

	A = rotintlft((A + G(B, C, D) + d[1 + 16 * blk] + 0x5a827999), 3);
	D = rotintlft((D + G(A, B, C) + d[5 + 16 * blk] + 0x5a827999), 5);
	C = rotintlft((C + G(D, A, B) + d[9 + 16 * blk] + 0x5a827999), 9);
	B = rotintlft((B + G(C, D, A) + d[13 + 16 * blk] + 0x5a827999), 13);

	A = rotintlft((A + G(B, C, D) + d[2 + 16 * blk] + 0x5a827999), 3);
	D = rotintlft((D + G(A, B, C) + d[6 + 16 * blk] + 0x5a827999), 5);
	C = rotintlft((C + G(D, A, B) + d[10 + 16 * blk] + 0x5a827999), 9);
	B = rotintlft((B + G(C, D, A) + d[14 + 16 * blk] + 0x5a827999), 13);

	A = rotintlft((A + G(B, C, D) + d[3 + 16 * blk] + 0x5a827999), 3);
	D = rotintlft((D + G(A, B, C) + d[7 + 16 * blk] + 0x5a827999), 5);
	C = rotintlft((C + G(D, A, B) + d[11 + 16 * blk] + 0x5a827999), 9);
	B = rotintlft((B + G(C, D, A) + d[15 + 16 * blk] + 0x5a827999), 13);

    }
    void round3(int blk) {
	A = rotintlft((A + H(B, C, D) + d[0 + 16 * blk] + 0x6ed9eba1), 3);
	D = rotintlft((D + H(A, B, C) + d[8 + 16 * blk] + 0x6ed9eba1), 9);
	C = rotintlft((C + H(D, A, B) + d[4 + 16 * blk] + 0x6ed9eba1), 11);
	B = rotintlft((B + H(C, D, A) + d[12 + 16 * blk] + 0x6ed9eba1), 15);

	A = rotintlft((A + H(B, C, D) + d[2 + 16 * blk] + 0x6ed9eba1), 3);
	D = rotintlft((D + H(A, B, C) + d[10 + 16 * blk] + 0x6ed9eba1), 9);
	C = rotintlft((C + H(D, A, B) + d[6 + 16 * blk] + 0x6ed9eba1), 11);
	B = rotintlft((B + H(C, D, A) + d[14 + 16 * blk] + 0x6ed9eba1), 15);

	A = rotintlft((A + H(B, C, D) + d[1 + 16 * blk] + 0x6ed9eba1), 3);
	D = rotintlft((D + H(A, B, C) + d[9 + 16 * blk] + 0x6ed9eba1), 9);
	C = rotintlft((C + H(D, A, B) + d[5 + 16 * blk] + 0x6ed9eba1), 11);
	B = rotintlft((B + H(C, D, A) + d[13 + 16 * blk] + 0x6ed9eba1), 15);

	A = rotintlft((A + H(B, C, D) + d[3 + 16 * blk] + 0x6ed9eba1), 3);
	D = rotintlft((D + H(A, B, C) + d[11 + 16 * blk] + 0x6ed9eba1), 9);
	C = rotintlft((C + H(D, A, B) + d[7 + 16 * blk] + 0x6ed9eba1), 11);
	B = rotintlft((B + H(C, D, A) + d[15 + 16 * blk] + 0x6ed9eba1), 15);

    }
    void round4(int blk) {
	System.out.println(" must be md5, in round4!");
    }
}

class md5 extends md {
    md5(String s) {
	super(s);
    }
    md5(byte in[]) {
	super(in);
    }
    static int F(int x, int y, int z) {
	return((x & y) | (~x & z));
    }
    static int G(int x, int y, int z) {
	return((x & z) | (y & ~z));
    }
    static int H(int x, int y, int z) {
	return(x ^ y ^ z);
    }
    static int I(int x, int y, int z) {
	return(y ^ (x | ~z));
    }
    void round1(int blk) {
	A = rotintlft(A + F(B, C, D) + d[0 + 16 * blk] +
		      0xd76aa478, 7) + B;
	D = rotintlft(D + F(A, B, C) + d[1 + 16 * blk] +
		      0xe8c7b756, 12) + A;
	C = rotintlft(C + F(D, A, B) + d[2 + 16 * blk] +
		      0x242070db, 17) + D;
	B = rotintlft(B + F(C, D, A) + d[3 + 16 * blk] +
		      0xc1bdceee, 22) + C;

	A = rotintlft(A + F(B, C, D) + d[4 + 16 * blk] +
		      0xf57c0faf, 7) + B;
	D = rotintlft(D + F(A, B, C) + d[5 + 16 * blk] +
		      0x4787c62a, 12) + A;
	C = rotintlft(C + F(D, A, B) + d[6 + 16 * blk] +
		      0xa8304613, 17) + D;
	B = rotintlft(B + F(C, D, A) + d[7 + 16 * blk] +
		      0xfd469501, 22) + C;
	A = rotintlft(A + F(B, C, D) + d[8 + 16 * blk] +
		      0x698098d8, 7) + B;
	D = rotintlft(D + F(A, B, C) + d[9 + 16 * blk] +
		      0x8b44f7af, 12) + A;
	C = rotintlft(C + F(D, A, B) + d[10 + 16 * blk] +
		      0xffff5bb1, 17) + D;
	B = rotintlft(B + F(C, D, A) + d[11 + 16 * blk] +
		      0x895cd7be, 22) + C;
	A = rotintlft(A + F(B, C, D) + d[12 + 16 * blk] +
		      0x6b901122, 7) + B;
	D = rotintlft(D + F(A, B, C) + d[13 + 16 * blk] +
		      0xfd987193, 12) + A;
	C = rotintlft(C + F(D, A, B) + d[14 + 16 * blk] +
		      0xa679438e, 17) + D;
	B = rotintlft(B + F(C, D, A) + d[15 + 16 * blk] +
		      0x49b40821, 22) + C;
    }
    void round2(int blk) {
	A = rotintlft(A + G(B, C, D) + d[1 + 16 * blk] +
		      0xf61e2562, 5) + B;
	D = rotintlft(D + G(A, B, C) + d[6 + 16 * blk] +
		      0xc040b340, 9) + A;
	C = rotintlft(C + G(D, A, B) + d[11 + 16 * blk] +
		      0x265e5a51, 14) + D;
	B = rotintlft(B + G(C, D, A) + d[0 + 16 * blk] +
		      0xe9b6c7aa, 20) + C;
	A = rotintlft(A + G(B, C, D) + d[5 + 16 * blk] +
		      0xd62f105d, 5) + B;
	D = rotintlft(D + G(A, B, C) + d[10 + 16 * blk] +
		      0x02441453, 9) + A;
	C = rotintlft(C + G(D, A, B) + d[15 + 16 * blk] + 
		      0xd8a1e681, 14) + D;
	B = rotintlft(B + G(C, D, A) + d[4 + 16 * blk] +
		      0xe7d3fbc8, 20) + C;
	A = rotintlft(A + G(B, C, D) + d[9 + 16 * blk] +
		      0x21e1cde6, 5) + B;
	D = rotintlft(D + G(A, B, C) + d[14 + 16 * blk] +
		      0xc33707d6, 9) + A;
	C = rotintlft(C + G(D, A, B) + d[3 + 16 * blk] +
		      0xf4d50d87, 14) + D;
	B = rotintlft(B + G(C, D, A) + d[8 + 16 * blk] +
		      0x455a14ed, 20) + C;
	A = rotintlft(A + G(B, C, D) + d[13 + 16 * blk] +
		      0xa9e3e905, 5) + B;
	D = rotintlft(D + G(A, B, C) + d[2 + 16 * blk] +
		      0xfcefa3f8, 9) + A;
	C = rotintlft(C + G(D, A, B) + d[7 + 16 * blk] +
		      0x676f02d9, 14) + D;
	B = rotintlft(B + G(C, D, A) + d[12 + 16 * blk] +
		      0x8d2a4c8a, 20) + C;
    }
    void round3(int blk) {
	A = rotintlft(A + H(B, C, D) + d[5 + 16 * blk] +
		      0xfffa3942, 4) + B;
	D = rotintlft(D + H(A, B, C) + d[8 + 16 * blk] +
		      0x8771f681, 11) + A;
	C = rotintlft(C + H(D, A, B) + d[11 + 16 * blk] +
		      0x6d9d6122, 16) + D;
	B = rotintlft(B + H(C, D, A) + d[14 + 16 * blk] +
		      0xfde5380c, 23) + C;
	A = rotintlft(A + H(B, C, D) + d[1 + 16 * blk] +
		      0xa4beea44, 4) + B;
	D = rotintlft(D + H(A, B, C) + d[4 + 16 * blk] +
		      0x4bdecfa9, 11) + A;
	C = rotintlft(C + H(D, A, B) + d[7 + 16 * blk] +
		      0xf6bb4b60, 16) + D;
	B = rotintlft(B + H(C, D, A) + d[10 + 16 * blk] +
		      0xbebfbc70, 23) + C;
	A = rotintlft(A + H(B, C, D) + d[13 + 16 * blk] +
		      0x289b7ec6, 4) + B;
	D = rotintlft(D + H(A, B, C) + d[0 + 16 * blk] +
		      0xeaa127fa, 11) + A;
	C = rotintlft(C + H(D, A, B) + d[3 + 16 * blk] +
		      0xd4ef3085, 16) + D;
	B = rotintlft(B + H(C, D, A) + d[6 + 16 * blk] +
		      0x04881d05, 23) + C;
	A = rotintlft(A + H(B, C, D) + d[9 + 16 * blk] +
		      0xd9d4d039, 4) + B;
	D = rotintlft(D + H(A, B, C) + d[12 + 16 * blk] +
		      0xe6db99e5, 11) + A;
	C = rotintlft(C + H(D, A, B) + d[15 + 16 * blk] +
		      0x1fa27cf8, 16) + D;
	B = rotintlft(B + H(C, D, A) + d[2 + 16 * blk] +
		      0xc4ac5665, 23) + C;
    }
    void round4(int blk) {
	A = rotintlft(A + I(B, C, D) + d[0 + 16 * blk] +
		      0xf4292244, 6) + B;
	D = rotintlft(D + I(A, B, C) + d[7 + 16 * blk] +
		      0x432aff97, 10) + A;
	C = rotintlft(C + I(D, A, B) + d[14 + 16 * blk] +
		      0xab9423a7, 15) + D;
	B = rotintlft(B + I(C, D, A) + d[5 + 16 * blk] +
		      0xfc93a039, 21) + C;
	A = rotintlft(A + I(B, C, D) + d[12 + 16 * blk] +
		      0x655b59c3, 6) + B;
	D = rotintlft(D + I(A, B, C) + d[3 + 16 * blk] +
		      0x8f0ccc92, 10) + A;
	C = rotintlft(C + I(D, A, B) + d[10 + 16 * blk] +
		      0xffeff47d, 15) + D;
	B = rotintlft(B + I(C, D, A) + d[1 + 16 * blk] +
		      0x85845dd1, 21) + C;
	A = rotintlft(A + I(B, C, D) + d[8 + 16 * blk] +
		      0x6fa87e4f, 6) + B;
	D = rotintlft(D + I(A, B, C) + d[15 + 16 * blk] +
		      0xfe2ce6e0, 10) + A;
	C = rotintlft(C + I(D, A, B) + d[6 + 16 * blk] +
		      0xa3014314, 15) + D;
	B = rotintlft(B + I(C, D, A) + d[13 + 16 * blk] +
		      0x4e0811a1, 21) + C;
	A = rotintlft(A + I(B, C, D) + d[4 + 16 * blk] +
		      0xf7537e82, 6) + B;
	D = rotintlft(D + I(A, B, C) + d[11 + 16 * blk] +
		      0xbd3af235, 10) + A;
	C = rotintlft(C + I(D, A, B) + d[2 + 16 * blk] +
		      0x2ad7d2bb, 15) + D;
	B = rotintlft(B + I(C, D, A) + d[9 + 16 * blk] +
		      0xeb86d391, 21) + C;
    }
}

class md {
    int A,B,C,D;
    int d[];
    int numwords;

    /* For verification of a modicum of sanity, run a few 
     * test strings through
     */
    public static void main(String[] argv) {
	boolean doinmd4;
	String mdtype;
	/* Test cases, mostly taken from rfc 1320 */
	String str[] = { "" , "a", "abc", "message digest", 
			 "abcdefghijklmnopqrstuvwxyz", 
	   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", 
 "12345678901234567890123456789012345678901234567890123456789012345678901234567890",
	 "01234567890123456789012345678901234567890123456789012345"};

	if (argv.length == 0) {
	    mdtype = "md4";
	    doinmd4 = true;
	} else if (argv.length > 1) {
	    System.err.println("Usage: md [4|5|md4|md5]");
	    return;
	} else	if ((argv[0].equals("4")) || (argv[0].equals("md4"))) {
	    mdtype = "md4";
	    doinmd4 = true;
	} else if ((argv[0].equals("5")) || (argv[0].equals("md5"))) {
	    mdtype = "md5";
	    doinmd4 = false;
	} else {
	    System.err.println("Usage: md [4|5|md4|md5]");
	    return;
	}
	for(int i = 0; i < str.length; i++) {
	    if (doinmd4) {
		md4 mdc = new md4(str[i]);
		mdc.calc();
		System.out.println(mdtype + "(\"" + str[i] + "\") = " + mdc);
	    } else {
		md5 mdc = new md5(str[i]);
		mdc.calc();
		System.out.println(mdtype + "(\"" + str[i] + "\") = " + mdc);
	    }
	}
    }
    md (String s) {
	byte in[] = new byte[s.length()];
	int i;

	for(i=0; i < s.length(); i++) {
	    in[i] = (byte) (s.charAt(i) & 0xff);
	}
	mdinit(in);
    }
    md (byte in[]) {
	mdinit(in);
    }

    void mdinit (byte in[]) {
	int newlen, endblklen, pad, i;
	long datalenbits;

	datalenbits = in.length  * 8;
	endblklen = in.length % 64;
	if (endblklen < 56) {
	    pad = 64 - endblklen;
	} else {
	    pad = (64 - endblklen) + 64;
	}
	newlen = in.length + pad;
	byte b[] = new byte[newlen];
	for(i=0; i < in.length; i++) {
	    b[i] = in[i];
	}
	b[in.length] = (byte) 0x80;
	for (i = b.length + 1; i < (newlen - 8); i++) {
	    b[i] = 0;
	}
	for (i = 0; i < 8; i++) {
	    b[newlen - 8 + i] = (byte) (datalenbits & 0xff);
	    datalenbits >>= 8;
	}
	/* init registers */
	A = 0x67452301;
	B = 0xefcdab89;
	C = 0x98badcfe;
	D = 0x10325476;
	this.numwords = newlen/4;
	this.d = new int[this.numwords];
	for (i = 0; i < newlen; i += 4) {
	    this.d[i/4] = (b[i] & 0xff) + ((b[i+1] & 0xff) << 8) + 
		((b[i+2] & 0xff) << 16) + ((b[i+3] & 0xff) << 24);
	}
   }
	
    public String toString() {
	String s;

	return(tohex(A) + tohex(B) + tohex(C) + tohex(D));
    }
    int[] getregs() {
	int regs[] = {this.A, this.B, this.C, this.D};

	return regs;
    }
    void calc() {
	int AA, BB, CC, DD, i;

	for(i=0; i < numwords/16; i++) {
	    AA = A; BB = B; CC = C; DD = D;
	    round1(i);
	    round2(i);
	    round3(i);
            if (this instanceof md5) {
		round4(i);
	    }
	    A += AA; B+= BB; C+= CC; D+= DD;
	}
    }
    /* Dummy round*() methods. these are overriden in the md4 and md5 
     * subclasses 
     */
    void round1(int blk) {
	System.err.println("Danger! Danger! Someone called md.round1()!");
    }
    void round2(int blk) {
	System.err.println("Danger! Danger! Someone called md.round2()!");
    }
    void round3(int blk) {
	System.err.println("Danger! Danger! Someone called md.round3()!");
    }
    void round4(int blk) {
	System.err.println("Danger! Danger! Someone called md.round4()!");
    }
    static int rotintlft(int val, int numbits) {
	return((val << numbits) | (val >>> (32 - numbits)));
    }
    static String tohex(int i) {
	int b;
	String tmpstr;

	tmpstr = "";
	for(b = 0; b < 4; b++) {
	    tmpstr += Integer.toString((i >> 4) & 0xf, 16) 
		+ Integer.toString(i & 0xf, 16);
	    i >>= 8;
	}
	return tmpstr;
    }

}
//@@@@@@//
//Contrib/jotp/otp.java
//@@@@@@//
/* Class for implementing OTP (aka s/key) one-time password calculation
 * using the accompanying md class for md4 (and hopefully md5 eventually) 
 * based key calculation.
 *
 * The constructor is used to set the challenge info and passphrase,
 * and the calc() method calculates the otp. The results can either
 * be retrieved using the tolong() method, which gives you the 64 bits
 * "folded" hash in a single word, or else as a String of otp "words"
 * via toString().
 *
 * Cripes this is slow. How can we make it faster? 
 *
 * Copyright 1996 Harry Mantakos, harry@cs.umd.edu
 */

class otp {
    int seq;
    String seed, passphrase;
    byte hash[];
    int sha;
    final static byte MD4 = 4;
    final static byte MD5 = 5;

    otp(int n, String s, String p, int hashalg) {
	this.seq = n;
	this.seed = s;
	this.passphrase = p;
	this.sha = hashalg;
    }
    void calc() {
	if (this.sha == MD5) {
	    this.md5calc();
	} else {
	    this.md4calc();
        }
    }
    void md4calc() {
	int tmpseq = this.seq;
	md4 mdc;

	mdc = new md4(this.seed + this.passphrase);
	mdc.calc();
	this.hash = otpfoldregs(mdc.getregs());
	while (tmpseq > 0) {
	    mdc = new md4(hash);
	    mdc.calc();
	    this.hash = otpfoldregs(mdc.getregs());
	    tmpseq--;
	}
    }
    void md5calc() {
	int tmpseq = this.seq;
	md5 mdc;

	mdc = new md5(this.seed + this.passphrase);
	mdc.calc();
	this.hash = otpfoldregs(mdc.getregs());
	while (tmpseq > 0) {
	    mdc = new md5(hash);
	    mdc.calc();
	    this.hash = otpfoldregs(mdc.getregs());
	    tmpseq--;
	}
    }

    static byte[] otpfoldregs(int regs[]) {
	int ac, bd, i;
	byte fold[] = new byte[8];

	ac = regs[0] ^ regs[2];
	bd = regs[1] ^ regs[3];
	for (i=0; i < 4; i++) {
	    fold[i] = (byte) (ac & 0xff);
	    ac >>= 8;
	}
	for (i=4; i < 8; i++) {
	    fold[i] = (byte) (bd & 0xff);
	    bd >>= 8;
	}
	return fold;
    }

    long tolong() {
	long wi;
	int i;

	wi = 0;
	for (i=0; i < 8; i++) {
	    wi <<= 8;
	    wi |= (this.hash[i] & 0xff);
	}
	return wi;
    }
    public String toString() {
	long wi, tmplong;
	String tmpstr;
	int i, j;
	byte parity;

	wi = this.tolong();
	tmplong = wi;
	tmpstr = "";
	parity = 0;
	for (i = 0; i < 64; i+=2) {
	    parity += tmplong & 0x3;
	    tmplong >>= 2;
	}
	for (i=4; i >= 0; i--) {
	    tmpstr += btoe((int) 
		      ((wi >> (i * 11 + 9)) & 0x7ff)) + " ";
	}
	tmpstr += btoe((int) ((wi << 2) & 0x7fc) | (parity & 0x03));
	return tmpstr;
    }

    public static String btoe(int index) {
        if (index < words.length) {
    	    return words[index];
        } else {
           return "bogus";
        }
    }

static String words[] =
{        "A",     "ABE",   "ACE",   "ACT",   "AD",    "ADA",   "ADD",
"AGO",   "AID",   "AIM",   "AIR",   "ALL",   "ALP",   "AM",    "AMY",
"AN",    "ANA",   "AND",   "ANN",   "ANT",   "ANY",   "APE",   "APS",
"APT",   "ARC",   "ARE",   "ARK",   "ARM",   "ART",   "AS",    "ASH",
"ASK",   "AT",    "ATE",   "AUG",   "AUK",   "AVE",   "AWE",   "AWK",
"AWL",   "AWN",   "AX",    "AYE",   "BAD",   "BAG",   "BAH",   "BAM",
"BAN",   "BAR",   "BAT",   "BAY",   "BE",    "BED",   "BEE",   "BEG",
"BEN",   "BET",   "BEY",   "BIB",   "BID",   "BIG",   "BIN",   "BIT",
"BOB",   "BOG",   "BON",   "BOO",   "BOP",   "BOW",   "BOY",   "BUB",
"BUD",   "BUG",   "BUM",   "BUN",   "BUS",   "BUT",   "BUY",   "BY",
"BYE",   "CAB",   "CAL",   "CAM",   "CAN",   "CAP",   "CAR",   "CAT",
"CAW",   "COD",   "COG",   "COL",   "CON",   "COO",   "COP",   "COT",
"COW",   "COY",   "CRY",   "CUB",   "CUE",   "CUP",   "CUR",   "CUT",
"DAB",   "DAD",   "DAM",   "DAN",   "DAR",   "DAY",   "DEE",   "DEL",
"DEN",   "DES",   "DEW",   "DID",   "DIE",   "DIG",   "DIN",   "DIP",
"DO",    "DOE",   "DOG",   "DON",   "DOT",   "DOW",   "DRY",   "DUB",
"DUD",   "DUE",   "DUG",   "DUN",   "EAR",   "EAT",   "ED",    "EEL",
"EGG",   "EGO",   "ELI",   "ELK",   "ELM",   "ELY",   "EM",    "END",
"EST",   "ETC",   "EVA",   "EVE",   "EWE",   "EYE",   "FAD",   "FAN",
"FAR",   "FAT",   "FAY",   "FED",   "FEE",   "FEW",   "FIB",   "FIG",
"FIN",   "FIR",   "FIT",   "FLO",   "FLY",   "FOE",   "FOG",   "FOR",
"FRY",   "FUM",   "FUN",   "FUR",   "GAB",   "GAD",   "GAG",   "GAL",
"GAM",   "GAP",   "GAS",   "GAY",   "GEE",   "GEL",   "GEM",   "GET",
"GIG",   "GIL",   "GIN",   "GO",    "GOT",   "GUM",   "GUN",   "GUS",
"GUT",   "GUY",   "GYM",   "GYP",   "HA",    "HAD",   "HAL",   "HAM",
"HAN",   "HAP",   "HAS",   "HAT",   "HAW",   "HAY",   "HE",    "HEM",
"HEN",   "HER",   "HEW",   "HEY",   "HI",    "HID",   "HIM",   "HIP",
"HIS",   "HIT",   "HO",    "HOB",   "HOC",   "HOE",   "HOG",   "HOP",
"HOT",   "HOW",   "HUB",   "HUE",   "HUG",   "HUH",   "HUM",   "HUT",
"I",     "ICY",   "IDA",   "IF",    "IKE",   "ILL",   "INK",   "INN",
"IO",    "ION",   "IQ",    "IRA",   "IRE",   "IRK",   "IS",    "IT",
"ITS",   "IVY",   "JAB",   "JAG",   "JAM",   "JAN",   "JAR",   "JAW",
"JAY",   "JET",   "JIG",   "JIM",   "JO",    "JOB",   "JOE",   "JOG",
"JOT",   "JOY",   "JUG",   "JUT",   "KAY",   "KEG",   "KEN",   "KEY",
"KID",   "KIM",   "KIN",   "KIT",   "LA",    "LAB",   "LAC",   "LAD",
"LAG",   "LAM",   "LAP",   "LAW",   "LAY",   "LEA",   "LED",   "LEE",
"LEG",   "LEN",   "LEO",   "LET",   "LEW",   "LID",   "LIE",   "LIN",
"LIP",   "LIT",   "LO",    "LOB",   "LOG",   "LOP",   "LOS",   "LOT",
"LOU",   "LOW",   "LOY",   "LUG",   "LYE",   "MA",    "MAC",   "MAD",
"MAE",   "MAN",   "MAO",   "MAP",   "MAT",   "MAW",   "MAY",   "ME",
"MEG",   "MEL",   "MEN",   "MET",   "MEW",   "MID",   "MIN",   "MIT",
"MOB",   "MOD",   "MOE",   "MOO",   "MOP",   "MOS",   "MOT",   "MOW",
"MUD",   "MUG",   "MUM",   "MY",    "NAB",   "NAG",   "NAN",   "NAP",
"NAT",   "NAY",   "NE",    "NED",   "NEE",   "NET",   "NEW",   "NIB",
"NIL",   "NIP",   "NIT",   "NO",    "NOB",   "NOD",   "NON",   "NOR",
"NOT",   "NOV",   "NOW",   "NU",    "NUN",   "NUT",   "O",     "OAF",
"OAK",   "OAR",   "OAT",   "ODD",   "ODE",   "OF",    "OFF",   "OFT",
"OH",    "OIL",   "OK",    "OLD",   "ON",    "ONE",   "OR",    "ORB",
"ORE",   "ORR",   "OS",    "OTT",   "OUR",   "OUT",   "OVA",   "OW",
"OWE",   "OWL",   "OWN",   "OX",    "PA",    "PAD",   "PAL",   "PAM",
"PAN",   "PAP",   "PAR",   "PAT",   "PAW",   "PAY",   "PEA",   "PEG",
"PEN",   "PEP",   "PER",   "PET",   "PEW",   "PHI",   "PI",    "PIE",
"PIN",   "PIT",   "PLY",   "PO",    "POD",   "POE",   "POP",   "POT",
"POW",   "PRO",   "PRY",   "PUB",   "PUG",   "PUN",   "PUP",   "PUT",
"QUO",   "RAG",   "RAM",   "RAN",   "RAP",   "RAT",   "RAW",   "RAY",
"REB",   "RED",   "REP",   "RET",   "RIB",   "RID",   "RIG",   "RIM",
"RIO",   "RIP",   "ROB",   "ROD",   "ROE",   "RON",   "ROT",   "ROW",
"ROY",   "RUB",   "RUE",   "RUG",   "RUM",   "RUN",   "RYE",   "SAC",
"SAD",   "SAG",   "SAL",   "SAM",   "SAN",   "SAP",   "SAT",   "SAW",
"SAY",   "SEA",   "SEC",   "SEE",   "SEN",   "SET",   "SEW",   "SHE",
"SHY",   "SIN",   "SIP",   "SIR",   "SIS",   "SIT",   "SKI",   "SKY",
"SLY",   "SO",    "SOB",   "SOD",   "SON",   "SOP",   "SOW",   "SOY",
"SPA",   "SPY",   "SUB",   "SUD",   "SUE",   "SUM",   "SUN",   "SUP",
"TAB",   "TAD",   "TAG",   "TAN",   "TAP",   "TAR",   "TEA",   "TED",
"TEE",   "TEN",   "THE",   "THY",   "TIC",   "TIE",   "TIM",   "TIN",
"TIP",   "TO",    "TOE",   "TOG",   "TOM",   "TON",   "TOO",   "TOP",
"TOW",   "TOY",   "TRY",   "TUB",   "TUG",   "TUM",   "TUN",   "TWO",
"UN",    "UP",    "US",    "USE",   "VAN",   "VAT",   "VET",   "VIE",
"WAD",   "WAG",   "WAR",   "WAS",   "WAY",   "WE",    "WEB",   "WED",
"WEE",   "WET",   "WHO",   "WHY",   "WIN",   "WIT",   "WOK",   "WON",
"WOO",   "WOW",   "WRY",   "WU",    "YAM",   "YAP",   "YAW",   "YE",
"YEA",   "YES",   "YET",   "YOU",   "ABED",  "ABEL",  "ABET",  "ABLE",
"ABUT",  "ACHE",  "ACID",  "ACME",  "ACRE",  "ACTA",  "ACTS",  "ADAM",
"ADDS",  "ADEN",  "AFAR",  "AFRO",  "AGEE",  "AHEM",  "AHOY",  "AIDA",
"AIDE",  "AIDS",  "AIRY",  "AJAR",  "AKIN",  "ALAN",  "ALEC",  "ALGA",
"ALIA",  "ALLY",  "ALMA",  "ALOE",  "ALSO",  "ALTO",  "ALUM",  "ALVA",
"AMEN",  "AMES",  "AMID",  "AMMO",  "AMOK",  "AMOS",  "AMRA",  "ANDY",
"ANEW",  "ANNA",  "ANNE",  "ANTE",  "ANTI",  "AQUA",  "ARAB",  "ARCH",
"AREA",  "ARGO",  "ARID",  "ARMY",  "ARTS",  "ARTY",  "ASIA",  "ASKS",
"ATOM",  "AUNT",  "AURA",  "AUTO",  "AVER",  "AVID",  "AVIS",  "AVON",
"AVOW",  "AWAY",  "AWRY",  "BABE",  "BABY",  "BACH",  "BACK",  "BADE",
"BAIL",  "BAIT",  "BAKE",  "BALD",  "BALE",  "BALI",  "BALK",  "BALL",
"BALM",  "BAND",  "BANE",  "BANG",  "BANK",  "BARB",  "BARD",  "BARE",
"BARK",  "BARN",  "BARR",  "BASE",  "BASH",  "BASK",  "BASS",  "BATE",
"BATH",  "BAWD",  "BAWL",  "BEAD",  "BEAK",  "BEAM",  "BEAN",  "BEAR",
"BEAT",  "BEAU",  "BECK",  "BEEF",  "BEEN",  "BEER",  "BEET",  "BELA",
"BELL",  "BELT",  "BEND",  "BENT",  "BERG",  "BERN",  "BERT",  "BESS",
"BEST",  "BETA",  "BETH",  "BHOY",  "BIAS",  "BIDE",  "BIEN",  "BILE",
"BILK",  "BILL",  "BIND",  "BING",  "BIRD",  "BITE",  "BITS",  "BLAB",
"BLAT",  "BLED",  "BLEW",  "BLOB",  "BLOC",  "BLOT",  "BLOW",  "BLUE",
"BLUM",  "BLUR",  "BOAR",  "BOAT",  "BOCA",  "BOCK",  "BODE",  "BODY",
"BOGY",  "BOHR",  "BOIL",  "BOLD",  "BOLO",  "BOLT",  "BOMB",  "BONA",
"BOND",  "BONE",  "BONG",  "BONN",  "BONY",  "BOOK",  "BOOM",  "BOON",
"BOOT",  "BORE",  "BORG",  "BORN",  "BOSE",  "BOSS",  "BOTH",  "BOUT",
"BOWL",  "BOYD",  "BRAD",  "BRAE",  "BRAG",  "BRAN",  "BRAY",  "BRED",
"BREW",  "BRIG",  "BRIM",  "BROW",  "BUCK",  "BUDD",  "BUFF",  "BULB",
"BULK",  "BULL",  "BUNK",  "BUNT",  "BUOY",  "BURG",  "BURL",  "BURN",
"BURR",  "BURT",  "BURY",  "BUSH",  "BUSS",  "BUST",  "BUSY",  "BYTE",
"CADY",  "CAFE",  "CAGE",  "CAIN",  "CAKE",  "CALF",  "CALL",  "CALM",
"CAME",  "CANE",  "CANT",  "CARD",  "CARE",  "CARL",  "CARR",  "CART",
"CASE",  "CASH",  "CASK",  "CAST",  "CAVE",  "CEIL",  "CELL",  "CENT",
"CERN",  "CHAD",  "CHAR",  "CHAT",  "CHAW",  "CHEF",  "CHEN",  "CHEW",
"CHIC",  "CHIN",  "CHOU",  "CHOW",  "CHUB",  "CHUG",  "CHUM",  "CITE",
"CITY",  "CLAD",  "CLAM",  "CLAN",  "CLAW",  "CLAY",  "CLOD",  "CLOG",
"CLOT",  "CLUB",  "CLUE",  "COAL",  "COAT",  "COCA",  "COCK",  "COCO",
"CODA",  "CODE",  "CODY",  "COED",  "COIL",  "COIN",  "COKE",  "COLA",
"COLD",  "COLT",  "COMA",  "COMB",  "COME",  "COOK",  "COOL",  "COON",
"COOT",  "CORD",  "CORE",  "CORK",  "CORN",  "COST",  "COVE",  "COWL",
"CRAB",  "CRAG",  "CRAM",  "CRAY",  "CREW",  "CRIB",  "CROW",  "CRUD",
"CUBA",  "CUBE",  "CUFF",  "CULL",  "CULT",  "CUNY",  "CURB",  "CURD",
"CURE",  "CURL",  "CURT",  "CUTS",  "DADE",  "DALE",  "DAME",  "DANA",
"DANE",  "DANG",  "DANK",  "DARE",  "DARK",  "DARN",  "DART",  "DASH",
"DATA",  "DATE",  "DAVE",  "DAVY",  "DAWN",  "DAYS",  "DEAD",  "DEAF",
"DEAL",  "DEAN",  "DEAR",  "DEBT",  "DECK",  "DEED",  "DEEM",  "DEER",
"DEFT",  "DEFY",  "DELL",  "DENT",  "DENY",  "DESK",  "DIAL",  "DICE",
"DIED",  "DIET",  "DIME",  "DINE",  "DING",  "DINT",  "DIRE",  "DIRT",
"DISC",  "DISH",  "DISK",  "DIVE",  "DOCK",  "DOES",  "DOLE",  "DOLL",
"DOLT",  "DOME",  "DONE",  "DOOM",  "DOOR",  "DORA",  "DOSE",  "DOTE",
"DOUG",  "DOUR",  "DOVE",  "DOWN",  "DRAB",  "DRAG",  "DRAM",  "DRAW",
"DREW",  "DRUB",  "DRUG",  "DRUM",  "DUAL",  "DUCK",  "DUCT",  "DUEL",
"DUET",  "DUKE",  "DULL",  "DUMB",  "DUNE",  "DUNK",  "DUSK",  "DUST",
"DUTY",  "EACH",  "EARL",  "EARN",  "EASE",  "EAST",  "EASY",  "EBEN",
"ECHO",  "EDDY",  "EDEN",  "EDGE",  "EDGY",  "EDIT",  "EDNA",  "EGAN",
"ELAN",  "ELBA",  "ELLA",  "ELSE",  "EMIL",  "EMIT",  "EMMA",  "ENDS",
"ERIC",  "EROS",  "EVEN",  "EVER",  "EVIL",  "EYED",  "FACE",  "FACT",
"FADE",  "FAIL",  "FAIN",  "FAIR",  "FAKE",  "FALL",  "FAME",  "FANG",
"FARM",  "FAST",  "FATE",  "FAWN",  "FEAR",  "FEAT",  "FEED",  "FEEL",
"FEET",  "FELL",  "FELT",  "FEND",  "FERN",  "FEST",  "FEUD",  "FIEF",
"FIGS",  "FILE",  "FILL",  "FILM",  "FIND",  "FINE",  "FINK",  "FIRE",
"FIRM",  "FISH",  "FISK",  "FIST",  "FITS",  "FIVE",  "FLAG",  "FLAK",
"FLAM",  "FLAT",  "FLAW",  "FLEA",  "FLED",  "FLEW",  "FLIT",  "FLOC",
"FLOG",  "FLOW",  "FLUB",  "FLUE",  "FOAL",  "FOAM",  "FOGY",  "FOIL",
"FOLD",  "FOLK",  "FOND",  "FONT",  "FOOD",  "FOOL",  "FOOT",  "FORD",
"FORE",  "FORK",  "FORM",  "FORT",  "FOSS",  "FOUL",  "FOUR",  "FOWL",
"FRAU",  "FRAY",  "FRED",  "FREE",  "FRET",  "FREY",  "FROG",  "FROM",
"FUEL",  "FULL",  "FUME",  "FUND",  "FUNK",  "FURY",  "FUSE",  "FUSS",
"GAFF",  "GAGE",  "GAIL",  "GAIN",  "GAIT",  "GALA",  "GALE",  "GALL",
"GALT",  "GAME",  "GANG",  "GARB",  "GARY",  "GASH",  "GATE",  "GAUL",
"GAUR",  "GAVE",  "GAWK",  "GEAR",  "GELD",  "GENE",  "GENT",  "GERM",
"GETS",  "GIBE",  "GIFT",  "GILD",  "GILL",  "GILT",  "GINA",  "GIRD",
"GIRL",  "GIST",  "GIVE",  "GLAD",  "GLEE",  "GLEN",  "GLIB",  "GLOB",
"GLOM",  "GLOW",  "GLUE",  "GLUM",  "GLUT",  "GOAD",  "GOAL",  "GOAT",
"GOER",  "GOES",  "GOLD",  "GOLF",  "GONE",  "GONG",  "GOOD",  "GOOF",
"GORE",  "GORY",  "GOSH",  "GOUT",  "GOWN",  "GRAB",  "GRAD",  "GRAY",
"GREG",  "GREW",  "GREY",  "GRID",  "GRIM",  "GRIN",  "GRIT",  "GROW",
"GRUB",  "GULF",  "GULL",  "GUNK",  "GURU",  "GUSH",  "GUST",  "GWEN",
"GWYN",  "HAAG",  "HAAS",  "HACK",  "HAIL",  "HAIR",  "HALE",  "HALF",
"HALL",  "HALO",  "HALT",  "HAND",  "HANG",  "HANK",  "HANS",  "HARD",
"HARK",  "HARM",  "HART",  "HASH",  "HAST",  "HATE",  "HATH",  "HAUL",
"HAVE",  "HAWK",  "HAYS",  "HEAD",  "HEAL",  "HEAR",  "HEAT",  "HEBE",
"HECK",  "HEED",  "HEEL",  "HEFT",  "HELD",  "HELL",  "HELM",  "HERB",
"HERD",  "HERE",  "HERO",  "HERS",  "HESS",  "HEWN",  "HICK",  "HIDE",
"HIGH",  "HIKE",  "HILL",  "HILT",  "HIND",  "HINT",  "HIRE",  "HISS",
"HIVE",  "HOBO",  "HOCK",  "HOFF",  "HOLD",  "HOLE",  "HOLM",  "HOLT",
"HOME",  "HONE",  "HONK",  "HOOD",  "HOOF",  "HOOK",  "HOOT",  "HORN",
"HOSE",  "HOST",  "HOUR",  "HOVE",  "HOWE",  "HOWL",  "HOYT",  "HUCK",
"HUED",  "HUFF",  "HUGE",  "HUGH",  "HUGO",  "HULK",  "HULL",  "HUNK",
"HUNT",  "HURD",  "HURL",  "HURT",  "HUSH",  "HYDE",  "HYMN",  "IBIS",
"ICON",  "IDEA",  "IDLE",  "IFFY",  "INCA",  "INCH",  "INTO",  "IONS",
"IOTA",  "IOWA",  "IRIS",  "IRMA",  "IRON",  "ISLE",  "ITCH",  "ITEM",
"IVAN",  "JACK",  "JADE",  "JAIL",  "JAKE",  "JANE",  "JAVA",  "JEAN",
"JEFF",  "JERK",  "JESS",  "JEST",  "JIBE",  "JILL",  "JILT",  "JIVE",
"JOAN",  "JOBS",  "JOCK",  "JOEL",  "JOEY",  "JOHN",  "JOIN",  "JOKE",
"JOLT",  "JOVE",  "JUDD",  "JUDE",  "JUDO",  "JUDY",  "JUJU",  "JUKE",
"JULY",  "JUNE",  "JUNK",  "JUNO",  "JURY",  "JUST",  "JUTE",  "KAHN",
"KALE",  "KANE",  "KANT",  "KARL",  "KATE",  "KEEL",  "KEEN",  "KENO",
"KENT",  "KERN",  "KERR",  "KEYS",  "KICK",  "KILL",  "KIND",  "KING",
"KIRK",  "KISS",  "KITE",  "KLAN",  "KNEE",  "KNEW",  "KNIT",  "KNOB",
"KNOT",  "KNOW",  "KOCH",  "KONG",  "KUDO",  "KURD",  "KURT",  "KYLE",
"LACE",  "LACK",  "LACY",  "LADY",  "LAID",  "LAIN",  "LAIR",  "LAKE",
"LAMB",  "LAME",  "LAND",  "LANE",  "LANG",  "LARD",  "LARK",  "LASS",
"LAST",  "LATE",  "LAUD",  "LAVA",  "LAWN",  "LAWS",  "LAYS",  "LEAD",
"LEAF",  "LEAK",  "LEAN",  "LEAR",  "LEEK",  "LEER",  "LEFT",  "LEND",
"LENS",  "LENT",  "LEON",  "LESK",  "LESS",  "LEST",  "LETS",  "LIAR",
"LICE",  "LICK",  "LIED",  "LIEN",  "LIES",  "LIEU",  "LIFE",  "LIFT",
"LIKE",  "LILA",  "LILT",  "LILY",  "LIMA",  "LIMB",  "LIME",  "LIND",
"LINE",  "LINK",  "LINT",  "LION",  "LISA",  "LIST",  "LIVE",  "LOAD",
"LOAF",  "LOAM",  "LOAN",  "LOCK",  "LOFT",  "LOGE",  "LOIS",  "LOLA",
"LONE",  "LONG",  "LOOK",  "LOON",  "LOOT",  "LORD",  "LORE",  "LOSE",
"LOSS",  "LOST",  "LOUD",  "LOVE",  "LOWE",  "LUCK",  "LUCY",  "LUGE",
"LUKE",  "LULU",  "LUND",  "LUNG",  "LURA",  "LURE",  "LURK",  "LUSH",
"LUST",  "LYLE",  "LYNN",  "LYON",  "LYRA",  "MACE",  "MADE",  "MAGI",
"MAID",  "MAIL",  "MAIN",  "MAKE",  "MALE",  "MALI",  "MALL",  "MALT",
"MANA",  "MANN",  "MANY",  "MARC",  "MARE",  "MARK",  "MARS",  "MART",
"MARY",  "MASH",  "MASK",  "MASS",  "MAST",  "MATE",  "MATH",  "MAUL",
"MAYO",  "MEAD",  "MEAL",  "MEAN",  "MEAT",  "MEEK",  "MEET",  "MELD",
"MELT",  "MEMO",  "MEND",  "MENU",  "MERT",  "MESH",  "MESS",  "MICE",
"MIKE",  "MILD",  "MILE",  "MILK",  "MILL",  "MILT",  "MIMI",  "MIND",
"MINE",  "MINI",  "MINK",  "MINT",  "MIRE",  "MISS",  "MIST",  "MITE",
"MITT",  "MOAN",  "MOAT",  "MOCK",  "MODE",  "MOLD",  "MOLE",  "MOLL",
"MOLT",  "MONA",  "MONK",  "MONT",  "MOOD",  "MOON",  "MOOR",  "MOOT",
"MORE",  "MORN",  "MORT",  "MOSS",  "MOST",  "MOTH",  "MOVE",  "MUCH",
"MUCK",  "MUDD",  "MUFF",  "MULE",  "MULL",  "MURK",  "MUSH",  "MUST",
"MUTE",  "MUTT",  "MYRA",  "MYTH",  "NAGY",  "NAIL",  "NAIR",  "NAME",
"NARY",  "NASH",  "NAVE",  "NAVY",  "NEAL",  "NEAR",  "NEAT",  "NECK",
"NEED",  "NEIL",  "NELL",  "NEON",  "NERO",  "NESS",  "NEST",  "NEWS",
"NEWT",  "NIBS",  "NICE",  "NICK",  "NILE",  "NINA",  "NINE",  "NOAH",
"NODE",  "NOEL",  "NOLL",  "NONE",  "NOOK",  "NOON",  "NORM",  "NOSE",
"NOTE",  "NOUN",  "NOVA",  "NUDE",  "NULL",  "NUMB",  "OATH",  "OBEY",
"OBOE",  "ODIN",  "OHIO",  "OILY",  "OINT",  "OKAY",  "OLAF",  "OLDY",
"OLGA",  "OLIN",  "OMAN",  "OMEN",  "OMIT",  "ONCE",  "ONES",  "ONLY",
"ONTO",  "ONUS",  "ORAL",  "ORGY",  "OSLO",  "OTIS",  "OTTO",  "OUCH",
"OUST",  "OUTS",  "OVAL",  "OVEN",  "OVER",  "OWLY",  "OWNS",  "QUAD",
"QUIT",  "QUOD",  "RACE",  "RACK",  "RACY",  "RAFT",  "RAGE",  "RAID",
"RAIL",  "RAIN",  "RAKE",  "RANK",  "RANT",  "RARE",  "RASH",  "RATE",
"RAVE",  "RAYS",  "READ",  "REAL",  "REAM",  "REAR",  "RECK",  "REED",
"REEF",  "REEK",  "REEL",  "REID",  "REIN",  "RENA",  "REND",  "RENT",
"REST",  "RICE",  "RICH",  "RICK",  "RIDE",  "RIFT",  "RILL",  "RIME",
"RING",  "RINK",  "RISE",  "RISK",  "RITE",  "ROAD",  "ROAM",  "ROAR",
"ROBE",  "ROCK",  "RODE",  "ROIL",  "ROLL",  "ROME",  "ROOD",  "ROOF",
"ROOK",  "ROOM",  "ROOT",  "ROSA",  "ROSE",  "ROSS",  "ROSY",  "ROTH",
"ROUT",  "ROVE",  "ROWE",  "ROWS",  "RUBE",  "RUBY",  "RUDE",  "RUDY",
"RUIN",  "RULE",  "RUNG",  "RUNS",  "RUNT",  "RUSE",  "RUSH",  "RUSK",
"RUSS",  "RUST",  "RUTH",  "SACK",  "SAFE",  "SAGE",  "SAID",  "SAIL",
"SALE",  "SALK",  "SALT",  "SAME",  "SAND",  "SANE",  "SANG",  "SANK",
"SARA",  "SAUL",  "SAVE",  "SAYS",  "SCAN",  "SCAR",  "SCAT",  "SCOT",
"SEAL",  "SEAM",  "SEAR",  "SEAT",  "SEED",  "SEEK",  "SEEM",  "SEEN",
"SEES",  "SELF",  "SELL",  "SEND",  "SENT",  "SETS",  "SEWN",  "SHAG",
"SHAM",  "SHAW",  "SHAY",  "SHED",  "SHIM",  "SHIN",  "SHOD",  "SHOE",
"SHOT",  "SHOW",  "SHUN",  "SHUT",  "SICK",  "SIDE",  "SIFT",  "SIGH",
"SIGN",  "SILK",  "SILL",  "SILO",  "SILT",  "SINE",  "SING",  "SINK",
"SIRE",  "SITE",  "SITS",  "SITU",  "SKAT",  "SKEW",  "SKID",  "SKIM",
"SKIN",  "SKIT",  "SLAB",  "SLAM",  "SLAT",  "SLAY",  "SLED",  "SLEW",
"SLID",  "SLIM",  "SLIT",  "SLOB",  "SLOG",  "SLOT",  "SLOW",  "SLUG",
"SLUM",  "SLUR",  "SMOG",  "SMUG",  "SNAG",  "SNOB",  "SNOW",  "SNUB",
"SNUG",  "SOAK",  "SOAR",  "SOCK",  "SODA",  "SOFA",  "SOFT",  "SOIL",
"SOLD",  "SOME",  "SONG",  "SOON",  "SOOT",  "SORE",  "SORT",  "SOUL",
"SOUR",  "SOWN",  "STAB",  "STAG",  "STAN",  "STAR",  "STAY",  "STEM",
"STEW",  "STIR",  "STOW",  "STUB",  "STUN",  "SUCH",  "SUDS",  "SUIT",
"SULK",  "SUMS",  "SUNG",  "SUNK",  "SURE",  "SURF",  "SWAB",  "SWAG",
"SWAM",  "SWAN",  "SWAT",  "SWAY",  "SWIM",  "SWUM",  "TACK",  "TACT",
"TAIL",  "TAKE",  "TALE",  "TALK",  "TALL",  "TANK",  "TASK",  "TATE",
"TAUT",  "TEAL",  "TEAM",  "TEAR",  "TECH",  "TEEM",  "TEEN",  "TEET",
"TELL",  "TEND",  "TENT",  "TERM",  "TERN",  "TESS",  "TEST",  "THAN",
"THAT",  "THEE",  "THEM",  "THEN",  "THEY",  "THIN",  "THIS",  "THUD",
"THUG",  "TICK",  "TIDE",  "TIDY",  "TIED",  "TIER",  "TILE",  "TILL",
"TILT",  "TIME",  "TINA",  "TINE",  "TINT",  "TINY",  "TIRE",  "TOAD",
"TOGO",  "TOIL",  "TOLD",  "TOLL",  "TONE",  "TONG",  "TONY",  "TOOK",
"TOOL",  "TOOT",  "TORE",  "TORN",  "TOTE",  "TOUR",  "TOUT",  "TOWN",
"TRAG",  "TRAM",  "TRAY",  "TREE",  "TREK",  "TRIG",  "TRIM",  "TRIO",
"TROD",  "TROT",  "TROY",  "TRUE",  "TUBA",  "TUBE",  "TUCK",  "TUFT",
"TUNA",  "TUNE",  "TUNG",  "TURF",  "TURN",  "TUSK",  "TWIG",  "TWIN",
"TWIT",  "ULAN",  "UNIT",  "URGE",  "USED",  "USER",  "USES",  "UTAH",
"VAIL",  "VAIN",  "VALE",  "VARY",  "VASE",  "VAST",  "VEAL",  "VEDA",
"VEIL",  "VEIN",  "VEND",  "VENT",  "VERB",  "VERY",  "VETO",  "VICE",
"VIEW",  "VINE",  "VISE",  "VOID",  "VOLT",  "VOTE",  "WACK",  "WADE",
"WAGE",  "WAIL",  "WAIT",  "WAKE",  "WALE",  "WALK",  "WALL",  "WALT",
"WAND",  "WANE",  "WANG",  "WANT",  "WARD",  "WARM",  "WARN",  "WART",
"WASH",  "WAST",  "WATS",  "WATT",  "WAVE",  "WAVY",  "WAYS",  "WEAK",
"WEAL",  "WEAN",  "WEAR",  "WEED",  "WEEK",  "WEIR",  "WELD",  "WELL",
"WELT",  "WENT",  "WERE",  "WERT",  "WEST",  "WHAM",  "WHAT",  "WHEE",
"WHEN",  "WHET",  "WHOA",  "WHOM",  "WICK",  "WIFE",  "WILD",  "WILL",
"WIND",  "WINE",  "WING",  "WINK",  "WINO",  "WIRE",  "WISE",  "WISH",
"WITH",  "WOLF",  "WONT",  "WOOD",  "WOOL",  "WORD",  "WORE",  "WORK",
"WORM",  "WORN",  "WOVE",  "WRIT",  "WYNN",  "YALE",  "YANG",  "YANK",
"YARD",  "YARN",  "YAWL",  "YAWN",  "YEAH",  "YEAR",  "YELL",  "YOGA",
"YOKE"   };

} /* End of class otp */
//@@@@@@//
//Contrib/MulticastSniffer.java
//@@@@@@//
import java.net.*;
import java.io.*;

/** Multicast Sniffer, from Elliotte Harold's book 
 * Java Network Programming, by O'Reilly & Associates.
 * Page 342, first edition.
 */

public class MulticastSniffer {
	public static void main(String[] args) {
		InetAddress ia = null;
		byte[] buffer = new byte[65535];
		DatagramPacket dp = new DatagramPacket(buffer, buffer.length);
		int port = 0;

		// read the address from the command line
		try {
			try {
				ia = InetAddress.getByName(args[0]);
			} catch (UnknownHostException e) {
				System.err.println(e);
			}
			port = Integer.parseInt(args[1]);
		} catch (Exception e) {
			System.err.println(e);
			System.err.println("Usage: java MulticastSniffer mcast-addr port");
			System.exit(1);
		}
		System.out.println("About to join " + ia);

		try {
			MulticastSocket ms = new MulticastSocket(port);
			ms.joinGroup(ia);
			while (true) {
				System.out.println("About to receive...");
				ms.receive(dp);
				String s = new String(dp.getData(), 0, 0, dp.getLength());
				System.out.println(s);
			}
		} catch(SocketException se) {
			System.err.println(se);
		} catch(IOException ie) {
			System.err.println(ie);
		}
	}
}
//@@@@@@//
//Contrib/MultiLineLabel.java
//@@@@@@//
// This example is from the book _Java in a Nutshell_ by David Flanagan.
// Written by David Flanagan.  Copyright (c) 1996 O'Reilly & Associates.
// You may study, use, modify, and distribute this example for any purpose.
// This example is provided WITHOUT WARRANTY either expressed or implied.

import java.awt.*;
import java.util.*;

public class MultiLineLabel extends Canvas {
    public static final int LEFT = 0; // Alignment constants
    public static final int CENTER = 1;
    public static final int RIGHT = 2;
    protected String[] lines;         // The lines of text to display
    protected int num_lines;          // The number of lines
    protected int margin_width;       // Left and right margins
    protected int margin_height;      // Top and bottom margins
    protected int line_height;        // Total height of the font
    protected int line_ascent;        // Font height above baseline
    protected int[] line_widths;      // How wide each line is
    protected int max_width;          // The width of the widest line
    protected int alignment = LEFT;   // The alignment of the text.
    
    // This method breaks a specified label up into an array of lines.
    // It uses the StringTokenizer utility class.
    protected void newLabel(String label) {
        StringTokenizer t = new StringTokenizer(label, "\n");
        num_lines = t.countTokens();
        lines = new String[num_lines];
        line_widths = new int[num_lines];
        for(int i = 0; i < num_lines; i++) lines[i] = t.nextToken();
    }
    
    // This method figures out how the font is, and how wide each
    // line of the label is, and how wide the widest line is.
    protected void measure() {
        FontMetrics fm = getFontMetrics(getFont());
        // If we don't have font metrics yet, just return.
        if (fm == null) return;
        
        line_height = fm.getHeight();
        line_ascent = fm.getAscent();
        max_width = 0;
        for(int i = 0; i < num_lines; i++) {
            line_widths[i] = fm.stringWidth(lines[i]);
            if (line_widths[i] > max_width) max_width = line_widths[i];
        }
    }
    
    // Here are four versions of the cosntrutor.
    // Break the label up into separate lines, and save the other info.
    public MultiLineLabel(String label, int margin_width, int margin_height,
                  int alignment) {
        newLabel(label);
        this.margin_width = margin_width;
        this.margin_height = margin_height;
        this.alignment = alignment;
    }
    public MultiLineLabel(String label, int margin_width, int margin_height) {
        this(label, margin_width, margin_height, LEFT);
    }
    public MultiLineLabel(String label, int alignment) {
        this(label, 10, 10, alignment);
    }
    public MultiLineLabel(String label) {
        this(label, 10, 10, LEFT);
    }
    
    // Methods to set the various attributes of the component
    public void setLabel(String label) {
        newLabel(label);
        measure();
        repaint();
    }
    public void setFont(Font f) {
        super.setFont(f);
        measure();
        repaint();
    }
    public void setForeground(Color c) { 
        super.setForeground(c); 
        repaint(); 
    }
    public void setAlignment(int a) { alignment = a; repaint(); }
    public void setMarginWidth(int mw) { margin_width = mw; repaint(); }
    public void setMarginHeight(int mh) { margin_height = mh; repaint(); }
    public int getAlignment() { return alignment; }
    public int getMarginWidth() { return margin_width; }
    public int getMarginHeight() { return margin_height; }
    
    // This method is invoked after our Canvas is first created
    // but before it can actually be displayed.  After we've
    // invoked our superclass's addNotify() method, we have font
    // metrics and can successfully call measure() to figure out
    // how big the label is.
    public void addNotify() { super.addNotify(); measure(); }
    
    // This method is called by a layout manager when it wants to
    // know how big we'd like to be.  
    public Dimension getPreferredSize() {
        return new Dimension(max_width + 2*margin_width, 
                     num_lines * line_height + 2*margin_height);
    }
    
    // This method is called when the layout manager wants to know
    // the bare minimum amount of space we need to get by.
    public Dimension getMinimumSize() {
        return new Dimension(max_width, num_lines * line_height);
    }
    
    // This method draws the label (applets use the same method).
    // Note that it handles the margins and the alignment, but that
    // it doesn't have to worry about the color or font--the superclass
    // takes care of setting those in the Graphics object we're passed.
    public void paint(Graphics g) {
        int x, y;
        Dimension d = getSize();
        y = line_ascent + (d.height - num_lines * line_height)/2;
        for(int i = 0; i < num_lines; i++, y += line_height) {
            switch(alignment) {
            case LEFT:
                x = margin_width; break;
            case CENTER:
            default:
                x = (d.width - line_widths[i])/2; break;
            case RIGHT:
                x = d.width - margin_width - line_widths[i]; break;
            }
            g.drawString(lines[i], x, y);
        }
    }
}
//@@@@@@//
//Contrib/oreilly/swing/BasicJogShuttleUI.java
//@@@@@@//
//  BasicJogShuttleUI.java
// A UI class for our custom JogShuttle component.
//
import java.awt.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.plaf.*;
import javax.swing.border.*;

public class BasicJogShuttleUI extends JogShuttleUI
    implements MouseListener, MouseMotionListener
{
    private static final int KNOB_DISPLACEMENT = 3;
    private static final int FINGER_SLOT_DISPLACEMENT = 15;

    private double lastAngle;  // Used to track mouse drags.

    public static ComponentUI createUI(JComponent c) {
        return new BasicJogShuttleUI();
    }

    public void installUI(JComponent c) {
        JogShuttle shuttle = (JogShuttle)c;
        shuttle.addMouseListener(this);
        shuttle.addMouseMotionListener(this);
    }

    public void uninstallUI(JComponent c) {
        JogShuttle shuttle = (JogShuttle)c;
        shuttle.removeMouseListener(this);
        shuttle.removeMouseMotionListener(this);
    }

    public void paint(Graphics g, JComponent c) {
        //  We don't want to paint inside the insets or borders.
        Insets insets = c.getInsets();
        g.translate(insets.left, insets.top);
        int width = c.getWidth() - insets.left - insets.right;
        int height = c.getHeight() - insets.top - insets.bottom;
 
        //  Draw the outside circle.
        g.setColor(c.getForeground());
        g.fillOval(0, 0, width, height); 
       
        Insets d = ((JogShuttle)c).getDialInsets();
        int value = ((JogShuttle)c).getValue();
        int valuePerRevolution = ((JogShuttle)c).getValuePerRevolution();
 
        //  Draw the edge of the dial. 
        g.setColor(Color.darkGray);
        g.fillOval(d.left, d.top, width-(d.right*2), height-(d.bottom*2)); 

        //  Draw the inside of the dial.
        g.setColor(Color.gray);
        g.fillOval(d.left + KNOB_DISPLACEMENT,
                   d.top + KNOB_DISPLACEMENT,
                   width - (d.right + d.left) - KNOB_DISPLACEMENT * 2,
                   height - (d.bottom + d.top) - KNOB_DISPLACEMENT * 2); 

        //  Draw the finger slot.
        drawFingerSlot(g, c, value, width, height, valuePerRevolution,
                FINGER_SLOT_DISPLACEMENT - 1,
                (double)(width/2) - d.right - FINGER_SLOT_DISPLACEMENT,
                (double)(height/2) - d.bottom - FINGER_SLOT_DISPLACEMENT);

        g.translate(-insets.left, -insets.top);
    }

    private void drawFingerSlot(Graphics g, JComponent c, int value,
        int width, int height, int valuePerRevolution, int size,
        double xradius, double yradius) {
    
        int currentPosition = value % valuePerRevolution;

        //  Obtain the current angle in radians.
        double angle = ((double)currentPosition / valuePerRevolution) *
                         java.lang.Math.PI * 2;

        // Obtain the X and Y coordinates of the finger slot, with the
        // minimum value at twelve o'clock.
        angle -= (java.lang.Math.PI / 2);
        int xPosition = (int) (xradius * java.lang.Math.sin(angle));
        int yPosition = (int) (yradius * java.lang.Math.cos(angle));
        xPosition = (width / 2) - xPosition;
        yPosition = (height / 2) + yPosition;

        //  Draw the finger slot with a crescent shadow on the top left.
        g.setColor(Color.darkGray); 
        g.fillOval(xPosition-(size/2), yPosition-(size/2), size, size); 
        g.setColor(Color.lightGray); 
        g.fillOval(xPosition-(size/2) + 1, yPosition - (size/2) + 1,
                   size - 1, size - 1); 

    }

    // Figure out angle at which a mouse event occurred with respect to the
    // center of the component for intuitive dial dragging.
    protected double calculateAngle(MouseEvent e) {
        int x = e.getX() - ((JComponent)e.getSource()).getWidth() / 2;
        int y = -e.getY() + ((JComponent)e.getSource()).getHeight() / 2;
        if (x == 0) {  // Handle case where math would blow up.
            if (y == 0) {
                return lastAngle;   // Can't tell...
            }
            if (y > 0) {
                return Math.PI / 2;
            }
            return -Math.PI / 2;
        }
        return Math.atan((double)y / (double)x);
    }

    public void mousePressed(MouseEvent e) { lastAngle = calculateAngle(e); }
    public void mouseReleased(MouseEvent e) { }
    public void mouseClicked(MouseEvent e) { }
    public void mouseEntered(MouseEvent e) { }
    public void mouseExited(MouseEvent e) { }

    // Figure out the change in angle over which the user has dragged,
    // expressed as a fraction of a revolution.
    public double angleDragged(MouseEvent e) {
        double newAngle = calculateAngle(e);
        double change = (lastAngle - newAngle) / Math.PI;
        if (Math.abs(change) > 0.5) {  // Handle crossing origin.
            if (change < 0.0) {
                change += 1.0;
            } else {
                change -= 1.0;
            }
        }

        lastAngle = newAngle;
        return change;
    }

    public void mouseDragged(MouseEvent e) {
        JogShuttle theShuttle = (JogShuttle)e.getComponent();
        theShuttle.setValue(theShuttle.getValue() +
            (int)(angleDragged(e) * theShuttle.getValuePerRevolution()));
    }

    public void mouseMoved(MouseEvent e) { }
}
//@@@@@@//
//Contrib/oreilly/swing/IanDemo.java
//@@@@@@//
import javax.swing.JFrame;
import javax.swing.UIManager;
import java.beans.*;

public class IanDemo extends JFrame {
	public static void main(String[] args) {
        UIManager.put(JogShuttleUI.UI_CLASS_ID, "BasicJogShuttleUI");
		new IanDemo().setVisible(true);
	}

	JogShuttle myJog;

	IanDemo() {
		myJog = new JogShuttle(0, 300, 150);
        myJog.addPropertyChangeListener(new PropertyChangeListener() {
			public void propertyChange(PropertyChangeEvent e) {
				if (e.getPropertyName() == "value") {
					System.out.println(myJog.getValue());
				}
			}
		});
		getContentPane().add(myJog);
		pack();
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}
//@@@@@@//
//Contrib/oreilly/swing/JogShuttle.java
//@@@@@@//
//  JogShuttle.java
// A custom jog shuttle component.  (Some VCRs have such a thing for doing
// variable speed fast-forward and fast-reverse.)  An example of using the
// JogShuttle can be found in Sketch.java.
//
import java.awt.*;
import java.awt.event.*;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.border.*;

public class JogShuttle extends JComponent implements ChangeListener {

    private BoundedRangeModel model;

    //  The dialInsets property tells how far the dial is inset
    //  from the sunken border.
    private Insets dialInsets = new Insets(3, 3, 3, 3);

    //  The valuePerRevolution property tells how many units the dial
    //  takes to make a complete revolution.
    private int valuePerRevolution;

    //  Constructors
    public JogShuttle() {
        init(new DefaultBoundedRangeModel());
    }

    public JogShuttle(BoundedRangeModel m) {
        init(m);
    }

    public JogShuttle(int min, int max, int value) {
        init(new DefaultBoundedRangeModel(value, 1, min, max));
    }
     
    protected void init(BoundedRangeModel m) {
        setModel(m);
        valuePerRevolution = m.getMaximum() - m.getMinimum();
        setMinimumSize(new Dimension(80, 80));
        setPreferredSize(new Dimension(80, 80));
        updateUI();
    }

    public void setUI(JogShuttleUI ui) {super.setUI(ui);}

    public void updateUI() {
       setUI((JogShuttleUI)UIManager.getUI(this));
       invalidate();
    }

    public String getUIClassID() {
        return JogShuttleUI.UI_CLASS_ID;
    }

    public void setModel(BoundedRangeModel m) {
        BoundedRangeModel old = model;
        if (old != null)
            old.removeChangeListener(this);

        if (m == null)
            model = new DefaultBoundedRangeModel();
        else
            model = m;
        model.addChangeListener(this);

        firePropertyChange("model", old, model);
    }

    public BoundedRangeModel getModel() {
        return model;
    }

    //  Methods
    public void resetToMinimum() {model.setValue(model.getMinimum());}

    public void resetToMaximum() {model.setValue(model.getMaximum());}
 
    public void stateChanged(ChangeEvent e) {repaint();}

    //  Accessors and mutators
    public int getMinimum() {return model.getMinimum();}

    public void setMinimum(int m) {
        int old = getMinimum();
        if (m != old) {
            model.setMinimum(m);
            firePropertyChange("minimum", old, m);
        }
    }

    public int getMaximum() {return model.getMaximum();}

    public void setMaximum(int m) {
        int old = getMaximum();
        if (m != old) {
            model.setMaximum(m);
            firePropertyChange("maximum", old, m);
        }
    }

    public int getValue() {return model.getValue();}

    public void setValue(int v) {
        int old = getValue();
        if (v != old) {
            model.setValue(v);
            firePropertyChange("value", old, v);
        }
    }


    //  Display-specific properties
    public int getValuePerRevolution() {return valuePerRevolution;}

    public void setValuePerRevolution(int v) {
        int old = getValuePerRevolution();
        if (v != old) {
            valuePerRevolution = v;
            firePropertyChange("valuePerRevolution", old, v);
        }
        repaint();
    }

    public void setDialInsets(Insets i) {dialInsets = i;}

    public void setDialInsets(int top, int left, int bottom, int right) {
        dialInsets = new Insets(top, left, bottom, right);
    }

    public Insets getDialInsets() {return dialInsets;}
}
//@@@@@@//
//Contrib/oreilly/swing/JogShuttleUI.java
//@@@@@@//
//  JogShuttleUI.java
// Fill out the proper UIClassID information for our JogShuttle.
//
import java.awt.*;
import javax.swing.*;
import javax.swing.plaf.*;

public abstract class JogShuttleUI extends ComponentUI {
    public static final String UI_CLASS_ID = "JogShuttleUI";
}
//@@@@@@//
//Contrib/oreilly/swing/Sketch.java
//@@@@@@//
//  Sketch.java
// A sketching application with two dials: one for horizontal movement, one
// for vertical movement.  The dials are instances of the JogShuttle class.
//
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.util.*;

import javax.swing.*;
import javax.swing.border.*;

public class Sketch extends JPanel
    implements PropertyChangeListener, ActionListener
{
    JogShuttle shuttle1;
    JogShuttle shuttle2;
    JPanel board;
    JButton clear;

    int lastX, lastY;  // Keep track of the last point we drew.

    public Sketch() {
        super(true);
 
        setLayout(new BorderLayout());
        board = new JPanel(true);
        board.setPreferredSize(new Dimension(300, 300));
        board.setBorder(new LineBorder(Color.black, 5));

        clear = new JButton("Clear Drawing Area");
        clear.addActionListener(this);

        shuttle1 = new JogShuttle(0, 300, 150);
        lastX = shuttle1.getValue();
        shuttle2 = new JogShuttle(0, 300, 150);
        lastY = shuttle2.getValue();

        shuttle1.setValuePerRevolution(100);
        shuttle2.setValuePerRevolution(100);

        shuttle1.addPropertyChangeListener(this);
        shuttle2.addPropertyChangeListener(this);

        shuttle1.setBorder(new BevelBorder(BevelBorder.RAISED));
        shuttle2.setBorder(new BevelBorder(BevelBorder.RAISED));

        add(board, BorderLayout.NORTH);
        add(shuttle1, BorderLayout.WEST);
        add(clear, BorderLayout.CENTER);
        add(shuttle2, BorderLayout.EAST);
    }

    public void propertyChange(PropertyChangeEvent e) {
        if (e.getPropertyName() == "value") {
            Graphics g = board.getGraphics();
            g.setColor(getForeground());
            g.drawLine(lastX, lastY,
                       shuttle1.getValue(), shuttle2.getValue());
            lastX = shuttle1.getValue();
            lastY = shuttle2.getValue();
        }
    }

    public void actionPerformed(ActionEvent e) {
        //  The button must have been pressed.
        Insets insets = board.getInsets();
        Graphics g = board.getGraphics();
        g.setColor(board.getBackground());
        g.fillRect(insets.left, insets.top,
                   board.getWidth()-insets.left-insets.right,
                   board.getHeight()-insets.top-insets.bottom);
    }

    public static void main(String[] args) {
        UIManager.put(JogShuttleUI.UI_CLASS_ID, "BasicJogShuttleUI");
        Sketch s = new Sketch();
        JFrame frame = new JFrame("Sample Sketch Application");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setContentPane(s);
        frame.pack();
        frame.setVisible(true);
    }
}
//@@@@@@//
//Contrib/PopupDemo.java
//@@@@@@//
// From: mg@dsd.camb.inmet.com (Mitch Gart)

import java.awt.*;
import java.awt.event.*;
import java.lang.*;
import java.util.*;

public class PopupDemo extends Frame 
    implements ActionListener, MouseListener {

	public static void main (String argv[]) {
		new PopupDemo().setVisible(true);
	}

	public PopupDemo() {
		MenuBar mb = new MenuBar();
		setMenuBar(mb);
		Menu m = new Menu("file");
		mb.add(m);
		MenuItem item = new MenuItem("file-1");
		item.addActionListener(this);
		m.add(item);
		item = new MenuItem("file-2");
		m.add(item);

		setSize(100, 100);
		setLayout(new BorderLayout());

		Label l = new Label("label");
		addPopup(l, "label");
		add(l, "North");

		Panel p = new Panel();
		addPopup(p, "Panel");
		add(p, "Center");

		Button b = new Button("button");
		addPopup(b, "button");
		add(b, "South");
	}

	public void actionPerformed(ActionEvent e) {
		System.out.println("actionPerformed, event=" + e + ", mod=" + getMods(e));
		System.out.println(" command=" + e.getActionCommand());
		System.out.println(" param=" + e.paramString());
		System.out.println(" source=" + e.getSource());
	}

	  String getMods(ActionEvent e) { return getMods(e.getModifiers()); }

	  String getMods(MouseEvent e) { return getMods(e.getModifiers()); }

  // a convenience routine for printing the Modifier keys
	String getMods(int mods) {
    String modstr = "";
    if ((mods & ActionEvent.SHIFT_MASK) == ActionEvent.SHIFT_MASK)
      modstr += (" SHIFT");
    if ((mods & ActionEvent.ALT_MASK) == ActionEvent.ALT_MASK)
      modstr += (" ALT");
    if ((mods & ActionEvent.CTRL_MASK) == ActionEvent.CTRL_MASK)
      modstr += (" CTRL");
    if ((mods & ActionEvent.META_MASK) == ActionEvent.META_MASK)
      modstr += (" META");
    return modstr;
  }

  public void mouseClicked (MouseEvent e) {
    mouseAction("mouseClicked", e);
  }

  public void mouseEntered (MouseEvent e) {
  }

  public void mouseExited (MouseEvent e) {
  }

  public void mousePressed (MouseEvent e) {
    mouseAction("mousePressed", e);
  }

  public void mouseReleased (MouseEvent e) {
    mouseAction("mouseReleased", e);
  }

  void mouseAction (String which, MouseEvent e) {
    Component c = e.getComponent();
    System.out.println(which + "e=" + e + ", mods=" + getMods(e) +
                       ", component=" + c);
    if (e.isPopupTrigger()) {
      System.out.println("isPopup");
      PopupMenu pm = getHash(c);
      pm.show(c, c.getSize().width/2, c.getSize().height/2);
    }
  }


  void addPopup(Component c, String name) {
    PopupMenu pm = new PopupMenu();
    MenuItem mi = new MenuItem(name + "-1");
    mi.addActionListener(this);
    pm.add(mi);

    mi = new MenuItem(name + "-2");
    pm.add(mi);

    setHash(c, pm);
    c.add(pm);
    c.addMouseListener(this);
  }


  Hashtable popupTable = new Hashtable();

  void setHash(Component c, PopupMenu p) {
    popupTable.put(c, p);
  }

  PopupMenu getHash(Component c) {
    return (PopupMenu)(popupTable.get(c));
  }
}
//@@@@@@//
//Contrib/SimpleBrowser.java
//@@@@@@//
// SimpleBrowser.java
// From O'Reilly's web site about their Swing GUI book
//

import java.awt.*;
import java.awt.event.*;
import java.io.*;

import javax.swing.*;
import javax.swing.text.html.*;
import javax.swing.event.*;

public class SimpleBrowser extends JFrame {

    static JTextField textField;
    static JEditorPane editor;

    public SimpleBrowser(String s) {
        super(s);

        JPanel panel = new JPanel();
        panel.setLayout(new BorderLayout());
        panel.setBorder(BorderFactory.createRaisedBevelBorder());

        editor = new JEditorPane();
        textField  = new JTextField();
        JScrollPane scrollPane = new JScrollPane(editor);

        editor.setEditable(false);

        panel.add(new JLabel("Location:  "), BorderLayout.WEST);
        panel.add(textField, BorderLayout.CENTER);

        getContentPane().add(panel, BorderLayout.NORTH);
        getContentPane().add(scrollPane, BorderLayout.CENTER);

        textField.addActionListener(new TextFieldListener());
    }

    public static void main(String[] args) {
        SimpleBrowser frame = new SimpleBrowser("Simple Browser");
        frame.setSize(400,400);
        frame.setVisible(true);
    }

    class TextFieldListener implements ActionListener {

        public void actionPerformed(ActionEvent e) {
            try {
                editor.setPage(textField.getText());
            } catch (IOException ex) {
                editor.setText("Page could not be loaded");
            }
        }
    }
}
//@@@@@@//
//Contrib/SlidePuzzle.java
//@@@@@@//
import java.applet.*;
import java.awt.*;

/* SlidePuzzle, originally from VisualJ++ Developer's News, July 1997 */
public class SlidePuzzle extends Applet implements Runnable {
     Thread m_SlidePuzzle = null;

     private Graphics m_Graphics;
     private Image logo;
     private boolean m_fAllLoaded = false;
     private Rectangle squares[];
     private int order[];
     private int x=1;
     private int y=0;

	public void init()
	{
		 //Define and populate Rectangle array
		 squares=new Rectangle[9];
		 squares[0]=new Rectangle(0,0,60,60);
		 squares[1]=new Rectangle(0,60,60,60);
		 squares[2]=new Rectangle(0,120,60,60);
		 squares[3]=new Rectangle(60,0,60,60);
		 squares[4]=new Rectangle(60,60,60,60);
		 squares[5]=new Rectangle(60,120,60,60);
		 squares[6]=new Rectangle(120,0,60,60);
		 squares[7]=new Rectangle(120,60,60,60);
		 squares[8]=new Rectangle(120,120,60,60);

		 //Define and populate int array
		 order = new int[9];
		 order[0]=6;
		 order[1]=2;
		 order[2]=8;
		 order[3]=1;
		 order[4]=0;
		 order[5]=7;
		 order[6]=5;
		 order[7]=4;
		 order[8]=3;
	}

	public void paint(Graphics g)
	{
		 if (m_fAllLoaded)
		 {
			  Rectangle r = g.getClipRect();
			  g.clearRect(r.x,r.y,r.width,r.height);
			  g.drawImage(logo,0,0,null);

	}      else
			  g.drawString("Loading images...", 10, 20);

	}

	public void start()
	{
		 if (m_SlidePuzzle == null)
		 {
			  m_SlidePuzzle = new Thread(this);
			  m_SlidePuzzle.start();
		 }
	}

	public void stop()
	{
		 if (m_SlidePuzzle != null)
		 {
			  m_SlidePuzzle.stop();
			  m_SlidePuzzle = null;
		 }
	}

	public void run()
	{
		 if (!m_fAllLoaded)
		 {
			m_Graphics = getGraphics();
			MediaTracker tracker = new MediaTracker(this);
			logo = getImage(getDocumentBase(),"vjlogo.gif");
			tracker.addImage(logo, 0);

			  try
			  {
				   tracker.waitForAll();
				   m_fAllLoaded = !tracker.isErrorAny();
			  }
			  catch (InterruptedException e)
			  {
			  }

			  if (!m_fAllLoaded)
			  {
			   stop();
			   m_Graphics.drawString("Error loading images!", 10, 40);
			   return;
			  }
		 }

	//Clear the screen and draw first image
	repaint();

	//Move the squares
	while(true)
	{
		 for (x=1;x<9;x++)
		 {
		 //Slow down the animation
		 try
		 {Thread.sleep(350);}
		 catch (InterruptedException e)
			  {}

	//Move square to next location

	m_Graphics.copyArea(squares[order[x]].x,
	squares[order[x]].y,60,60,
	squares[order[x-1]].x-
	squares[order[x]].x,squares[order[x-1]].y-
	squares[order[x]].y);

	//Clear most recently copied square

	m_Graphics.clearRect(squares[order[x]].x,
	squares[order[x]].y,60,60);
		 }

	//Repaint original graphic after two cycles
		 y++;
		 if(y==2)
		 {
		 repaint();
		 y=0;
		 }
	   }
	}
}
//@@@@@@//
//Contrib/TouchWindow3.java
//@@@@@@//

// Noel Enete
// noel@enete.com

import java.applet.*;
import java.awt.*;
import java.awt.event.*;

public class TouchWindow3 extends Applet
      implements MouseMotionListener
      {
      int xMouse;
      int yMouse;
      int xWindow;
      int yWindow;


      public void init ()
        {
        addMouseMotionListener (this);
        }


      public void mouseDragged (MouseEvent evt)
        {
        xMouse = evt.getX ();
        yMouse = evt.getY ();
        repaint ();
        }
      public void mouseMoved (MouseEvent evt)
        {
        xMouse = evt.getX ();
        yMouse = evt.getY ();
        repaint ();
        }


      public void paint (Graphics g)
        {
        xWindow = getSize().width;
        yWindow = getSize().height;
        drawTinkerToys (g, 25);
        }


      void drawTinkerToys (Graphics g,
        int iNumSpokes)
        {
        int i;
        Color c;

        for (i = 0; i < iNumSpokes; i++)
          {
          c = new Color
            (
            (int) (255 * Math.random ()),
            (int) (255 * Math.random ()),
            (int) (255 * Math.random ())
            );
          g.setColor (c);

          g.drawLine
            (
            (int) (xWindow * Math.random ()),
            (int) (yWindow * Math.random ()),
            (int) (xWindow * Math.random ()),
            (int) (yWindow * Math.random ())
            );
          }
        }
      }

//@@@@@@//
//Contrib/treelayout/TreeLayout.java
//@@@@@@//

import java.util.*;
import java.awt.*;

/**
 * Simple layout manager that arranges its children in a tree.
 * The tree always expands to fill the available area, and the
 * internal components are resized to fit the area proportional
 * to their preferred size and the actual available size.
 *
 * This layout manager requires several method calls beyond the
 * normal layout manager. Please notice the following:
 *	* Components must be added using the add(String, Component) method.
 *	  The strings don't have to be unique, but must be present.
 *	* Each instance must have exactly one root object, 
 *	  which must be add()ed, <I>then</I> setRoot()ed.
 *	* Each component after the root must first be added and then must
 *	  be connected into the tree using setParent(child, parent).
 * 	* If you want lines between parents and children,
 *	  you <EM>must</EM> call paintLines() from your
 *	  applet's paint() method.
 *
 * @author	name unknown, xxx@blackdown.org
 */

public class TreeLayout implements LayoutManager
{
  TreeNode root;
  Hashtable nodes;

  public TreeLayout()
  { nodes = new Hashtable();  }

  public void addLayoutComponent(String name, Component comp)
  {
    TreeNode tn = new TreeNode(comp);
    nodes.put(comp, tn);
  }

  public void removeLayoutComponent(Component comp)
  { nodes.remove(comp);  }

  /**
   * You <em>must</em> make this call, otherwise none of the
   * components will be layed out.
   */
  public void setRoot(Component c)
  { root = (TreeNode) nodes.get(c); }

  /**
   * Sets the tree parent of a child. The components <em>must</em>
   * have been previously added. If either component has not
   * previously been added, this injunction is silently ignored.
   * Cycles are <em>not</em> checked.
   */
  public void setParent(Component child, Component parent)
  {
    TreeNode p = (TreeNode) nodes.get(parent);
    TreeNode c = (TreeNode) nodes.get(child);
    if ((p != null) && (c != null))   p.addChild(c);
  }

  public Dimension minimumLayoutSize(Container target)
  {
    Dimension d = root.getMinimumSize();
    Insets insets = target.getInsets();
    d.width += insets.left + insets.right;
    d.height += insets.top + insets.bottom;
    return d;
  }

  public Dimension preferredLayoutSize(Container target)
  {
    Dimension d = root.getPreferredSize();
    Insets insets = target.getInsets();
    d.width += insets.left + insets.right;
    d.height += insets.top + insets.bottom;
    return d;
  }

  public void layoutContainer(Container target)
  {
    Insets insets = target.getInsets();
    Dimension d = target.getSize();
    Dimension root_pref = root.getPreferredSize();
    double xscale =
      ((double)(d.width-insets.left-insets.right)/(double)(root_pref.width));
    double yscale =
      ((double)(d.height-insets.top-insets.bottom)/(double)(root_pref.height));
    root.doLayout(xscale, yscale, insets.left, insets.top);
  }

  /**
   * This piece of hackery is needed since one cant really draw things
   * from a layout manager. Call this if you want to draw lines between
   * components.
   */
  public void paintLines(Graphics g, Color bg)
  {
    Color dk = bg.darker();
    Color br = bg.brighter();
    root.paintLines(g, dk, br);
  }
}

class TreeNode
{
  Component comp;
  Vector children;
  Dimension prefSz, minSz;

  TreeNode(Component comp)
  {
    super();
    this.comp = comp;
    children = new Vector();
  }

  Dimension getMinimumSize()
  {
    if (!comp.isVisible()) return new Dimension(0, 0);
    if (minSz == null)
      {
	Dimension d = comp.getMinimumSize();
	minSz = new Dimension(d.width, d.height);

	if (children.size() > 0)
	  {
	    for (Enumeration e = children.elements();
		 e.hasMoreElements();)
	      {
		TreeNode t = (TreeNode)(e.nextElement());
		if (t.comp.isVisible())
		  {
		    d = t.getMinimumSize();
		    minSz.height += d.height;
		    minSz.width = Math.max(d.width, minSz.width);
		  }
	      }
	  }
      }
    return minSz;
  }

  Dimension getPreferredSize()
  {
    if (!comp.isVisible()) return new Dimension(0, 0);
    if (prefSz == null)
      {
	Dimension d = comp.getPreferredSize();
	prefSz = new Dimension(d.width, d.height);

	if (children.size() > 0)
	  {
	    int wmax = 0;
	    for (Enumeration e = children.elements();
		 e.hasMoreElements();)
	      {
		TreeNode t = (TreeNode)(e.nextElement());
		if (t.comp.isVisible())
		  {
		    d = t.getPreferredSize();
		    prefSz.height += d.height;
		    if (wmax < d.width)
		      { wmax = d.width; }
		  }
	      }
	    prefSz.width += wmax;
	  }
      }
    return prefSz;
  }

  void addChild(TreeNode t)
  {
    children.addElement(t);
    prefSz = null; minSz = null;
  }

  void removeChild(TreeNode t)
  {
    children.removeElement(t);
    prefSz = null; minSz = null;
  }

  void paintLines(Graphics g, Color dk, Color br)
  {
    if (comp.isVisible())
      {
	Rectangle b = comp.getBounds();
	int x1off = b.x + b.width/2;
	int x2off = b.x + b.width;
	int y1off = b.y;
	for (Enumeration e = children.elements();
	     e.hasMoreElements();)
	  {
	    TreeNode tn = (TreeNode)(e.nextElement());
	    if (tn.comp.isVisible())
	      {
		Rectangle bn = tn.comp.getBounds();
		int y2off = bn.y + bn.height/2;
		g.setColor(dk);
		g.drawLine(x1off, y1off, x1off, y2off);
		g.drawLine(x1off, y2off-1, x2off, y2off-1);
		g.setColor(br);
		g.drawLine(x1off+1, y1off, x1off+1, y2off);
		g.drawLine(x1off, y2off, x2off, y2off);
		tn.paintLines(g, dk, br);
	      }
	  }
      }
  }

	
  void doLayout(double xscale, double yscale, int x, int y)
  {
				// x and y are the offsets into the
				// Container where we start doing the
				// goodies for this Node
    if (comp.isVisible())
      {
	Dimension pref = comp.getPreferredSize();
	int ht = (int) Math.round(yscale*pref.height);
	int wd = (int) Math.round(xscale*pref.width);

	ht = (pref.height<ht) ? pref.height : ht;
        wd = (pref.width<wd) ? pref.width : wd;

	comp.setBounds(x, y, wd, ht);
	y += ht;
	x += wd;

	for (Enumeration e = children.elements();
	     e.hasMoreElements();)
	  {
	    TreeNode tn = (TreeNode)(e.nextElement());
	    if (tn.comp.isVisible())
	      {
		pref = tn.getPreferredSize();
		tn.doLayout(xscale, yscale, x, y);
		y += (int) Math.round(yscale * pref.height);

	      }
	  }
      }
  }
}
//@@@@@@//
//Contrib/treelayout/TreeLink.java
//@@@@@@//
import java.awt.*;
import java.applet.*;
import java.io.*;
import java.net.*;
import java.util.*;

/** Applet GUI demo of Gamelan TreeLayout layout manager. 
 * Constructs a tree and, for each entry, makes a button that jumps to it.
 *
 * The input language is a file like this:
 *	R Java Resources				# root
 *	L - Resources at Sun				# label
 *	B http://www.sun.com/foo/bar	Interesting Stuff # URLbutton
 *	B http://javasoft.com/b/c	More Stuff	# URLbutton
 *
 * The result is (supposedly) a beautiful(?) tree.
 * Each L is a top-level label, and each B is in the tree below it.
 *
 * Could be made much fancier with getParameter("FontName"), "FontSize",
 * adjusting width with fontMetrics, etc.  Works adequately for now.
 */
public class TreeLink extends Applet {
	Label root;
	TreeLayout tl;
	Label l;
	URLButton b;
	Hashtable h;
	int wid = 400, ht = 0, htIncr = 30;

	// Initialize this TreeLink applet
	public void init() {

		showStatus("TreeLink initializing tree...");

		URL origin = getCodeBase();

		h = new Hashtable();

		// Read the configuration file from the URL.
		try {

			setLayout(tl = new TreeLayout());

			String txt;
			String fn;	// Control file name
			if ((fn = getParameter("treelink")) == null)
				fn = "treelink.txt";
			URL ctlFile = new URL(origin, fn);
			BufferedReader is =
				new BufferedReader(
					new InputStreamReader(ctlFile.openStream()));

			// Read the control file a line at a time, parse
			// it, and save the ones that are links in 
			// the Hashtable indexed by their pushbutton

			while ((txt = is.readLine()) != null) {
				if (txt.startsWith("#"))
					continue;
				StringTokenizer st = new StringTokenizer(txt);
				if (st.countTokens() < 3) {
					println("TreeLink: Bad input: " + txt);
					return;
				}
				String type = st.nextToken();
				String bURL = st.nextToken();
				String text = "";
				while (st.hasMoreTokens())
					text += st.nextToken() + " ";
				// println("Type " + type + "; link " +
				// 	bURL + "; text " + text);
				ht += htIncr;
				if (type.equals("R")) {
					add("root",
					root = new Label(text));
					root.setBackground(Color.pink);
					tl.setRoot(root);	// required!
				} else if (type.equals("L")) {
					add("label", l = new Label(text));
					l.setBackground(Color.pink);
					tl.setParent(l, root);
				} else if (type.equals("B")) {
					URL u;
					if (bURL.indexOf(':') > 0)
						u = new URL(bURL);
					else
						u = new URL(origin, bURL);
					add("button", b = new URLButton(this, text, u));
					tl.setParent(b, l);
				} else {
					println("TreeLink: Invalid input " + txt);
				}
			}
		} catch(MalformedURLException mfc) {
			println("TreeLink: Error: " + mfc);
		} catch(IOException billg) {
			println("TreeLink: Error: " + billg);
		}

		setSize(wid, ht);
		System.out.println("Size now " + getSize());

		showStatus("TreeLink ready");
	}


	// Need to call paintLines from a "paint" method
	// to draw lines at right time...
	public void paint(Graphics g) {
		tl.paintLines(g, getForeground());
	}

	// Convenience Routine
	protected void println(String s) {
		System.out.println(s);
		showStatus("Informational message(s), see Java Console");
	}

	// Convenience Routine
	protected void eprintln(String s) {
		System.err.println(s);
		showStatus("Error, see Java Console");
	}

	/** Return information about this applet. */
	public String getAppletInfo() {
		return "TreeLink Demo Applet\n" +
			"Copyright Learning Tree International";
	}

	/** Return list of allowable parameters. */
	public String[][] getParameterInfo() {
		String param_info[][] = {
			{"TreeLink",    "filename",    "List of links"},
		};
		return param_info;
	}
}
//@@@@@@//
//Contrib/treelayout/TreeLink1_0.java
//@@@@@@//
import java.awt.*;
import java.applet.*;
import java.io.*;
import java.net.*;
import java.util.*;

/** Applet GUI demo of Gamelan TreeLayout layout manager. 
 * Constructs a tree and, for each entry, makes a button that jumps to it.
 *
 * The input language is a file like this:
 *	R Java Resources				# root
 *	L - Resources at Sun				# label
 *	B http://www.sun.com/foo/bar	Interesting Stuff # URLbutton
 *	B http://javasoft.com/b/c	More Stuff	# URLbutton
 *
 * The result is (supposedly) a beautiful(?) tree.
 * Each L is a top-level label, and each B is in the tree below it.
 *
 * Could be made much fancier with getParameter("FontName"), "FontSize",
 * adjusting width with fontMetrics, etc.  Works adequately for now.
 */
public class TreeLink1_0 extends Applet {
	Label root;
	TreeLayout tl;
	Label l;
	Button b;
	Hashtable h;
	int wid = 300, ht = 0, htIncr = 30;

	// Initialize this TreeLink1_0 applet
	public void init() {

		showStatus("TreeLink1_0 initializing tree...");

		URL origin = getCodeBase();

		h = new Hashtable();

		// Read the configuration file from the URL.
		try {

			setLayout(tl = new TreeLayout());

			String txt;
			String fn;	// Control file name
			if ((fn = getParameter("treelink")) == null)
				fn = "treelink.txt";
			URL ctlFile = new URL(origin, fn);
			DataInputStream is =
				new DataInputStream(ctlFile.openStream());

			// Read the control file a line at a time, parse
			// it, and save the ones that are links in 
			// the Hashtable indexed by their pushbutton

			while ((txt = is.readLine()) != null) {
				StringTokenizer st = new StringTokenizer(txt);
				if (st.countTokens() < 3) {
					println("TreeLink1_0: Bad input: " + txt);
					return;
				}
				String type = st.nextToken();
				String bURL = st.nextToken();
				String text = "";
				while (st.hasMoreTokens())
					text += st.nextToken() + " ";
				if (false)
					println("Type " + type + "; link " +
						bURL + "; text " + text);
				ht += htIncr;
				if (type.equals("R")) {
					add("root",
					root = new Label(text));
					root.setBackground(Color.pink);
					tl.setRoot(root);	// required!
				} else if (type.equals("L")) {
					add("label", l = new Label(text));
					l.setBackground(Color.pink);
					tl.setParent(l, root);
				} else if (type.equals("B")) {
					add("button", b = new Button(text));
					if (bURL.indexOf(':') > 0)
						h.put(b, new URL(bURL));
					else
						h.put(b, new URL(origin, bURL));
					tl.setParent(b, l);
				} else {
					println("TreeLink:1_0 Invalid input " + txt);
				}
			}
		} catch(MalformedURLException mfc) {
			println("TreeLink1_0: Error: " + mfc);
		} catch(IOException billg) {
			println("TreeLink1_0: Error: " + billg);
		}

		setSize(wid, ht);
		System.out.println("Size now " + size());

		showStatus("TreeLink1_0 ready");
	}

	public boolean action(Event e, Object o) {
		URL u = (URL)h.get(e.target);
		showStatus("Showing document at URL " + u);

		getAppletContext().showDocument(u);
		// No error checking on showDocument() -- the
		// browser will honk at the user if the link
		// is invalid. We should open "u" ourselves,
		// check the open, and close it. Or not...

		return true;
	}
 
	// Need to call paintLines from a "paint" method
	// to draw lines at right time...
	public void paint(Graphics g) {
		tl.paintLines(g, getForeground());
	}

	// Convenience Routine
	protected void println(String s) {
		System.out.println(s);
		showStatus("Informational message(s), see Java Console");
	}

	// Convenience Routine
	protected void eprintln(String s) {
		System.err.println(s);
		showStatus("Error, see Java Console");
	}

	/** Return information about this applet. */
	public String getAppletInfo() {
		return "TreeLink1_0 Demo Applet\n" +
			"Copyright Learning Tree International";
	}

	/** Return list of allowable parameters. */
	public String[][] getParameterInfo() {
		String param_info[][] = {
			{"TreeLink1_0",    "filename",    "List of links"},
		};
		return param_info;
	}
}
//@@@@@@//
//Contrib/treelayout/TreeLinkTest.java
//@@@@@@//
import java.applet.*;
import java.awt.*;

public class TreeLinkTest extends Applet
{
	TreeLayout tl;
	public void init()
	{
		tl = new TreeLayout();
		setLayout(tl);
		Button root = new Button("This is the root");
		add("Root", root); tl.setRoot(root);
		Component x = new Label("A random label");
		add("label", x);tl.setParent(x, root);
		Component y;
		y = new TextField("Add any component");
		add("comp", y); tl.setParent(y, root);
		x = new List();
		((List)x).add("List entry");
		((List)x).add("Similarly useless list entry");
		add("list", x); tl.setParent(x, root);
		x=new Button("Extremely long and unnecessary button title");
		add("button", x); tl.setParent(x, y);
		x = new MyCanvas(getImage(getDocumentBase(), "icons/tools.gif"));
		add("image", x); tl.setParent(x, y);
	}

	public void paint(Graphics g)
	{
		super.paint(g);
		tl.paintLines(g, getBackground());
	}

	class MyCanvas extends Canvas {
		Image img;

		MyCanvas(Image img) {
			this.img = img;
		}
		public Dimension getPreferredSize() {
			return new Dimension(64, 64);
		} 
		public void update(Graphics g) {
			paint(g);
		}
		public void paint(Graphics g)
		{
			g.drawImage(img, 0, getSize().height/2 - 16, 32, 32, this);
		}
	}
}
//@@@@@@//
//Contrib/Wavelet.java
//@@@@@@//
import java.awt.*;
import java.applet.*;

/** Simple Applet demo, showing a math function.
 * @author Arthur Van Hoff, avh
 * @author Ian F. Darwin, http://www.darwinsys.com/
 */
public class Wavelet extends Applet {
	/** Called by AWT when the window needs painting; just recompute
	 * all the data and draw it, since it's a simple calculation and
	 * simpler than precomputing and storing the data.
	 */
    public void paint(Graphics g) {
		Dimension d = getSize();
        for (int x = 0 ; x < d.width ; x++) {
			g.drawLine(x, 20+(int)func(x), x + 1, 20+(int)func(x + 1));
        }
    }

	/** This is the function that is plotted. */
    double func(double x) {
		Dimension d = getSize();
		return (Math.cos(x/9) + Math.sin(x/3) + 1) * d.height / 4;
    }
}
//@@@@@@//
//Contrib/XSplineFun.java
//@@@@@@//
/**
 * Xsplinefun displays colorful moving splines in a window.
 *
 * Taken from xsplinefun, Distribution of 02may92, by Jef Poskanzer,
 *  jef@netcom.com, jef@well.sf.ca.us
 *
 * @copyright (C) 1992 by Jef Poskanzer
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided
 * that the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation.  This software is provided "as is" without express or
 * implied warranty.
 *
 * First step in converting to Java was to junk all the X Windows stuff;
 * in the process we lost all the customization (need to re-add with getopt?).
 */
public class XSplineFun {
	public static final int POINTS = 20;
	public static final int DEFAULT_MAX_COLORS = 20;

	/* Spline-fun smarts. */

	static int x[POINTS], y[POINTS], dx[POINTS], dy[POINTS];
	static int nred, ngreen, nblue, dred, dgreen, dblue;
	static int color;
	static XColor xcolors[DEFAULT_MAX_COLORS];

	public static void main(String[] av) {
		Frame f = new Frame("Spline Fun");
		XSplineFun xf = new XSplineFun();
		xf.init_splines();
		f.add(xf);
		while(true)
			try {
				xf.move_splines();
				Thread.sleep(150);		// msec
			} catch (Exception e) {
				System.out.println(e);
			}
	}

	static void
	init_splines()
	{
		int i;

		/* Initialize points. */
		for ( i = 0; i < POINTS; ++i )
		{
		x[i] = random() % width;
		y[i] = random() % height;
		dx[i] = random() % ( MAX_DELTA * 2 ) - MAX_DELTA;
		if ( dx[i] <= 0 ) --dx[i];
		dy[i] = random() % ( MAX_DELTA * 2 ) - MAX_DELTA;
		if ( dy[i] <= 0 ) --dy[i];
		}

		/* Initalize colors. */
		for ( color = 0; color < ncolors; ++color )
		{
		xcolors[color].red = xcolors[color].green = xcolors[color].blue = 0;
		xcolors[color].pixel = pixels[color];
		xcolors[color].flags = DoRed|DoGreen|DoBlue;
		}
		color = 0;
		nred = ngreen = nblue = 0;
		dred = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
		if ( dred <= 0 ) --dred;
		dgreen = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
		if ( dgreen <= 0 ) --dgreen;
		dblue = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
		if ( dblue <= 0 ) --dblue;
	}

	static void
	rotate_colormap()
	{
		int t, i;

		if ( forwards )
		{
		t = xcolors[0].pixel;
		for ( i = 0; i < ncolors - 1; ++i )
			xcolors[i].pixel = xcolors[i + 1].pixel;
		xcolors[ncolors - 1].pixel = t;
		XStoreColors(display, cmap, xcolors, ncolors );
		}
		else if ( backwards )
		{
		t = xcolors[ncolors - 1].pixel;
		for ( i = ncolors - 1; i > 0; --i )
			xcolors[i].pixel = xcolors[i - 1].pixel;
		xcolors[0].pixel = t;
		XStoreColors(display, cmap, xcolors, ncolors );
		}
	}

	static void
	new_color()
	{
		int t;

		for ( ; ; )
		{
		t = (int) nred + dred;
		if ( t >= 0 && t < 65536 ) break;
		dred = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
		if ( dred <= 0 ) --dred;
		}
		xcolors[color].red = nred = t;
		for ( ; ; )
		{
		t = (int) ngreen + dgreen;
		if ( t >= 0 && t < 65536 ) break;
		dgreen = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
		if ( dgreen <= 0 ) --dgreen;
		}
		xcolors[color].green = ngreen = t;
		for ( ; ; )
		{
		t = (int) nblue + dblue;
		if ( t >= 0 && t < 65536 ) break;
		dblue = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
		if ( dblue <= 0 ) --dblue;
		}
		xcolors[color].blue = nblue = t;
		XStoreColor(display, cmap, &(xcolors[color]) );
		XSetForeground( display, gc, xcolors[color].pixel );
		if ( ++color >= ncolors ) color -= ncolors;
	}

	static void
	move_splines()
	{
		int i, t, px, py, zx, zy, nx, ny;

		/* Rotate colormap if necessary. */
		rotate_colormap();

		/* Choose new color. */
		new_color();

		/* Backwards rotation requires two new colors each loop. */
		if ( backwards )
		new_color();

		/* Move the points. */
		for ( i = 0; i < POINTS; i++ )
		{
		for ( ; ; )
			{
			t = x[i] + dx[i];
			if ( t >= 0 && t < width ) break;
			dx[i] = random() % ( MAX_DELTA * 2 ) - MAX_DELTA;
			if ( dx[i] <= 0 ) --dx[i];
			}
		x[i] = t;
		for ( ; ; )
			{
			t = y[i] + dy[i];
			if ( t >= 0 && t < height ) break;
			dy[i] = random() % ( MAX_DELTA * 2 ) - MAX_DELTA;
			if ( dy[i] <= 0 ) --dy[i];
			}
		y[i] = t;
		}

		/* Draw the figure. */
		px = zx = ( x[0] + x[POINTS-1] ) / 2;
		py = zy = ( y[0] + y[POINTS-1] ) / 2;
		for ( i = 0; i < POINTS-1; ++i )
		{
		nx = ( x[i+1] + x[i] ) / 2;
		ny = ( y[i+1] + y[i] ) / 2;
		XDrawSpline(g, px, py, x[i], y[i], nx, ny );
		px = nx;
		py = ny;
		}
		XDrawSpline(g, px, py, x[POINTS-1], y[POINTS-1], zx, zy );
	}


	/* X spline routine. */

	int abs(x) {
		return x < 0 ? -x : x;
	}

	static void
	XDrawSpline(Graphics g, int x0, y0, x1, y1, x2, y2) {
		register int xa, ya, xb, yb, xc, yc, xp, yp;

		xa = ( x0 + x1 ) / 2;
		ya = ( y0 + y1 ) / 2;
		xc = ( x1 + x2 ) / 2;
		yc = ( y1 + y2 ) / 2;
		xb = ( xa + xc ) / 2;
		yb = ( ya + yc ) / 2;

		xp = ( x0 + xb ) / 2;
		yp = ( y0 + yb ) / 2;
		if ( abs( xa - xp ) + abs( ya - yp ) > SPLINE_THRESH )
		XDrawSpline( display, d, gc, x0, y0, xa, ya, xb, yb );
		else
		XDrawLine( display, d, gc, x0, y0, xb, yb );

		xp = ( x2 + xb ) / 2;
		yp = ( y2 + yb ) / 2;
		if ( abs( xc - xp ) + abs( yc - yp ) > SPLINE_THRESH )
		XDrawSpline( display, d, gc, xb, yb, xc, yc, x2, y2 );
		else
		XDrawLine( display, d, gc, xb, yb, x2, y2 );
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/database/DataBaseException.java
//@@@@@@//
package com.darwinsys.database;

/** Checked Exception DataBase Failures (so most of code does not
 * need to import SQLException).
 */
public class DataBaseException extends RuntimeException {
	public DataBaseException() {
		super();
	}
	public DataBaseException(String msg) {
		super(msg);
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/database/InsertException.java
//@@@@@@//
package com.darwinsys.database;

/** Checked Exception for failed insertions */
public class InsertException extends DataBaseException {
	public InsertException() {
		super();
	}
	public InsertException(String msg) {
		super(msg);
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/html/Tag.java
//@@@@@@//
package com.darwinsys.html;

import java.io.*;

/** A series of methods for writing HTML/XML tags.
 * Substantially less capable than Jakarta Element Constructor Set (ECS),
 * but simpler to get started with.
 * <p>
 * All methods are static for ease of use.
 * @version $Id: Tag.java,v 1.3 2003/05/29 18:06:30 ian Exp $
 */
public class Tag {
	protected static final char LB = '<';
	protected static final char RB = '>';
	protected static final char END = '/';

	/** Output an empty tag */
	public static void dotag(PrintWriter out, String tag) {
		startTag(out, tag);
		endTag(out, tag);
	}

	/** Output an body-content tag */
	public static void doTag(PrintWriter out, String tag, String content) {
		startTag(out, tag);
		out.println(content);
		endTag(out, tag);
	}

	/** Output a start tag */
	public static void startTag(PrintWriter out, String tag) {
		out.print(
			new StringBuffer(LB).append(tag).append(RB).toString());
	}

	/** Output an end tag */
	public static void endTag(PrintWriter out, String tag) {
		out.print(
			new StringBuffer(LB).append(END).append(tag).append(RB).toString());
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/io/ByteArrayDumpGetter.java
//@@@@@@//
package com.darwinsys.io;

/** A Getter that reads from an in-memory array of bytes */
class ByteArrayDumpGetter implements DumpGetter {

	public ByteArrayDumpGetter(byte[] d) {
		data = d;
		offset = 0;
		max = data.length;
	}

	private byte[] data;
	private int offset;
	private int max;

	public int get() {
		if (offset < max)
			return data[offset++];
		return -1;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/io/DataIO.java
//@@@@@@//
package com.darwinsys.io;

import java.io.*;

/**
 * Some I-O primitives for datastreams.
 * All methods are static, since there is no state.
 * @version $Id: DataIO.java,v 1.3 2004/03/07 17:14:57 ian Exp $
 */
public class DataIO {

	/** Nobody should need to create an instance; all methods are static */
	private DataIO() { 
		// nothing to do
	}

    /** Read an unsigned int from a DataInput
	 * @param is DataInput (DataInputStream, RandomAccessFile, etc).
	 * @return long, to hold an unsigned int.
	 */
    public static long readUnsignedInt(DataInput is) throws IOException {
		// Need to read 4 bytes from the input, unsigned.
		// Do it yourself; there is no readUnsignedInt().
		return
			((long)(is.readUnsignedByte() & 0xff) << 24) |
			((long)(is.readUnsignedByte() & 0xff) << 16) |
			((long)(is.readUnsignedByte() & 0xff) <<  8) |
			((long)(is.readUnsignedByte() & 0xff) <<  0);
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/io/Dumper.java
//@@@@@@//
package com.darwinsys.io;

import java.io.*;
import java.text.*;

/**
 * Class to do formatted dump ("hex dump") of data from various sources.
 * For example, the first few lines of running "java Dumper" with this
 * class' class file as its argument might look like this:
 * <pre>
 * 00016: ca fe ba be 00 00 00 2e 00 87 0a 00 29 00 3d 07  ???????.........
 * 00032: 00 3e 08 00 3f 0a 00 02 00 40 09 00 0a 00 41 07  ..............A.
 * 00048: 00 42 0a 00 06 00 3d 09 00 0a 00 43 09 00 0a 00  .B.........C....
 * 00064: 44 07 00 45 0a 00 0a 00 3d 07 00 46 09 00 47 00  D..E.......F..G.
 * 00080: 48 0a 00 0c 00 49 0a 00 0a 00 4a 07 00 4b 0a 00  H....I....J..K..
 * 00096: 10 00 40 07 00 4c 09 00 47 00 4d 0a 00 4e 00 4f  .....L..G.M..N.O
 * 00112: 09 00 47 00 50 09 00 0a 00 51 0a 00 52 00 53 0a  ..G.P....Q..R.S.
 * 00128: 00 4e 00 54 08 00 55 0a 00 4e 00 56 0a 00 4e 00  .N.T..U..N.V..N.
 * 00144: 57 0a 00 4e 00 58 0a 00 06 00 59 0a 00 06 00 5a  W..N.X....Y....Z
 * 00160: 0a 00 5b 00 5c 0a 00 06 00 5d 0a 00 5e 00 5f 0a  ................
 * 00176: 00 0a 00 60 0b 00 61 00 62 07 00 63 08 00 64 0a  ......a.b..c..d.
 * 00192: 00 24 00 65 0a 00 06 00 65 0a 00 4e 00 66 07 00  ...e....e..N.f..
 * 00208: 67 01 00 0f 6f 66 66 73 65 74 46 6f 72 6d 61 74  g...offsetFormat
 * 00224: 74 65 72 01 00 18 4c 6a 61 76 61 2f 74 65 78 74  ter...Ljava.text
 * 00240: 2f 4e 75 6d 62 65 72 46 6f 72 6d 61 74 3b 01 00  .NumberFormat...
 * 00256: 0e 42 59 54 45 53 5f 50 45 52 5f 4c 49 4e 45 01  .BYTES.PER.LINE.
 * 00272: 00 01 49 01 00 0d 43 6f 6e 73 74 61 6e 74 56 61  ..I...ConstantVa
 * 00288: 6c 75 65 03 00 00 00 10 01 00 03 6e 75 6d 01 00  lue........num..
 * 00304: 18 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69  .Ljava.lang.Stri
 * 00320: 6e 67 42 75 66 66 65 72 3b 01 00 03 74 78 74 01  ngBuffer....txt.
 * </pre>
 * @author Ian F. Darwin, http://www.darwinsys.com/contact.html
 * @version $Id: Dumper.java,v 1.14 2003/05/30 13:16:07 ian Exp $
 */
public class Dumper {

	/** A formatter for the offset */
	NumberFormat offsetFormatter = new DecimalFormat("00000");

	public static void main(String[] av) throws IOException {
		Dumper c = new Dumper();
		switch(av.length) {
		case 0: c.dump(new StreamDumpGetter(System.in));
			break;
		default:
			for (int i=0; i<av.length; i++)
				try {
					c.dump(new StreamDumpGetter(new FileInputStream(av[i])));
				} catch (FileNotFoundException e) {
					System.err.println(e);
				}
		}
	}

	/** The number of items per line */
	public final static int BYTES_PER_LINE = 16;

	protected StringBuffer num = new StringBuffer();
	protected StringBuffer txt = new StringBuffer();

	private int offset;

	/** Output the line's bytes and printables, send line end,
	 * and reset the two StringBuffers.
	 */
	protected void endOfLine() {
		System.out.print(offsetFormatter.format(offset += BYTES_PER_LINE));
		System.out.print(": ");
		System.out.print(num);
		System.out.print(' ');
		System.out.print(txt);
		System.out.println();
		num.setLength(0);
		txt.setLength(0);
	}

	/** print one file, given an open InputStream */
	public void dump(DumpGetter g) {
		num.setLength(0);
		txt.setLength(0);

		offset = 0;
		
		try {
			int b = 0;
			int column = 0;

			while ((b=g.get()) != -1) {
				// XXX sleazebag formatting
				if (b < 16)
					num.append('0');
				num.append(Integer.toString(b, 16));
				num.append(' ');
				txt.append(Character.isLetterOrDigit((char)b) ? (char)b : '.');

				if (++column % BYTES_PER_LINE == 0) {
					endOfLine();
				}
			}
			// if partial line, output it.
			if (++column % BYTES_PER_LINE != 0) {
				endOfLine();
			}
			System.out.println();
		} catch (IOException ex) {
			System.out.println("Dumper: " + ex.toString());
		}
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/io/DumpGetter.java
//@@@@@@//
package com.darwinsys.io;

import java.io.*;

/** The general contract of a class to get bytes.
  * Used in Dumper and related classes.
  */
public interface DumpGetter {
	public int get() throws IOException;
}

//@@@@@@//
//darwinsys/src/com/darwinsys/io/FileIO.java
//@@@@@@//
package com.darwinsys.io;

import java.io.*;

/**
 * Some simple file I-O primitives reimplemented in Java.
 * All methods are static, since there is no state.
 * @version $Id: FileIO.java,v 1.18 2004/05/30 01:39:27 ian Exp $
 */
public class FileIO {

	/** Nobody should need to create an instance; all methods are static */
	private FileIO() {
		// Nothing to do
	}

    /** Copy a file from one filename to another */
    public static void copyFile(String inName, String outName)
	throws FileNotFoundException, IOException {
		BufferedInputStream is = 
			new BufferedInputStream(new FileInputStream(inName));
		BufferedOutputStream os = 
			new BufferedOutputStream(new FileOutputStream(outName));
		copyFile(is, os, true);
	}

	/** Copy a file from an opened InputStream to opened OutputStream */
	public static void copyFile(InputStream is, OutputStream os, boolean close) 
	throws IOException {
		byte[] b = new byte[BLKSIZ];				// the byte read from the file
		int i;
		while ((i = is.read(b)) != -1) {
			os.write(b, 0, i);
		}
		is.close();
		if (close)
			os.close();
    }

	/** Copy a file from an opened Reader to opened Writer */
	public static void copyFile(Reader is, Writer os, boolean close) 
	throws IOException {
		int b;				// the byte read from the file
		BufferedReader bis = new BufferedReader(is);
		while ((b = is.read()) != -1) {
			os.write(b);
		}
		is.close();
		if (close)
			os.close();
    }

	/** Copy a file from a filename to a PrintWriter. */
	public static void copyFile(String inName, PrintWriter pw, boolean close) 
	throws FileNotFoundException, IOException {
		BufferedReader ir = new BufferedReader(new FileReader(inName));
		copyFile(ir, pw, close);
	}

	/** Open a file and read the first line from it. */
	public static String readLine(String inName)
	throws FileNotFoundException, IOException {
		BufferedReader is = new BufferedReader(new FileReader(inName));
		String line = null;
		line = is.readLine();
		is.close();
		return line;
	}

	/** The size of blocking to use */
	protected static final int BLKSIZ = 16384;

	/** Copy a data file from one filename to another, alternate method.
	 * As the name suggests, use my own buffer instead of letting
	 * the BufferedReader allocate and use the buffer.
	 */
	public void copyFileBuffered(String inName, String outName) throws
			FileNotFoundException, IOException {
		InputStream is = new FileInputStream(inName);
		OutputStream os = new FileOutputStream(outName);
		int count = 0;		// the byte count
		byte[] b = new byte[BLKSIZ];	// the bytes read from the file
		while ((count = is.read(b)) != -1) {
			os.write(b, 0, count);
		}
		is.close();
		os.close();
	}

	/** Read the entire content of a Reader into a String */
	public static String readerToString(Reader is) throws IOException {
		StringBuffer sb = new StringBuffer();
		char[] b = new char[BLKSIZ];
		int n;

		// Read a block. If it gets any chars, append them.
		while ((n = is.read(b)) > 0) {
			sb.append(b, 0, n);
		}

		// Only construct the String object once, here.
		return sb.toString();
	}

	/** Read the content of a Stream into a String */
	public static String inputStreamToString(InputStream is)
	throws IOException {
		return readerToString(new InputStreamReader(is));
	}

	/** Write a String as the entire content of a File */
	public static void stringToFile(String text, String fileName)
	throws IOException {
		BufferedWriter os = new BufferedWriter(new FileWriter(fileName));
		os.write(text);
		os.flush();
		os.close();
	}

	/** Open a BufferedReader from a named file. */
	public static BufferedReader openFile(String fileName)
	throws IOException {
		return new BufferedReader(new FileReader(fileName));
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/io/StreamDumpGetter.java
//@@@@@@//
package com.darwinsys.io;

import java.io.*;

/** A DumpGetter that reads from a file. */
public class StreamDumpGetter implements DumpGetter {
	private BufferedInputStream is;
	public StreamDumpGetter(InputStream ois) throws IOException {
		if (ois instanceof BufferedInputStream)
			is = (BufferedInputStream)ois;
		else
			is = new BufferedInputStream(ois);
	}

	public int get() throws IOException {
		return is.read();
	}

	public void close() throws IOException {
		is.close();
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/jsptags/BackRefTag.java
//@@@@@@//
package com.darwinsys.jsptags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.JspWriter;
import javax.servlet.jsp.tagext.TagSupport;


/**
 * BackRefTag - generate a href back to the referrer, initially for use on help.
 * @version $Id: BackRefTag.java,v 1.3 2004/06/16 18:50:24 ian Exp $
 */
public class BackRefTag extends TagSupport {
	private final static String DEFAULT_LABEL = "Back";
	private String surroundingtag;
	private String label;

	/** Invoked at the end tag boundary, does the work */
	public int doEndTag() throws JspException {
		final String myLabel = label == null ? DEFAULT_LABEL : label;
		try {
			final HttpServletRequest request = (HttpServletRequest)pageContext.getRequest();
			final JspWriter out = pageContext.getOut();
			final String whereFrom = request.getHeader("referer");
			if (whereFrom == null) {
				System.out.println("Warning: BackRefTag: no referer");
				return SKIP_BODY;
			}
			if (surroundingtag != null) {
				out.println("<" + surroundingtag + ">");
			}
			out.println("<a href=" + whereFrom + ">" + 
							(label == null ? DEFAULT_LABEL : label) + "</a>");
			if (surroundingtag != null) {
				out.println("<" + "/" + surroundingtag + ">");
			}
			out.flush();
			return SKIP_BODY;
		} catch (Throwable t) {
			System.err.println("Tag caught: " + t);
			throw new JspException(t.toString());
		}
	}

	/**
	 * @param lab The label to print (e.g., "Back");
	 */
	public void setLabel(String lab) {
		label = lab;
	}
	
	/**
	 * @param surround The HTML tag to surrounding the link (e.g., "h6").
	 */
	public void setSurroundingtag(String surround) {
		surroundingtag = surround;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/jsptags/LoggedInRoleTag.java
//@@@@@@//
package com.darwinsys.jsptags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.tagext.BodyTagSupport;

/**
 * LoggedInRole - include body content if user is logged in as a user that has this "role".
 * @version $Id: LoggedInRoleTag.java,v 1.4 2004/06/16 18:50:24 ian Exp $
 */
public class LoggedInRoleTag extends BodyTagSupport {
	private String role;

	/** Invoked at the start tag boundary; does the work. */
	public int doStartTag() throws JspException {
		String myLabel = null;

		HttpServletRequest request = (HttpServletRequest)pageContext.getRequest();
		return request.isUserInRole(role) ? EVAL_BODY_INCLUDE : SKIP_BODY;

	}

	/**
	 * @param r The role to check for (e.g., "admin");
	 */
	public void setRole(String r) {
		role = r;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/jsptags/LoggedInTag.java
//@@@@@@//
package com.darwinsys.jsptags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.tagext.BodyTagSupport;

/**
 * LoggedInUser - include body content if the user is logged in as "user".
 * @version $Id: LoggedInTag.java,v 1.2 2004/06/16 18:50:24 ian Exp $
 */
public class LoggedInTag extends BodyTagSupport {
	private String userName;

	/** Invoked at the tag start boundary; does the work */
	public int doStartTag() throws JspException {
		String myLabel = null;

		HttpServletRequest request = (HttpServletRequest)pageContext.getRequest();
		return request.getRemoteUser().equals(null) ? 
				SKIP_BODY :
				EVAL_BODY_INCLUDE  ;

	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/jsptags/LoggedInUserTag.java
//@@@@@@//
package com.darwinsys.jsptags;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.jsp.JspException;
import javax.servlet.jsp.tagext.BodyTagSupport;

/**
 * LoggedInUser - include body content if the user is logged in as "user".
 * @version $Id: LoggedInUserTag.java,v 1.3 2004/06/16 18:50:24 ian Exp $
 */
public class LoggedInUserTag extends BodyTagSupport {
	private String userName;

	/** Invoked at the tag start transition; does the work */
	public int doStartTag() throws JspException {
		String myLabel = null;

		HttpServletRequest request = (HttpServletRequest)pageContext.getRequest();
		return request.getRemoteUser().equals(userName) ? EVAL_BODY_INCLUDE : SKIP_BODY;

	}

	/**
	 * @param label The role to check for (e.g., "admin");
	 */
	public void setUser(String label) {
		this.userName = label;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/lang/ExecAndPrint.java
//@@@@@@//
package com.darwinsys.lang;

import com.darwinsys.io.*;
import java.io.*;

/**
 * ExecAndPrint runs a program using Runtime.exec(),
 * read the program's output, and returns its exit status.
 */
public class ExecAndPrint {

	/** Need a Runtime object for any of these methods */
	protected static Runtime r = Runtime.getRuntime();

	/** Run the command given as a String, printing its output to System.out */
	public static int run(String cmd) throws IOException { 
		return run(cmd, new OutputStreamWriter(System.out));
	}

	/** Run the command given as a String, print its output to "out" */
	public static int run(String cmd, Writer out) throws IOException { 

		String line;
		
		Process p = r.exec(cmd);

		FileIO.copyFile(new InputStreamReader(p.getInputStream()), out, true);
		try {
			p.waitFor();	// wait for process to complete
		} catch (InterruptedException e) {
			return -1;
		}
		return p.exitValue();
	}

	/** Run the command given as a String[], print its output to System.out */
	public static int run(String[] cmd) throws IOException { 
		return run(cmd, new OutputStreamWriter(System.out));
	}

	/** Run the command given as a String[], print its output to "out" */
	public static int run(String[] cmd, Writer out) throws IOException { 

		String line;
		
		Process p = r.exec(cmd);

		FileIO.copyFile(new InputStreamReader(p.getInputStream()), out, true);

		try {
			p.waitFor();	// wait for process to complete
		} catch (InterruptedException e) {
			return -1;
		}
		return p.exitValue();
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/lang/GetOpt.java
//@@@@@@//
package com.darwinsys.lang;

import com.darwinsys.util.Debug;

import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;

/** A class to implement UNIX-style (single-character) command line argument
 * parsing. Originally patterned after (but not using code from) the UNIX 
 * getopt(3) program, this has been redesigned to be more Java-friendly.
 * As a result, there are two ways of using it.
 * <ol><li>Original model:
 * <pre>
        GetOpt go = new GetOpt("hno:");
        boolean numeric_option = false;
        String outFileName = "(standard output)";
        char c;
        while ((c = go.getopt(args)) != GetOpt.DONE) {
            switch(c) {
            case 'h':
                doHelp(0);
                break;
            case 'n':
                numeric_option = true;
                break;
            case 'o':
                outFileName = go.optarg();
                break;
            default:
                System.err.println("Unknown option character " + c);
                doHelp(1);
            }
        }
        System.out.print("Options: ");
        System.out.print("Numeric: " + numeric_option + ' ');
        System.out.print("Output: " + outFileName + "; ");
        System.out.print("Inputs: ");
        if (go.getOptInd() == args.length) {
            doFile("(standard input)");
        } else for (int i = go.getOptInd(); i < args.length; i++) {
            doFile(args[i]);
        }
 * </pre></li>
 * <li>Newer model, which allows long-named options:
 * <pre>
        boolean numeric_option = false;
        boolean errs = false;
        String outputFileName = null;

        GetOptDesc options[] = {
            new GetOptDesc('n', "numeric", false),
            new GetOptDesc('o', "output-file", true),
        };
        GetOpt parser = new GetOpt(options);
        Map optionsFound = parser.parseArguments(argv);
        Iterator it = optionsFound.keySet().iterator();
        while (it.hasNext()) {
            String key = (String)it.next();
            char c = key.charAt(0);
            switch (c) {
                case 'n':
                    numeric_option = true;
                    break;
                case 'o':
                    outputFileName = (String)optionsFound.get(key);
                    break;
                case '?':
                    errs = true;
                    break;
                default:
                    throw new IllegalStateException(
                    "Unexpected option character: " + c);
            }
        }
        if (errs) {
            System.err.println("Usage: GetOptDemo [-n][-o file][file...]");
        }
        System.out.print("Options: ");
        System.out.print("Numeric: " + numeric_option + ' ');
        System.out.print("Output: " + outputFileName + "; ");
        System.out.print("Input files: ");
        List files = parser.getFilenameList();
        while (files.hasNext()) {
            System.out.print(files.next());
            System.out.print(' ');
        }
        System.out.println();
	}
 * </pre></li>
 * </ol>
 * <p>
 * This is <em>not</em> threadsafe; it is expected to be used only from main().
 * <p>
 * For another way of dealing with command lines, see the
 * <a href="http://jakarta.apache.org/commons/cli/">Jakarta Commons
 * Command Line Interface</a>.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: GetOpt.java,v 1.23 2004/06/01 02:51:36 ian Exp $
 */
public class GetOpt {
	/** The List of File Names found after args */
	protected List fileNameArguments;
	/** The set of characters to look for */
	protected final GetOptDesc[] options;
	/** Where we are in the options */
	protected int optind = 0;
	/** Public constant for "no more options" */
	public static final int DONE = 0;
	/** Internal flag - whether we are done all the options */
	protected boolean done = false;
	/** The current option argument. */
	protected String optarg;

	/** Retrieve the current option argument; UNIX variant spelling. */
	public String optarg() {
		return optarg;
	}
	/** Retrieve the current option argument; Java variant spelling. */
	public String optArg() {
		return optarg;
	}

	/* Construct a GetOpt parser, given the option specifications
	 * in an array of GetOptDesc objects. This is the preferred constructor.
	 */
	public GetOpt(final GetOptDesc[] opt) {
		this.options = opt;
	}

	/* Construct a GetOpt parser, storing the set of option characters.
	 * This is a legacy constructor for backwards compatibility.
	 */
	public GetOpt(final String patt) {
		if (patt == null) {
			throw new IllegalArgumentException("Pattern may not be null");
		}

		// Pass One: just count the letters
		int n = 0;
		for (int i = 0; i<patt.length(); i++) {
			if (patt.charAt(i) != ':')
				++n;
		}
		if (n == 0) {
			throw new IllegalArgumentException(
				"No option letters found in " + patt);
		}

		// Pass Two: construct an array of GetOptDesc opjects.
		options = new GetOptDesc[n];
		for (int i = 0, ix = 0; i<patt.length(); i++) {
			final char c = patt.charAt(i);
			boolean argTakesValue = false;
			if (i < patt.length() - 1 && patt.charAt(i+1) == ':') {
				argTakesValue = true;
				++i;
			}
			options[ix] = new GetOptDesc(c, null, argTakesValue);
			Debug.println("getopt",
				"CONSTR: options[" + ix + "] = " + c + ", " + argTakesValue);
			++ix;
		}
	}

	/** Reset this GetOpt parser */
	public void rewind() {
		fileNameArguments = null;
		done = false;
		optind = 0;
	}

	/** Array used to convert a char to a String */
	private static char[] strConvArray = { 0 };

	/** 
	 * Modern way of using GetOpt: call this once and get all options.
	 * <p>
	 * This parses the options, returns a Map whose keys are the found options.
	 * Normally followed by a call to getFilenameList().
	 * @return a Map whose keys are Strings of length 1 (containing the char
	 * from the option that was matched) and whose value is a String
	 * containing the value, or null for a non-option argument.
	 */
	public Map parseArguments(String[] argv) {
		Map optionsAndValues = new HashMap();
		fileNameArguments = new ArrayList();
		for (int i = 0; i < argv.length; i++) {
			Debug.println("getopt", "parseArg: i=" + i + ": arg " + argv[i]);
			char c = getopt(argv);
			if (c != DONE) {
				strConvArray[0] = c;
				optionsAndValues.put(new String(strConvArray), optarg);
				// If this arg takes an option, we must skip it here.
				if (optarg != null)
					++i;
			} else {
				fileNameArguments.add(argv[i]);
			}
		}
		return optionsAndValues;
	}

	/** Get the list of filename-like arguments after options */
	public List getFilenameList() {
		if (fileNameArguments == null) {
			throw new IllegalArgumentException(
				"Illegal call to getFilenameList() before parseOptions()");
		}
		return fileNameArguments;
	}

	/** The true heart of getopt, whether used old way or new way:
	 * returns one argument; call repeatedly until it returns DONE.
	 */
	public char getopt(String argv[]) {
		Debug.println("getopt",
			"optind=" + optind + ", argv.length="+argv.length);

		if (optind >= (argv.length)-1) {
			done = true;
		}

		// If we are (now) finished, bail.
		if (done) {
			return DONE;
		}

		// XXX TODO - two-pass, 1st check long args, 2nd check for
		// char, may be multi char as in "-no outfile" == "-n -o outfile".

		// Pick off the next command line argument, check if it starts "-".
		// If so look it up in the list.
		String thisArg = argv[optind++];
		if (thisArg.startsWith("-")) {
			optarg = null;
			for (int i=0; i<options.length; i++) {
				if ( options[i].argLetter == thisArg.charAt(1) ||
					(options[i].argName != null &&
					 options[i].argName == thisArg.substring(1))) { // found it
					// If it needs an option argument, get it.
					if (options[i].takesArgument) {
						if (optind < argv.length) {
							optarg = argv[optind]; 
							++optind;
						} else {
							throw new IllegalArgumentException(
								"Option " + options[i].argLetter +
								" needs value but found end of arg list");
						}
					}
					return options[i].argLetter;
				}
			}
			// Began with "-" but not matched, so must be error.
			return '?';
		} else {
			// Found non-argument non-option word in argv: end of options.
			done = true;
			return DONE;
		}
	}

	/** Return optind, the index into args of the last option we looked at */
	public int getOptInd() {
		return optind;
	}

}
//@@@@@@//
//darwinsys/src/com/darwinsys/lang/GetOptDesc.java
//@@@@@@//
package com.darwinsys.lang;

/** A GetOptDesc describes one argument that may be accepted by the program.
 */
public class GetOptDesc {
	/** The short-form option letter */
	protected char argLetter;
	/** The long-form option name */
	protected String argName;
	/** True if this option needs an argument after it */
	protected boolean takesArgument;

	/** Construct a GetOpt option.
	 * @param ch The single-character name for this option.
	 * @param nm The word name for this option.
	 * @param ta True if this option requires an argument after it.
	 */
	public GetOptDesc(char ch, String nm, boolean ta) {
		if (!Character.isLetter(ch) && !Character.isDigit(ch)) {
			throw new IllegalArgumentException(ch + ": not letter or digit");
		}
		argLetter = ch;
		argName   = nm;	// may be null, meaning no long name.
		takesArgument = ta;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/lang/MutableInteger.java
//@@@@@@//
package com.darwinsys.lang;

/** A MutableInteger is like an Integer but mutable, to avoid the
 * excess object creation involved in 
 * c = new Integer(c.getInt()+1)
 * which can get expensive if done a lot.
 * Not subclassed from Integer, since Integer is final (for performance :-))
 * @version $Id: MutableInteger.java,v 1.6 2004/05/24 17:48:38 ian Exp $
 */
public class MutableInteger {
	private int value = 0;

	public MutableInteger(int i) {
		value = i;
	}
	
	public MutableInteger() {
		this(0);
	}

	public int incr() {
		value++;
		return value;
	}

	public int incr(int amt) {
		value += amt;
		return value;
	}

	public int decr() {
		value--;
		return value;
	}

	public int setValue(int i) {
		value = i;
		return value;
	}

	public int getValue() {
		return value;
	}

	public String toString() {
		return Integer.toString(value);
	}

	public static String toString(int val) {
		return Integer.toString(val);
	}

	public static int parseInt(String str) {
		return Integer.parseInt(str);
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/lang/StringFormat.java
//@@@@@@//
package com.darwinsys.lang;

import java.text.*;

/** Bare-minimum "String formatter": format a string to a given
 * maximum length with left, centre, or right justification.
 */
public class StringFormat extends Format {
	/* Constant for left justification. */
	public static final int JUST_LEFT = 'l';
	/* Constant for centering. */
	public static final int JUST_CENTRE = 'c';
	/* Constant for centering, for those who spell "centre" the American way. */
	public static final int JUST_CENTER = JUST_CENTRE;
	/** Constant for right-justified Strings. */
	public static final int JUST_RIGHT = 'r';

	/** Current justification */
	private int just;
	/** Current max length */
	private int maxChars;

	public StringFormat(int maxCh, int justn) {
		switch(justn) {
		case JUST_LEFT:
		case JUST_CENTRE:
		case JUST_RIGHT:
			this.just = justn;
			break;
		default:
			throw new IllegalArgumentException("invalid justification arg.");
		}
		if (maxCh < 1) {
			throw new IllegalArgumentException("maxChars must be positive.");
		}
		this.maxChars = maxCh;
	}

	/** Format a String */
	public StringBuffer format(
		Object obj, StringBuffer where, FieldPosition ignore)  {

		String s = (String)obj;
		String wanted = s.substring(0, Math.min(s.length(), maxChars));

		// If no space left for justification, return maxChars' worth */
		if (wanted.length() > maxChars) {
			where.append(wanted);
		}
		// Else get the spaces in the right place.
		else switch (just) {
			case JUST_RIGHT:
				pad(where, maxChars - wanted.length());
				where.append(wanted);
				break;
			case JUST_CENTRE:
				int startPos = where.length();
				pad(where, (maxChars - wanted.length())/2);
				where.append(wanted);
				pad(where, (maxChars - wanted.length())/2);
				// Adjust for "rounding error"
				pad(where, maxChars - (where.length() - startPos));
				break;
			case JUST_LEFT:
				where.append(wanted);
				pad(where, maxChars - wanted.length());
				break;
			}
		return where;
	}

	protected final void pad(StringBuffer to, int howMany) {
		for (int i=0; i<howMany; i++)
			to.append(' ');
	}

	/** Convenience Routine */
	String format(String s) {
		return format(s, new StringBuffer(), null).toString();
	}

	/** ParseObject is required by Format interface, 
	 *but not useful here.
	 */
	public Object parseObject (String source, ParsePosition pos)  {
		return source;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/lang/StringUtil.java
//@@@@@@//
package com.darwinsys.lang;

/** Miscellaneous string utilities:
 * arrayToCommaList - print an array with commas, "and";
 * subst - simple substitute (like 1-4's String.subst but not RE-based)
 * .
 */
public class StringUtil {

	/** Format an array of Object as a list with commas,
	 * like "apples, oranges, and bananas");
	 */
	public static String arrayToCommaList(Object[] array) {
		StringBuffer sb = new StringBuffer();
		for (int i=0; i<array.length; i++) {
			if (i > 0 && i < array.length - 1) {
				sb.append(',');
			}
			if (i > 0) {
				sb.append(' ');
			}
			if (i==(array.length-1)) {
				sb.append("and ");
			}
			sb.append(array[i]);
		}
		return sb.toString();
	}

	/** Simple string substitution (not RE-based). */
	public static String subst(String oldStr, String newStr, String input) {
		int where = 0;
		StringBuffer sb = new StringBuffer(input);
		while ((where = StringUtil.indexOf(sb, oldStr, where)) != -1) {
			sb.replace(where, where + oldStr.length(), newStr);
		}
		return sb.toString();
	}

	/** Backwards-compability: StringBuffer.indexOf(String, int) added in
	 * JDK 1-4, but we need it here and one of my servers is on JDK 1-3.
	 */
	public static int indexOf(StringBuffer sb, String str, int fromIndex) {

		// Reject the impossible at once
		if (sb == null || str == null) {
			throw new IllegalArgumentException(
				"input strings may not be null");
		}
		if (fromIndex < 0) {
			throw new ArrayIndexOutOfBoundsException(
				fromIndex + " is negative");
		}
		if (fromIndex + str.length() > sb.length())
			return -1;

		// OK, hunt and peck.
		int i;
		for ( ; fromIndex < sb.length(); fromIndex++) { 
			boolean foundThisRound = true;
		 	for (i = 0; foundThisRound && i < str.length(); i++) {
				if (sb.charAt(fromIndex + i) != str.charAt(i))
					foundThisRound = false;
			}
			if (foundThisRound)
				return fromIndex;
		}
		return -1;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/lang/SysDep.java
//@@@@@@//
package com.darwinsys.lang;

/** Some things that are System Dependent.
 * All methods are static, like java.lang.Math.
 * @author Ian Darwin
 * @version $Id: SysDep.java,v 1.2 2003/05/29 18:06:30 ian Exp $
 */
public class SysDep {
	/** Return the name of the Null device on platforms which support it,
	 * or "jnk" otherwise.
	 */
	public static String getDevNull() {
		String sys = System.getProperty("os.name");
		if (sys==null || sys.indexOf("Mac") >= 0)
			return "jnk";
		if (sys.startsWith("Windows"))
			return "NUL:";
		return "/dev/null";
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/macosui/AboutBoxHandler.java
//@@@@@@//
package com.darwinsys.macosui;

import javax.swing.JFrame;

/** Handler for part of MacOS UI extensions */
public interface AboutBoxHandler {
	public void showAboutBox(JFrame jf);
}
//@@@@@@//
//darwinsys/src/com/darwinsys/macosui/MacOSAppAdapter.java
//@@@@@@//
package com.darwinsys.macosui;

import javax.swing.JFrame;

import com.apple.eawt.Application;
import com.apple.eawt.ApplicationEvent;
import com.apple.eawt.ApplicationListener;

/**
 * The only os-dependant part of com.darwinsys, this is the
 * adapter class to handle MacOS's "different" way of doing About Box,
 * Quit item in App menu, Preferences, and so on.
 */
public class MacOSAppAdapter extends Application {
	ApplicationListener appListener;
	JFrame  parent;
	AboutBoxHandler abouter;
	PrefsHandler prefser;
	PrintHandler printer;
	ShutdownHandler shutter;


	/** Construct a MacOSAppAdapter.
	 * @param theParent A JFrame, usually the main application window.
	 * @param about A handler for the About box.
	 * @param prefs A Preferences handler.
	 * @param print A Print handler (bug: does not get invoked now).
	 * @param shut A shutdown handler
	 */
	public MacOSAppAdapter(JFrame theParent, AboutBoxHandler about,
		PrefsHandler prefs, PrintHandler print, ShutdownHandler shut) {
		appListener = new MyAppEventHandler();
		parent = theParent;

		if (about != null) {
			abouter = about;
			setEnabledAboutMenu(true);
			addAboutMenuItem();
		}

		if (prefs != null) {
			prefser = prefs;
			setEnabledPreferencesMenu(true);
			addPreferencesMenuItem();
		}
		
		printer = print;

		shutter = shut;
	}

	/** Method to register this handler with Apple's event manager, calling
	 * addApplicationListener in parent class.
	 */
	public void register() {
		addApplicationListener(appListener);
	}

	/** Inner class to provide ApplicationListener support. */
	class MyAppEventHandler implements ApplicationListener {

		/** This is called when the user does Application->About */
		public void handleAbout(ApplicationEvent event) {
			abouter.showAboutBox(parent);
			event.setHandled(true);
		}

		/** Called when the user does Application->Preferences */
		public void handlePreferences(ApplicationEvent event) {
			if (prefser != null)
				prefser.showPrefsDialog(parent);
				event.setHandled(true);
		}

		public void handlePrint(ApplicationEvent event) {
			if (printer != null)
				printer.doPrint(parent);
				event.setHandled(true);
		}

		/** This is called when the user does Application->Quit */
		public void handleQuit(ApplicationEvent event) {
			if (shutter != null)
				shutter.shutdown(parent);
			System.exit(0);	// should be notreached
		}

		/**
		 * @see com.apple.eawt.ApplicationListener#handleOpenApplication(com.apple.eawt.ApplicationEvent)
		 */
		public void handleOpenApplication(ApplicationEvent arg0) {
			// TODO Auto-generated method stub
			
		}

		/**
		 * @see com.apple.eawt.ApplicationListener#handleOpenFile(com.apple.eawt.ApplicationEvent)
		 */
		public void handleOpenFile(ApplicationEvent arg0) {
			// TODO Auto-generated method stub
			
		}

		/**
		 * @see com.apple.eawt.ApplicationListener#handlePrintFile(com.apple.eawt.ApplicationEvent)
		 */
		public void handlePrintFile(ApplicationEvent arg0) {
			// TODO Auto-generated method stub
			
		}

		/**
		 * @see com.apple.eawt.ApplicationListener#handleReOpenApplication(com.apple.eawt.ApplicationEvent)
		 */
		public void handleReOpenApplication(ApplicationEvent arg0) {
			// TODO Auto-generated method stub
			
		}
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/macosui/MacOSUtil.java
//@@@@@@//
package com.darwinsys.macosui;

/** Utilities for GUI work.
 * @version $Id: MacOSUtil.java,v 1.11 2004/01/31 01:26:05 ian Exp $
 */
public class MacOSUtil {

	/** Return true if we are running MacOS; needs a few GUI tweaks if so. */
	public static boolean isMacOS() {
		return System.getProperty("mrj.version") != null;
	}

	/** Set a few common properties for the given application if
	 * we are running under MacOS.
	 * Usage Example:
	 * <pre>
	 *	if (MacOSUtil.isMacOS()) {
	 *		MacOSUtil.setMacOS("JabaDex");
	 *	}
	 * </pre>
	 * @param appName - the name of the Application.
	 */
	public static void setMacOS(String appName) {
		System.setProperty("apple.laf.useScreenMenuBar",  "true");
		System.setProperty("apple.awt.showGrowBox",  "true");
		System.setProperty("com.apple.mrj.application.apple.menu.about.name",
			appName);
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/macosui/PrefsHandler.java
//@@@@@@//
package com.darwinsys.macosui;

import javax.swing.JFrame;

/** Handler for part of MacOS UI extensions */
public interface PrefsHandler {
	public void showPrefsDialog(JFrame jf);
}
//@@@@@@//
//darwinsys/src/com/darwinsys/macosui/PrintHandler.java
//@@@@@@//
package com.darwinsys.macosui;

import javax.swing.JFrame;

/** Handler for part of MacOS UI extensions */
public interface PrintHandler {
	public void doPrint(JFrame jf);
}
//@@@@@@//
//darwinsys/src/com/darwinsys/macosui/ShutdownHandler.java
//@@@@@@//
package com.darwinsys.macosui;

import javax.swing.JFrame;

/** Handler for part of MacOS UI extensions */
public interface ShutdownHandler {
	public void shutdown(JFrame jf);
}
//@@@@@@//
//darwinsys/src/com/darwinsys/mail/Mailer.java
//@@@@@@//
package com.darwinsys.mail;

import java.util.*;
import javax.mail.*;
import javax.mail.internet.*; 

/** Mailer. No relation to Norman. Sends an email message.
 * My old Sender class, recast as a Bean for use in JSP's & elsewhere.
 * Example usage:
 * <pre>
 * Mailer mb = new Mailer();
 * mb.setFrom("orders@YourDomain.com");
 * mb.addTo("orders@YourDomain.com");
 * mb.setSubject("LHBOOKS ORDER!!");
 * mb.setBody(order.toString());
 * mb.setServer(application.getInitParameter("mail.server.smtp")); 
 * try {
 *     mb.doSend();
 * } catch (MessagingException ex) {
 *	   ...
 * }
 * </pre>
 * @author Ian F. Darwin
 * @version $Id: Mailer.java,v 1.16 2004/01/31 01:26:05 ian Exp $
 */
public class Mailer {
	/** The javamail session object. */
	protected Session session;
	/** The sender's email address */
	protected String from;
	/** The subject of the message. */
	protected String subject;
	/** The recipient ("To:"), as Strings. */
	protected ArrayList toList = new ArrayList();
	/** The CC list, as Strings. */
	protected ArrayList ccList = new ArrayList();
	/** The BCC list, as Strings. */
	protected ArrayList bccList = new ArrayList();
	/** The text of the message. */
	protected String body;
	/** The SMTP relay host */
	protected String mailHost;
	/** The verbosity setting */
	protected boolean verbose;

	/** Get from */
	public String getFrom() {
		return from;
	}

	/** Set from */
	public void setFrom(String fm) {
		from = fm;
	}

	/** Get subject */
	public String getSubject() {
		return subject;
	}

	/** Set subject */
	public void setSubject(String subj) {
		subject = subj;
	}

	// SETTERS/GETTERS FOR TO: LIST 

	/** Get tolist, as an array of Strings */
	public ArrayList getToList() {
		return toList;
	}

	/** Set to list to an ArrayList of Strings */
	public void setToList(ArrayList to) {
		toList = to;
	}

	/** Set to as a string like "tom, mary, robin@host". Loses any
	 * previously-set values. */
	public void setToList(String s) {
		toList = tokenize(s);
	}

	/** Add one "to" recipient */
	public void addTo(String to) {
		toList.add(to);
	}

	// SETTERS/GETTERS FOR CC: LIST 

	/** Get cclist, as an array of Strings */
	public ArrayList getCcList() {
		return ccList;
	}

	/** Set cc list to an ArrayList of Strings */
	public void setCcList(ArrayList cc) {
		ccList = cc;
	}

	/** Set cc as a string like "tom, mary, robin@host". Loses any
	 * previously-set values. */
	public void setCcList(String s) {
		ccList = tokenize(s);
	}

	/** Add one "cc" recipient */
	public void addCc(String cc) {
		ccList.add(cc);
	}

	// SETTERS/GETTERS FOR BCC: LIST 

	/** Get bcclist, as an array of Strings */
	public ArrayList getBccList() {
		return bccList;
	}

	/** Set bcc list to an ArrayList of Strings */
	public void setBccList(ArrayList bcc) {
		bccList = bcc;
	}

	/** Set bcc as a string like "tom, mary, robin@host". Loses any
	 * previously-set values. */
	public void setBccList(String s) {
		bccList = tokenize(s);
	}

	/** Add one "bcc" recipient */
	public void addBcc(String bcc) {
		bccList.add(bcc);
	}

	// SETTER/GETTER FOR MESSAGE BODY

	/** Get message */
	public String getBody() {
		return body;
	}

	/** Set message */
	public void setBody(String text) {
		body = text;
	}

	// SETTER/GETTER FOR VERBOSITY

	/** Get verbose */
	public boolean isVerbose() {
		return verbose;
	}

	/** Set verbose */
	public void setVerbose(boolean v) {
		verbose = v;
	}

	/** Check if all required fields have been set before sending.
	 * Normally called e.g., by a JSP before calling doSend.
	 * Is also called by doSend for verification.
	 */
	public boolean isComplete() {
		if (from == null    || from.length()==0) {
			System.err.println("doSend: no FROM");
			return false;
		}
		if (subject == null || subject.length()==0) {
			System.err.println("doSend: no SUBJECT");
			return false;
		}
		if (toList.size()==0) {
			System.err.println("doSend: no recipients");
			return false;
		}
		if (body == null || body.length()==0) {
			System.err.println("doSend: no body");
			return false;
		}
		if (mailHost == null || mailHost.length()==0) {
			System.err.println("doSend: no server host");
			return false;
		}
		return true;
	}

	public void setServer(String s) {
		mailHost = s;
	}

	/** Send the message.
	 */
	public synchronized void doSend() throws MessagingException {

		if (!isComplete())
			throw new IllegalArgumentException(
				"doSend called before message was complete");

		/** Properties object used to pass props into the MAIL API */
		Properties props = new Properties();
		props.put("mail.smtp.host", mailHost);

		// Create the Session object
		if (session == null) {
			session = Session.getDefaultInstance(props, null);
			if (verbose)
				session.setDebug(true);		// Verbose!
		}
		
		// create a message
		final Message mesg = new MimeMessage(session);

		InternetAddress[] addresses;

		// TO Address list
		addresses = new InternetAddress[toList.size()];
		for (int i=0; i<addresses.length; i++)
			addresses[i] = new InternetAddress((String)toList.get(i));
		mesg.setRecipients(Message.RecipientType.TO, addresses);

		// From Address
		mesg.setFrom(new InternetAddress(from));

		// CC Address list
		addresses = new InternetAddress[ccList.size()];
		for (int i=0; i<addresses.length; i++)
			addresses[i] = new InternetAddress((String)ccList.get(i));
		mesg.setRecipients(Message.RecipientType.CC, addresses);

		// BCC Address list
		addresses = new InternetAddress[bccList.size()];
		for (int i=0; i<addresses.length; i++)
			addresses[i] = new InternetAddress((String)bccList.get(i));
		mesg.setRecipients(Message.RecipientType.BCC, addresses);

		// The Subject
		mesg.setSubject(subject);

		// Now the message body.
		mesg.setText(body);

		// Finally, send the message! (use static Transport method)
		// Do this in a Thread as it sometimes is too slow for JServ
		// new Thread() {
			// public void run() {
				// try {

					Transport.send(mesg);

				// } catch (MessagingException e) {
					// throw new IllegalArgumentException(
					// "Transport.send() threw: " + e.toString());
				// }
			// }
		// }.start();
	}

	/** Convenience method that does it all with one call.
	 * @param mailhost - SMTP server host
	 * @param recipient - domain address of email (user@host.domain)
	 * @param sender - your email address
	 * @param subject - the subject line
	 * @param message - the entire message body as a String with embedded \n's
	 */
	public static void send(String mailhost, 
		String recipient, String sender, String subject, String message) 
	throws MessagingException {
		Mailer m = new Mailer();
		m.setServer(mailhost);
		m.addTo(recipient);
		m.setFrom(sender);
		m.setSubject(subject);
		m.setBody(message);
		m.doSend();
	}


	/** Convert a list of addresses to an ArrayList. This will work
	 * for simple names like "tom, mary@foo.com, 123.45@c$.com"
	 * but will fail on certain complex (but RFC-valid) names like
	 * "(Darwin, Ian) <http://www.darwinsys.com/>".
	 * Or even "Ian Darwin <http://www.darwinsys.com/>".
	 */
	protected ArrayList tokenize(String s) {
		ArrayList al = new ArrayList();
		StringTokenizer tf = new StringTokenizer(s, ",");
		// For each word found in the line
		while (tf.hasMoreTokens()) {
			// trim blanks, and add to list.
			al.add(tf.nextToken().trim());
		}
		return al;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/security/PassPhrase.java
//@@@@@@//
package com.darwinsys.security;

/** Cheap, lightweight, low-security password generator.
 * See also: java.security.*;
 */
public class PassPhrase {
	/** Minimum length for a decent password */
	public static final int MIN_LENGTH = 10;

	/** The random number generator. */
	protected static java.util.Random r = new java.util.Random();

	/* Set of characters that is valid. Must be printable, memorable,
	 * and "won't break HTML" (i.e., not '<', '>', '&', '=', ...).
 	 * or break shell commands (i.e., not '<', '>', '$', '!', ...).
	 * I, L and O are good to leave out, as are numeric zero and one.
	 */
	protected static char[] goodChar = {
		'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n',
		'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'M', 'N',
		'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
		'2', '3', '4', '5', '6', '7', '8', '9',
		'+', '-', '@', 
	};

	/* Generate a Password object with a random password. */
	public static String getNext() {
		StringBuffer sb = new StringBuffer();
		for (int i=0; i < MIN_LENGTH; i++) {
			sb.append(goodChar[r.nextInt(goodChar.length)]);
		}
		return sb.toString();
	}

	public static void main(String[] argv) {
		for (int i=0; i<20; i++) {
			System.out.println(PassPhrase.getNext());
		}
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/sql/ConnectionUtil.java
//@@@@@@//
package com.darwinsys.sql;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

import com.darwinsys.database.DataBaseException;

/** Encapsulate the Connection-related operations that every 
 * JDBC program seems to use.
 */
public class ConnectionUtil {
	/** The default config filename, relative to ${user.home} */
	public static final String DEFAULT_NAME = ".db.properties";
	
	/** The current config filename */
	private static String configFileName =
		System.getProperty("user.home") + File.separator + DEFAULT_NAME;

	/** Get a Connection for the given config using the default or set property file name */
	public static Connection getConnection(String config) throws DataBaseException {
		try {
			Properties p = new Properties();
			p.load(new FileInputStream(configFileName));
			return getConnection(p, config);
		} catch (IOException ex) {
			throw new DataBaseException(ex.toString());
		}
	}
	
	/** Get a Connection for the given config name from a provided Properties */
	public static Connection getConnection(Properties p,  String config) throws DataBaseException {
		try {
			String db_driver = p.getProperty(config  + "." + "DBDriver");
			String db_url = p.getProperty(config  + "." + "DBURL");
			String db_user = p.getProperty(config  + "." + "DBUser");
			String db_password = p.getProperty(config  + "." + "DBPassword");
			if (db_driver == null || db_url == null) {
				throw new IllegalStateException("Driver or URL null: " + config);
			}
			return createConnection(db_driver, db_url, db_user, db_password);
		} catch (ClassNotFoundException ex) {
			throw new DataBaseException(ex.toString());
	
		} catch (SQLException ex) {
			throw new DataBaseException(ex.toString());
		}
	}

	public static Connection createConnection(String db_driver, String db_url, 
					String db_user, String db_password)
			throws ClassNotFoundException, SQLException {


		// Load the database driver
		System.out.println("Loading driver " + db_driver);
		Class.forName(db_driver);

		System.out.println("Connecting to DB " + db_url);
		return DriverManager.getConnection(
			db_url, db_user, db_password);
	}
	
	/** Returns the full path of the configuration file being used.
	 * @return Returns the configFileName.
	 */
	public static String getConfigFileName() {
		return configFileName;
	}
	
	/** Sets the full path of the config file to read.
	 * @param configFileNam The FileName of the configuration file to use.
	 */
	public static void setConfigFileName(String configFileNam) {
		configFileName = configFileNam;
		File file = new File(configFileName);
		if (!file.canRead()) {
			throw new IllegalArgumentException("Unreadable: " + configFileName);
		}
		try {
			ConnectionUtil.configFileName = file.getCanonicalPath();
		} catch (IOException ex) {
			System.err.println("Warning: IO error checking path: " + configFileName);
			ConnectionUtil.configFileName = configFileName;
		}
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/ArrayListTableModel.java
//@@@@@@//
package com.darwinsys.swingui;

import javax.swing.table.*;
import java.util.*;

/** JTable model for ArrayList of heterogeneous objects.
 * Subclasses must set String columnNames[] and
 * Class columnClasses[], which MUST be in the same order.
 * Subclasses need only implement these AbstractTableModel methods:
 * <pre>
 * public int getColumnCount() {
 * public Object getValueAt(int row, int col)  {
 * public void setValueAt(Object val, int row, int col)  {
 * </pre>
 */
public abstract class ArrayListTableModel extends AbstractTableModel {

	/** List of column names, must be provided by subclass. */
	protected String columnNames[];
	/** List of column names, must be provided by subclass. */
	protected Class columnClasses[];

	/** The list of Method object */
	protected ArrayList methods = null;

	/** for caching. */
	private int ROW_INVALID = -1;
	/** for caching, shared by get/set ValueAt */
	private int prevRow = ROW_INVALID;
	/** for caching, shared by get/set ValueAt */
	private Object current  = null;

	/** Constructor requires the list of objects */
	public ArrayListTableModel(ArrayList m) {
		methods = m;
	}

	/** Allow the model to load the ArrayList all at once, as when
	 * loading a file.
	 */
	void setListData(ArrayList v) {
		methods = v;
		invalidateCache();
	}

	/** Get the name of a given column, from the list provided by subclass */
	public String getColumnName(int n) {
		if (columnNames == null)
			throw new IllegalStateException("columnNames not set");
		int max = columnNames.length;
		if (n>=max)
			throw new ArrayIndexOutOfBoundsException(
			"columnNames has " + max + " elements; you asked for " + max);
		return columnNames[n];
	}

	/** Get the class of a given column, from the list provided by subclass */
	public Class getColumnClass(int n) {
		if (columnClasses == null)
			throw new IllegalStateException("columnClasses not set");
		int max = columnClasses.length;
		if (n>=max)
			throw new ArrayIndexOutOfBoundsException(
			"columnClasses has " + max + " elements; you asked for " + max);
		return columnClasses[n];
	}

	/** Returns the number of objects in the list. */
	public int getRowCount()  {
		return methods.size();
	}

	/** All cells are editable.
	 * Subclasses can override this if only some cells should be editable.
	 */
	public boolean isCellEditable(int rowIndex, int columnIndex) {
		return true;
	}

	/** Cache one most-recently-used item. This is a convenience
	 * routine that subclasses are invited but not required to use.
	 * Normal use would be, in get/setValueAt():
	 * <pre>
	 *		public void setValueAt(int row, ...) {
	 *			MyDataType current = (MyDataType) getCached(row);
	 *			...
	 *		}
	 * </pre>
	 */
	public Object getCached(int row) {
		if (row != prevRow) {
			current = methods.get(row);
			prevRow = row;
		}
		return current;
	}

	/** Invalidate the cache. Called automatically by setListData();
	 * must be called if you otherwise change the ArrayList.
	 */
	public void invalidateCache() {
		prevRow = ROW_INVALID;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/ArrayListTablePanel.java
//@@@@@@//
package com.darwinsys.swingui;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.util.*;

/**
 * ArrayListTablePanel - Bean/GUI panel for ArrayListTableModel.
 * <p>
 * Subclass should call getTable() and set any
 * desired Renderers or Editors.
 * <p>
 * The class of things in the list must have a public, no-argument constructor.
 *
 * <p>TODO
 * <ul>
 * <li>Debug MoveUp/MoveDown!
 * <li>add constructor options for Add, Remove, MoveUp/MoveDown buttons
 * </ul>
 *
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version	$Id: ArrayListTablePanel.java,v 1.8 2004/01/31 01:26:05 ian Exp $
 */
public class ArrayListTablePanel extends JPanel {

	/** The list of objects we are viewing */
	protected ArrayList list;
	/** The kind of thing that is in the list. */
	protected Class objectClass;
	/** The JTable's data (model) */
	protected ArrayListTableModel model;
	/** The JTable itself */
	protected JTable table;

	/** Construct new ArrayListTablePanel */
	public ArrayListTablePanel(Class objClass,
		ArrayList al, ArrayListTableModel lm) {

		objectClass = objClass;
		list = al;
		model = lm;
		table = new JTable(model);

		setLayout(new BorderLayout());

		add(new JScrollPane(table), BorderLayout.CENTER);

		JPanel botPanel = new JPanel();
		JButton jb;
		botPanel.add(jb = new JButton("Add"));
		jb.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				int i = table.getSelectedRow();
				if (i<0) i = list.size();
				Object newObj = null;
				try {
					newObj = objectClass.newInstance();
				} catch (Exception ex) {
					JOptionPane.showMessageDialog(null,
						"Object creation FAILED\n " + ex, "Error",
						JOptionPane.ERROR_MESSAGE);
					return;
				}
				list.add(i, newObj);
				table.tableChanged(new 
					TableModelEvent(model, i, i, 
					TableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT));
			}
		});

		botPanel.add(jb = new JButton("Move Up"));
		jb.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				int i = table.getSelectedRow();
				if (i == -1 || i == 0)
					return;
				Object obj = list.get(i);
				list.remove(i);
				list.add(i-1, obj);
				table.tableChanged(new 
					TableModelEvent(model, i-1, i-1, 
					TableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT));
				model.invalidateCache();
			}
		});

		botPanel.add(jb = new JButton("Move Down"));
		jb.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				int i = table.getSelectedRow();
				if (i == -1 || i == list.size()-1)
					return;
				Object obj = list.get(i);
				list.remove(i);
				list.add(i+1, obj);
				table.tableChanged(new 
					TableModelEvent(model, i, i, 
					TableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT));
				// table.setSelectedRowInterval(i+1, i+1);
				model.invalidateCache();
			}
		});

		botPanel.add(jb = new JButton("Remove"));
		jb.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				int i = table.getSelectedRow();
				if (i<0)
					return;	// nothing selected
				list.remove(i);
				table.tableChanged(new 
					TableModelEvent(model, i, i, 
					TableModelEvent.ALL_COLUMNS, TableModelEvent.DELETE));
				model.invalidateCache();
			}
		});

		add(botPanel, BorderLayout.SOUTH);
	}

	/** Return a reference to the JTable. */
	public JTable getTable() {
		return table;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/CalIcon.java
//@@@@@@//
package com.darwinsys.swingui;

import java.awt.*;
import java.util.*;
import javax.swing.*;

/** Display one of those standard Calendar Page icons with
 * Weekday, Day and Month. Can be used as the Icon in a
 * JButton. Can include or exclude an updating Clock at the top
 * (invoke constructor with value of true to include).
 * However, it should be excluded when using as an Icon, and 
 * true when using as a Component.
 * @author	Ian Darwin, http://www.darwinsys.com
 * @version $Id: CalIcon.java,v 1.3 2003/05/29 18:06:31 ian Exp $
 */
public class CalIcon extends JComponent implements Icon {
	/** The size shalle be 64x64. */
	protected final int SIZE = 64;
	protected final Dimension d = new Dimension(SIZE, SIZE);
	/** The size of the inner white box */
	protected final int RBW=40, RBH=40;
	/** The x location of the inner box */
	protected final int RBX;
	/** The y location of the inner box */
	protected final int RBY;
	/** Our Calendar */
	protected Calendar myCal;
	/** True if user wants the time shown */
	protected boolean showTime = true;
	/** The Clock to show the time, if showTime */
	protected Clock clock;
	/** Font for displaying the time */
	protected Font dayNumbFont;
	/** FontMetrics for displaying the time */
	protected FontMetrics dayNumbFM;
	/** Font for displaying the time */
	protected Font dayNameFont;
	/** FontMetrics for displaying the time */
	protected FontMetrics dayNameFM;
	/** Font for displaying the time */
	protected Font monNameFont;
	/** FontMetrics for displaying the time */
	protected FontMetrics monNameFM;

	/** Construct the object with default arguments */
	public CalIcon(boolean showT) {
		this(Calendar.getInstance(), showT);
	}

	/** Construct the object with a Calendar object */
	public CalIcon(Calendar c, boolean showT) {
		super();
		showTime = showT;
		myCal = c;

		setLayout(null);			// we don't need another layout, ...

		if (showTime) {
			// System.err.println("Constructing and adding Clock");
			clock = new Clock();
			add(clock);
			clock.setBounds(0, 2, SIZE, 10);
			// clock.setBackground(Color.black);
			// clock.setForeground(Color.green);
			RBY = d.height - (RBH+(showTime?12:0)/2);
		} else {
			RBY = 6;
		}
		RBX = 12;	// raised box x offset
		// System.err.println("RBX, RBY = " + RBX + "," + RBY);

		dayNumbFont = new Font("Serif",     Font.BOLD, 20);
		dayNumbFM = getFontMetrics(dayNumbFont);
		dayNameFont = new Font("SansSerif", Font.PLAIN, 10);
		dayNameFM = getFontMetrics(dayNameFont);
		monNameFont = new Font("SansSerif", Font.ITALIC, 10);
		monNameFM = getFontMetrics(monNameFont);
	}

	/** Days of the week */
	public String[] days = { "SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"};
	public String[] mons = { 
		"JAN", "FEB", "MAR", "APR", "MAY", "JUN",
		"JUL", "AUG", "SEP", "OCT", "NOV", "DEC",
	};

	/** Paint: draw the calendar page in the JComponent.
	 * Delegates most work to paintIcon().
	 */
	public void paint(Graphics g) {

		paintIcon(this, g, 0, 0);
	}

	/** paintIcon: draw the calendar page. */
	public void paintIcon(Component c, Graphics g, int x, int y) {

		// Allow clock to get painted (voodoo magic)
		if (showTime)
			super.paint(g);

		// Outline it.
		g.setColor(Color.black);
		g.draw3DRect(x, y, d.width-2, d.height-2, true);

		// Show the date: First, a white page with a drop shadow.
		g.setColor(Color.gray);
		g.fillRect(x + RBX+3, y + RBY+3, RBW, RBH);
		g.setColor(Color.white);
		g.fillRect(x + RBX, y + RBY, RBW, RBH);

		// g.setColor(getForeground());
		g.setColor(Color.black);

		String s = days[myCal.get(Calendar.DAY_OF_WEEK)-1];
		g.setFont(dayNameFont);
		int w = dayNameFM.stringWidth(s);
		g.drawString(s, x + RBX+((RBW-w)/2), y + RBY+10);

		s = Integer.toString(myCal.get(Calendar.DAY_OF_MONTH));
		g.setFont(dayNumbFont);
		w = dayNumbFM.stringWidth(s);
		g.drawString(s, x + RBX+((RBW-w)/2), y + RBY+25);

		s = mons[myCal.get(Calendar.MONTH)];
		g.setFont(monNameFont);
		w = monNameFM.stringWidth(s);
		g.drawString(s, x + RBX+((RBW-w)/2), y + RBY+35);
	}

	public int getIconWidth() { return SIZE; }
	public int getIconHeight() { return SIZE; }

	public Dimension getPreferredSize() {
		return d;
	}
	public Dimension getMinimumSize() {
		return d;
	}

	public static void main(String[] args) {
		JFrame jf = new JFrame("Calendar");
		Container cp = jf.getContentPane();
		cp.setLayout(new GridLayout(0,1,5,5));
		CalIcon c = new CalIcon(true);
		cp.add(c);
		JButton j = new JButton("As Icon", new CalIcon(false));
		cp.add(j);
		jf.pack();
		jf.setVisible(true);
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/Clock.java
//@@@@@@//
package com.darwinsys.swingui;

import java.awt.*;
import java.text.*;
import java.util.*;

/** A simple Clock */
public class Clock extends javax.swing.JComponent {
	protected DecimalFormat tflz, tf;
	protected boolean done = false;

	public Clock() {
		new Thread(new Runnable() {
			public void run() {
				while (!done) {
					Clock.this.repaint();	// request a redraw
					try {
						Thread.sleep(1000);
					} catch (InterruptedException e){ /* do nothing*/ }
				}
			}
		}).start();
		tf = new DecimalFormat("#0");
		tflz = new DecimalFormat("00");
	}

	public void stop() {
		done = true;
	}
 
	/* paint() - get current time and draw (centered) in Component. */ 
	public void paint(Graphics g) {
		Calendar myCal = Calendar.getInstance();
		StringBuffer sb = new StringBuffer();
		sb.append(tf.format(myCal.get(Calendar.HOUR)));
		sb.append(':');
		sb.append(tflz.format(myCal.get(Calendar.MINUTE)));
		sb.append(':');
		sb.append(tflz.format(myCal.get(Calendar.SECOND)));
		String s = sb.toString();
		FontMetrics fm = getFontMetrics(getFont());
		int x = (getSize().width - fm.stringWidth(s))/2;
		// System.out.println("Size is " + getSize());
		g.drawString(s, x, 10);
	}

	public Dimension getPreferredSize() {
		return new Dimension(100, 30);
	}

	public Dimension getMinimumSize() {
		return new Dimension(50, 10);
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/ErrorUtil.java
//@@@@@@//
package com.darwinsys.swingui;

import java.awt.Component;
import java.awt.Container;
import java.awt.BorderLayout;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.sql.SQLException;
import javax.swing.JFrame;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JTextArea;
import javax.swing.JOptionPane;

// For DetailsDialog inner class
import java.io.CharArrayWriter;
import java.io.PrintWriter;

/**
 * Convenience class for fielding Exceptions in a Swing App.
 * Displays exceptions in a JOptionPane, and follows chained
 * exceptions, both the 1.x SQLException.getNextExeption() and
 * the new 1.4 Exception.getCause().
 * <p>
 * The user (will be able to) press a Details... button to see the
 * traceback in a dialog; tracebacks are <b>not</b> displayed unless
 * the user requests them.
 * @author Ian Darwin
 * @version $Id: ErrorUtil.java,v 1.8 2004/03/07 17:14:57 ian Exp $
 */
public class ErrorUtil {

	// static { System.out.println("ErrorUtil loaded"); }

	/** The button options for the ultimate (or only) Excepton */
	final static String[] choicesNoMore = { "OK", "Details..." };

	/** The button options for any non-ultimate Exception */
	final static String[] choicesMore = { "OK", "Details...", "Next" };

	/** Secondary dialog for the "Details..." button */
	protected static DetailsDialog detailsDialog;

	/** Public no-arg constructor for those who like simple instantiation. */
	public ErrorUtil() {
		// Nothing to do
	}

	/** Convenience routine for use with AWT's dispatch thread. Usage:
	 * <pre>
	 * System.setProperty("sun.awt.exception.handler",
	 *		"com.darwinsys.swingui.ErrorUtil");
	 * </pre>
	 */
	public void handle(Throwable th) {
		//System.out.println("handle() called with " + th.getClass().getName());
		showExceptions(null, th);
	}
		
	/** Show the given Exception (and any nested Exceptions) in JOptionPane(s).
	 */
	public static void showExceptions(Component parent, Throwable theExc) {

		Throwable next = null;

		do {
			String className = theExc.getClass().getName();
			String message = className;

			if (theExc instanceof SQLException) {
				SQLException sexc = (SQLException)theExc;
				message += "; code=" + sexc.getErrorCode();
				next = sexc.getNextException();
			}
			// else next = theExc.getCause();   // Comment out if < JDK 1.4

			String[] choices = next != null ? choicesMore : choicesNoMore;

			/* Show the Dialog! */
			int response = JOptionPane.showOptionDialog(
				parent,
				message,
				className,	 						// title
				JOptionPane.YES_NO_CANCEL_OPTION,	// icontType
				JOptionPane.ERROR_MESSAGE,			// messageType
				null,								// icon
				choices,							// options
				choices[0]							// default
				);

			if (response == 0)			// "OK"
				return;
			if (response == 1) {		// "Details"
				// show a JDialog with a JTextArea of printStackTrace();
				if (detailsDialog == null)
					detailsDialog = new DetailsDialog((JFrame)parent);
				detailsDialog.showStackTrace(theExc);
			}
			// else resp = 2, "Next", let it fall through:

			theExc = next;

		} while (next != null);
	}

	/** Inner class Dialog to display the details of an Exception */
	protected static class DetailsDialog extends JDialog {
		JButton ok;
		JTextArea text;
		/** Construct a DetailsDialog given a parent (Frame/JFrame) */
		DetailsDialog(JFrame parent) {
			super(parent);
			Container cp = getContentPane();
			text = new JTextArea(40, 40);
			cp.add(text, BorderLayout.CENTER);
			ok = new JButton("Close");
			cp.add(ok, BorderLayout.SOUTH);
			ok.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					dispose();
				}
			});
			pack();
		}

		/** Display the stackTrace from the given Throwable in this Dialog. */
		void showStackTrace(Throwable exc) {
			CharArrayWriter buff = new CharArrayWriter();
			PrintWriter pw = new PrintWriter(buff);
			exc.printStackTrace(pw);
			pw.close();
			text.setText(buff.toString());
			setVisible(true);
		}
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/FilterGUI.java
//@@@@@@//
package com.darwinsys.swingui;

import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JList;
import javax.swing.JPanel;

/** FilterGUI implements a back-and-forth list, ie, two columns of items, in
 * which items can be moved back and forth between them with "Add" and "Del"
 * buttons.
 * This is meant to provide a framework for Java programs that want
 * to provide chaining of various filters, or any other example where
 * you want to move items between an inactive list and an active list.
 * It does some neat things, including balancing the widths of the
 * two JLists.
 * <p>The test classes are called Filters because this type of selection GUI
 * is often used to select chained filters, but the FilterGUI is much
 * more general than this: a list of files to include/exclude, a list of
 * users, or a list of filters; any of these can be used.
 * <p>
 * TODO: fix balancing (have main pack() then call adjustWidths()?).
 * Set single-selection mode on the scrolling lists.
 * And maybe find a more standard name for this thing.
 * @author	Ian Darwin, http://www.darwinsys.com/contact.html
 * @version $Id: FilterGUI.java,v 1.11 2004/06/01 02:51:38 ian Exp $
 */
public class FilterGUI extends JComponent {

	protected final JList addableList;
	protected final FilterGUIListModel addableListModel;
	protected final JList currentList;
	protected final FilterGUIListModel currentListModel;

	/** Construct the object including its GUI */
	public FilterGUI(final Object[] data, final int defaultIndex) {
		super();

		setLayout(new BorderLayout(5, 5));

		addableList = new JList();
		addableListModel = new FilterGUIListModel(addableList);
		addableList.setModel(addableListModel);
		addableList.setBorder(BorderFactory.createEtchedBorder());
		// addableList.setText("Addable");
		for (int i=0; i<data.length; i++) {
			if (i != defaultIndex)
				addableListModel.add(data[i]);
		}

		currentList = new JList();
		currentListModel = new FilterGUIListModel(currentList);
		currentList.setModel(currentListModel);
		// currentList.setText("Current");
		currentList.setBorder(BorderFactory.createEtchedBorder());
		if (defaultIndex >= 0)
			currentListModel.add(data[defaultIndex]);

		add(BorderLayout.WEST, addableList);
		JPanel c = new JPanel();
		c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));
		JButton addButton, delButton;
		c.add(addButton = new JButton("-->"));
		addButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				int i = addableList.getSelectedIndex();
				if (i < 0 || i >= addableListModel.size())
					return;
				Object o = addableList.getSelectedValue();
				if (o == null)
					return;
				addableListModel.remove(o);
				addableList.setSelectedIndex(-1);
				currentListModel.add(o);
			}
		});
		c.add(delButton = new JButton("<--"));
		delButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				int i = currentList.getSelectedIndex();
				if (i < 0 || i >= currentListModel.size())
					return;
				Object o = currentList.getSelectedValue();
				if (o == null)
					return;
				currentListModel.remove(o);
				currentList.setSelectedIndex(-1);
				addableListModel.add(o);
			}
		});
		add(BorderLayout.CENTER, c);
		add(BorderLayout.EAST, currentList);

		// Balance Widths
		// Should get longest toString() from list.
		addableList.setPrototypeCellValue("Some Filter Name");
		currentList.setPrototypeCellValue("Some Filter Name");
	}

	/** Retrieve the list of currently-selected objects */
	public java.util.List getSelected() {
		return currentListModel;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/FilterGUIListModel.java
//@@@@@@//
package com.darwinsys.swingui;

import java.util.*;
import javax.swing.ListModel;
import javax.swing.event.*;

/** FilterGUIListModel combines an ArrayList with a ListModel for ease of use.
 */
public class FilterGUIListModel extends ArrayList implements ListModel {

	protected Object source;

	FilterGUIListModel(Object src) {
		source = src;
	}

	public Object getElementAt(int index) {
		return get(index);
	}

	public int getSize() {
		return size();
	}

	ArrayList listeners = new ArrayList();

	public void removeListDataListener(javax.swing.event.ListDataListener l)  { 
		listeners.remove(l);
	}

	public void addListDataListener(javax.swing.event.ListDataListener l)  {
		listeners.add(l);
	}

	void notifyListeners() {
		// no attempt at optimziation
		ListDataEvent le = new ListDataEvent(source,
			ListDataEvent.CONTENTS_CHANGED, 0, getSize());
		for (int i=0; i<listeners.size(); i++) {
			((ListDataListener)listeners.get(i)).contentsChanged(le);
		}
	}
	// REMAINDER ARE OVERRIDES JUST TO CALL NOTIFYLISTENERS


	public boolean add(Object o)  {
		boolean b = super.add(o);
		if (b)
			notifyListeners();
		return b;
	}

	public void add(int index, Object element) {
		super.add(index, element);
		notifyListeners();
	}

	public boolean addAll(Collection o)  {
		boolean b = super.add(o);
		if (b)
          notifyListeners();
		return b;
	}

	public void clear()  {
		super.clear();
		notifyListeners();
	}

	public Object remove(int i) {
		Object o = super.remove(i);
		notifyListeners();
		return o;
	}

	public boolean remove(Object o) {
		boolean b = super.remove(o);
		if (b)
			notifyListeners();
		return b;
	}

	public Object set(int index, Object element) {
		Object o = super.set(index, element);
		notifyListeners();
		return o;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/I18N.java
//@@@@@@//
package com.darwinsys.swingui;

import java.util.*;
import javax.swing.*;

/** Set of convenience routines for internationalized code.
 * All convenience methods are static, for ease of use.
 * @version $Id: I18N.java,v 1.7 2004/05/13 20:20:29 ian Exp $
 */
public class I18N {

	/** Convenience routine to make a JButton */
	public static JButton mkButton(ResourceBundle b, String name) {
		String label;
		try { label = b.getString(name+".label"); }
		catch (MissingResourceException e) { label=name; }
		return new JButton(label);
	}

	/** Convenience routine to make a JMenu */
	public static JMenu mkMenu(ResourceBundle b, String name) {
		String menuLabel;
		try { menuLabel = b.getString(name+".label"); }
		catch (MissingResourceException e) { menuLabel=name; }
		return new JMenu(menuLabel);
	}

	/** Convenience routine to make a JMenuItem */
	public static JMenuItem mkMenuItem(ResourceBundle b,
			String menu, String name) {

		String miLabel;
		try { miLabel = b.getString(menu + "." + name + ".label"); }
		catch (MissingResourceException e) { miLabel=name; }
		String key = null;
		try { key = b.getString(menu + "." + name + ".key"); }
		catch (MissingResourceException e) { key=null; }

		if (key == null)
			return new JMenuItem(miLabel);
		else
			return new JMenuItem(miLabel, key.charAt(0));
	}

	/** Show a JOptionPane message dialog */
	public static void mkDialog(ResourceBundle b,JFrame parent,
		String dialogTag, String titleTag, int messageType) {
			JOptionPane.showMessageDialog(
				parent,
				getString(b, dialogTag, "DIALOG TEXT MISSING: " + dialogTag),
				getString(b, titleTag, "DIALOG TITLE MISSING: "  + titleTag),
				messageType);
	}

	/** Just get a String (for dialogs, labels, etc.) */
	public static String getString(ResourceBundle b, String name, String dflt) {
		String result;
		try {
			result = b.getString(name);
		} catch (MissingResourceException e) {
			result = dflt;
		}
		return result;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/IntlAction.java
//@@@@@@//
package com.darwinsys.swingui;

import java.util.*;
import javax.swing.*;

/** Class for creating an Internationalized Swing Action.
 * See also
 <a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/action.html">
 * How to use Actions"</a>.
 * @version $Id: IntlAction.java,v 1.1 2003/07/12 20:31:26 ian Exp $
 */
public abstract class IntlAction extends AbstractAction {

	/** Convenience routing to make a Swing Action.
	 * @param b - ResourceBundle containting strings
	 * @param key - name such as "edit.cut" identifiying this action;
	 *		should have at least "label", "descr" and "key" values
	 * @param icon - an ImageIcon (24x24?)
	 */
	public IntlAction(
		ResourceBundle b, String key, ImageIcon icon) {

		String text =     b.getString(key + ".label");
		putValue(NAME, text);
		putValue(SMALL_ICON, icon);

		// May be a Mnemonic under ".key".
		try {
			String mnemonic = b.getString(key + ".key");
			putValue(MNEMONIC_KEY, new Integer(mnemonic.charAt(0)));
		} catch (MissingResourceException ex) {
			// Nothing to do.
		}

		// May be a ToolTip Description under ".descr".
		try {
			String ttDesc =   b.getString(key + ".descr");
			putValue(SHORT_DESCRIPTION, ttDesc);
		} catch (MissingResourceException ex) {
			putValue(SHORT_DESCRIPTION, text);
		}

	}
}

//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/LabelText.java
//@@@@@@//
package com.darwinsys.swingui;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** A label and text combination, inspired by
 * the LabelText control in Guy Eddon's ActiveX Components book
 * (2nd Edition, page 203). But done more simply.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: LabelText.java,v 1.11 2004/03/08 01:06:23 ian Exp $
 */
public class LabelText extends JPanel implements java.io.Serializable {
	/** The label component */
	protected JLabel theLabel;
	/** The text field component */
	protected JTextField theTextField;
	/** The font to use */
	protected Font myFont;

	/** Construct the object with no initial values.
	 * To be usable as a JavaBean there MUST be a no-argument constructor.
	 */
	public LabelText() {
		this("(LabelText)",  12);
	}

	/** Construct the object with the label and a default textfield size */
	public LabelText(String label) {
		this(label, 12);
	}

	/** Construct the object with given label and textfield size */
	public LabelText(String label, int numChars) {
		super();
		setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
		theLabel = new JLabel(label);
		add(theLabel);
		theTextField = new JTextField(numChars);
		add(theTextField);
		//if (myFont != null) {
		//	// See setFont() below!
		//	theLabel.setFont(myFont);
		//	theTextField.setFont(myFont);
		//}
	}

	/** Get the label's horizontal alignment */
	public int getLabelAlignment() {
		return theLabel.getHorizontalAlignment();
	}

	/** Set the label's horizontal alignment */
	public void setLabelAlignment(int align) {
		theLabel.setHorizontalAlignment(align);
	}

	/** Get the text displayed in the text field */
	public String getText() {
		return theTextField.getText();
	}

	/** Set the text displayed in the text field */
	public void setText(String text) {
		theTextField.setText(text);
	}

	/** Get the text displayed in the label */
	public String getLabel() {
		return theLabel.getText();
	}

	/** Set the text displayed in the label */
	public void setLabel(String text) {
		theLabel.setText(text);
	}

	/** Set the font used in both subcomponents. */
	// public void setFont(Font f) {
		// myFont = f;
		// Since this class' constructors call to super() can trigger
		// calls to setFont() (from Swing.LookAndFeel.installColorsAndFont),
		// have to cache the font here.
		// if (theLabel != null)
			// theLabel.setFont(f);
		// if (theTextField != null)
			// theTextField.setFont(f);
	// }

	/** Adds the ActionListener to receive action events from the textfield */
	public void addActionListener(ActionListener l) {
		theTextField.addActionListener(l);
	}

	/** Remove an ActionListener from the textfield. */
	public void removeActionListener(ActionListener l) {
		theTextField.removeActionListener(l);
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/layout/CircleLayout.java
//@@@@@@//
package com.darwinsys.swingui.layout;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.LayoutManager;
import java.awt.Point;

import com.darwinsys.util.Debug;

/** A simplistic CircleLayout implementation of the LayoutManager interface.
 * Components are drawn at their preferred size.
 * <br/>
 * Bugs:
 * <ul>
 * <li>Only works well if the container is approximately square.
 * </ul>
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: CircleLayout.java,v 1.9 2004/06/01 02:51:37 ian Exp $
 */
public class CircleLayout implements LayoutManager {

	/** True to start at 12:00 position; false to start 1/2 way */
	boolean startAtTop = false;

	/** Construct a CircleLayout
	 */
	public CircleLayout(boolean isTop) {
		startAtTop = isTop;
	}

	/** Construct a CircleLayout with default values.
	 */
	public CircleLayout() {
		// Nothing to do
	}

	/** Adds the specified component with the specified constraint 
	 * to the layout; required by LayoutManager but not used.
	 */
	public void addLayoutComponent(String name, Component comp) {
		throw new IllegalArgumentException(
			"Don't use add(component, constraint) with CircleLayout");
	}

	/** Removes the specified component from the layout;
	 * required by LayoutManager, but does nothing.
	 */
	public void removeLayoutComponent(Component comp)  {
		// nothing to do
	}

	/** Calculates the preferred size dimensions for the specified panel 
	 * given the components in the specified parent container. */
	public Dimension preferredLayoutSize(Container parent)  {
		// System.out.println("preferredLayoutSize");
		return computelayoutSize(parent);
	}

	/** Find the minimum Dimension for the 
	 * specified container given the components therein.
	 */
	public Dimension minimumLayoutSize(Container parent)  {
		return computelayoutSize(parent);
	}

	Point[] points;

	/** Compute the size of the whole mess. Serves as the guts of 
	 * preferredLayoutSize() and minimumLayoutSize().
	 */
	protected Dimension computelayoutSize(Container parent) {

		// Pass the sums back as the actual size.
		// XXX finish this!
		return new Dimension(300, 300); // width == height!
	}

	/** Lays out the container in the specified panel. */
	public void layoutContainer(Container parent) {
		Component[] components = parent.getComponents();
		points = new Point[components.length];
		Dimension totalSize = parent.getSize();

		int dx = totalSize.width / 2;
		int dy = totalSize.height / 2;

		// make one quick pass to get max(PreferredSize.width[1..n]
		int width = 0, height = 0;
		for (int i=0; i < components.length; i++) {
			width = Math.max(width, components[i].getPreferredSize().width);
			height = Math.max(height, components[i].getPreferredSize().height);
		}
		int componentPad = Math.max(width, height) / 2;

		int PAD = 10;
		// Assumed to be regular (circle, not ellipse).
		int radius = dx - componentPad - PAD;

		int degreesPer = 360 / components.length;
		int angle = startAtTop ? 0 : degreesPer/2;

		for (int i=0; i < components.length; i++, angle += degreesPer) {
			Component c = components[i];
			Dimension d = c.getPreferredSize();
			double theta = Math.toRadians(angle);
			int x = (int)(Math.sin(theta) * radius);
			int y = (int)(Math.cos(theta) * radius);
			Debug.println("layout", c.getClass().getName() + 
				" " + angle + ", " + theta +
				", x=" + x + ", y=" + y);
			c.setBounds(dx + x - (d.width/2), dy + y - (d.height/2),
				d.width, d.height);
		}
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/layout/ColumnLayout.java
//@@@@@@//
package com.darwinsys.swingui.layout;

import java.awt.*;

/** 
 * <p>
 * ColumnLayout, a Columnar Layout Manager for AWT/Swing.
 * Sort of a cross between BoxLayout and GridLayout(0, x).
 * Displays components in a single row or column based on the
 * alignment given to the constructor, with optional padding.</p>
 * <p>
 * There is a utility method for adding space between the previous
 * and next components, which (like Menu.addSeparator()) adds a
 * fixed-size non-visible component between two added components.</p>
 * <p>
 * Note: The current version of ColumnLayout doesn't resize.</p>
 *
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: ColumnLayout.java,v 1.10 2004/03/14 20:36:44 ian Exp $
 */

public class ColumnLayout implements LayoutManager {
	/** Constant for X AXIS (horizontal column) alignment */
	public static final int X_AXIS = 'x';
	/** Constant for Y AXIS (vertical column) alignment */
	public static final int Y_AXIS = 'y';
	/** The alignment for this ColumnLayout */
	protected final int alignment;
	/** The X padding for this ColumnLayout */
	protected final int hPadding;	// blank final
	/** The Y padding for this ColumnLayout */
	protected final int vPadding;	// blank final
	/** The minimum width of each component */
	protected int minw;
	/** The minimum height of each component */
	protected int minh;
	/** The list of components */
	Component[] curComps;

	/** Construct a ColumnLayout given only an alignment. */
	public ColumnLayout(int dirn) {
		this(dirn, 0, 0);
	}

	/** Construct a ColumnLayout given an alignment and a padding amount. */
	public ColumnLayout(int dirn, int pad) {
		this(dirn, pad, pad);
	}

	/** Construct a ColumnLayout given an alignment and h,v padding amounts. */
	public ColumnLayout(int dirn, int hpad, int vpad) {
		alignment = dirn;
		hPadding  = hpad;
		vPadding  = vpad;
	}

	/**
	 * Called by AWT when the user uses the form add(name, Component).
	 * Adds the specified component with the specified name to the layout. 
	 * Not necessary to use this form.
	 *
	 * @param	name	String with location for component c
	 * @param	c	Component to be added.
	 */
	public void addLayoutComponent(String name, Component c) {
		System.err.println("don't use add(component,name) with ColumnLayout");
	}

	/**
	 * Called by AWT to lay out the components 
	 * in the target Container at its current size.
	 *
	 * @param	target	Container whose components are to be laid out.
	 */
	public void layoutContainer(Container target) {
		//System.out.println("ColumnLayout.layoutContainer() called.");
		doLayout(target);
	}

	/** Used internally: compute the layout and the maximal preferred 
	 * width & height
	 * <br/>
	 * TODO XXX NEED TO SCALE BY TARGSIZE?
	 */
	protected Dimension doLayout(Container target) {
		Dimension targSize = target.getSize();
		Insets ins = target.getInsets();

		// Pass 1 - get preferred sizes 
		minw = minh = 0;
		curComps = target.getComponents();
		for (int i = 0; i<curComps.length; i++) {
			Component tc = curComps[i];
			Dimension d = tc.getPreferredSize();
			minw = Math.max(minw, d.width);
			minh = Math.max(minh, d.height);
		}


		int x = hPadding, y = vPadding;
		// Pass 2 - move & resize components
		for (int i = 0; i<curComps.length; i++) {
			Component tc = curComps[i];
			Dimension d = tc.getPreferredSize();
			int cx, cy, cw, ch;
			switch (alignment) {
			case X_AXIS:
				if (tc instanceof Spacer)
					cw = d.width;
				else
					cw = minw;
				ch = minh; // d.height;
				cx = x;
				x += cw+hPadding;
				cy = vPadding;
				y  = ch;
				break;
			case Y_AXIS:
				cw = minw; // d.width;
				if (tc instanceof Spacer)
					ch = d.height;
				else
					ch = minh;
				cx = hPadding;
				x = cw;
				cy = y;
				y += ch+vPadding;
				break;
			default:
				throw new IllegalArgumentException("Invalid alignment");
			}
			tc.setBounds(cx, cy, cw, ch);
		}
		switch (alignment) {
			case X_AXIS:
				return new Dimension(x, y+2*vPadding);
			case Y_AXIS:
				return new Dimension(x+2*hPadding, y);
			default:
				throw new IllegalArgumentException("Invalid alignment");
		}
	}

	/**
	 * Called from AWT to calculate the minimum size dimensions 
	 * for the target panel given the components in it.
	 * But we use our own list of named insertions, not the
	 * list of Components that the container keeps.
	 *
	 * @param	target	Container to calculate for
	 */
	public Dimension minimumLayoutSize(Container target) {
		// XXX should return doLayout(target, 0, 0); - add vpad, hpad args
		return doLayout(target);
	}

	/**
	 * Called by AWT to compute the preferred size for the target panel
	 * given our list of the components that it contains.
	 *
	 * @param	target	Container to calculate for
	 */
	public Dimension preferredLayoutSize(Container target) {
		System.out.println("preferredLayoutSize() called");
		return doLayout(target);
	}

	/** Class to represent a spacer, like Menubar.separator. */
	protected class Spacer extends Component {
		public Dimension getPreferredSize() {
			return new Dimension(10, 10);
		}
	}

	/** Utility method to add a "spacer" */
	public void addSpacer(Container target) {
		target.add(new Spacer());
	}

	/**
	 * Called by AWT to remove a given component from the layout. 
	 *
	 * @param	c	Component to be removed
	 */
	public void  removeLayoutComponent(Component c) {
		// nothing to do! user will (hopefully) invalidate() the target.
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/layout/EntryLayout.java
//@@@@@@//
package com.darwinsys.swingui.layout;

import java.awt.*;

import com.darwinsys.util.Debug;

/** A simple layout manager, for "Entry" areas ith e.g., a list of labels
 * and their corresponding JTextFields. These typically look like:
 * <PRE>
 *    Login: _______________
 * Password: _______________
 * </PRE>
 * Basically two (or more) columns of different, but constant, widths.
 * <b>Note: all columns must be the same height!</b>.
 * <P>
 * Construct instances by passing an array of the column width percentages
 * (as doubles, fractions from 0.1 to 0.9, so 40%,60% would be {0.4, 0.6}).
 * The length of this array uniquely determines the number of columns.
 * Columns are forced to be the relevant widths.
 * <b>Note:</b> As with GridLayout, the number of items 
 * added <B>must</B> be an even
 * multiple of the number of columns. If not, exceptions may be thrown!
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: EntryLayout.java,v 1.11 2004/06/01 02:51:37 ian Exp $
 */
public class EntryLayout implements LayoutManager {
	/** The array of widths, as decimal fractions (0.4 == 40%, etc.). */
	protected final double[] widthPercentages;

	/** The number of columns. */
	protected final int COLUMNS;

	/** The default padding */
	protected final static int HPAD = 5, VPAD = 5;
	/** The actual padding */
	protected final int hpad, vpad;

	/** True if the list of widths was valid. */
	protected boolean validWidths = false;

	/** Construct an EntryLayout with widths and padding specified.
	 * @param relWidths	Array of doubles specifying relative column widths.
	 * @param h			Horizontal padding between items
	 * @param v			Vertical padding between items
	 */
	public EntryLayout(double[] relWidths, int h, int v) {
		COLUMNS = relWidths.length;
		widthPercentages = new double[COLUMNS];
		for (int i=0; i<relWidths.length; i++) {
			if (relWidths[i] >= 1.0)
				throw new IllegalArgumentException(
					"EntryLayout: widths must be fractions < 1");
			widthPercentages[i] = relWidths[i];
		}
		validWidths = true;
		hpad = h;
		vpad = v;
	}
	/** Construct an EntryLayout with widths and with default padding amounts.
	 * @param relWidths	Array of doubles specifying column widths.
	 */
	public EntryLayout(double[] relWidths) {
		this(relWidths, HPAD, VPAD);
	}

	/** Adds the specified component with the specified constraint 
	 * to the layout; required by LayoutManager but not used.
	 */
	public void addLayoutComponent(String name, Component comp) {
		// nothing to do
	}

	/** Removes the specified component from the layout;
	 * required by LayoutManager, but does nothing.
	 */
	public void removeLayoutComponent(Component comp)  {
		// nothing to do
	}

	/** Calculates the preferred size dimensions for the specified panel 
	 * given the components in the specified parent container. */
	public Dimension preferredLayoutSize(Container parent)  {
		// System.out.println("preferredLayoutSize");
		return computeLayoutSize(parent, hpad, vpad);
	}

	/** Find the minimum Dimension for the 
	 * specified container given the components therein.
	 */
	public Dimension minimumLayoutSize(Container parent)  {
		// System.out.println("minimumLayoutSize");
		return computeLayoutSize(parent, 0, 0);
	}

	/** The width of each column, as found by computLayoutSize(). */
	int[] widths;
	/** The height of each row, as found by computLayoutSize(). */
	int[] heights;

	/** Compute the size of the whole mess. Serves as the guts of 
	 * preferredLayoutSize() and minimumLayoutSize().
	 * @param parent The container in which to do the layout.
	 * @param hp The horizontal padding (may be zero)
	 * @param vp The Vertical Padding (may be zero).
	 */
	protected Dimension computeLayoutSize(Container parent, int hp, int vp) {
		if (!validWidths)
			return null;
		Component[] components = parent.getComponents();
		Dimension contSize = parent.getSize();
		int preferredWidth = 0, preferredHeight = 0;
		widths = new int[COLUMNS];
		heights = new int[components.length / COLUMNS];
		// System.out.println("Grid: " + widths.length + ", " + heights.length);

		int i;
		// Pass One: Compute largest widths and heights.
		for (i=0; i<components.length; i++) {
			int row = i / widthPercentages.length;
			int col = i % widthPercentages.length;
			Component c = components[i];
			Dimension d = c.getPreferredSize();
			widths[col] = Math.max(widths[col], d.width);
			heights[row] = Math.max(heights[row], d.height);
		}

		// Pass two: agregate them.
		for (i=0; i<widths.length; i++)
			preferredWidth += widths[i] + hp;
		for (i=0; i<heights.length; i++)
			preferredHeight += heights[i] + vp;

		// Finally, pass the sums back as the actual size.
		return new Dimension(preferredWidth, preferredHeight);
	}

	/** Lays out the container in the specified panel. This is a row-column
	 * type layout; find x, y, width and height of each Component.
	 * @param parent The Container whose children we are laying out.
	 */
	public void layoutContainer(Container parent) {
		Debug.println("layout","layoutContainer:");
		if (!validWidths)
			return;
		Component[] components = parent.getComponents();
		Dimension contSize = parent.getSize();
		int x = 0;
		for (int i=0; i<components.length; i++) {
			int row = i / COLUMNS;
			int col = i % COLUMNS;
			Component c = components[i];
			Dimension d = c.getPreferredSize();
			int colWidth = (int)(contSize.width * widthPercentages[col]);
			
			if (col == 0) {
				x = hpad;
			} else {
				x += hpad * (col-1) + (int)(contSize.width * widthPercentages[col-1]);
			}
			int y = vpad * (row) + (row * heights[row]) + (heights[row]-d.height);
			Rectangle r = new Rectangle(x, y, colWidth, d.height);
			c.setBounds(r);
		}
	}

}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/layout/RelativeLayout.java
//@@@@@@//
package com.darwinsys.swingui.layout;

import java.awt.*;
import java.util.*;

/** 
 * <p>
 * RelativeLayout, a Relative Layout Manager for Java J2SE.
 * Mainly for porting tired old code that uses x,y locations.
 * You really can't just assign x,y locations to components 
 * in Java Java J2SE - it breaks badly when the user resizes (and you can
 * <em>not</em> mandate that the user can't resize you -- see any book
 * on UI design for <em>that</em> little discussion -- and can also look
 * bad due to resolution independance.  Symantec Cafe 1.x, for example,
 * used to spit out unfortunate (and unmaintainable) code like this:
 * <pre>
 *       setLayout(null);
 *       setSize(331,241);
 *       label1=new Label("Info Applet", Label.CENTER);
 *       add(label1);
 *       label1.setBounds(91,19,107,15);
 * </pre>
 * </p> <p>
 * <em>Bleaarrgghh!!!</em>
 * To make it work properly at all resolutions and survive
 * user-initiated resize actions, change it to
 * <pre>
 *	setLayout(new RelativeLayout(331,241,false);
 *	label1=new Label("Info Applet", Label.CENTER);
 *	add("91,19", label1);
 * </pre>
 * Note that it's actually <EM>less</EM> work to get it right.
 * Symantec, Microsoft, and others, please take note!</p>
 * @author Ian Darwin, http://www.darwinsys.com/
 */

public class RelativeLayout implements LayoutManager {
	/** requested absolute width of canvas */
	protected int reqWid;
	/** requested absolute height of canvas */
	protected int reqHgt;

	/** actual size width when laid out */
	protected int curWid;
	/** actual size height when laid out */
	protected int curHgt;

	/** to track Components added by named add form. */
	protected Vector curComps = new Vector();

	/**
	 * Constructs an RelativeLayout, given original hard-coded size of panel.
	 */
	public RelativeLayout(int wid, int ht) {
		this.reqWid = wid;
		this.reqHgt = ht;
	}

	/**
	 * Called by AWT when the user uses the form add(name, Component).
	 * Adds the specified component with the specified name to the layout. 
	 *
	 * @param	name	String with location for component c
	 * <EM>Note</EM>: the "name" <EM>must</EM> contain x, y location, ie.,
	 * <BR>add("" + 320 + "," + 100, new Button("Quit"));
	 * <BR>or
	 * <BR>add("320,100", new Button("Quit").
	 * <BR>This adds the Button at x=320, y=100 when the Panel is 
	 * at its original full size.
	 * @param	c	Component to be added.
	 */
	public void addLayoutComponent(String name, Component c) {
		int x, y;
		StringTokenizer st = new StringTokenizer(name, ",");
		x = Integer.parseInt(st.nextToken());
		y = Integer.parseInt(st.nextToken());
		// System.out.println("Adding: Name " + name +"; obj " + c
		//	 + "; x " + x + "; y " + y);
		Tracker t = new Tracker(x, y, c);
		curComps.addElement(t);
	}

	/**
	 * Called by AWT to lay out the components 
	 * in the target Container at its current size.
	 *
	 * @param	target	Container whose components are to be laid out.
	 */
	public void layoutContainer(Container target) {
		Dimension targSize = target.getSize();
		Insets ins = target.getInsets();
		// System.out.println("layoutContainer: size " + targSize);
		curWid = targSize.width;
		curHgt = targSize.height;
		float widRatio = (float)curWid / (float)reqWid;
		float hgtRatio = (float)curHgt / (float)reqHgt;
		for (int i = 0; i<curComps.size(); i++) {
			int px, py, pw, ph;
			Tracker t = (Tracker)curComps.elementAt(i);
			Component tc = t.getComponent();
			Dimension d = tc.getPreferredSize();
			px = ins.right+(int)(t.getRequestedLoc().x * widRatio);
			py = ins.top + (int)(t.getRequestedLoc().y * hgtRatio);
			pw = d.width;
			ph = d.height;
			// System.out.println("layoutContainer["+i+"]: move " +
			// tc + " to " + px + ", " + py);
			tc.setBounds(px, py, pw, ph);
		}
	}

	/**
	 * Called from AWT to calculate the minimum size dimensions 
	 * for the target panel given the components in it.
	 * But we use our own list of named insertions, not the
	 * list of Components that the container keeps.
	 *
	 * @param	target	Container to calculate for
	 */
	public Dimension minimumLayoutSize(Container target) {
		int minw = 0, minh = 0;
		for (int i = 0; i<curComps.size(); i++) {
			Tracker t = (Tracker)curComps.elementAt(i);
			Component tc = t.getComponent();
			Dimension d = tc.getMinimumSize();
			Point rl = t.getRequestedLoc();
			minw = Math.max(minw, rl.x +d.width);
			minh = Math.max(minh, rl.y +d.height);
			// System.out.println("minLay, minw = " + minw 
			// + "; minh = " + minh);
		}
		return new Dimension(minw, minw);
	}

	/**
	 * Called by AWT to compute the preferred size for the target panel
	 * given our list of the components that it contains.
	 *
	 * @param	target	Container to calculate for
	 */
	public Dimension preferredLayoutSize(Container target) {
		int prefw = 0, prefh = 0;
		for (int i = 0; i<curComps.size(); i++) {
			Tracker t = (Tracker)curComps.elementAt(i);
			Component tc = t.getComponent();
			Dimension d = tc.getMinimumSize();
			Point rl = t.getRequestedLoc();
			prefw = Math.max(prefw, rl.x+d.width);
			prefh = Math.max(prefh, rl.y+d.height);
			// System.out.println("prefLay, prefw = " + 
			// prefw + "; prefh = " + prefh);
		}
		return new Dimension(prefw, prefh);
	}

	/**
	 * Called by AWT to remove a given component from the layout. 
	 *
	 * @param	c	Component to be removed
	 */
	public void  removeLayoutComponent(Component c) {
		curComps.removeElement(c);
	}

	/**
	 * Tracker is a class used only by RelativeLayout,
	 * to track the original "requested" (hard-coded) x,y locations of
	 * each Component.
	 */
	class Tracker {
		int absx, absy;
		Component theComp;

		/** Construct a tracker item given its location and Component. */
		Tracker(int x, int y, Component c) {
			this.absx = x;
			this.absy = y;
			this.theComp = c;
		}

		/** Extract the location as a Point. */
		public Point getRequestedLoc() {
			return new Point(absx, absy);
		}

		/** Extract the Component from this Tracker. */
		public Component getComponent() {
			return theComp;
		}
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/SimpleHelp.java
//@@@@@@//
package com.darwinsys.swingui;

import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.io.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;

/**
 * Simple Help Frame based on JFC JEditorPane.
 * <p>
 * May someday rewrite using JavaHelp API.
 * @version $Id: SimpleHelp.java,v 1.10 2003/05/30 13:16:07 ian Exp $
 */
public class SimpleHelp extends JFrame implements HyperlinkListener {
	/** The contentpane */
	protected Container cp;
	/** The editorpane */
	JEditorPane help;

	/* Construct a Help object. Just construct a JEditorPane
	 * with a URL, and it does all the help from there.
	 */
    public SimpleHelp(String windowName, String helpIndexFileName) {
		super(windowName + " Help Window");
		cp = getContentPane();
		getAccessibleContext().setAccessibleName(windowName + " Help Window");
		getAccessibleContext().setAccessibleDescription(
			"A window for viewing the help for " + windowName +
			", which is somewhat hyperlinked.");
	
		try {
			URL url = new File(helpIndexFileName).toURL();
			// Only create the window once.
			if (help == null) {
				// System.out.println("Creat-ing help window for " + url);
				help = new JEditorPane(url);
				// System.out.println("Done!");
				help.setEditable(false);
				help.addHyperlinkListener(this);
				JScrollPane scroller = new JScrollPane();
				scroller.setBorder(BorderFactory.createTitledBorder(windowName + " Help"));
				scroller.getViewport().add(help);
				cp.add(BorderLayout.CENTER, scroller);
				addWindowListener(new WindowAdapter() {
					public void windowClosing(WindowEvent e) {
						SimpleHelp.this.setVisible(false);
						SimpleHelp.this.dispose();
					}
				});
				setSize(500,400);
			} else {
				System.out.println("Re-using help window!");
			}
		} catch (MalformedURLException e) {
			System.out.println("Malformed URL: " + e);
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
    }

    /**
     * Notification of a change relative to a hyperlink. 
	 * From: java.swing.event.HyperlinkListener
     */
    public void hyperlinkUpdate(HyperlinkEvent e) {
		if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
			URL target = e.getURL();
			// System.out.println("linkto: " + target);

			// Get the help panel's cursor and the wait cursor
			Cursor oldCursor = help.getCursor();
			Cursor waitCursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);
			help.setCursor(waitCursor);

			// Now arrange for the page to get loaded asynchronously,
			// and the cursor to be set back to what it was.
			SwingUtilities.invokeLater(new PageLoader(target, oldCursor));
		}
	}

    /**
     * Inner class that loads a URL synchronously into the help panel.
	 * Loads it later than the request so that a cursor change
     * can be done at the very end.
	 * @author BORROWED FROM SUN'S SWING DEMO, UNTIL JAVAHELP AVAILABLE
     */
    class PageLoader implements Runnable {
		URL url;
		Cursor cursor;
	
		PageLoader(URL u, Cursor c) {
			url = u;
			cursor = c;
		}

        public void run() {
			// System.out.println("PageLoader: u=" + url);
			if (url == null) {
				// restore the original cursor
				help.setCursor(cursor);

				// PENDING(prinz) remove this hack when 
				// automatic validation is activated.
				Container parent = help.getParent();
				parent.repaint();
			} else {
				Document doc = help.getDocument();
				try {
					help.setPage(url);
				} catch (Exception ioe) {
					help.setDocument(doc);
					getToolkit().beep();
				} finally {
					// schedule the cursor to revert after
					// the paint has happended.
					url = null;
					SwingUtilities.invokeLater(this);
				}
			}
		}
    }

}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/Splash.java
//@@@@@@//
package com.darwinsys.swingui;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.MediaTracker;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JWindow;

/** A simple Splash screen. */
public class Splash extends JWindow {
	protected ImageIcon im;

	public Splash(JFrame f, String progName, String fileName) {
		super();
		// Can't use Swing border on JWindow: not a JComponent.
		// setBorder(BorderFactory.createBevelBorder(BevelBorder.RAISED));
		im = new ImageIcon(fileName);
		if (im.getImageLoadStatus() != MediaTracker.COMPLETE)
			JOptionPane.showMessageDialog(f,
				"Warning: can't load image " + fileName + "\n" +
				"Please be sure you have installed " + progName + " correctly",
				"Warning",
				JOptionPane.WARNING_MESSAGE);
		int w = im.getIconWidth(), h = im.getIconHeight();
		setSize(w, h);
		UtilGUI.center(this);
		addMouseListener(new MouseAdapter() {
			public void mouseClicked(MouseEvent e) {
				dispose();
			}
		});
		addKeyListener(new KeyAdapter() {
			public void keyTyped(KeyEvent e) {
				dispose();
			}
		});
	}

	public void paint(Graphics g) {
		im.paintIcon(this, g, 0, 0);
		g.setColor(Color.green);
		g.drawRoundRect(0, 0, getWidth()-1, getHeight()-1, 7, 7);
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/UtilGUI.java
//@@@@@@//
package com.darwinsys.swingui;

import java.awt.*;

/** Utilities for GUI work.
 * @version $Id: UtilGUI.java,v 1.6 2003/07/12 23:28:01 ian Exp $
 */
public class UtilGUI {

	/** Centre a Window, Frame, JFrame, Dialog, etc. */
	public static void centre(Window w) {
		// After packing a Frame or Dialog, centre it on the screen.
		Dimension us = w.getSize(), 
			them = Toolkit.getDefaultToolkit().getScreenSize();
		int newX = (them.width - us.width) / 2;
		int newY = (them.height- us.height)/ 2;
		w.setLocation(newX, newY);
	}

	/** Center a Window, Frame, JFrame, Dialog, etc., 
	 * but do it the American Spelling Way :-)
	 */
	public static void center(Window w) {
		UtilGUI.centre(w);
	}

	/** Maximize a window, the hard way. */
	public static void maximize(Window w) {
		Dimension us = w.getSize(),
			them = Toolkit.getDefaultToolkit().getScreenSize();
		w.setBounds(0,0, them.width, them.height);
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/swingui/WindowCloser.java
//@@@@@@//
package com.darwinsys.swingui;

import java.awt.Window;
import java.awt.event.*;

/** A WindowCloser - watch for Window Closing events, and
 * follow them up with setVisible(false), dispose(), and optionally
 * ends (it all) with a System.exit(0).
 * <p>
 * @deprecated For simple closing, just use JFrame.setDefaultCloseOperation().
 * @author Ian F. Darwin
 * @version $Id: WindowCloser.java,v 1.7 2003/05/29 18:06:31 ian Exp $
 */
public class WindowCloser extends WindowAdapter {

	/** The window we are to close */
	Window win;

	/** True if we are to exit as well. */
	boolean doExit = false;

	/** Construct a WindowCloser that doesn't exit, just closes the window */
	public WindowCloser(Window w) {
		this(w, false);
	}

	/** Construct a WindowCloser with control over whether it exits */
	public WindowCloser(Window w, boolean exit) {
		win = w;
		doExit = exit;
	}

	/** Called by AWT when the user tries to close the window */
	public void windowClosing(WindowEvent e) {
		win.setVisible(false);
		win.dispose();
		if (doExit)
			System.exit(0);
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/util/ArrayIterator.java
//@@@@@@//
package com.darwinsys.util;

import java.util.Iterator;

/** De-mystify the Iterator interface, showing how
 * to write a simple Iterator for an Array of Objects.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version	$Id: ArrayIterator.java,v 1.10 2004/06/16 17:39:33 ian Exp $
 */
public class ArrayIterator implements Iterator {
	/** The data to be iterated over. */
	protected Object[] data;

	protected int index = 0;

	/** Construct an ArrayIterator object.
	 * @param d The array of objects to be iterated over.
	 */
	public ArrayIterator(final Object[] d) {
		setData(d);
	}

	/** (Re)set the data array to the given array, and reset the iterator.
	 * @param d The array of objects to be iterated over.
	 */
	public void setData(final Object[] d) {
		this.data = d;
		index = 0;
	}

	/** 
	 * Tell if there are any more elements.
	 * @return true if not at the end, i.e., if next() will succeed.
	 * @return false if next() will throw an exception.
	 */
	public boolean hasNext() {
		return (index < data.length);
	}

	/** Returns the next element from the data */
	public Object next() {
		if (hasNext()) {
			return data[index++];
		}
		throw new IndexOutOfBoundsException("only " + data.length + " elements");
	}

	/** Remove the object that next() just returned.
	 * An Iterator is not required to support this interface,
	 * and we certainly don't!
	 */
	public void remove() {
		throw new UnsupportedOperationException(
			"This demo does not implement the remove method");
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/util/Debug.java
//@@@@@@//
package com.darwinsys.util;

/** Utilities for debugging
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version	$Id: Debug.java,v 1.8 2004/01/31 01:26:06 ian Exp $
 */
public class Debug {
	/** Static method to see if a given category of debugging is enabled.
	 * Enable by setting e.g., -Ddebug.fileio to debug file I/O operations.
	 * For example:<br/>
	 * if (Debug.isEnabled("fileio"))<br/>
	 * 	System.out.println("Starting to read file " + fileName);
	 */
	public static boolean isEnabled(String category) {
		return System.getProperty("debug." + category) != null;
	}

	/** Static method to println a given message if the
	 * given category is enabled for debugging, as reported by isEnabled.
	 */
	public static void println(String category, String msg) {
		if (isEnabled(category))
			System.out.println(msg);
	}
	/** Static method to println an arbitrary Objecct if the given
	 * category is enabled for debugging, as reported by isEnabled.
	 */
	public static void println(String category, Object stuff) {
		println(category, stuff.toString());
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/util/EnumerationIterator.java
//@@@@@@//
package com.darwinsys.util;

import java.util.Iterator;
import java.util.Enumeration;

/** A GOF Adapter to make instances of old Enumeration interface
 * behave like new Iterator interface, so we only have to deal
 * with one well-defined implementation of the Iterator pattern.
 */
public class EnumerationIterator implements Iterator {

	/** The Enumeration being delegated to */
	private final Enumeration oldEnum;

	/** Construct an EnumerationIterator from an old-style Enumeration.
	 * @param  old The Enumeration to be adapted.
	 */
	public EnumerationIterator(final Enumeration old) {
		oldEnum = old;
	}

	/** Fulfuls the general contract of Iterator.hasNext(), that is,
	 * return true as long as there is at least one more item in
	 * the Iterator.
	 */
	public boolean hasNext() {
		return oldEnum.hasMoreElements();
	}
	/** Fulfuls the general contract of Iterator.next(), that is,
	 * returns the next element in the Iterator.
	 */
	public Object next() {
		return oldEnum.nextElement();
	}

	/** Remove is not implemented (optional method).
	 * @throws java.lang.UnsupportedOperationException in all cases.
	 */
	public void remove() {
		throw new UnsupportedOperationException("remove");
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/util/FileProperties.java
//@@@@@@//
package com.darwinsys.util;

import java.io.*;
import java.util.*;

/** 
 * The <CODE>FileProperties</CODE> class extends <CODE>Properties</CODE>,
 * "a persistent set of properties [that] can be saved to a stream
 * or loaded from a stream". This subclass attends to all the mundane
 * details of opening the Stream(s) for actually saving and loading
 * the Properties.
 *
 * <P>This subclass preserves the useful feature that
 * a property list can contain another property list as its
 * "defaults"; this second property list is searched if
 * the property key is not found in the original property list.
 *
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: FileProperties.java,v 1.10 2004/03/07 17:14:56 ian Exp $
 */
public class FileProperties extends Properties {
	/** The name of the file this FileProperties represents. */
	protected String fileName = null;
	/** True if the file represented by fileName exists */
	private boolean exists = false;

	/** Construct a FileProperties given a fileName. */
	public FileProperties(String loadsaveFileName)
	throws IOException {
		super();
		setFileName(loadsaveFileName);
		load();
	}

	/** Construct a FileProperties given a fileName and 
	 * a list of default properties.
	 */
	public FileProperties(String loadsaveFileName, Properties defProp)
	throws IOException {
		super(defProp);
		setFileName(loadsaveFileName);
		load();
	}

	/** Set the fileName. If it exists not, but it+".properties" does,
	 * save the full name.
	 */
	void setFileName(String newName) {
		fileName = newName;
		if (new File(fileName).exists()) {
			exists = true;
			return;
		}
		if (!newName.endsWith(".properties")) {
			File f2 = new File(newName + ".properties");
			if (f2.exists()) {
				exists = true;
				fileName = newName + ".properties";
				return;
			}
		}
	}

	public String getFileName() {
		return fileName;
	}

	/** Load the properties from the saved filename.
	 * If that fails, try again, tacking on the .properties extension
	 */
	public Properties load() throws IOException {

		if (!exists)
			return this;

		// Sorry it's an InputStream not a Reader, but that's what
		// the superclass load method still requires (as of 1.4 at least).
		InputStream inStr = new FileInputStream(fileName);

		// now message the superclass code to load the file.
		load(inStr);

		inStr.close();

		// Return "this" for convenience
		return this;
	}

	/** Save the properties to disk for later loading. */
	public void save() throws IOException {
		OutputStream outStr = new FileOutputStream(fileName);
		
		// Get the superclass to do most of the work for us.
		store(outStr, "# Written by FileProperties.save() at " + new Date());

		outStr.close();
	}

	/** No longer needed.
	 * @deprecated No longer needed.
	 */
	public void close() {
		// Nothing to do
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/util/IdMapEntry.java
//@@@@@@//
package com.darwinsys.util;

/**
 * An IdMapEntry is one int-String pair, for example, an "id" or primary key
 * in a database and a name or description of the item in the named row.
 * IdMapEntry objects are immutable.
 * <p>Rather like a java.util.Map.Entry but without needing to convert.
 * @version $Id: IdMapEntry.java,v 1.6 2004/06/01 02:51:38 ian Exp $
 */
public class IdMapEntry {
	private final int id;
	private final String name;

	public IdMapEntry(final int i, final String n) {
		this.id = i;
		this.name = n;
	}

	public int getKey() {
		return id;
	}

	public String getValue() {
		return name;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/util/IndexList.java
//@@@@@@//
package com.darwinsys.util;

import java.util.Collection;
import java.util.List;
import java.util.Iterator;
import java.util.ListIterator;

/**
 * <p>
 * A general-purpose List, in which objects keep their identity (index),
 * that is, insert() operations do not renumber remaining objects.
 * Hence, more like a real array than an ArrayList is(!).
 * </p><p>
 * Not necessarily for production use; written as an example of
 * implementing the List interface.
 */
public class IndexList implements List {
	/** high water mark */
	private int hwm = 0;

	/** Implementation: data */
	private Object[] data;

	/** The initial size of an instance's internal store */
	public static final int DEFAULT_START_SIZE = 42;

	public IndexList() {
		this(DEFAULT_START_SIZE);
	}
	public IndexList(int startSize) {
		data = new Object[startSize];
		hwm = 0;
	}

	public void ensureCapacity(int i) {
		if (i > data.length) {
			Object newData = new Object[i + 10];
			System.arraycopy(data, 0, newData, 0, hwm);
		}
	}

    public int size() {
		return hwm;
	}
    public boolean isEmpty() {
		return hwm > 0;
	}
    public boolean contains(Object o) {
		return indexOf(o) >= 0;
	}
	/** Add the given object to the end of the list */
    public boolean add(Object o) {
		ensureCapacity(hwm);
		data[hwm++] = o;
		return true;
	}
	/** remove() simply sets the given value to null.
	 */
    public boolean remove(Object o) {
		int i;
		if ((i = indexOf(o)) == -1)
			return false;
		remove(i);
		return true;
	}

	/** remove() simply sets the given value to null.
	 */
    public Object remove(int i) {
		Object old = data[i];
		data[i] = null;
		return old;
	}

	/** removeAll removes all the elements in a Collection from this List
	 * <br/>NOT IMPLEMENTED.
	 */
    public boolean removeAll(Collection c) {
		throw new IllegalStateException(
			"removeAll method not implemented in IndexList");
	}

    public Iterator iterator() {
		Object[] newData = new Object[hwm];
		System.arraycopy(data, 0, newData, 0, hwm);
		return new ArrayIterator(newData);
	}

	/** Return the collection as an Array of Object */
    public Object[] toArray() {
		return (Object[])data.clone();
	}

	/** Return the collection as an Array of newData's type */
    public Object[] toArray(Object[] newData) {
		if (newData.length != hwm) {
			throw new IllegalArgumentException("newData length != current");
		}
		System.arraycopy(data, 0, newData, 0, hwm);
		return newData;
	}

    public boolean containsAll(Collection c) {
		Iterator it = c.iterator();
		while (it.hasNext()) {
			if (indexOf(it.next()) == -1) {
				return false;
			}
		}
		return true;
	}

    public boolean addAll(Collection c) {
		Iterator it = c.iterator();
		while (it.hasNext()) {
			add(it.next());
		}
		return true;
	}

    public boolean addAll(int i, Collection c) {
		throw new IllegalStateException(
			"addAll method not implemented in IndexList");
	}

    public boolean retainAll(Collection c) {
		throw new IllegalStateException(
			"removeAll method not implemented in IndexList");
	}

    public void clear() {
		data = new Object[DEFAULT_START_SIZE];
		hwm = 0;
	}

    public int hashCode() {
		return data.hashCode();
	}

    public Object get(int i) {
		return data[i];
	}

    public Object set(int i, Object o) {
		ensureCapacity(i);
		Object old = data[i];
		data[i] = o;
		return old;
	}

	/** Unlike the general contract of List, this will replace, not insert
	 * before, the object at the given index.
	 */
    public void add(int i, Object o) {
		ensureCapacity(i);
		data[i] = o;
	}

	/** Find the location where this object is referenced, or null */
    public int indexOf(Object o) {
		for (int i=0; i<hwm; i++) {
			if (o == data[i]) {
				return i;
			}
		}
		return -1;
	}
    public int lastIndexOf(Object o) {
		for (int i=hwm-1; i>=0; i--) {
			if (o == data[i]) {
				return i;
			}
		}
		return -1;
	}
    public ListIterator listIterator() {
		throw new IllegalStateException(
			"listIterator method not implemented in IndexList");
	}
    public ListIterator listIterator(int i) {
		throw new IllegalStateException(
			"listIterator method not implemented in IndexList");
	}
    public List subList(int from, int to) {
		throw new IllegalStateException(
			"subList method not implemented in IndexList");
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/util/MkAccessors.java
//@@@@@@//
package com.darwinsys.util;

import java.io.PrintWriter;

/** MkAccessors is a utility to make a series of Java "accessors"
 * (set/get methods a la JavaBeans pattern). 
 * You're probably better off using an IDE!
 * <p>
 * Primarily meant for command-line use, but can be used from within
 * other tools (note that all methods are static).
 * I use it (with a shell script mkAccessors, which is
 * <pre>java -classpath $HOME/classes/ext/com-darwinsys-all.jar \
	com.darwinsys.util.MkAccessors $* </pre>
 * or something similar); in the vi or vim editors you just say
 * <pre>:r !mkAccessors firstName lastName address</pre>
 * to generate the setFirstName/getFirstName, etc. methods
 * right in the Java source while you're editing.
 * Your mileage may vary if you use a less-powerful editing tool.
 * @author Ian Darwin, http://www.darwinsys.com/
 */
public class MkAccessors {

	/** Private constructor, since no instances are allowed */
	private MkAccessors() {
		// Null
	}

	/** make an accessor for each field named in the command line */
	public static void main(String[] args) {
System.out.println("in main(" + args + ")...");
		PrintWriter out = new PrintWriter(System.out);
		for (int i=0; i < args.length; i++) {
			process(args[i], out);
		}
	}

	/** Generate the set and get methods for field "fld"
	 * @param fld - the field name
	 * @param out - the PrintWriter to print to.
	 */
	public static void process(String fld, PrintWriter out) {
System.out.println("process(" + fld + ")...");
		System.out.println( "\t/** Get the value of " + fld + " */");
		out.println( "\tpublic String get" + firstCap(fld) + "() {");
		out.println( "\t	return " + fld + ";");
		out.println( "\t}");
		out.println();
		out.println( "\t/** Set the value of " + fld + " */");
		out.println( "\tpublic void set" + firstCap(fld) + 
			"(String " + fld + ") {");
		out.println( "\t	this." + fld + " = " + fld + ";");
		out.println( "\t}");
		out.println();
	}

	static String firstCap(String fld) {
		StringBuffer sb = new StringBuffer(fld);
		char ch = sb.charAt(0);
		sb.deleteCharAt(0);
		sb.insert(0, Character.toUpperCase(ch));
		return sb.toString();
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/util/PropertiesMap.java
//@@@@@@//
package com.darwinsys.util;

import java.io.*;
import java.util.*;

/**
 * PropertiesMap -- a Map that loads from a Properties file, but unlike
 * Properties, preserves the ordering of the original file.
 * <p>
 * Written mainly as a demonstration of building a simple Map implementation
 * from scratch, but useful when order matters and yet you want the 
 * convenience of Map acccess.
 * @author  Ian F. Darwin
 * @version $Id: PropertiesMap.java,v 1.4 2003/05/29 17:36:28 ian Exp $
 */
public class PropertiesMap implements Map {

	private List names = new ArrayList();
	private List values = new ArrayList();

	public void load(String fileName) throws IOException {
		if (fileName == null) {
			throw new IOException("filename is null!");
		}
		InputStream is = new FileInputStream(fileName);
		BufferedReader rdr = new BufferedReader(
			new InputStreamReader(is));
		String line;
		while ((line = rdr.readLine()) != null) {
			int ix = line.indexOf('=');
			String name = line.substring(0, ix);
			String value = line.substring(ix+1);
			names.add(name);
			values.add(value);
		}
		rdr.close();
	}

	/** Return the number of entries in the Map */
    public int size() {
		return names.size();
	}

	/** Return true if the Map is empty */
    public boolean isEmpty() {
		return names.isEmpty();
	}

	/** Return true if the given object is contained as a Key */
    public boolean containsKey(Object obj) {
		return names.contains(obj);
	}

	/** Return true if the given object is contained as a Value */
    public boolean containsValue(Object obj) {
		return values.contains(obj);
	}

	/** Get a given object */
    public Object get(Object obj) {
		return values.get(names.indexOf(obj));
	}

	/** Add a given object into this Map. */
    public Object put(Object n, Object v) {
		names.add(n);
		values.add(v);
		return n;
	}

	/** Remove a given object */
    public Object remove(Object obj) {
		int i = values.indexOf(obj);
		if (i < 0) 
			throw new IllegalArgumentException("remove(" + obj + ") not found");
		names.remove(i);
		values.remove(i);
		return obj;
	}

	/** Merge all the values from another map into this map. */
    public void putAll(java.util.Map map) {
		Iterator k = map.keySet().iterator();
		while (k.hasNext()) {
			Object key = k.next();
			Object val = map.get(key);
			put(key, val);
		}
	}

	/** Discard all object references held in the collection, i.e.,
	 * reset to its initial state.
	 */
    public void clear() {
		names.clear();
		values.clear();
	}

	/** Return the set of keys */
    public java.util.Set keySet() {
		return new HashSet(names);
	}

	/** Return a Collection containing the values */
    public java.util.Collection values() {
		return values;
	}

	/** EntrySet (not implemented, returns null) */
    public java.util.Set entrySet() {
		return null;
	}
}
//@@@@@@//
//darwinsys/src/com/darwinsys/util/ScaledNumberFormat.java
//@@@@@@//
package com.darwinsys.util;

import java.text.DecimalFormat;
import java.text.FieldPosition;
import java.text.Format;
import java.text.ParseException;
import java.text.ParsePosition;

/**
 * Format numbers scaled for human comprehension.
 *
 * "Human-readable" output uses43 digits max, and puts unit suffixes at
 * the end.  Makes output compact and easy-to-read esp. on huge disks.
 * Formatting code was originally in OpenBSD "df", converted to library routine.
 * Scanning code written by Ian Darwin, originally for OpenBSD libutil.
 * 
 * Rewritten in Java in January, 2001; re-synched with OpenBSD in 2004.
 *
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ScaledNumberFormat.java,v 1.7 2004/06/16 23:02:45 ian Exp $
 */
public class ScaledNumberFormat extends Format {

	final static int NONE = 0;		// to become an enum for 1.5
	final static int KILO = 1;
	final static int MEGA = 2;
	final static int GIGA = 3;
	final static int TERA = 4;
	final static int PETA = 5;
	final static int EXA  = 6;

	DecimalFormat df;

	public ScaledNumberFormat() {
		df = new DecimalFormat("0");
	}

	/** The input scaling factors. All three arrays must be in same order. */
	static char scale_chars[] = { 'B', 'K', 'M', 'G', 'T', 'P', 'E',  };
	/** The numeric scale values. All three arrays must be in same order. */
	int units[] = { NONE, KILO, MEGA, GIGA, TERA, PETA, EXA };
	/** The input scale sizes. All three arrays must be in same order. */
	static long scale_factors[] = {
		1,
		1024,
		1048576L,
		1073741824L,
		1099511627776L,
		1125899906842624L,
		1152921504606846976L
	};
	private final static long LLONG_MAX = scale_factors[6];

	/* To prevent numeric overflow (Java doesn't need a "long long") */
	static final int MAX_DIGITS = 10;

	
	/** Parse a String expected to contain a number in Human Scaled Form.
	 * @param str - String to be parsed.
	 * @param where Ignored - required by API
	 * @return a Long containing the value (value is always
	 * integral, even though has a fractional part before scaling).
	  */
	public Object parseObject(String s, ParsePosition where) {
		int i, sign = 0, fract_digits = 0;
		long scale_fact = 1, whole = 0;
		long fpart = 0;

		if (s == null)
			return null;

		char[] b = s.trim().toCharArray();
		int p = 0;	// the index into b; the # of chars we've scanned.
		
		/* Then at most one leading + or - */
		while (b[p] == '-' || b[p] == '+') {
			if (b[p] == '-') {
				if (sign != 0)
					throw new NumberFormatException(
							"Number " + s + " has more than one sign.");
				sign = -1;
				++p;
			} else if (b[p] == '+') {
				if (sign != 0)
					throw new NumberFormatException(
							"Number " + s + " has more than one sign.");
				sign = +1;
				++p;
			}
		}
		
		/* Main loop: Scan digits, find decimal point, if present.
		 * We don't allow exponentials, so no scientific notation
		 * (but note that E for Exa might look like e to some!).
		 * Advance 'p' to end, to get scale factor.
		 */
		for (; p<b.length && (Character.isDigit(b[p]) || b[p]=='.'); ++p) {
			int ndigits = 0;
			if (b[p] == '.') {
				if (fract_digits>0) {
					throw new NumberFormatException(
					"Number " + s + " has more than one decimal point ");
				}
				fract_digits = 1;
				continue;
			}

			i = (b[p]) - '0';			// whew! finally a digit we can use
			if (fract_digits > 0) {	// fractional digit
				if (fract_digits >= MAX_DIGITS)
					throw new NumberFormatException("Number too large");
				fpart *= 10;
				fpart += i;
				++fract_digits;		// track for later scaling
			} else {						// normal digit
				if (++ndigits >= MAX_DIGITS)
					throw new NumberFormatException("Number too large");
				whole *= 10;
				whole += i;
			}
		}
		/* printf("whole=%qd, fpart %ld, fract_digits %ld\n",
		 *	whole, fpart, fract_digits);
		 */
		if (sign < 0) {
			whole *= sign;
			fpart *= sign;
		}

		/* If no scale factor given, we're done. fraction is discarded. */
		if (p >= b.length) {
			return new Long(whole);
		}

		/* Validate scale factor, and scale whole and fraction by it. */
		for (i = 0; i < scale_factors.length; i++) {
			if (b[p] == scale_chars[i] ||
				b[p] == Character.toLowerCase(scale_chars[i])) {
				// XXX if digits after this, throw exception
				scale_fact = scale_factors[i];
				// scale whole part: easy
				whole *= scale_fact;
				/* truncate fpart so it does't overflow.
				 * then scale fractional part.
				 */
				while (fpart >= LLONG_MAX / scale_fact) {
					fpart /= 10;
					fract_digits--;
				}
				fpart *= scale_fact;
				if (fract_digits > 0) {
					for (i = 0; i < fract_digits -1; i++)
						fpart /= 10;
				}
				whole += fpart;
				return new Long(whole);
			}
		}
		throw new IllegalArgumentException("invalid scale factor " + b[p]);	
	}

	/* Parse a String containing a Human Scaled Number.
	 * @see ScaledNumberFormat#parseObject(java.lang.String)
	 */
	public Object parseObject(String arg0) throws ParseException {
		return parseObject(arg0, null);
	}
	
	/* Format the given Number as a Scaled Numeral, returning the
	 * Stringbuffer (updated), and <em>ignoring</em> the FieldPosition.
	 * Method signature is overkill, but required as a subclass of Format.
	 */
	public StringBuffer format(Object on, StringBuffer sb, FieldPosition fp) {
		if (on instanceof String) {
			String son = (String)on;
			if (son.length() == 0) {
				return sb.append("0B");
			}
			on = parseObject(son, null);
		}
		if (!(on instanceof Long)) {
			throw new IllegalArgumentException("Argument " + on + " must be String or Long");
		}
		long n = ((Long)on).longValue();
		sb.append(format(n));
		return sb;
	}

	/** Format a double as a Scaled Numeral; just truncate to a
	 * long, and call format(long).
	 */
	public String format(double n) {
		return format((long)n);
	}

	/** Format a given long as a Scaled Numeral.
	 * This method is the REAL FORMATTING ENGINE.
	 */
	public String format(long number) {
		long fract = 0;
		int unit = NONE;

		StringBuffer buf = new StringBuffer();

		long abval = Math.abs(number);

		for (int i = 1/*!*/; i < scale_factors.length; i++) {
			if (abval < scale_factors[i]) {
				unit = units[i-1];
				fract = i == 1 ? 0 : abval % scale_factors[i-1];
				number /= scale_factors[i-1];
				break;
			}
		}

		if (fract < 0)
			fract = -fract;

		/* scale fraction to one digit (truncate, not round) */
		while (fract>9)
			fract /= 10;

		if (number == 0)
			return "0B";
		else if (unit == NONE || number >= 100 || number <= -100) {
			buf.append(df.format(number)).append(scale_chars[unit]);
		} else {
			buf.append(df.format(number)).append('.').
				append(fract).append(scale_chars[unit]);
		}

		return buf.toString();
	}
}
//@@@@@@//
//darwinsys/src/regress/AllTestsNonGUI.java
//@@@@@@//
package regress;

import junit.framework.Test;
import junit.framework.TestSuite;

/**
 * @author ian
 */
public class AllTestsNonGUI {

	public static void main(String[] args) {
		junit.swingui.TestRunner.run(AllTestsNonGUI.class);
	}

	public static Test suite() {
		TestSuite suite = new TestSuite("Test for regress");
		//$JUnit-BEGIN$
		suite.addTestSuite(ArrayIteratorTest.class);
		suite.addTestSuite(GetOptTest.class);
		suite.addTestSuite(StringFormatTest.class);
		suite.addTestSuite(FileIOTest.class);
		suite.addTestSuite(FilePropertiesTest.class);
		suite.addTestSuite(IndexListTest.class);
		suite.addTestSuite(StringUtilTest.class);
		suite.addTestSuite(ScaledNumberFormatTest.class);
		//$JUnit-END$
		return suite;
	}
}
//@@@@@@//
//darwinsys/src/regress/ArrayIteratorTest.java
//@@@@@@//
package regress;

import junit.framework.*;

import com.darwinsys.util.ArrayIterator;

public class ArrayIteratorTest extends TestCase {

	String[] TESTDATA = { "one", "two", "three" };

	ArrayIterator it = new ArrayIterator(TESTDATA);

	/** JUnit test classes require this constructor */
	public ArrayIteratorTest(String name) {
		super(name);
	}

	/** Simple tryout */
	public void testGetting() {
		int i = 0;
		while (it.hasNext()) {
			assertEquals(TESTDATA[i++], it.next());
		}

		// XXX read up on writing JUnit tests that should throw exceptions
		try {
			it.next();		// EXPECT RUNTIME ERROR
			System.err.println("ERROR - DID NOT GET EXPECTED EXCEPTION");
		} catch (IndexOutOfBoundsException e) {
			System.err.println("Got expected exception -- OK!");
		}
	}
}
//@@@@@@//
//darwinsys/src/regress/ArrayListTableDatum.java
//@@@@@@//
package regress;

/** Class to hold a name and a value from a Properties; the
 * ArrayList contains one of these per Properties entry.
 * Needs to be a non-inner class only to allow the Panel
 * to construct instances of it.
 */
public class ArrayListTableDatum {
	String name;
	String value;
	/** Constructor used below */
	public ArrayListTableDatum(String n, String v) {
		name = n; value = v;
	}
	/** public no-arg constructor, req'd for Add operation */
	public ArrayListTableDatum() {
		// Nothing
	}
}
//@@@@@@//
//darwinsys/src/regress/ArrayListTableSimple.java
//@@@@@@//
package regress;

import com.darwinsys.swingui.*;
import javax.swing.*;
import java.util.*;

/** Simple demo of the com.darwinsys.swingui.ArrayListTable{Model,Panel}.
 * The "data" is an ArrayList made from the System Properties
 */
public class ArrayListTableSimple extends JFrame {

	/** inner class for TableModel */
	class Model extends ArrayListTableModel {

		/** This defines the order of the columns. Must agree with columnClasses */
		protected String[] myColumnNames = { "Name", "Value" };
	
		protected Class[] myColumnClasses = { String.class, String.class };

		/** Return the width of the table */
		public int getColumnCount() { return 2; }

		/** Construct a Model given the ArrayList */
		public Model(ArrayList m) {
			super(m);
			columnNames = myColumnNames;
			columnClasses = myColumnClasses;
		}

		/** Returns a data value for the cell at row, col  */
		public Object getValueAt(int row, int col)  {

			ArrayListTableDatum current = (ArrayListTableDatum)getCached(row);
			switch(col) {
				case 0: return current.name;
				case 1: return current.value;
				default: 
					System.out.println("ERROR getValueAt(" + row + "," + col + "); invalid");
					return null;
			}
		}

		/** Set a data value for the cell at row, col */
		public void setValueAt(Object val, int row, int col)  {

			ArrayListTableDatum current = (ArrayListTableDatum)getCached(row);
			switch(col) {
				case 0: current.name = (String)val;
				case 1: current.value = (String)val;
			}
		}
	}

	/** Construct the main program's GUI */
	public ArrayListTableSimple() {
		super("ArrayListTableSimple");

		// Create empty ArrayList
		ArrayList data = new ArrayList();

		// Get the System Properties
		Properties p = System.getProperties();

		// Get an Iterator for the sorted set of keys in p
		Iterator it = new TreeMap(p).keySet().iterator();

		// Copy them into the ArrayList
		while (it.hasNext()) {
			String key = (String)it.next();
			String val = p.getProperty(key);
			data.add(new ArrayListTableDatum(key, val));
		}

		// Make the Model and View
		Model m = new Model(data);
		JPanel v = new ArrayListTablePanel(ArrayListTableDatum.class, data, m);

		// Make it show up in this JFrame
		setContentPane(new JScrollPane(v));
		pack();

		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}

	public static void main(String[] args) {
		new ArrayListTableSimple().setVisible(true);
	}
}
//@@@@@@//
//darwinsys/src/regress/CircleLayoutTest.java
//@@@@@@//
package regress;

import java.awt.*;
import javax.swing.*;

import com.darwinsys.swingui.layout.CircleLayout;

/** Testbed for CircleLayout layout manager.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: CircleLayoutTest.java,v 1.7 2004/01/31 01:26:06 ian Exp $
 */
public class CircleLayoutTest {

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		final JFrame f = new JFrame("CircleLayout Demonstration");
		Container cp = f.getContentPane();
		cp.setLayout(new CircleLayout(true));
		cp.add(new JButton("One"));
		cp.add(new JButton("Two"));
		cp.add(new JButton("Three"));
		cp.add(new JButton("Four"));
		cp.add(new JButton("Five"));
		cp.add(new JButton("Six"));
		f.pack();
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.setLocation(200, 200);
		f.setVisible(true);
	}
}
//@@@@@@//
//darwinsys/src/regress/ColumnLayoutTest.java
//@@@@@@//
package regress;

import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

import com.darwinsys.swingui.layout.ColumnLayout;

/**
 * Simple class to non-exhaustively test out RelLayout layout manager.
 */
public class ColumnLayoutTest extends JFrame {
	JButton adButton;	// adjust (dummy here)
	JButton qb;			// quit

	/**
	 * Simple main program to test out RelLayout.
	 * Invoke directly from Java interpreter.
	 */
	public static void main(String[] av) {
		new ColumnLayoutTest(ColumnLayout.X_AXIS, 0, 0).setVisible(true);
		new ColumnLayoutTest(ColumnLayout.Y_AXIS, 0, 0).setVisible(true);
		new ColumnLayoutTest(ColumnLayout.X_AXIS, 10, 10).setVisible(true);
		new ColumnLayoutTest(ColumnLayout.Y_AXIS, 10, 10).setVisible(true);
	}

	/** Construct a Test test program. */
	ColumnLayoutTest(int alignment, int hpad, int vpad) {
		super("Column Layout Tester");
		Container cp = getContentPane();
		ColumnLayout cl = new ColumnLayout(alignment, hpad, vpad);
		cp.setLayout(cl);
		cp.add(new JButton("X"));
		cp.add(new JButton("MidWidth"));
		cp.add(new JButton("A Long Button"));
		cl.addSpacer(cp);
		cp.add(qb = new JButton("Quit"));
		qb.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.exit(0);
			}
		});
		pack();
	}
}
//@@@@@@//
//darwinsys/src/regress/EntryLayoutTest.java
//@@@@@@//
package regress;

import java.awt.*;
import javax.swing.*;

import com.darwinsys.swingui.layout.EntryLayout;

/** Testbed for EntryLayout layout manager.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: EntryLayoutTest.java,v 1.10 2004/03/14 19:58:49 ian Exp $
 */
public class EntryLayoutTest {

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		testTwoCols();
		testFiveCols();
	}

	static void testTwoCols() {
		final JFrame f = new JFrame("EntryLayout Demonstration");
		Container cp = f.getContentPane();
		double widths[] = { .33, .66 };
		cp.setLayout(new EntryLayout(widths));
		cp.add(new JLabel("Login:", SwingConstants.RIGHT));
		cp.add(new JTextField(10));
		cp.add(new JLabel("Password:", SwingConstants.RIGHT));
		cp.add(new JPasswordField(20));
		cp.add(new JLabel("Security Domain:", SwingConstants.RIGHT));
		cp.add(new JTextField(20));
		// cp.add(new JLabel("Monkey wrench in works"));
		f.pack();
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.setLocation(200, 200);
		f.setVisible(true);
	}

	static void testFiveCols() {
		final JFrame f = new JFrame("EntryLayout Five Columns");
		Container cp = f.getContentPane();
		double widths[] = { .25, .33, .10, .10, .20 };
		cp.setLayout(new EntryLayout(widths));
		cp.add(new JLabel("Login:", SwingConstants.RIGHT));
		cp.add(new JTextField(10));
		cp.add(new JCheckBox());
		cp.add(new JCheckBox());
		cp.add(new JCheckBox());
		cp.add(new JLabel("Password:", SwingConstants.RIGHT));
		cp.add(new JPasswordField(20));
		cp.add(new JCheckBox());
		cp.add(new JCheckBox());
		cp.add(new JCheckBox());
		cp.add(new JLabel("Security Domain:", SwingConstants.RIGHT));
		cp.add(new JTextField(20));
		cp.add(new JCheckBox());
		cp.add(new JCheckBox());
		cp.add(new JCheckBox());
		f.pack();
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.setLocation(200, 200);
		f.setVisible(true);
	}
}
//@@@@@@//
//darwinsys/src/regress/ErrorUtilCatchTest.java
//@@@@@@//
package regress;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

/** Test the "sun.awt.exception.handler" trick to invoke swingui.ErrorUtil
 */
public class ErrorUtilCatchTest extends JFrame {

	public ErrorUtilCatchTest() {
		super("GUI");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Container cp = getContentPane();
		JButton bx = new JButton("Throw!");
		bx.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				throw new IllegalArgumentException("foo");
			}
		});
		cp.add(bx, BorderLayout.CENTER);
		JButton cl = new JButton("Close");
		cl.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				System.exit(0);
			}
		});
		cp.add(cl, BorderLayout.SOUTH);
		setBounds(200, 200, 200, 100);
	}

	public static void main(String[] args) {
		System.setProperty("sun.awt.exception.handler",
						   "com.darwinsys.swingui.ErrorUtil");
		new ErrorUtilCatchTest().setVisible(true);
	}
}


//@@@@@@//
//darwinsys/src/regress/ErrorUtilTest.java
//@@@@@@//
package regress;

import java.sql.SQLException;
import com.darwinsys.swingui.ErrorUtil;

public class ErrorUtilTest {
	public static void main(String[] args) {
		SQLException ex1 = new SQLException("One");
		SQLException ex2 = new SQLException("Two");
		SQLException ex3 = new SQLException("Three");
		ex1.setNextException(ex2);
		ex2.setNextException(ex3);
		ErrorUtil.showExceptions(null, ex3);

		Exception ioe = new Exception("Read error",
			new java.io.FileNotFoundException("No such file"));
		ErrorUtil.showExceptions(null, ioe);

		System.exit(0);
	}
}
//@@@@@@//
//darwinsys/src/regress/FileIOTest.java
//@@@@@@//
package regress;

import junit.framework.*;

import com.darwinsys.io.FileIO;

import java.io.*;

public class FileIOTest extends TestCase {
	/** Test File name. This file is created in build.xml */
	public static final String FILENAME="fileiotest.dat";
	/** Test string. */
	public static final String MESSAGE =
		"The quick brown fox jumps over the lazy dog.";

	/** Constructor sets up initial state data file state for testing */
	public FileIOTest() {
		try {
			PrintWriter out = new PrintWriter(new FileWriter(FILENAME));
			out.print(MESSAGE);	// NOT println; FileToString doesn't handle.
			out.close();
		} catch (IOException ex) {
			throw new IllegalStateException("FileIOTest: can't create " + FILENAME);
		}
	}

	public void testReaderToString() {
		try {
			String s = FileIO.readerToString(new FileReader(FILENAME));

			// Make sure that readerToString really reads from the file.
			assertEquals(s, MESSAGE);

			// Make sure that readerToString doesn't append gunk like
			// extraneous nulls.
			assertEquals(s.length(), new File(FILENAME).length());

		} catch (Exception ex) {
			System.err.println(ex);
			throw new IllegalArgumentException(ex.toString());
		}
	}
    public void testCopyFile() {
		String fileName = FILENAME;
		String targetFileName = FILENAME + ".bak";
		try {
			FileIO.copyFile(fileName, targetFileName);
			String s1 = FileIO.readerToString(new FileReader(fileName));
			String s2 = FileIO.readerToString(new FileReader(targetFileName));
			assertEquals(s1, s2);
		} catch (IOException ex) {
			System.err.println(ex);
			throw new IllegalArgumentException(ex.toString());
		}
	}
}
//@@@@@@//
//darwinsys/src/regress/FilePropertiesTest.java
//@@@@@@//
package regress;

import java.io.*;
import java.util.*;

import junit.framework.TestCase;

import com.darwinsys.util.FileProperties;

public class FilePropertiesTest extends TestCase {
	private static final String TEST_FILE_NAME = "erewhon";
	Properties p;
	File erewhon = new File(TEST_FILE_NAME);
	/** Set up for junit test.
	 * @see junit.framework.TestCase#setUp()
	 */
	protected void setUp() throws Exception {
		super.setUp();
		erewhon.delete();
		// no such file should exist; should not throw IOException
		p = new FileProperties(TEST_FILE_NAME); 
		
	}
	
    public void testSet() throws Exception {
		System.out.println("Properties p should be empty:");
		assertEquals(p.size(), 0);
		p.list(System.out);
		p.setProperty("foo", "bar");
		((FileProperties)p).save();

		p = new FileProperties(TEST_FILE_NAME);
		System.out.println("This properties should be have foo=bar:");
		p.list(System.out);

		new File("no such file").delete();
	}
}
//@@@@@@//
//darwinsys/src/regress/filtergui/FilterGUIDemo1.java
//@@@@@@//
package regress.filtergui;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;

import com.darwinsys.swingui.*;

/** A simple demo of FilterGUI */
public class FilterGUIDemo1 {

	/** "main program" method - construct and show */
	public static void main(String[] av) {

		String[] filters = { 
			"Apples",
			"Bananas",
			"Run for it!"
		};

		int DEFAULT_FILTER = 1;	// i.e., filters[DEFAULT_FILTER] is default

		// create a this object, tell it to show up
		final JFrame f = new JFrame("FilterGUI Demo 1");
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		final FilterGUI comp = new FilterGUI(filters, DEFAULT_FILTER);
		Container cp = f.getContentPane();
		cp.add(BorderLayout.CENTER, comp);
		JButton b = new JButton("Show");
		cp.add(BorderLayout.SOUTH, b);
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				java.util.List l = comp.getSelected();
				Iterator it = l.iterator();
				while (it.hasNext()) {
					System.out.println(it.next());
				}
			}
		});

		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		f.pack();
		f.setLocation(200, 200);
		f.setVisible(true);
	}
}
//@@@@@@//
//darwinsys/src/regress/filtergui/FilterGUIDemo2.java
//@@@@@@//
package regress.filtergui;

import javax.swing.JFrame;

import com.darwinsys.swingui.FilterGUI;

/** A simple demo of FilterGUI */
public class FilterGUIDemo2 {

	/** "main program" method - construct and show */
	public static void main(String[] av) {

		/** Inner class to represent real MyFilter implementations */
		class BasicFilter extends MyFilter {
			String title;
			BasicFilter(String s) {
				title = s;
			}
			public String toString() {
				return title;
			}
			public void write(byte[] data) throws MyFilterException {
				next.write(data);
			}
		}

		MyFilter[] filters = { 
			new BasicFilter("Basic Copy"),
			new BasicFilter("Noise Reduction"),
			new BasicFilter("RLE")
		};

		int DEFAULT_FILTER = 1;	// i.e., filters[DEFAULT_FILTER] is default

		// create a this object, tell it to show up
		final JFrame f = new JFrame("Filter FilterGUI");
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		FilterGUI comp = new FilterGUI(filters, DEFAULT_FILTER);
		f.getContentPane().add(comp);
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.pack();
		f.setLocation(200, 200);
		f.setVisible(true);
	}
}
//@@@@@@//
//darwinsys/src/regress/filtergui/MyFilter.java
//@@@@@@//
package regress.filtergui;

/** A trivial filter baseclass used in testing FilterGUI */
public abstract class MyFilter {
	protected MyFilter next;
	public abstract void write(byte[] data) throws MyFilterException;
	public void setNext(MyFilter n) {
		next = n;
	}
}
//@@@@@@//
//darwinsys/src/regress/filtergui/MyFilterException.java
//@@@@@@//
package regress.filtergui;

/** Simple marker class 
 * */
public class MyFilterException extends Exception {
	
	public MyFilterException() {
		super();
		// TODO Auto-generated constructor stub
	}

	public MyFilterException(String message) {
		super(message);
		// TODO Auto-generated constructor stub
	}

	public MyFilterException(String message, Throwable cause) {
		super(message, cause);
		// TODO Auto-generated constructor stub
	}

	public MyFilterException(Throwable cause) {
		super(cause);
		// TODO Auto-generated constructor stub
	}

}
//@@@@@@//
//darwinsys/src/regress/GetOptTest.java
//@@@@@@//
package regress;

import java.util.*;

import junit.framework.*;

import com.darwinsys.lang.GetOpt;
import com.darwinsys.lang.GetOptDesc;

/** Some test cases for GetOpt.
 * <br/>XXX TODO - compare with expected 'c' values.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: GetOptTest.java,v 1.15 2003/12/29 18:47:30 ian Exp $
 */
public class GetOptTest extends TestCase {

	private String goodArgChars = "o:h";
	private String goodArgs[]  = {
			"-h", "-o", "outfile", "infile"
	};
	private String goodLongArgs[]  = {
			"-help", "-output-file", "outfile", "infile"
	};
	private char[] goodArgsExpectChars = { 'h', 'o' };

	private 	String badArgChars = "f1o";
	private String badArgs[]  = {
			"-h", "-o", "outfile", "infile"
	};
	private char[] badArgsExpectChars = { '?', 'o' };

	private GetOptDesc[] options = {
		new GetOptDesc('o', "output-file", true),
		new GetOptDesc('h', "help", false),
	};

	public void testBadArgChar() {
		String bad = "abc@";
		try {
			new GetOpt(bad);
			fail("GetOpt(" + bad + ") did not throw expected exception");
		} catch (IllegalArgumentException ex) {
			System.err.println("Caught expected exception " + ex);
		}
	}
	public void testOldwayGood() {
		process1(goodArgChars, goodArgs, false);
		process2(goodArgChars, goodArgs, false);
	}
	public void testOldwayBadCharsGoodArgs() {
		process1(badArgChars, goodArgs, true);
		process2(badArgChars, goodArgs, true);
	}
	public void testOldwayBadCharsBadArgs() {
		process1(badArgChars, badArgs, true);
		process2(badArgChars, badArgs, true);
	}

	public void testNewWayShort() {
		GetOpt go = new GetOpt(options);
		Map map = go.parseArguments(goodArgs);
		newWayInner(go, map);
	}
	public void testNewWayLong() {
		GetOpt go = new GetOpt(options);
		Map map = go.parseArguments(goodLongArgs);
		newWayInner(go, map);
	}

	protected void newWayInner(GetOpt go, Map map) {
		assertFalse(map.size() == 0);
		if (map.size() == 0) {
			throw new IllegalArgumentException(
				"Unexpected empty map");
		}
		int errs = 0;
		Iterator it = map.keySet().iterator();
		while (it.hasNext()) {
			String key = (String)it.next();
			char c = key.charAt(0);
			String val = (String)map.get(key);
			switch(c) {
				case '?':
					errs++; break;
				case 'o': assertEquals(val, "outfile"); break;
				case 'f':
				case 'h':
				case '1':
					 assertEquals(val, null);
					break;
				default:
					throw new IllegalArgumentException(
						"Unexpected c value " + c);
			}
		}
		assertEquals(1, go.getFilenameList().size());
		assertEquals("infile", go.getFilenameList().get(0));
	}

	void process1(String argChars, String[] args, boolean shouldFail) {

		System.out.println("** START ** " + argChars);

		GetOpt go = new GetOpt(argChars);

		int errs = 0, ix = 0;

		char c;
		while ((c = go.getopt(args)) != 0) {
			if (c == '?') {
				System.out.print("Bad option");
				++errs;
			} else {
				System.out.print("Found " + c);
				if (go.optarg() != null)
					System.out.print("; Option " + go.optarg());
			}
			System.out.println();
		}

		// Process any filename-like arguments.
		for (int i=go.getOptInd(); i<args.length; i++) {
			System.out.println("Filename-like arg " + args[i]);
		}
	}

	void process2(String argChars, String[] args, boolean shouldFail) {
		int errs = 0;

		System.out.println("** START NEW WAY ** " + argChars);
		GetOpt go2 = new GetOpt(argChars);
		Map m = go2.parseArguments(args);
		if (m.size() == 0)
			System.out.println("NO ARGS MATCHED");
		Iterator it = m.keySet().iterator();
		while (it.hasNext()) {
			Object key = it.next();
			char c = ((String)key).charAt(0);
			System.out.print("Found " + c);
			if (c == '?')
				errs++;
			String val = (String)m.get(key);
			if (val == null || val.equals(""))
				System.out.print("; (no option)");
			else
				System.out.print("; Option " + val);
			System.out.println();
		}

		List filenames = go2.getFilenameList();
		for (int i = 0; i < filenames.size(); i++) {
			System.out.println("Filename-like arg " + filenames.get(i));
		}

		if (shouldFail) {
			if (errs != 0)
				System.out.println("Expected error(s) found");
			else
				System.out.println("** FAILURE ** Expected errors not found");
		} else {
			if (errs == 0)
				System.out.println("Expected error(s) found");
			else
				System.out.println("** FAILURE ** Expected errors not found");
		}
	}

	public void testConstructorArgs() {
		try {
			String bad = null;
			new GetOpt(bad);
			fail("GetOpt(null) did not throw expected exception");
		} catch (IllegalArgumentException ex) {
			System.err.println("Caught expected exception " + ex);
		}
		try {
			new GetOpt("::");
			fail("GetOpt(::) did not throw expected exception");
		} catch (IllegalArgumentException ex) {
			System.err.println("Caught expected exception " + ex);
		}
		new GetOpt("f:c:");		// this failed at one point - multiple : args
		new GetOpt("foo");		// multiple occurrences of same letter - ok?
	}
}
//@@@@@@//
//darwinsys/src/regress/IndexListTest.java
//@@@@@@//
package regress;

import java.util.Iterator;
import junit.framework.*;
import com.darwinsys.util.IndexList;

public class IndexListTest extends TestCase {

	String[] TESTDATA = { "one", "two", "three" };

	IndexList victim = new IndexList();

	/** JUnit test classes require this constructor */
	public IndexListTest(String name) {
		super(name);
	}

	public void setUp() {
		for (int i = 0; i<TESTDATA.length; i++) {
			victim.add(TESTDATA[i]);
		}
	}

	public void testIterator() {
		Iterator it = victim.iterator();
		int i = 0;
		while (it.hasNext()) {
			assertEquals(TESTDATA[i++], it.next());
		}
	}

	public void testSetAndGet() {
		victim.set(1, "deux");
		assertEquals( "deux", victim.get(1));
	}

	public void testSize() {
		assertEquals( TESTDATA.length, victim.size());
	}
}
//@@@@@@//
//darwinsys/src/regress/LabelTextBeansDemo.java
//@@@@@@//
package regress;

import javax.swing.*;

import com.darwinsys.swingui.LabelText;

/**
 * Demo of LabelText JavaBean
 * @author  Ian Darwin, http://www.darwinsys.com/
 * @version $Id: LabelTextBeansDemo.java,v 1.9 2004/06/01 02:51:37 ian Exp $
 */
public class LabelTextBeansDemo extends javax.swing.JFrame {

  /** Initializes the Form */
  public LabelTextBeansDemo() {
    initComponents ();
    pack ();
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the FormEditor.
   */
  private void initComponents () {//GEN-BEGIN:initComponents
    addWindowListener (new java.awt.event.WindowAdapter () {
        public void windowClosing (java.awt.event.WindowEvent evt) {
          exitForm (evt);
        }
      }
    );
    getContentPane ().setLayout (new java.awt.BorderLayout ());

    jPanel1 = new javax.swing.JPanel ();
    jPanel1.setLayout (new java.awt.FlowLayout ());

      jButton1 = new javax.swing.JButton ();
      jButton1.setText ("Display");
      jButton1.addActionListener (new java.awt.event.ActionListener () {
          public void actionPerformed (java.awt.event.ActionEvent evt) {
            jButton1ActionPerformed (evt);
          }
        }
      );
      jPanel1.add (jButton1);

      jButton2 = new javax.swing.JButton ();
      jButton2.setText ("Exit");
      jButton2.addActionListener (new java.awt.event.ActionListener () {
          public void actionPerformed (java.awt.event.ActionEvent evt) {
            jButton2ActionPerformed (evt);
          }
        }
      );
      jPanel1.add (jButton2);

    getContentPane ().add (jPanel1, "South");

    jPanel2 = new javax.swing.JPanel ();
    jPanel2.setLayout (new javax.swing.BoxLayout (jPanel2, 1));

      bean1 = new LabelText ();
      bean1.setLabel ("Name:");
      jPanel2.add (bean1);

      bean2 = new LabelText ();
      bean2.setLabel ("Address:");
      jPanel2.add (bean2);

    getContentPane ().add (jPanel2, "Center");

  }//GEN-END:initComponents

  void jButton1ActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
    String name = bean1.getText();
    String addr = bean2.getText();
    JOptionPane.showMessageDialog(this,
      "Name = " + name + "\n" +
      "Addr = " + addr,
      "Info",
      JOptionPane.INFORMATION_MESSAGE);
  }//GEN-LAST:event_jButton1ActionPerformed

  void jButton2ActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
    System.exit(0);
  }//GEN-LAST:event_jButton2ActionPerformed

  /** Exit the Application */
  void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
    System.exit (0);
  }//GEN-LAST:event_exitForm


// Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JPanel jPanel1;
  private javax.swing.JButton jButton1;
  private javax.swing.JButton jButton2;
  private javax.swing.JPanel jPanel2;
  private LabelText bean1;
  private LabelText bean2;
// End of variables declaration//GEN-END:variables


  public static void main(java.lang.String[] args) {
    new LabelTextBeansDemo().setVisible(true);
  }

}
//@@@@@@//
//darwinsys/src/regress/LabelTextTest.java
//@@@@@@//
package regress;

import com.darwinsys.swingui.LabelText;
import java.awt.*;
import javax.swing.*;

/** Test program for LabelText class.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: LabelTextTest.java,v 1.6 2004/01/31 01:26:07 ian Exp $
 */
public class LabelTextTest extends JPanel {

	/** "main program" method - construct and show */
	public static void main(String[] argv) {
		JFrame f = new JFrame("LabelTextTest");
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		LabelTextTest testee = new LabelTextTest();
		f.setContentPane(testee);	// it is a JPanel
		f.pack();
		f.setLocation(200, 200);
		f.setVisible(true);
	}

	/** Construct the object including its GUI */
	public LabelTextTest() {
		super();
		setLayout(new GridLayout(0, 1));
		JComponent foo;
		add(foo = new LabelText("Hello, and welcome to the world of Java"));
		foo.setFont(new Font("helvetica", Font.BOLD, 24));
		add(foo = new LabelText("Exit")); 
		foo.setForeground(Color.red);
	}
}
//@@@@@@//
//darwinsys/src/regress/MacOSUITest.java
//@@@@@@//
package regress;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;

import com.darwinsys.macosui.AboutBoxHandler;
import com.darwinsys.macosui.MacOSAppAdapter;
import com.darwinsys.macosui.MacOSUtil;
import com.darwinsys.macosui.PrefsHandler;
import com.darwinsys.macosui.PrintHandler;
import com.darwinsys.macosui.ShutdownHandler;

/**
 * Interactive test for "macosui" package.
 * Class can not extend JFrame; must invoke setMacOS() before first
 * call to any Swing constructor.
 * @version $Id: MacOSUITest.java,v 1.5 2004/03/08 00:19:02 ian Exp $
 */
public class MacOSUITest {

	public static void main(String[] args) {
		// Tester: check that this string appears in the Application Menu.
		MacOSUtil.setMacOS("MacOSUITest");
		new MacOSUITest();

	}
	
	public MacOSUITest() {
		JFrame jf = new JFrame("MacOSUITest");
		JButton button = new JButton("Exit");
		button.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				System.exit(0);
			}
		});
		jf.getContentPane().add(button);
		// Tester: see that Application->About produces our popup
		// Ditto for Preferences and Shutdown.
		MacOSAppAdapter adapter =
			new MacOSAppAdapter(jf, abouter, prefser, printer, shutter);
		adapter.register();
		jf.setSize(300, 200);
		jf.setVisible(true);
	}

	
	AboutBoxHandler abouter = new AboutBoxHandler() {
		public void showAboutBox(JFrame jf) {
			JOptionPane.showMessageDialog(
				null,
				"This is my About Box",
				"About Box",
				JOptionPane.INFORMATION_MESSAGE);

		};
	};
	PrefsHandler prefser = new PrefsHandler() {
		public void showPrefsDialog(JFrame jf) {
			JOptionPane.showMessageDialog(
				null,
				"This is my Preferences Panel",
				"Preferences Box",
				JOptionPane.INFORMATION_MESSAGE);
		};
	};
	PrintHandler printer = new PrintHandler() {
		public void doPrint(JFrame jf) {
			JOptionPane.showMessageDialog(
				null,
				"Print Handler",
				"Print Handler",
				JOptionPane.INFORMATION_MESSAGE);
		}
	};
	ShutdownHandler shutter = new ShutdownHandler() {
		public void shutdown(JFrame jf) {
			JOptionPane.showMessageDialog(
				null,
				"About to shut down the application",
				"Shutdown",
				JOptionPane.INFORMATION_MESSAGE);
			System.exit(0);
		};
	};

}
//@@@@@@//
//darwinsys/src/regress/RelativeLayoutTest.java
//@@@@@@//
package regress;

import java.awt.*;
import java.awt.event.*;

import javax.swing.JFrame;

import com.darwinsys.swingui.layout.RelativeLayout;

/**
 * Simple class to non-exhaustively test out RelativeLayout layout manager.
 */
public class RelativeLayoutTest extends JFrame {
	Button adButton;	// adjust (dummy here)
	Button qb;			// quit

	/**
	 * Simple main program to test out RelativeLayout.
	 * Invoke directly from Java interpreter.
	 */
	public static void main(String[] av) {
		RelativeLayoutTest f = new RelativeLayoutTest();
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.setVisible(true);
	}

	/** Construct a RelativeLayoutTest test program. */
	public RelativeLayoutTest() {
		super("RelativeLayout Tester");
		Container cp = getContentPane();
		cp.setLayout(new RelativeLayout(300, 150));
		cp.add("80,20", adButton = new Button("MidWidth"));
		cp.add("150,75", qb = new Button("Quit"));
		qb.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.exit(0);
			}
		});
		pack();
	}
}
//@@@@@@//
//darwinsys/src/regress/ScaledNumberFormatTest.java
//@@@@@@//
package regress;
import com.darwinsys.util.ScaledNumberFormat;

import junit.framework.*;

/** A simple test case for ScaledNumberFormat parse and format */

public class ScaledNumberFormatTest extends TestCase {

	class data {
		long number;
		String string;
		data(long n, String s) { number = n; string = s; }
		data(String s, long n) { this(n, s); }
	}

	ScaledNumberFormat sf = new ScaledNumberFormat();

	/** data for scan (parse) test */
	data sdata[] = {
		new data("123", 123),
		new data("1k", 1024),		// lower case
		new data("10099", 10099),
		new data("1M", 1024*1024),
		new data("1.5M", 1572864),		// fractions
		new data("-2K",	-2048),	// negatives
		new data("-2.2k", -2252),
		new data("0.5G", 536870912),
		new data("1G", 1073741824),
		new data("G", 0),
		new data("931G", 999653638144L),
	};

	public void testParseGood() throws Exception {
		for (int i = 0; i<sdata.length; i++) {
			Object o = sf.parseObject(sdata[i].string, null);
			assertEquals(sdata[i].string, sdata[i].number, ((Long)o).longValue());
		}
	}

	/** data for format test.
	  */
	data ddata[] = {
		new data(0,          "0B"),
		new data(999,      "999B"),
		new data(1000,    "1000B"),
		new data(1023,    "1023B"),
		new data(1024,    "1.0K"),
		new data(-1234,  "-1.2K"),
		new data(1025,    "1.1K"),
		new data(123456, "120K"),
		new data(999999999L,   "953M"),
		new data(999999999999L,   "931G"),
	};

	public void testFormatGood() {
		for (int i = 0; i < ddata.length; i++) {
			try {
				String expect = ddata[i].string;
				String actual = sf.format(ddata[i].number);
				System.out.println("Expect: " + expect + "; actual: " + actual);
				assertEquals(expect, expect, actual);
			} catch (Exception ex) {
				System.out.println("ERROR IN FORMAT CASE " + i);
				System.out.println(ddata[i] + " threw " + ex);
			}
		}
	}
	
	public void testFormatThreeArgs() throws Exception {
		StringBuffer sb = new StringBuffer();
		assertEquals("sb return", sb, sf.format("999999999", sb, null));
		assertEquals("format3Args", "953M", sb.toString());
		System.out.println("Format 3 args => " + sb.toString());
		sb.setLength(0);
		sf.format("", sb, null);
		assertEquals("format3Args", "0B", sb.toString());
		try {
			sf.format(null, sb, null);
		} catch (IllegalArgumentException ex) {
			System.out.println("Caught expected IAE on null input");
		}
	}
}
//@@@@@@//
//darwinsys/src/regress/SimpleHelpTest.java
//@@@@@@//
package regress;

import javax.swing.JFrame;

import com.darwinsys.swingui.SimpleHelp;

public class SimpleHelpTest {
	/** Test case */
	public static void main(String argv[]) {
		if (argv.length == 0)
			throw new IllegalArgumentException(
			"Usage: SimpleHelpTest helpFile");
		JFrame jf = new SimpleHelp("TESTING", argv[0]);
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
	}
}
//@@@@@@//
//darwinsys/src/regress/StringFormatTest.java
//@@@@@@//
package regress;

import junit.framework.*;

import com.darwinsys.lang.StringFormat;

public class StringFormatTest extends TestCase {
	String mesg = "JavaFun";

	public void testLeft() {
		assertEquals("JavaF",
			new StringFormat(5, StringFormat.JUST_LEFT).format(mesg));
		assertEquals("JavaFun   ",
			new StringFormat(10, StringFormat.JUST_LEFT).format(mesg));
	}
	public void testCentre() {
		assertEquals("JavaF",
			new StringFormat(5, StringFormat.JUST_CENTER).format(mesg));
		assertEquals(" JavaFun  ",
			new StringFormat(10, StringFormat.JUST_CENTER).format(mesg));
	}
	public void testRight() {
		assertEquals("JavaF",
			new StringFormat(5, StringFormat.JUST_RIGHT).format(mesg));
		assertEquals("   JavaFun",
			new StringFormat(10, StringFormat.JUST_RIGHT).format(mesg));
	}
}
//@@@@@@//
//darwinsys/src/regress/StringUtilTest.java
//@@@@@@//
package regress;

import junit.framework.*;

import com.darwinsys.lang.StringUtil;

public class StringUtilTest extends TestCase {

	public void testToCommaList() {
		String[] list = { "apples", "oranges", "pumpkins", "bananas" };
		assertEquals(
			"apples, oranges, pumpkins and bananas",
			StringUtil.arrayToCommaList(list));
	}

	public void testIndexOf() {
		StringBuffer sb = new StringBuffer("This Fish in the Ish Wish Dish");

		// Test Successes
		assertEquals(2, StringUtil.indexOf(sb, "is", 0));
		assertEquals(2, StringUtil.indexOf(sb, "is", 2));
		assertEquals(6, StringUtil.indexOf(sb, "is", 3));
		assertEquals(6, StringUtil.indexOf(sb, "is", 4));
		assertEquals(6, StringUtil.indexOf(sb, "is", 5));
		assertEquals(6, StringUtil.indexOf(sb, "is", 6));
		assertEquals(22,StringUtil.indexOf(sb, "is", 7));

		// Test Failures
		assertEquals(-1, StringUtil.indexOf(sb, "XX", 0));
		assertEquals(-1, StringUtil.indexOf(sb, "XX", 100));
	}

	public void testSubst() {
		String oldStr = "Old Mc${fred} had a farm, had ${fred}";
		String expect = "Old McFRED had a farm, had FRED";
		String newStr = StringUtil.subst("${fred}", "FRED", oldStr);
		System.out.println("OLD: " + oldStr);
		System.out.println("EXP: " + expect);
		System.out.println("GOT: " + newStr);
		assertEquals(expect, newStr);
	}
}
//@@@@@@//
//datetime/Cal.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;
import java.util.*;

/** Bean to display a month calendar in a JPanel. 
 * Only works for the Western calendar. 
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Cal.java,v 1.5 2004/02/09 03:33:45 ian Exp $
 */
public class Cal extends JPanel {
	/** The currently-interesting year (not modulo 1900!) */
	protected int yy;
	/** Currently-interesting month and day */
	protected int mm, dd;
	/** The buttons to be displayed */
	protected JButton labs[][];
	/** The number of day squares to leave blank at the start of this month */
	protected int leadGap = 0;
	/** A Calendar object used throughout */
	Calendar calendar = new GregorianCalendar();
	/** Today's year */
	protected final int thisYear = calendar.get(Calendar.YEAR);
	/** Today's month */
	protected final int thisMonth = calendar.get(Calendar.MONTH);
	/** One of the buttons. We just keep its reference for getBackground().*/
	private JButton b0;
	/** The month choice */
	private JComboBox monthChoice;
	/** The year choice */
	private JComboBox yearChoice;

	/** Construct a Cal, starting with today.
	 */
	Cal() {
		super();
		setYYMMDD(calendar.get(Calendar.YEAR),
			calendar.get(Calendar.MONTH),
			calendar.get(Calendar.DAY_OF_MONTH));
		buildGUI();
		recompute();
	}

	/** Construct a Cal, given the leading days and the total days
	 * @exception	IllegalArgumentException	If year out of range
	 */
	Cal(int year, int month, int today) {
		super();
		setYYMMDD(year, month, today);
		buildGUI();
		recompute();
	}

	private void setYYMMDD(int year, int month, int today) {
		yy = year;
		mm = month;
		dd = today;
	}

	String[] months = {
		"January", "February", "March", "April",
		"May", "June", "July", "August",
		"September", "October", "November", "December"
	};

	/** Build the GUI. Assumes that setYYMMDD has been called. */
	private void buildGUI() {
		getAccessibleContext().setAccessibleDescription(
			"Calendar not accessible yet. Sorry!");
		setBorder(BorderFactory.createEtchedBorder());

		setLayout(new BorderLayout());

		JPanel tp = new JPanel();
		tp.add(monthChoice = new JComboBox());
		for (int i=0; i<months.length; i++)
			monthChoice.addItem(months[i]);
		monthChoice.setSelectedItem(months[mm]);
		monthChoice.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ae) {
				int i = monthChoice.getSelectedIndex();
				if (i>=0) {
					mm = i;
					// System.out.println("Month=" + mm);
					recompute();
				}
			}
		});
		monthChoice.getAccessibleContext().setAccessibleName("Months");
		monthChoice.getAccessibleContext().setAccessibleDescription("Choose a month of the year");

		tp.add(yearChoice = new JComboBox());
		yearChoice.setEditable(true);
		for (int i=yy-5; i<yy+5; i++)
			yearChoice.addItem(Integer.toString(i));
		yearChoice.setSelectedItem(Integer.toString(yy));
		yearChoice.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ae) {
				int i = yearChoice.getSelectedIndex();
				if (i>=0) {
					yy = Integer.parseInt(yearChoice.getSelectedItem().toString());
					// System.out.println("Year=" + yy);
					recompute();
				}
			}
		});
		add(BorderLayout.CENTER, tp);

		JPanel bp = new JPanel();
		bp.setLayout(new GridLayout(7,7));
		labs = new JButton[6][7];	// first row is days

		bp.add(b0 = new JButton("S"));
		bp.add(new JButton("M"));
		bp.add(new JButton("T"));
		bp.add(new JButton("W"));
		bp.add(new JButton("R"));
		bp.add(new JButton("F"));
		bp.add(new JButton("S"));

		ActionListener dateSetter = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				String num = e.getActionCommand();
				if (!num.equals("")) {
					// set the current day highlighted
					setDayActive(Integer.parseInt(num));
					// When this becomes a Bean, you can
					// fire some kind of DateChanged event here.
					// Also, build a similar daySetter for day-of-week btns.
				}
			}
		};

		// Construct all the buttons, and add them.
		for (int i=0; i<6; i++)
			for (int j=0; j<7; j++) {
				bp.add(labs[i][j] = new JButton(""));
				labs[i][j].addActionListener(dateSetter);
			}

		add(BorderLayout.SOUTH, bp);
	}

	public final static int dom[] = {
			31, 28, 31, 30,	/* jan feb mar apr */
			31, 30, 31, 31, /* may jun jul aug */
			30, 31, 30, 31	/* sep oct nov dec */
	};

	/** Compute which days to put where, in the Cal panel */
	protected void recompute() {
		// System.out.println("Cal::recompute: " + yy + ":" + mm + ":" + dd);
		if (mm < 0 || mm > 11)
			throw new IllegalArgumentException("Month " + mm + " bad, must be 0-11");
		clearDayActive();
		calendar = new GregorianCalendar(yy, mm, dd);

		// Compute how much to leave before the first.
		// getDay() returns 0 for Sunday, which is just right.
		leadGap = new GregorianCalendar(yy, mm, 1).get(Calendar.DAY_OF_WEEK)-1;
		// System.out.println("leadGap = " + leadGap);

		int daysInMonth = dom[mm];
		if (isLeap(calendar.get(Calendar.YEAR)) && mm > 1)
			++daysInMonth;

		// Blank out the labels before 1st day of month
		for (int i = 0; i < leadGap; i++) {
			labs[0][i].setText("");
		}

		// Fill in numbers for the day of month.
		for (int i = 1; i <= daysInMonth; i++) {
			JButton b = labs[(leadGap+i-1)/7][(leadGap+i-1)%7];
			b.setText(Integer.toString(i));
		}

		// 7 days/week * up to 6 rows
		for (int i = leadGap+1+daysInMonth; i < 6*7; i++) {
			labs[(i)/7][(i)%7].setText("");
		}

		// Shade current day, only if current month
		if (thisYear == yy && mm == thisMonth)
			setDayActive(dd);		// shade the box for today

		// Say we need to be drawn on the screen
		repaint();
	}

	/**
	 * isLeap() returns true if the given year is a Leap Year.
	 *
	 * "a year is a leap year if it is divisible by 4
	 * but not by 100, except that years divisible by 400
	 * *are* leap years." 
	 *	-- Kernighan & Ritchie, _The C Programming Language_, p 37.
	 */
	public boolean isLeap(int year) {
		if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0)
			return true;
		return false;
	}

	/** Set the year, month, and day */
	public void setDate(int yy, int mm, int dd) {
		// System.out.println("Cal::setDate");
		this.yy = yy;
		this.mm = mm;		// starts at 0, like Date
		this.dd = dd;
		recompute();
	}

	/** Unset any previously highlighted day */
	private void clearDayActive() {
		JButton b;

		// First un-shade the previously-selected square, if any
		if (activeDay > 0) {
			b = labs[(leadGap+activeDay-1)/7][(leadGap+activeDay-1)%7];
			b.setBackground(b0.getBackground());
			b.repaint();
			activeDay = -1;
		}
	}

	private int activeDay = -1;

	/** Set just the day, on the current month */
	public void setDayActive(int newDay) {

		clearDayActive();

		// Set the new one
		if (newDay <= 0)
			dd = new GregorianCalendar().get(Calendar.DAY_OF_MONTH);
		else
			dd = newDay;
		// Now shade the correct square
		Component square = labs[(leadGap+newDay-1)/7][(leadGap+newDay-1)%7];
		square.setBackground(Color.red);
		square.repaint();
		activeDay = newDay;
	}

	/** For testing, a main program */
	public static void main(String[] av) {
		JFrame f = new JFrame("Cal");
		Container c = f.getContentPane();
		c.setLayout(new FlowLayout());

		// for this test driver, hardcode 1995/02/10.
		c.add(new Cal(1995, 2-1, 10));

		// and beside it, the current month.
		c.add(new Cal());

		f.pack();
		f.setVisible(true);
	}
}
//@@@@@@//
//datetime/CalApplet.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;

/** An Applet to display a "Cal" calendar component */
public class CalApplet extends Applet implements ActionListener {
	int yy, mm, dd;
	Cal cal;
	Panel p;
	TextField yyText, mmText, ddText;

	public void init() {
		setLayout(new BorderLayout());

		Calendar d = new GregorianCalendar();
		yy = d.get(Calendar.YEAR);
		mm = d.get(Calendar.MONTH);
		dd = d.get(Calendar.DAY_OF_MONTH);

		add(cal    = new Cal(yy, mm, dd), BorderLayout.NORTH);
		p = new Panel();
		p.setLayout(new FlowLayout());

		// The action for changing yy or mm draws a new calendar
		p.add(yyText = new TextField(""+yy));
		yyText.addActionListener(this);
		p.add(mmText = new TextField(""+(mm+1)));
		mmText.addActionListener(this);

		// The action for changing the day just highlights that day.
		p.add(ddText = new TextField(""+dd));
		ddText.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cal.setDayActive(Integer.parseInt(ddText.getText()));
			}
		});
		add(p, BorderLayout.SOUTH);
	}

	public void actionPerformed(ActionEvent e) {
		System.out.println("CalApplet::ActionPerformed");
		yy = Integer.parseInt(yyText.getText());
		mm = Integer.parseInt(mmText.getText());
		dd = Integer.parseInt(ddText.getText());

		cal.setDate(yy, mm-1, dd);
	}
}
//@@@@@@//
//datetime/CalCalcs.java
//@@@@@@//
import java.util.*;
/**
 * Show some calendar calculations.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: CalCalcs.java,v 1.3 2004/02/09 03:33:45 ian Exp $
 */
public class CalCalcs {
	public static void main(String[] argv) {
		//+
		Calendar c = Calendar.getInstance();
		System.out.println("I got a " + c.getClass());
		c.set(1951, 03, 24, 12, 30, 0);
		System.out.println("I set it to " + c.getTime().toString());
		System.out.println("I actually set the year to " +c.get(Calendar.YEAR));
		System.out.println("In milliseconds, that's " + c.getTime().getTime());
		System.out.println("Or, in seconds, " + c.getTime().getTime()/1000);
		//-
	}
}
//@@@@@@//
//datetime/CalendarDemo.java
//@@@@@@//
import java.util.*;

public class CalendarDemo {
	/** The Date we are about to format */
	Date timeNow;
	/** A calendar formatting object, used throughout. Note that
	 * other forms of the Calendar constructor let you pass in
	 * Locale, TimeZone, or both, or yy,mm,dd,[hh, mm [, ss]]
	 * You can also set your own Daylight Saving rules, fiddle
	 * the Gregorian cutover of 1582, and probably the phase of the moon!
	 */
	Calendar calendar = new GregorianCalendar();

	public static void main(String[] a) {
		new CalendarDemo().format();
	}

	/** Construct a CalendarDemo object with the current date/time */
	CalendarDemo() {
		timeNow = new Date();
	}

	public void format() {

		// Tell the calendar what date/time to format
		calendar.setTime(timeNow);

		// print out most of the known fields
		System.out.println("ERA: " + calendar.get(Calendar.ERA));
		System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
		System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
		System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR));
		System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH));
		System.out.println("DATE: " + calendar.get(Calendar.DATE));
		System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH));
		System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR));
		System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
		System.out.println("DAY_OF_WEEK_IN_MONTH: "
					 + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
		System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM));
		System.out.println("HOUR: " + calendar.get(Calendar.HOUR));
		System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY));
		System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE));
		System.out.println("SECOND: " + calendar.get(Calendar.SECOND));
		System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND));
		System.out.println("ZONE_OFFSET: "
					 + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000)));
		System.out.println("DST_OFFSET: "
					 + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000)));
	}
}
//@@@@@@//
//datetime/CalendarPage.java
//@@@@@@//
import java.util.*;
import java.text.*;

/** Print a month page.
 * Only works for the Western calendar. 
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: CalendarPage.java,v 1.7 2004/03/07 03:19:41 ian Exp $
 */
public class CalendarPage {

	/** The names of the months */
	String[] months = {
		"January", "February", "March", "April",
		"May", "June", "July", "August",
		"September", "October", "November", "December"
	};

	/** The days in each month. */
	public final static int[] dom = {
			31, 28, 31, 30,	/* jan feb mar apr */
			31, 30, 31, 31, /* may jun jul aug */
			30, 31, 30, 31	/* sep oct nov dec */
	};

	/** Compute which days to put where, in the Cal panel */
	public void print(int mm, int yy) {
		/** The number of days to leave blank at the start of this month */
		int leadGap = 0;

		System.out.print(months[mm]);		// print month and year
		System.out.print(" ");
		System.out.print(yy);
		System.out.println();

		if (mm < 0 || mm > 11)
			throw new IllegalArgumentException("Month " + mm + " bad, must be 0-11");
		GregorianCalendar calendar = new GregorianCalendar(yy, mm, 1);

		System.out.println("Su Mo Tu We Th Fr Sa");

		// Compute how much to leave before the first.
		// get(DAY_OF_WEEK) returns 0 for Sunday, which is just right.
		leadGap = calendar.get(Calendar.DAY_OF_WEEK)-1;

		int daysInMonth = dom[mm];
		if (calendar.isLeapYear(calendar.get(Calendar.YEAR)) && mm == 1)
			++daysInMonth;

		// Blank out the labels before 1st day of month
		for (int i = 0; i < leadGap; i++) {
			System.out.print("   ");
		}

		// Fill in numbers for the day of month.
		for (int i = 1; i <= daysInMonth; i++) {

			// This "if" statement is simpler than fiddling with NumberFormat
			if (i<=9)
				System.out.print(' ');
			System.out.print(i);

			if ((leadGap + i) % 7 == 0)		// wrap if end of line.
				System.out.println();
			else
				System.out.print(' ');
		}
		System.out.println();
	}

	/** For testing, a main program */
	public static void main(String[] av) {
		int month, year;

		CalendarPage cp = new CalendarPage();

		// print the current month.
		if (av.length == 2) {
			cp.print(Integer.parseInt(av[0])-1, Integer.parseInt(av[1]));
		} else {
			Calendar c = Calendar.getInstance();
			cp.print(c.get(Calendar.MONTH), c.get(Calendar.YEAR));
		}
	}
}
//@@@@@@//
//datetime/ClockApplet.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.util.Date;
import java.text.DateFormat;

/** An Applet to display the current time */
public class ClockApplet extends Applet implements Runnable {
	/** A Thread to run the timer */
	protected Thread timerThread;
	/** The date object */
	Date date = new Date();
	/** The date format */
	protected DateFormat format = DateFormat.getTimeInstance();

	/* Applet Lifestyle Methods */
	public void start() {
		timerThread = new Thread(this, "Clock");
		timerThread.start();
	}

	public void stop() {
		if (timerThread == null)
			return;
		timerThread = null;
	}
 
	/** Show the time, and wait a while. */
	public void run() {
		while (timerThread != null) {
			repaint();	// request a redraw
			try {
				timerThread.sleep(1000);
			} catch (InterruptedException e){ /* do nothing*/ }
		}
	}

	/** Display the time. */
	public void paint(Graphics g) {
		date.setTime(System.currentTimeMillis());
		g.drawString(format.format(date), 2, 10);
	}
}
//@@@@@@//
//datetime/CompareDates.java
//@@@@@@//
import java.util.*;
import java.text.*;

public class CompareDates {
	public static void main(String[] args) throws ParseException {

		DateFormat df = new SimpleDateFormat ("yyyy-MM-dd");

		// Get Date 1
		Date d1 = df.parse(args[0]);

		// Get Date 2
		Date d2 = df.parse(args[1]);

		String relation;
		if (d1.equals(d2))
			relation = "the same date as";
		else if (d1.before(d2))
			relation = "before";
		else
			relation = "after";
		System.out.println(d1 + " is " + relation + ' ' + d2);
	}
}
//@@@@@@//
//datetime/CompareFileDates.java
//@@@@@@//
import java.util.*;
import java.io.File;

public class CompareFileDates {
	public static void main(String[] args) {
		// Get the timestamp from file 1
		String f1 = args[0];
		long d1 = new File(f1).lastModified();

		// Get the timestamp from file 2
		String f2 = args[1];
		long d2 = new File(f2).lastModified();

		String relation;
		if (d1 == d2)
			relation = "the same age as";
		else if (d1 < d2)
			relation = "older than";
		else
			relation = "newer than";
		System.out.println(f1 + " is " + relation + ' ' + f2);
	}
}
//@@@@@@//
//datetime/Date0.java
//@@@@@@//
/**
 * Simple demo of Date class.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Date0.java,v 1.4 2004/02/09 03:33:45 ian Exp $
 */
public class Date0 {
	public static void main(String[] argv) {
		//+
		System.out.println(new java.util.Date());
		//-
	}
}
//@@@@@@//
//datetime/Date1.java
//@@@@@@//
import java.util.*;

/**
 * Get date/time using a Calendar, but use toString (uck!).
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Date1.java,v 1.3 2004/02/09 03:33:45 ian Exp $
 */
public class Date1 {
	public static void main(String[] argv) {
		//+
		System.out.println(Calendar.getInstance());
		//-
	}
}
//@@@@@@//
//datetime/Date2.java
//@@@@@@//
import java.util.*;

/**
 * Get date/time using a Calendar.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Date2.java,v 1.3 2004/02/09 03:33:45 ian Exp $
 */
public class Date2 {
	public static void main(String[] argv) {
		//+
		System.out.println(Calendar.getInstance().getTime());
		//-
	}
}
//@@@@@@//
//datetime/DateAdd.java
//@@@@@@//
import java.util.*;

/** DateAdd -- compute the difference between two dates.
 */
public class DateAdd {
	public static void main(String[] av) {
		//+
		/** Today's date */
		Date now = new Date();

		long t = now.getTime();

		t -= 700*24*60*60*1000;

		Date then = new Date(t);

		System.out.println("Seven hundred days ago was " + then);
		//-
	}
}
//@@@@@@//
//datetime/DateCalAdd.java
//@@@@@@//
import java.text.*;
import java.util.*;

/** DateCalAdd -- compute the difference between two dates.
 */
public class DateCalAdd {
	public static void main(String[] av) {
		/** Today's date */
		Calendar now = Calendar.getInstance();

		/* Do "DateFormat" using "simple" format. */
		SimpleDateFormat formatter
			= new SimpleDateFormat ("E yyyy/MM/dd 'at' hh:mm:ss a zzz");
		System.out.println("It is now " + 
			formatter.format(now.getTime()));

		now.add(Calendar.YEAR, -2);
		System.out.println("Two years ago was " + 
			formatter.format(now.getTime()));
	}
}
//@@@@@@//
//datetime/DateDemo.java
//@@@@@@//
import java.text.*;
import java.util.*;

/** Show some date uses */
public class DateDemo {
    public static void main(String[] args) {
		//+
		Date dNow = new Date();

		/* Simple, Java 1.0 date printing */
		System.out.println("It is now " + dNow.toString());


		// Use a SimpleDateFormat to print the date our way.
		SimpleDateFormat formatter
			= new SimpleDateFormat ("E yyyy.MM.dd 'at' hh:mm:ss a zzz");
		System.out.println("It is " + formatter.format(dNow));
		//-
	}
}
//@@@@@@//
//datetime/DateDiff.java
//@@@@@@//
import java.util.*;

/** DateDiff -- compute the difference between two dates.
 */
public class DateDiff {
	public static void main(String[] av) {
		/** The date at the end of the last century */
		Date d1 = new GregorianCalendar(2000,11,31,23,59).getTime();

		/** Today's date */
		Date today = new Date();

		// Get msec from each, and subtract.
		long diff = today.getTime() - d1.getTime();

		System.out.println("The 21st century (up to " + today + 
			") is " + (diff / (1000*60*60*24)) + " days old.");
	}
}
//@@@@@@//
//datetime/DateFormatBest.java
//@@@@@@//
import java.util.*;
import java.text.*;

/** The "best" way to format a date/time is to use
 * the DateFormat.getInstance() method, which will
 * be localized automatically.
 * @version $Id: DateFormatBest.java,v 1.1 2004/03/03 17:22:14 ian Exp $
 */
public class DateFormatBest {
	public static void main(String[] args) {
		Date today = new Date();

		DateFormat df = DateFormat.getInstance();
		System.out.println(df.format(today));

		DateFormat df_fr = 
			DateFormat.getDateInstance(DateFormat.FULL, Locale.FRENCH);
		System.out.println(df_fr.format(today));
	}
}
//@@@@@@//
//datetime/DateFormatFile.java
//@@@@@@//
import java.text.*;
import java.util.*;
import java.io.*;

/** Create SimpleDateFormats from a string read from a file */
public class DateFormatFile {
	/** Today's Date */
	Date dNow = new Date();

    public static void main(String[] args) throws IOException {
		DateFormatFile df = new DateFormatFile();
		BufferedReader is = 
			new BufferedReader(new InputStreamReader(System.in));
		String line;
		while ((line = is.readLine()) != null) {
			df.process(line);
		}
	}

	/** Use a SimpleDateFormat - based on arg - to print the date your way. */
	protected void process(String arg) {	
		SimpleDateFormat formatter = new SimpleDateFormat(arg);
		System.out.println("FORMAT: " + arg);
		System.out.println("RESULT: " + formatter.format(dNow));
		System.out.println();
	}
}
//@@@@@@//
//datetime/DateParse1.java
//@@@@@@//
import java.text.*;
import java.util.*;

/** Show some date uses */
public class DateParse1 {
	public static void main(String[] args) {

		SimpleDateFormat formatter
			= new SimpleDateFormat ("yyyy-MM-dd");
		String input = args.length == 0 ? "1818-11-11" : args[0];
		System.out.print(input + " parses as ");
		Date t;
		try {
			t = formatter.parse(input);
			System.out.println(t);
		} catch (ParseException e) {
			System.out.println("unparseable using " + formatter);
		}
	}
}
//@@@@@@//
//datetime/DateParse2.java
//@@@@@@//
import java.text.*;
import java.util.*;

/** Show some date uses */
public class DateParse2 {
	public static void main(String[] args) {

		//+
		SimpleDateFormat formatter =
			new SimpleDateFormat ("yyyy-MM-dd");
		String input[] = { 
			"BD: 1913-10-01 Vancouver, B.C.",
			"MD: 1948-03-01 Ottawa, ON",
			"DD: 1983-06-06 Toronto, ON" };
		for (int i=0; i<input.length; i++) {
			String aLine = input[i];
			String action;
			switch(aLine.charAt(0)) {
				case 'B': action = "Born"; break;
				case 'M': action = "Married"; break;
				case 'D': action = "Died"; break;
				// others...
				default: System.err.println("Invalid code in " + aLine);
				continue;
			}
			int p = aLine.indexOf(' ');
			ParsePosition pp = new ParsePosition(p);
			Date d = formatter.parse(aLine, pp);
			if (d == null) {
				System.err.println("Invalid date in " + aLine);
				continue;
			}
			String location = aLine.substring(pp.getIndex());
			System.out.println(
				action + " on " + d + " in " + location);
		}
		//-
	}
}
//@@@@@@//
//datetime/DatePrint1.java
//@@@@@@//
import java.util.*;
/**
 * Show dates before 1970.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: DatePrint1.java,v 1.3 2004/02/09 03:33:46 ian Exp $
 */
public class DatePrint1 {
	public static void main(String[] argv) {
		//+
		Calendar c = new GregorianCalendar(1918, 10, 11);
		System.out.println(c.get(Calendar.DAY_OF_MONTH) + " " +
			c.get(Calendar.MONTH) + ", " +
			c.get(Calendar.YEAR) + " " +
			c.get(Calendar.ERA));
		//-
	}
}
//@@@@@@//
//datetime/DatePrint2.java
//@@@@@@//
import java.util.*;
/**
 * Show dates before 1970, in JDK1.0/1.1 when Date was broken
 * DO NOT USE ANYMORE -- use DateFormat instead!!.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: DatePrint2.java,v 1.4 2004/02/09 03:33:46 ian Exp $
 */
public class DatePrint2 {
	//+
	static String months[] = {
		"January", "February", "March",
		"April",   "May",      "June",
		"July",    "August",   "September",
		"October", "November", "December" };
	static String[] eras = { "B.C.", "A.D." };
	public static void main(String[] argv) {
		Calendar c = new GregorianCalendar(1918, 10, 11);
		System.out.println(
			months[c.get(Calendar.MONTH)] + " " +
			c.get(Calendar.DAY_OF_MONTH) + ", " +
			c.get(Calendar.YEAR) + " " +
			eras[c.get(Calendar.ERA)]);
	//-
	}
}
//@@@@@@//
//datetime/DateUse.java
//@@@@@@//
import java.io.*;
import java.text.*;
import java.util.*;

/** Trivial class to show use of Date & Calendar objects */
public class DateUse {

	/** Typical main method ("main program") declaration */
	public static void main(String[] av) {

		Locale l1 = new Locale("en", "US"),
			l2 = new Locale("es", "ES");

		// Create a Date object for May 5, 1986
		Calendar c = Calendar.getInstance();
		c.set(1986, 04, 05);		// May 5, 1986
		Date d1 = c.getTime();

		// Create a Date object for today.
		Date d2 = new Date();		// today

		DateFormat df_us = DateFormat.getDateTimeInstance(
				DateFormat.MEDIUM, DateFormat.MEDIUM, l1),
			df_sp = DateFormat.getDateTimeInstance(
				DateFormat.MEDIUM, DateFormat.MEDIUM, l2);
		System.out.println("Date d1 for US is " + df_us.format(d1));
		System.out.println("Date d1 for Spain is " + df_sp.format(d1));
		System.out.println("Date d2 is " + df_us.format(d2));
	}
}
//@@@@@@//
//datetime/DayWeek.java
//@@@@@@//
import java.util.*;

/** Show use of Calendar get() method with various parameters. */
public class DayWeek {

	public static void main(String[] av) {
		//+
		Calendar c = Calendar.getInstance();	// today

		System.out.println("Year: " + c.get(Calendar.YEAR));
		System.out.println("Month: " + c.get(Calendar.MONTH));
		System.out.println("Day: " + c.get(Calendar.DAY_OF_MONTH));
		System.out.println("Day of week = " + c.get(Calendar.DAY_OF_WEEK));
		System.out.println("Day of year = " + c.get(Calendar.DAY_OF_YEAR));
		System.out.println("Week in Year: " + c.get(Calendar.WEEK_OF_YEAR));
		System.out.println("Week in Month: " + c.get(Calendar.WEEK_OF_MONTH));
		System.out.println("Day of Week in Month: " + c.get(Calendar.DAY_OF_WEEK_IN_MONTH));
		System.out.println("Hour: " + c.get(Calendar.HOUR));
		System.out.println("AM or PM: " + c.get(Calendar.AM_PM));
		System.out.println("Hour (24-hour clock): " + c.get(Calendar.HOUR_OF_DAY));
		System.out.println("Minute: " + c.get(Calendar.MINUTE));
		System.out.println("Second: " + c.get(Calendar.SECOND));
		//-
	}
}
//@@@@@@//
//datetime/Easter.java
//@@@@@@//
import java.util.*;
import java.applet.*;

/** Easter - compute the day on which Easter falls.
 *
 * In the Christian religion, Easter is possibly the most important holiday
 * of the year, so getting its date <I>just so</I> is worthwhile.
 *
 * @author: Ian F. Darwin, http://www.darwinsys.com/,
 * based on a detailed algorithm in Knuth, vol 1, pg 155.
 *
 * @Version: $Id: Easter.java,v 1.5 2004/02/09 03:33:46 ian Exp $
 * Written in C, Toronto, 1988. Java version 1996.
 *
 * @Note: It's not proven correct, although it gets the right answer for 
 * years around the present.
 */
public class Easter {

	/* Compute the day of the year that Easter falls on.
	 * Step names E1 E2 etc., are direct references to Knuth, Vol 1, p 155.
	 * @exception IllegalArgumentexception If the year is before 1582 (since the
	 * 		algorithm only works on the Gregorian calendar).
	 */
	public static final Calendar findHolyDay(int year) {
		if (year <= 1582) {
			throw new IllegalArgumentException("Algorithm invalid before April 1583");
		}
		int golden, century, x, z, d, epact, n;

		golden = (year % 19) + 1;	/* E1: metonic cycle */
		century = (year / 100) + 1;	/* E2: e.g. 1984 was in 20th C */
		x = (3*century/4) - 12;		/* E3: leap year correction */
		z = ((8*century+5) / 25) -5; 	/* E3: sync with moon's orbit */
		d = (5*year/4) - x - 10;
		epact = (11*golden + 20 + z - x) % 30; /* E5: epact */
		if ((epact == 25 && golden > 11) || epact == 24)
			epact++;
		n = 44 - epact;
		n += 30 * (n < 21?1:0);		/* E6: */
		n += 7 - ((d+n)%7);
		if (n>31)			/* E7: */
			return new GregorianCalendar(year, 4-1, n-31);	/* April */
		else
			return  new GregorianCalendar(year, 3-1, n);	/* March */
	}

	/** Main program, when used as a standalone application */
	public static void main(String[] argv) {

		if (argv.length == 0) {
			int thisYear = new GregorianCalendar().get(Calendar.YEAR);
			Calendar c = Easter.findHolyDay(thisYear);
			System.out.println( c.getTime());
		} else for (int i=0; i<argv.length; i++) {
			int year = 0;
			try {
				year = Integer.parseInt(argv[i]);
				System.out.println(Easter.findHolyDay(year).getTime());
			} catch (IllegalArgumentException e) {
				System.err.println("Year " + argv[i] + " invalid (" + e.getMessage() + ").");
			}
		}
	}
}
//@@@@@@//
//datetime/GregCalDemo.java
//@@@@@@//
import java.util.*;

/** Show use of Calendar objects */
public class GregCalDemo {

	public static void main(String[] av) {
		//+
		GregorianCalendar d1 = new GregorianCalendar(1986, 04, 05); // May 5
		GregorianCalendar d2 = new GregorianCalendar();	// today
		Calendar d3 = Calendar.getInstance();	// today

		System.out.println("It was then " + d1.getTime());
		System.out.println("It is now " + d2.getTime());
		System.out.println("It is now " + d3.getTime());
		d3.set(Calendar.YEAR, 1915);
		d3.set(Calendar.MONTH, Calendar.APRIL);
		d3.set(Calendar.DAY_OF_MONTH, 12);
		System.out.println("D3 set to " + d3.getTime());
		//-
	}
}
//@@@@@@//
//datetime/IBMCalDemo.java
//@@@@@@//
import java.util.Locale;
import com.ibm.icu.util.Calendar;
import java.text.DateFormat;
import com.ibm.icu.util.IslamicCalendar;
import java.awt.Container;
import java.awt.Font;
import java.awt.FlowLayout;
import javax.swing.*;

public class IBMCalDemo {
	public static void main(String[] args) {

		Locale ar_loc = new Locale("ar");

		Calendar c = new com.ibm.icu.util.IslamicCalendar();

		DateFormat d = DateFormat.getDateInstance(DateFormat.LONG, ar_loc);

		String ar_date = d.format(c.getTime());
		System.out.println(ar_date);

		JFrame jf = new JFrame();
		Container cp = jf.getContentPane();
		cp.setLayout(new FlowLayout());
		JComponent demo = new JLabel(ar_date);
		demo.setFont(new Font("Lucida Sans", Font.PLAIN, 20));
		cp.add(demo);
		jf.pack();
		jf.setVisible(true);
	}
}
//@@@@@@//
//datetime/LongToMSec.java
//@@@@@@//
/** Convert longs (time_t in UNIX terminology) to seconds.
 */
public class LongToMSec {
	public static void main(String[] args) {
		System.out.println(msToSecs(1000));
		System.out.println(msToSecs(1100));
		System.out.println(msToSecs(1024));
	}

	/** Convert a long ("time_t") to seconds and milliseconds */
	public static String msToSecs(long t) {
		// The first attempt fails for the case "1024"
		//return t/1000 + "." + t%1000;

		return Double.toString(t/1000D);
	}
}

//@@@@@@//
//datetime/QuickTimeFormat.java
//@@@@@@//
package com.darwinsys.text;

/** Just some quick-and-dirty time format.
 * Nothing to do with Apple's excellent multimedia format!
 */
public class QuickTimeFormat {
	//+
	/** Convert a long ("time_t") to seconds and thousandths. */
	public static String msToSecs(long t) {
		return Double.toString(t/1000D);
	}
	//-
}
//@@@@@@//
//datetime/Reminder.java
//@@@@@@//
import java.util.*;
/**
 * Beep every 5 minutes.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Reminder.java,v 1.3 2004/02/09 03:33:46 ian Exp $
 */
public class Reminder {
	public static void main(String[] argv) throws InterruptedException {
		//+
		while (true) {
			System.out.println(new Date() + "\007");
			Thread.sleep(5*60*1000);
		}
		//-
	}
}
//@@@@@@//
//datetime/ReminderService.java
//@@@@@@//
import java.io.*;
import java.text.*;
import java.util.*;
import javax.swing.JOptionPane;

/**
 * Read a file of reminders, run each when due using java.util.Timer
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ReminderService.java,v 1.7 2004/02/09 03:33:46 ian Exp $
 */
public class ReminderService {

	/** The Timer object */
	Timer timer = new Timer();

	class Item extends TimerTask {
		String message;
		Item(String m) {
			message = m;
		}
		public void run() {
			message(message);
		}
	}

	public static void main(String[] argv) throws IOException {
		new ReminderService().load();
	}

	protected void load() throws IOException {

		BufferedReader is = new BufferedReader(
			new FileReader("ReminderService.txt"));
		SimpleDateFormat formatter =
			new SimpleDateFormat ("yyyy MM dd hh mm");
		String aLine;
		while ((aLine = is.readLine()) != null) {
			ParsePosition pp = new ParsePosition(0);
			Date date = formatter.parse(aLine, pp);
			if (date == null) {
				message("Invalid date in " + aLine);
				continue;
			}
			String mesg = aLine.substring(pp.getIndex());
			timer.schedule(new Item(mesg), date);
		}
	}

	/** Display a message on the console and in the GUI.
	 * Used both by Item tasks and by mainline parser.
	 */
	void message(String message) {
		System.out.println("\007" + message);
		JOptionPane.showMessageDialog(null,
			message, 
			"Timer Alert",				// titlebar
			JOptionPane.INFORMATION_MESSAGE);	// icon
	}
}
//@@@@@@//
//datetime/ReminderServiceOld.java
//@@@@@@//
import java.io.*;
import java.text.*;
import java.util.*;
import javax.swing.*;

/**
 * Read a file of reminders, sleep until each is due, beep.
 * Much of this logic has been uperceded by java.util.Timer, which is used
 * in the non-Old version of this program.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ReminderServiceOld.java,v 1.2 2004/02/09 03:33:46 ian Exp $
 */
public class ReminderServiceOld {
	class Item {
		Date due;
		String message;
		Item(Date d, String m) {
			due = d;
			message = m;
		}
	}

	ArrayList l = new ArrayList();

	public static void main(String[] argv) throws IOException {
		ReminderServiceOld rs = new ReminderServiceOld();
		rs.load();
		rs.run();
	}

	protected void load() throws IOException {

		BufferedReader is = new BufferedReader(
			new FileReader("ReminderService.txt"));
		SimpleDateFormat formatter =
			new SimpleDateFormat ("yyyy MM dd hh mm");
		String aLine;
		while ((aLine = is.readLine()) != null) {
			ParsePosition pp = new ParsePosition(0);
			Date date = formatter.parse(aLine, pp);
			if (date == null) {
				message("Invalid date in " + aLine);
				continue;
			}
			String mesg = aLine.substring(pp.getIndex());
			l.add(new Item(date, mesg));
		}
	}

	public void run() {
		System.out.println("ReminderServiceOld: Starting at " + new Date());
		while (!l.isEmpty()) {
			Date d = new Date();
			Item i = (Item)l.get(0);
			long interval = i.due.getTime() - d.getTime();
			if (interval > 0) {
				System.out.println("Sleeping until " + i.due);
				try {
					Thread.sleep(interval);
				} catch (InterruptedException e) {
					System.exit(1);	// unexpected intr
				}
				message(i.due + ": " + i.message);
			} else
				message("MISSED " + i.message + " at " + i.due);
			l.remove(0);
		}
		System.exit(0);
	}
	void message(String message) {
		System.out.println("\007" + message);
		JOptionPane.showMessageDialog(null,
			message, 
			"Timer Alert",				// titlebar
			JOptionPane.INFORMATION_MESSAGE);	// icon
	}
}
//@@@@@@//
//datetime/TimeComputation.java
//@@@@@@//
import java.io.*;
import java.text.*;

import com.darwinsys.lang.SysDep;

/**
 * TimeComputation for processing sqrt and I/O operations.
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: TimeComputation.java,v 1.7 2004/02/09 03:33:46 ian Exp $
 */
public class TimeComputation {
	public static void main(String[] argv) {
		try {
			new TimeComputation().run();
		} catch (IOException e) {
			System.err.println(e);
		}
	}
	public void run() throws IOException {

		DataOutputStream n = new DataOutputStream(
			new BufferedOutputStream(new FileOutputStream(SysDep.getDevNull())));
		long t0, t1;
		System.out.println("Java Starts at " + (t0=System.currentTimeMillis()));
		double k;
		for (int i=0; i<100000; i++) {
			k = 2.1 * Math.sqrt((double)i);
			n.writeDouble(k);
		}
		System.out.println("Java Ends at " + (t1=System.currentTimeMillis()));
		double deltaT = t1-t0;
		System.out.println("This run took " + 
			DecimalFormat.getInstance().format(deltaT/1000.) + " seconds.");
	}

}
//@@@@@@//
//datetime/Timer0.java
//@@@@@@//
import java.io.*;
import java.text.*;

/**
 * How quickly can you press return?
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: Timer0.java,v 1.4 2004/02/09 03:33:46 ian Exp $
 */
public class Timer0 {
	public static void main(String[] argv) throws IOException {
		//+
		long t0, t1;
		System.out.println("Press return when ready");
		t0=System.currentTimeMillis();
		int b;
		do {
			b = System.in.read();
		} while (b!='\r' && b != '\n');
		t1=System.currentTimeMillis();
		double deltaT = t1-t0;
		System.out.println("You took " + 
			DecimalFormat.getInstance().format(deltaT/1000.) + " seconds.");
		//-
	}
}
//@@@@@@//
//datetime/Y2038.java
//@@@@@@//
/** When does the UNIX date get into trouble? */

public class Y2038 {
	public static void main(String[] a) {

		// This should yield 2038AD, the hour of doom for the
		// last remaining 32-bit UNIX systems (there will be
		// millions of 64-bit UNIXes by then).

		long expiry = 0x7FFFFFFFL;

		System.out.println("32-bit UNIX expires on " +
			Long.toHexString(expiry) + " or " +
			new java.util.Date(expiry * 1000));
	}
}
//@@@@@@//
//DBM/DBM.java
//@@@@@@//
import java.io.*;

/** This class provides a dbm-compatible interface to the UNIX-style
 * database access methods described in dbm(3) (which is on some UNIXes
 * a front-end to db(3).
 * <P>Each unique record in the database is a unique key/value pair,
 * similar to a java.util.Hashtable but stored on persistent medium, not
 * kept in memory. Dbm was originally optimized for UNIX for fast
 * access to individual key/value pairs.
 *
 * @author This Java/C hookup by Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: DBM.java,v 1.13 2004/02/09 03:33:40 ian Exp $
 */
public class DBM {
	/** Since you can only have one DBM database in use at a time due
	 * to implementation restrictions, we enforce this rule with a
	 * class-wide boolean.
	 */
	protected static boolean inuse = false;

	/** Save the filename for messages, etc. */
	protected String fileName;

	/** Construct a DBM given its filename */
	public DBM(String file) {
		synchronized(this) {
			if (inuse)
				throw new IllegalArgumentException(
					"Only one DBM object at a time per Java Machine");
			inuse = true;
		}
		fileName = file;
		int retCode = dbminit(fileName);
		if (retCode < 0)
			throw new IllegalArgumentException(
				"dbminit failed, code = " + retCode);
	}

	// Static code blocks are executed once, when class file is loaded.
	// This is here to ensure that the shared library gets loaded.
	static {
		System.loadLibrary("jdbm");
	}

	protected ByteArrayOutputStream bo;

	/** serialize an Object to byte array. */
	protected byte[] toByteArray(Object o) throws IOException {
		if (bo == null)
			bo = new ByteArrayOutputStream(1024);
		bo.reset();
		ObjectOutputStream os = new ObjectOutputStream(bo);
		os.writeObject(o);
		os.close();
		return bo.toByteArray();
	}

	/** un-serialize an Object from a byte array. */
	protected Object toObject(byte[] b) throws IOException {
		Object o;

		ByteArrayInputStream bi = new ByteArrayInputStream(b);
		ObjectInputStream os = new ObjectInputStream(bi);
		try {
			o = os.readObject();
		} catch (ClassNotFoundException ex) {
			// Convert ClassNotFoundException to I/O error
			throw new IOException(ex.getMessage());
		}
		os.close();
		return o;
	}

	protected native int dbminit(String file);

	protected native int dbmclose();

	/** Public wrapper for close method. */
	public void close() {
		this.dbmclose();
		inuse = false;
	}

	protected void checkInUse() {
		if (!inuse)
			throw new IllegalStateException("Method called when DBM not open");
	}

	protected native byte[] dbmfetch(byte[] key);

	/** Fetch using byte arrays */
	public byte[] fetch(byte[] key) throws IOException {
		checkInUse();
		return dbmfetch(key);
	}

	/** Fetch using Objects */
	public Object fetch(Object key) throws IOException {
		checkInUse();
		byte[] datum = dbmfetch(toByteArray(key));
		return toObject(datum);
	}

	protected native int dbmstore(byte[] key, byte[] content);

	/** Store using byte arrays */
	public void store(byte[] key, byte[] value) throws IOException {
		checkInUse();
		dbmstore(key, value);
	}

	/** Store using Objects */
	public void store(Object key, Object value) throws IOException {
		checkInUse();
		dbmstore(toByteArray(key), toByteArray(value));
	}

	protected native int delete(Object key);

	public native byte[] firstkey() throws IOException;

	public Object firstkeyObject() throws IOException {
		return toObject(firstkey());
	}

	public native byte[] nextkey(byte[] key) throws IOException;

	public Object nextkey(Object key) throws IOException {
		byte[] ba = nextkey(toByteArray(key));
		if (ba == null)
			return null;
		return toObject(ba);
	}

	public String toString() {
		return "DBM@" + hashCode() + "[" + fileName + "]";
	}
}
//@@@@@@//
//DBM/ReadHistNS.java
//@@@@@@//
import java.io.IOException;

/** Demonstration of reading the MS-Windows Netscape History
 * under UNIX using DBM.java.
 * @version $Id: ReadHistNS.java,v 1.2 2000/06/24 23:10:15 ian Exp $
 */
public class ReadHistNS {
	public static void main(String[] unused) throws IOException {
		DBM d = new DBM("netscape.hst");
		byte[] ba;
		for (ba = d.firstkey(); ba != null; ba = d.nextkey(ba)) {
			System.out.println("Key=\"" + new String(ba) + '"');
			byte[] val = d.fetch(ba);
			for (int i=0; i<16&&i<val.length; i++) {
				System.out.print((short)val[i]);
				System.out.print(' ');
			}
		}
	}
}
//@@@@@@//
//DBM/TestDBM.java
//@@@@@@//
import java.io.*;
import java.util.*;

public class TestDBM {
	public static void main(String javaNamesCauseRSI[]) throws IOException {
		DBM d = new DBM("/tmp/mydb");
		System.out.println(d);
		d.store("today", new Date());
		d.store("here", System.getProperty("user.dir"));
		DBM d2;
		try { d2 = new DBM("NoSuchDbAnyway"); 
			System.out.println("** ERROR ** failed to throw Exception");
		} catch (IllegalArgumentException e) {
			System.out.println("Correctly threw " + e);
		}
		d.close();

		System.out.println("Now close, re-open, and fetch");
		d2 = new DBM("/tmp/mydb");
		System.out.println("d2 contains " + d2.fetch("here"));
		System.out.println("d2 contains " + d2.fetch("today"));
		d2.close();

		System.out.println("Now try iterating");
		DBM d3 = new DBM("/tmp/mydb");
		Object o;
		for (o = d3.firstkeyObject(); o != null; o = d3.nextkey(o)) {
			System.out.println("Key=\"" + o + "\"; " +
				"value=\"" + d3.fetch(o) + "\"");
		}
	}
}
//@@@@@@//
//dir_file/CheckFiles.java
//@@@@@@//
import java.io.*;
import java.util.*;

/**
 * Get a list of files, and check if any files are missing.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: CheckFiles.java,v 1.3 2004/02/09 03:33:46 ian Exp $
 */
public class CheckFiles {
	public static void main(String[] argv) {
		CheckFiles cf = new CheckFiles();
		System.out.println("CheckFiles starting.");
		cf.getListFromFile();
		cf.getListFromDirectory();
		cf.reportMissingFiles();
		System.out.println("CheckFiles done.");
	}
	public String FILENAME = "filelist.txt";

	protected ArrayList listFromFile;
	protected ArrayList listFromDir = new ArrayList();

	protected void getListFromFile() {
		listFromFile = new ArrayList();
		BufferedReader is;
		try {
			is = new BufferedReader(new FileReader(FILENAME));
			String line;
			while ((line = is.readLine()) != null)
				listFromFile.add(line);
		} catch (FileNotFoundException e) {
			System.err.println("Can't open file list file.");
			return;
		} catch (IOException e) {
			System.err.println("Error reading file list");
			return;
		}
	}

	/** Get list of names from the directory */
	protected void getListFromDirectory() {
		listFromDir = new ArrayList();
		String[] l = new java.io.File(".").list();
		for (int i=0; i<l.length; i++)
			listFromDir.add(l[i]);
	}

	protected void reportMissingFiles() {
		for (int i=0; i<listFromFile.size(); i++)
			if (!listFromDir.contains(listFromFile.get(i)))
				System.err.println("File " + listFromFile.get(i) + " missing.");
	}
}
//@@@@@@//
//dir_file/Creat.java
//@@@@@@//
import java.io.*;

/**
 * Create one or more files by name.
 * The final "e" is omitted in homage to the underlying UNIX system call.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Creat.java,v 1.3 2004/02/09 03:33:47 ian Exp $
 */
public class Creat {
	public static void main(String[] argv) throws IOException {

		// Ensure that a filename (or something) was given in argv[0]
		if (argv.length == 0) {
			System.err.println("Usage: Creat filename");
			System.exit(1);
		}

		for (int i = 0; i< argv.length; i++) {
			// Constructing a File object doesn't affect the disk, but
			// the createNewFile() method does.
			new File(argv[i]).createNewFile();
		}
	}
}
//@@@@@@//
//dir_file/Delete.java
//@@@@@@//
import java.io.*;

/**
 * Delete a file from within Java
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Delete.java,v 1.5 2004/02/09 03:33:47 ian Exp $
 */
public class Delete {
	public static void main(String[] argv) throws IOException {

		// Construct a File object for the backup created by editing
		// this source file. The file probably already exists.
		// My editor creates backups by putting ~ at the end of the name.
		File bkup = new File("Delete.java~");
		// Quick, now, delete it immediately:
		bkup.delete();
	}
}
//@@@@@@//
//dir_file/Delete2.java
//@@@@@@//
import java.io.*;

/**
 * Delete a file from within Java, with error handling.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Delete2.java,v 1.5 2004/02/09 03:33:47 ian Exp $
 */
public class Delete2 {

	public static void main(String[] argv) {
		for (int i=0; i<argv.length; i++)
			delete(argv[i]);
	}

	public static void delete(String fileName) {
		try {
			// Construct a File object for the file to be deleted.
			File target = new File(fileName);

			if (!target.exists()) {
				System.err.println("File " + fileName + 
					" not present to begin with!");
				return;
			}

			// Quick, now, delete it immediately:
			if (target.delete())
				System.err.println("** Deleted " + fileName + " **");
			else
				System.err.println("Failed to delete " + fileName);
		} catch (SecurityException e) {	
			System.err.println("Unable to delete " + fileName +
				"(" + e.getMessage() + ")");
		}
	}
}
//@@@@@@//
//dir_file/DirTree.java
//@@@@@@//
import java.io.*;
/**
 * DirTree - directory lister, like UNIX ls or DOS/VMS dir
 *
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: DirTree.java,v 1.4 2004/02/09 03:33:47 ian Exp $
 */
public class DirTree {
	/** Main program */
	public static void main(String[] argv) {
		DirTree dt = new DirTree();
		if (argv.length == 0)
			dt.doDir(".");
		else for (int i = 0; i<argv.length; i++)
			dt.doDir(argv[i]);
	}

	/** doDir - handle one filesystem object by name */
	private void doDir(String s) {
		File f = new File(s);
		if (!f.exists()) {
			System.out.println(s + " does not exist");
			return;
		}
		if (f.isFile())
			doFile(f);
		else if (f.isDirectory()) {
			System.out.println("d " + f.getPath());
			String objects[] = f.list();

			for (int i=0; i<objects.length; i++)
				doDir(s + f.separator + objects[i]);
		} else
			System.err.println("Unknown: " + s);
	}

	/** doFile - process one regular file. */
	private static void doFile(File f) {
		System.out.println("f " + f.getPath());
	}
}
//@@@@@@//
//dir_file/Empty.java
//@@@@@@//
import java.io.*;
/**
 * DANGEROUS Program to empty a directory
 * Written for Course 333 comparison section.
 * @author	Ian Darwin, Learning Tree, Course 471/478
 */
public class Empty {
	public static void main(String[] argv) {
		if (argv.length != 1) {	// no progname in argv[0]
			System.err.println("usage: Empty dirname");
			System.exit(1);
		}

		File dir = new File(argv[0]);
		if (!dir.exists()) {
			System.out.println(argv[0] + " does not exist");
			return;
		}

		String[] info = dir.list();
		for (int i=0; i<info.length; i++) {
			File n = new File(argv[0] + dir.separator + info[i]);
			if (!n.isFile())	// skip ., .., other directories too
				continue;
			System.out.println("removing " + n.getPath());
			if (!n.delete())
				System.err.println("Couldn't remove " + n.getPath());
		}
	}
}
//@@@@@@//
//dir_file/FileStatus.java
//@@@@@@//
import java.io.*;
import java.util.*;

/**
 * Report on a file's status in Java
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: FileStatus.java,v 1.6 2004/03/11 03:25:35 ian Exp $
 */
public class FileStatus {
	public static void main(String[] argv) throws IOException {

		// Ensure that a filename (or something) was given in argv[0]
		if (argv.length == 0) {
			System.err.println("Usage: FileStatus filename");
			System.exit(1);
		}
		for (int i = 0; i< argv.length; i++) {
			status(argv[i]);
		}
	}

	public static void status(String fileName) throws IOException {
		System.out.println("---" + fileName + "---");

		// Construct a File object for the given file.
		File f = new File(fileName);

		// See if it actually exists
		if (!f.exists()) {
			System.out.println("file not found");
			System.out.println();	// Blank line
			return;
		}
		// Print full name
		System.out.println("Canonical name " + f.getCanonicalPath());
		// Print parent directory if possible
		String p = f.getParent();
		if (p != null) {
			System.out.println("Parent directory: " + p);
		}
		// Check if the file is readable
		if (f.canRead()) {
			System.out.println("File is readable.");
		}
		// Check if the file is writable
		if (f.canWrite()) {
			System.out.println("File is writable.");
		}
		// Report on the modification time.
		Date d = new Date();
		d.setTime(f.lastModified());
		System.out.println("Last modified " + d);

		// See if file, directory, or other. If file, print size.
		if (f.isFile()) {
			// Report on the file's size
			System.out.println("File size is " + f.length() + " bytes.");
		} else if (f.isDirectory()) {
			System.out.println("It's a directory");
		} else {
			System.out.println("I dunno! Neither a file nor a directory!");
		}

		System.out.println();	// blank line between entries
	}
}
//@@@@@@//
//dir_file/Find.java
//@@@@@@//
import java.io.*;
import java.io.*;

import com.darwinsys.lang.GetOpt;
import com.darwinsys.util.Debug;

/**
 * Find - find files by name, size, or other criteria. Non-GUI version.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: Find.java,v 1.6 2004/02/09 03:33:47 ian Exp $
 */
public class Find {
	/** Main program */
	public static void main(String[] args) {
		Find finder = new Find();
		GetOpt argHandler = new GetOpt("n:s:");
		int c;
		while ((c = argHandler.getopt(args)) != GetOpt.DONE) {
			switch(c) {
			case 'n': finder.filter.setNameFilter(argHandler.optarg()); break;
			case 's': finder.filter.setSizeFilter(argHandler.optarg()); break;
			default:	
				System.out.println("Got: " + c);
				usage();
			}
		}
		if (args.length == 0 || argHandler.getOptInd()-1 == args.length) {
			finder.doName(".");
		} else {
			for (int i = argHandler.getOptInd()-1; i<args.length; i++)
				finder.doName(args[i]);
		}
	}

	protected FindFilter filter = new FindFilter();

	public static void usage() {
		System.err.println(
			"Usage: Find [-n namefilter][-s sizefilter][dir...]");
		System.exit(1);
	}

	/** doName - handle one filesystem object by name */
	private void doName(String s) {
		Debug.println("flow", "doName(" + s + ")");
		File f = new File(s);
		if (!f.exists()) {
			System.out.println(s + " does not exist");
			return;
		}
		if (f.isFile())
			doFile(f);
		else if (f.isDirectory()) {
			// System.out.println("d " + f.getPath());
			String objects[] = f.list(filter);

			for (int i=0; i<objects.length; i++)
				doName(s + f.separator + objects[i]);
		} else
			System.err.println("Unknown type: " + s);
	}

	/** doFile - process one regular file. */
	private static void doFile(File f) {
		System.out.println("f " + f.getPath());
	}
}
//@@@@@@//
//dir_file/FindFilter.java
//@@@@@@//
import java.io.*;
import java.util.regex.*;
import com.darwinsys.util.Debug;

/** Class to encapsulate the filtration for Find.
 * For now just setTTTFilter() methods. Really needs to be a real
 * data structure to allow complex things like
 *		-n "*.html" -a \( -size < 0 -o mtime < 5 \).
 * @version $Id: FindFilter.java,v 1.4 2003/05/31 21:18:34 ian Exp $
 */
public class FindFilter implements FilenameFilter {
	boolean sizeSet;
	int size;
	String name;
	Pattern nameRE;

	public FindFilter() {
	}

	void setSizeFilter(String sizeFilter) {
		size = Integer.parseInt(sizeFilter);
		sizeSet = true;
	}

	/** Convert the given shell wildcard pattern into internal form (an RE) */
	void setNameFilter(String nameFilter) {
		name = nameFilter;
		StringBuffer sb = new StringBuffer('^');
		for (int i = 0; i < nameFilter.length(); i++) {
			char c = nameFilter.charAt(i);
			switch(c) {
				case '.':	sb.append("\\."); break;
				case '*':	sb.append(".*"); break;
				case '?':	sb.append('.'); break;
				default:	sb.append(c); break;
			}
		}
		sb.append('$');
		Debug.println("name", "RE=\"" + sb + "\".");
		try {
			nameRE = Pattern.compile(sb.toString());
		} catch (PatternSyntaxException ex) {
			System.err.println("Error: RE " + sb.toString() +
				" didn't compile: " + ex);
		}
	}

	/** Do the filtering. For now, only filter on name */
	public boolean accept(File dir, String fileName) {
		File f = new File(dir, fileName);
		if (f.isDirectory()) {
			return true;	// allow recursion
		}

		if (nameRE != null) {
			return nameRE.matcher(fileName).matches();
		}

		// TODO size handling.

		// Catchall
		return false;
	}
}
//@@@@@@//
//dir_file/FindNumFilter.java
//@@@@@@//
/** class to handle a numeric filter for Find, such as:
 * <li>5, meaning exactly 5
 * <li>+5, meaning greater than 5
 * <li>-5, meaning less than 5
 */
class FindNumFilter {
	/** The value of this filter */
	int num;
	/** Constants for the comparison operators. */
	final int LE = -2, LT = -1, EQ = 0, GT = +1, GE = +2;
	/** The current comparison operator */
	int mode = EQ;

	/** Constructor */
	FindNumFilter(String input) {
		switch(input.charAt(0)) {
			case '+': mode = GT; break;
			case '-': mode = LT; break;
			case '=': mode = EQ; break;
			// No syntax for LE or GE yet.
		}
		num = Math.abs(Integer.parseInt(input));
	}

	/** Construct a NumFilter when you know its mode and value */
	FindNumFilter(int mode, int value) {
		this.mode = mode;
		num = value;
	}
	boolean accept(int n) {
		switch(mode) {
			case GT: return n > num;
			case EQ: return n == num;
			case LT: return n < num;
			default:
				System.err.println("UNEX CASE " + mode );
				return false;
		}
	}
}
//@@@@@@//
//dir_file/FNFilter.java
//@@@@@@//
import java.io.*;

/**
 * FNFilter - Ls directory lister modified to use FilenameFilter
 * @author Ian Darwin
 * @version $Id: FNFilter.java,v 1.3 2004/03/11 03:33:35 ian Exp $
 */
public class FNFilter {
	public static void main(String argh_my_aching_fingers[]) {
		// Generate the selective list, with a one-use File object.
		String[] dir = new java.io.File(".").list(new OnlyJava());
		java.util.Arrays.sort(dir);		// Sort it (Data Structuring chapter))
		for (int i=0; i<dir.length; i++)
			System.out.println(dir[i]);	// Print the list
	}
}

/** This class implements the FilenameFilter interface.
 * The Accept method returns true for .java, .class and .jar files.
 */
class OnlyJava implements FilenameFilter {
	public boolean accept(File dir, String s) {
		if (s.endsWith(".java") || s.endsWith(".class") || s.endsWith(".jar"))
			return true;
		// others: projects, ... ?
		return false;
	}
}
//@@@@@@//
//dir_file/FNFilter2.java
//@@@@@@//
import java.io.*;

/**
 * FNFilter - directory lister using FilenameFilter
 *
 * @author Ian Darwin
 */

public class FNFilter2 implements FilenameFilter {

	public static void main(String[] av) {
		FNFilter2 ff = new FNFilter2();
		ff.process(".");
	}

	public void process(String dir) {
		String objects[] = (new File(dir)).list(this);

		for (int i=0; i<objects.length; i++)
			System.out.println(objects[i]);
	}

	public boolean accept(File dir, String s) {
		if (s.endsWith(".java"))
			return true;
		// others?
		return false;
	}
}
//@@@@@@//
//dir_file/KillFilesByName.java
//@@@@@@//
import java.io.*;
/**
 * DANGEROUS Program to remove files matching a name in a directory
 * @author	Ian Darwin, http://www.darwinsys.com/
 */
public class KillFilesByName {
	public static void main(String[] argv) {
		if (argv.length != 2) {
			System.err.println("usage: KillFilesByName dirname pattern");
			System.exit(1);
		}

		File dir = new File(argv[0]);
		if (!dir.exists()) {
			System.out.println(argv[0] + " does not exist");
			return;
		}
		String patt = argv[1];

		String[] info = dir.list();
		for (int i=0; i<info.length; i++) {
			File n = new File(argv[0] + dir.separator + info[i]);
			if (!n.isFile()) {	// skip ., .., other directories, etc.
				continue;
			}
			if (info[i].indexOf(patt) == -1) {	// name doesn't match
				continue;
			}
			System.out.println("removing " + n.getPath());
			if (!n.delete())
				System.err.println("Couldn't remove " + n.getPath());
		}
	}
}
//@@@@@@//
//dir_file/ListRoots.java
//@@@@@@//
import java.io.*;

public class ListRoots {
	public static void main(String argh_my_aching_fingers[]) {
		File[] drives = File.listRoots(); // Get list of names
		for (int i=0; i<drives.length; i++)
			System.out.println(drives[i]);	// Print the list
	}
}
//@@@@@@//
//dir_file/Ls.java
//@@@@@@//
/** Simple directory lister.
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: Ls.java,v 1.3 2004/02/09 03:33:47 ian Exp $
 */
public class Ls {
	public static void main(String argh_my_aching_fingers[]) {
		String[] dir = new java.io.File(".").list(); // Get list of names
		java.util.Arrays.sort(dir);		// Sort it (Data Structuring chapter))
		for (int i=0; i<dir.length; i++)
			System.out.println(dir[i]);	// Print the list
	}
}
//@@@@@@//
//dir_file/MkDirExamples.java
//@@@@@@//
import java.io.File;

/** The collected mkdir examples (JavaCook 2e, Recipe 11.9).
 */
public class MkDirExamples {
	public static void main(String[] args) {
		boolean status;
		status = new File("/home/ian/bin").mkdir();
		report(status);
		status = new File("/home/ian/src").mkdir();
		report(status);

		status = new File("/home/ian/once/twice/again").mkdir();	// should fail
		report(status);
		status = new File("/home/ian/once/twice/again").mkdirs();	// should succeed
		report(status);
	}

	static void report(boolean b) {
		System.out.println(b ? "success" : "failure");
	}
}
//@@@@@@//
//dir_file/ReadOnly.java
//@@@@@@//
import java.io.*;

public class ReadOnly {
	public static void main(String[] a) throws IOException {

		File f = new File("f");

		if (!f.createNewFile()) {
			System.out.println("Can't create new file.");
			return;
		}

		if (!f.canWrite()) {
			System.out.println("Can't write new file!");
			return;
		}

		if (!f.setReadOnly()) {
			System.out.println("Grrr! Can't set file read-only.");
			return;
		}

		if (f.canWrite()) {
			System.out.println("Most immutable, captain!");
			System.out.println("But it still says canWrite() after setReadOnly");
			return;
		} else {
			System.out.println("Logical, captain!");
			System.out.println("canWrite() correctly returns false after setReadOnly");
		}
	}
}
//@@@@@@//
//dir_file/Rename.java
//@@@@@@//
import java.io.*;

/**
 * Rename a file in Java
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Rename.java,v 1.4 2004/02/09 03:33:47 ian Exp $
 */
public class Rename {
	public static void main(String[] argv) throws IOException {

		// Construct the file object. Does NOT create a file on disk!
		File f = new File("Rename.java~"); // backup of this source file.

		// Rename the backup file to "junk.dat"
		// Renaming requires a File object for the target.
		f.renameTo(new File("junk.dat"));
	}
}
//@@@@@@//
//dir_file/TempFiles.java
//@@@@@@//
import java.io.*;

/**
 * Work with temporary files in Java.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: TempFiles.java,v 1.3 2004/02/09 03:33:47 ian Exp $
 */
public class TempFiles {
	public static void main(String[] argv) throws IOException {

		// 1. Make an existing file temporary

		// Construct a File object for the backup created by editing
		// this source file. The file probably already exists.
		// My editor creates backups by putting ~ at the end of the name.
		File bkup = new File("Rename.java~");
		// Arrange to have it deleted when the program ends.
		bkup.deleteOnExit();

		// 2. Create a new temporary file.

		// Make a file object for foo.tmp, in the default temp directory
		File tmp = File.createTempFile("foo", "tmp");
		// Report on the filename that it made up for us.
		System.out.println("Your temp file is " + tmp.getCanonicalPath());
		// Arrange for it to be deleted at exit.
		tmp.deleteOnExit();
		// Now do something with the temporary file, without having to
		// worry about deleting it later.
		writeDataInTemp(tmp.getCanonicalPath());
	}

	public static void writeDataInTemp(String tempnam) {
		// This version is dummy. Use your imagination.
	}
}
//@@@@@@//
//email/Alias.java
//@@@@@@//
public class Alias {
	/** The name for the alias */
	protected String name;
	/** The email address for this alias */
	protected String address;

	public Alias(String n, String addr) {
		name = n;
		address = addr;
	}

	public String toString() {
		return name + " = " + address;
	}

	/** Get name */
	public String getName() {
		return name;
	}

	/** Set name */
	public void setName(String name) {
		this.name = name;
	}

	/** Get address */
	public String getAddress() {
		return address;
	}

	/** Set address */
	public void setAddress(String address) {
		this.address = address;
	}
}
//@@@@@@//
//email/AliasBean.java
//@@@@@@//
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;

public class AliasBean extends JPanel {
	protected Vector aliVector;
	protected JList aliJList;
	private JTextField nameTF, addrTF;

	public AliasBean() {
		aliVector = new Vector();
		aliJList = new JList();
		// XXX MUST FIX THIS
		// aliJList.setSelectionMode(JList.SINGLE_SELECTION);
		aliJList.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent evt) {
				int i = aliJList.getSelectedIndex();
				if (i<0) return;
				Alias al = (Alias)aliVector.get(i);
				nameTF.setText(al.getName());
				addrTF.setText(al.getAddress());
			}
		});

		setLayout(new BorderLayout());
		add(BorderLayout.WEST, new JScrollPane(aliJList));

		JPanel rightPanel = new JPanel();
		add(BorderLayout.EAST, rightPanel);
		rightPanel.setLayout(new GridLayout(0, 1));

		JPanel buttons = new JPanel();
		rightPanel.add(buttons);
		buttons.setLayout(new GridLayout(0, 1, 15, 15));
		JButton b;
		buttons.add(b = new JButton("Set"));
		b.setToolTipText("Add or Change an alias");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				int i = aliJList.getSelectedIndex();
				if (i<0) {
					// XXX error dialog??
					return;
				}
				setAlias(i, nameTF.getText(), addrTF.getText());
			}
		});
		buttons.add(b = new JButton("Delete"));
		b.setToolTipText("Delete the selected alias");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				int i = aliJList.getSelectedIndex();
				if (i<0) {
					return;
				}
				deleteAlias(i);
			}
		});
		buttons.add(b = new JButton("Apply"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				System.err.println("NOT WRITTEN YET");
			}
		});

		JPanel fields = new JPanel();
		rightPanel.add(fields);
		fields.setLayout(new GridLayout(2,2));
		fields.add(new JLabel("Name"));
		fields.add(nameTF = new JTextField(10));
		fields.add(new JLabel("Address"));
		fields.add(addrTF = new JTextField(20));
	}

	public String expandAlias(String ali) {
		Alias a = findAlias(ali);
		if (a == null)
			return null;
		return a.getAddress();
	}

	public Alias findAlias(String ali) {
		for (int i=0; i<aliVector.size(); i++) {
			Alias a = (Alias)aliVector.get(i);
			if (a.getName().equals(ali))
				return a;
		}
		return null;	// not found
	}

	/** Add an Alias */
	public void addAlias(Alias a) {
		Alias al = findAlias(a.getName());
		if (al == null) {
			aliVector.addElement(a);
		} else {
			// aliVector.setElement(a);		// XXX fuzzy
		}
		aliJList.setListData(aliVector);
	}

	/** Add an alias, by its constituent parts */
	public void addAlias(String nn, String addr) {
		addAlias(new Alias(nn, addr));
	}

	/** Replace an Alias */
	public void setAlias(int n, String nam, String addr) {
		// TODO find it, replace it, or add it.
		aliVector.setElementAt(new Alias(nam, addr), n);
		aliJList.setListData(aliVector);
	}

	public void deleteAlias(int i) {
		aliVector.removeElementAt(i);
		aliJList.setListData(aliVector);
	}
}
//@@@@@@//
//email/AliasBeanTest.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** Test for AliasBean.
 * @version $Id: AliasBeanTest.java,v 1.3 2004/02/09 03:33:48 ian Exp $
 */
public class AliasBeanTest extends JFrame {
	JButton quitButton;

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create a JFrameDemo object, tell it to show up
		new AliasBeanTest().setVisible(true);
	}

	/** Construct the object including its GUI */
	public AliasBeanTest() {
		super("AliasBeanTest");
		Container cp = getContentPane();

		AliasBean ab = new AliasBean();
		cp.add(BorderLayout.CENTER, ab);
		ab.addAlias("ian-cvs", "ian@openbsd.org");
		ab.addAlias("ian-dos", "http://www.darwinsys.com/");

		cp.add(BorderLayout.SOUTH, quitButton = new JButton("Exit"));
		quitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
	
		pack();
	}
}
//@@@@@@//
//email/BatchMailer.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.mail.*;

import com.darwinsys.mail.Mailer;

/** Command-line batch mailer */
public class BatchMailer {
	public static void main(String[] args) throws IOException {
		if (args.length != 3) {
			System.err.println("Usage: BatchMail subj template custlist");
			System.exit(1);
		}
		BatchMailer b = new BatchMailer();
		String subj = args[0];
		String template = args[1];
		String listfile = args[2];
		b.readTemplate(template);
		b.setSubject(subj);
		b.readCustList(listfile);
		b.sendMails();
	}

	/** The message */
	protected String messageBody;
	/** The subject */
	protected String subject = "Re: Your mail (what a lame subject)";

	/** Read the template file.
	  */
	public void readTemplate(String fileName) throws IOException {
		messageBody = null;
		BufferedReader is = new BufferedReader(new FileReader(fileName));
		String line;
		StringBuffer bs = new StringBuffer();
		while ((line = is.readLine()) != null) {
			bs.append(line).append("\n");
		}
		messageBody = bs.toString();
		is.close();
	}

	protected ArrayList custList = new ArrayList();

	/** Read the customer list. 
	  * Format: one customer email per line.
	  */
	public void readCustList(String fileName) throws IOException {
		BufferedReader is = new BufferedReader(new FileReader(fileName));
		String line;
		while ((line = is.readLine()) != null) {
			custList.add(line);
		}
		is.close();
	}

	public void setSubject(String s) {
		subject = s;
	}

	public void sendMails() {
		Iterator it = custList.iterator();
		while (it.hasNext()) {
			String customer = (String)it.next();
			try {
				// This should be a bit more flexible :-(
				Mailer.send("mailhost", 
					customer, "http://www.darwinsys.com/", subject, messageBody);
				System.out.println(customer + " HANDOFF OK");
			} catch (MessagingException e) {
				System.out.println(customer + " failed: " + e.toString());
			}
		}
	}
}
//@@@@@@//
//email/CustMailer.java
//@@@@@@//
import javax.swing.*;

/** CustMailer -- to be a small Mailing List sender. */
public class CustMailer extends JFrame {
	public static void main(String[] argv) {
		new CustMailer().setVisible(true);
	}
	public CustMailer() {
		JTabbedPane jtp = new JTabbedPane();
		setContentPane(jtp);
		jtp.addTab("Sending", new JPanel());
		jtp.addTab("Editing", new JPanel()); 
		
	}

}
//@@@@@@//
//email/DropReceivedLines.java
//@@@@@@//
import java.io.*;

import com.darwinsys.util.Debug;

/**
 * Read a file and print, using LineReader and System.out
 */
public class DropReceivedLines {

    public static void main(String[] av) {
        DropReceivedLines d = new DropReceivedLines();
		// For stdin, act as a filter. For named files,
		// update each file in place (safely, by creating a new file).
		try {
			if (av.length == 0) 
				d.process(new BufferedReader(
						new InputStreamReader(System.in)), 
						new PrintWriter(System.out));
			else for (int i=0; i<av.length; i++)
				d.process(av[i]);
		} catch (FileNotFoundException e) {
			System.err.println(e.getMessage());
		} catch (IOException e) {
			System.err.println("I/O error " + e);
		}
    }

	protected static File tempFile = new File("holding.tmp");

	/** Process one file given only its name */
	public void process(String fileName) throws IOException {
		File old = new File(fileName);
		String newFileName = fileName + ".TMP";
		File newf = new File(newFileName);
		BufferedReader is =
				new BufferedReader(new FileReader(fileName));
		PrintWriter p = new PrintWriter(new FileWriter(newFileName));
		process(is, p);		// call other process(), below
		p.close();
		old.renameTo(tempFile);
		newf.renameTo(old);
		tempFile.delete();
	}

    /** process one file, given an open LineReader */
    public void process(BufferedReader is, PrintWriter out)
		throws IOException {
        try {
            String lin;

			// If line begins with "Received:", ditch it, and its continuations
            while ((lin = is.readLine()) != null) {
				Debug.println("read", "Read line " + lin);
				if (lin.startsWith("Received:")) {
					do {
						lin = is.readLine();
						Debug.println("read", "\tContin read line " + lin);
					} while (lin.length() > 0 &&
						Character.isWhitespace(lin.charAt(0)));
				}
				out.println(lin);
            }
            is.close();
			out.close();
        } catch (IOException e) {
            System.out.println("IOException: " + e);
        }
    }
}
//@@@@@@//
//email/FolderNode.java
//@@@@@@//
import javax.mail.*;
import javax.swing.tree.*;

/** A Mutable Tree Node that is also a Folder. */
public class FolderNode extends DefaultMutableTreeNode {
	Folder f;
	FolderNode(Folder f) {
		this.f = f;
	}
	public String toString() {
		return f.getName();
	}
}
//@@@@@@//
//email/Header.java
//@@@@@@//
/** Represent a Mail or News Header */
public class Header {
	public String type;
	public String text;
	Header(String n, String v) {
		type = n;
		text = v;
	}
	public String toString() {
		return new StringBuffer("Header[").append(type).append(",").append(text).append("]").toString();
	}
}
//@@@@@@//
//email/MailClient.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;
import java.util.*;

import com.darwinsys.util.FileProperties;

/** Standalone MailClient GUI application.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: MailClient.java,v 1.15 2004/02/09 03:33:48 ian Exp $
 */
public class MailClient extends JComponent implements MailConstants {
	/** The quit button */
	JButton quitButton;
	/** The read mode */
	MailReaderBean mrb;
	/** The send mode */
	MailComposeFrame mcb;
	/** The Aliases panel */
	AliasBean alb;

	/** Construct the MailClient JComponent a default Properties filename */
	public MailClient() throws Exception {
		this(PROPS_FILE_NAME);
	}

	/** Construct the MailClient JComponent with a Properties filename */
	public MailClient(String propsFileName) throws Exception {
		super();

		// Construct and load the Properties for the mail reader and sender.
		Properties mailProps = new FileProperties(propsFileName);

		// Gather some key values
		String proto = mailProps.getProperty(RECV_PROTO);
		String user  = mailProps.getProperty(RECV_USER);
		String pass  = mailProps.getProperty(RECV_PASS);
		String host  = mailProps.getProperty(RECV_HOST);

		if (proto==null)
			throw new IllegalArgumentException(RECV_PROTO + "==null");

		// Protocols other than "mbox" need a password.
		if (!proto.equals("mbox") && (pass == null || pass.equals("ASK"))) {
			String np;
			do {
				//np = JOptionPane.showInputDialog(null,
				//"Please enter password for " + proto + " user  " +
				//		user + " on " + host + "\n" +
				//		"(warning: password WILL echo)",
				//	"Password request", JOptionPane.QUESTION_MESSAGE);

				// Kludge so JOptionPane prompts for password in no-echo.
				// Create "message" using JPanel, JLabel, & JPasswordField
				// Courtesy of Marc Loy.
				JPanel p = new JPanel();
				p.add(new JLabel("Password for " + proto + " user " +
						user + " on " + host));
				JPasswordField jpf = new JPasswordField(20);
				p.add(jpf);
				JOptionPane.showMessageDialog(null, p,
					"Password request", JOptionPane.QUESTION_MESSAGE);
				np = new String(jpf.getPassword());
			} while (np == null || (np != null && np.length() == 0));
			mailProps.setProperty(RECV_PASS, np);
		}

		// Dump them all into System.properties so other code can find.
		System.getProperties().putAll(mailProps);

		// Construct the GUI
		// System.out.println("Constructing GUI");
		setLayout(new BorderLayout());
		JTabbedPane tbp = new JTabbedPane();
		add(BorderLayout.CENTER, tbp);
		tbp.addTab("Reading", mrb = new MailReaderBean());
		tbp.addTab("Sending", mcb = new MailComposeFrame());
		tbp.addTab("Aliases", alb = new AliasBean());
		tbp.addTab("List sending", new JLabel("Under construction",
			JLabel.CENTER));
		add(BorderLayout.SOUTH, quitButton = new JButton("Exit")); 
		// System.out.println("Leaving Constructor");
	}

	/** "main program" method - run the program */
	public static void main(String[] av) throws Exception {

		final JFrame f = new JFrame("MailClient");

		// Start by checking that the javax.mail package is installed!
		try {
			Class.forName("javax.mail.Session");
		} catch (ClassNotFoundException cnfe) {
			JOptionPane.showMessageDialog(f, 
				"Sorry, the javax.mail package was not found\n(" + cnfe + ")",
				"Error", JOptionPane.ERROR_MESSAGE);
			return;
		}

		// create a MailClient object
		MailClient comp;
		if (av.length == 0)
			comp = new MailClient();
		else
			comp = new MailClient(av[0]);
		f.getContentPane().add(comp);

		// Set up action handling for GUI
		comp.quitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				f.setVisible(false);
				f.dispose();
				System.exit(0);
			}
		});
		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				f.setVisible(false);
				f.dispose();
				System.exit(0);
			}
		});

		// Set bounds. Best at 800,600, but works at 640x480
		// f.setLocation(140, 80);
		// f.setSize    (500,400);
		f.pack();

		f.setVisible(true);
	}
}
//@@@@@@//
//email/MailComposeBean.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;
import java.io.*;
import javax.activation.*;
import javax.mail.*;
import javax.mail.internet.*;

import com.darwinsys.mail.Mailer;
import com.darwinsys.util.FileProperties;

/** MailComposeBean - Mail gather and send Component Bean.
 *
 * Can be used as a Visible bean or as a Non-Visible bean.
 * If setVisible(true), puts up a mail compose window with a Send button.
 * If user clicks on it, tries to send the mail to a Mail Server
 * for delivery on the Internet.
 *
 * If not visible, use addXXX(), setXXX(), and doSend() methods.
 *
 * @author Ian F. Darwin
 * @version $Id: MailComposeBean.java,v 1.11 2003/05/31 21:18:35 ian Exp $
 */
public class MailComposeBean extends JPanel {

	/** The parent frame to be hidden/disposed; may be JFrame, JInternalFrame
	 * or JPanel, as necessary */
	private Container parent;

	private JButton sendButton, cancelButton;
	private JTextArea msgText;		// The message!

	// The To, Subject, and CC lines are treated a bit specially,
	// any user-defined headers are just put in the tfs array.
	private JTextField tfs[], toTF, ccTF, subjectTF;
	// tfsMax MUST == how many are current, for focus handling to work
	private int tfsMax = 3;
	private final int TO = 0, SUBJ = 1, CC = 2, BCC = 3, MAXTF = 8;

	/** The JavaMail session object */
	private Session session = null;
	/** The JavaMail message object */
	private Message mesg = null;

	private int mywidth;
	private int myheight;

	/** Construct a MailComposeBean with no default recipient */
	MailComposeBean(Container parent, String title, int height, int width) {
		this(parent, title, null, height, width);
	}

	/** Construct a MailComposeBean with no arguments (needed for Beans) */
	MailComposeBean() {
		this(null, "Compose", null, 300, 200);
	}

	/** Constructor for MailComposeBean object.
	 *
	 * @param parent	Container parent. If JFrame or JInternalFrame,
	 *					will setvisible(false) and dispose() when
	 *					message has been sent. Not done if "null" or JPanel.
	 * @param title		Title to display in the titlebar
	 * @param recipient	Email address of recipient
	 * @param height	Height of mail compose window
	 * @param width		Width of mail compose window
	 */
	MailComposeBean(Container parent, String title, String recipient,
			int width, int height) {
		super();

		this.parent = parent;

		mywidth = width;
		myheight = height;

		// THE GUI
		Container cp = this;
		cp.setLayout(new BorderLayout());


		// Top is a JPanel for name, address, etc.
		// Centre is the TextArea.
		// Bottom is a panel with Send and Cancel buttons.
		JPanel tp = new JPanel();
		tp.setLayout(new GridLayout(3,2));
		cp.add(BorderLayout.NORTH, tp);

		tfs = new JTextField[MAXTF];

		tp.add(new JLabel("To: ", JLabel.RIGHT));
		tp.add(tfs[TO] = toTF = new JTextField(35));
		if (recipient != null)
			toTF.setText(recipient);
		toTF.requestFocus();

		tp.add(new JLabel("Subject: ", JLabel.RIGHT));
		tp.add(tfs[SUBJ] = subjectTF = new JTextField(35));
		subjectTF.requestFocus();

		tp.add(new JLabel("Cc: ", JLabel.RIGHT));
		tp.add(tfs[CC] = ccTF = new JTextField(35));

		// Centre is the TextArea
		cp.add(BorderLayout.CENTER, msgText = new JTextArea(70, 10));
		msgText.setBorder(BorderFactory.createTitledBorder("Message Text"));

		// Bottom is the apply/cancel button
		JPanel bp = new JPanel();
		bp.setLayout(new FlowLayout());
		bp.add(sendButton = new JButton("Send"));
		sendButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				try {
					doSend();
				} catch(Exception err) {
					System.err.println("Error: " + err);
					JOptionPane.showMessageDialog(null,
						"Sending error:\n" + err.toString(),
						"Send failed", JOptionPane.ERROR_MESSAGE);
				}
			}
		});
		bp.add(cancelButton = new JButton("Cancel"));
		cancelButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				maybeKillParent();
			}
		});
		cp.add(BorderLayout.SOUTH, bp);
	}

	public Dimension getPreferredSize() {
		return new Dimension(mywidth, myheight);
	}
	public Dimension getMinimumSize() {
		return getPreferredSize();
	}

	/** Do the work: send the mail to the SMTP server.
	 *
	 * ASSERT: must have set at least one recipient.
	 */
	public void doSend() {

		try {
			Mailer m = new Mailer();

			FileProperties props =
				new FileProperties(MailConstants.PROPS_FILE_NAME);
			String serverHost = props.getProperty(MailConstants.SEND_HOST);
			if (serverHost == null) {
				JOptionPane.showMessageDialog(parent,
					"\"" + MailConstants.SEND_HOST +
						"\" must be set in properties",
					"No server!",
					JOptionPane.ERROR_MESSAGE);
				return;
			}
			m.setServer(serverHost);

			String tmp = props.getProperty(MailConstants.SEND_DEBUG);
			m.setVerbose(tmp != null && tmp.equals("true"));

			String myAddress = props.getProperty("Mail.address");
			if (myAddress == null) {
				JOptionPane.showMessageDialog(parent,
					"\"Mail.address\" must be set in properties",
					"No From: address!",
					JOptionPane.ERROR_MESSAGE);
				return;
			}
			m.setFrom(myAddress);

			m.setToList(toTF.getText());
			m.setCcList(ccTF.getText());
			// m.setBccList(bccTF.getText());

			if (subjectTF.getText().length() != 0) {
				m.setSubject(subjectTF.getText());
			}

			// Now copy the text from the Compose TextArea.
			m.setBody(msgText.getText());
			// XXX I18N: use setBody(msgText.getText(), charset)
				
			// Finally, send the sucker!
			m.doSend();

			// Now hide the main window
			maybeKillParent();

		} catch (MessagingException me) {
			me.printStackTrace();
			while ((me = (MessagingException)me.getNextException()) != null) {
				me.printStackTrace();
			}
			JOptionPane.showMessageDialog(null,
				"Mail Sending Error:\n" + me.toString(),
				"Error", JOptionPane.ERROR_MESSAGE);
		} catch (Exception e) {
			JOptionPane.showMessageDialog(null,
				"Mail Sending Error:\n" + e.toString(),
				"Error", JOptionPane.ERROR_MESSAGE);
		}
	}

	private void maybeKillParent() {
		if (parent == null)
			return;
		if (parent instanceof Frame) {
			((Frame)parent).setVisible(true);
			((Frame)parent).dispose();
		}
		if (parent instanceof JInternalFrame) {
			((JInternalFrame)parent).setVisible(true);
			((JInternalFrame)parent).dispose();
		}
	}


	/** Simple test case driver */
	public static void main(String[] av) {
		final JFrame jf = new JFrame("DarwinSys Compose Mail Tester");
		System.getProperties().setProperty("Mail.server", "mailhost");
		System.getProperties().setProperty("Mail.address", "nobody@home");
		MailComposeBean sm =
			new MailComposeBean(jf, 
			"Test Mailer", "spam-magnet@darwinsys.com", 500, 400);
		sm.setSize(500, 400);
		jf.getContentPane().add(sm);
		jf.setLocation(100, 100);
		jf.setVisible(true);
        jf.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
			jf.setVisible(false);
			jf.dispose();
			System.exit(0);
			}
		});
		jf.pack();
	}
}
//@@@@@@//
//email/MailComposeFrame.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** A frame for (possibly) multiple MailComposeBean windows.
 */
public class MailComposeFrame extends JPanel {
	JDesktopPane dtPane;
	JButton newButton;
	protected int nx, ny;

	/** To be useful here, a MailComposeBean has to be inside
	 * its own little JInternalFrame. 
	 */
	public MailComposeBean newSend() {

		// Make the JInternalFrame wrapper
		JInternalFrame jf = new JInternalFrame();

		// Bake the actual Bean
		MailComposeBean newBean = 
			new MailComposeBean(this, "Compose", 400, 250);

		// Arrange them on the diagonal.
		jf.setLocation(nx+=10, ny+=10);

		// Make the new Bean be the contents of the JInternalFrame
		jf.setContentPane(newBean);
		jf.pack();
		jf.toFront();

		// Add the JInternalFrame to the JDesktopPane
		dtPane.add(jf);
		return newBean;
	}

	/* Construct a MailComposeFrame, with a Compose button. */
	public MailComposeFrame() {

		setLayout(new BorderLayout());

		dtPane = new JDesktopPane();
		add(dtPane, BorderLayout.CENTER);

		newButton = new JButton("Compose");
		newButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				newSend();
			}
		});
		add(newButton, BorderLayout.SOUTH);
	}
}
//@@@@@@//
//email/MailConstants.java
//@@@@@@//
/** Simply a list of names for the Mail System to use.
 * If you "implement" this interface, you don't have to prefix
 * all the names with MailProps in your code.
 */
public interface MailConstants {
	public static final String PROPS_FILE_NAME = "MailClient.properties";

	public static final String SEND_PROTO = "Mail.send.protocol";
	public static final String SEND_USER  = "Mail.send.user";
	public static final String SEND_PASS  = "Mail.send.password";
	public static final String SEND_ROOT  = "Mail.send.root";
	public static final String SEND_HOST  = "Mail.send.host";
	public static final String SEND_DEBUG = "Mail.send.debug";

	public static final String RECV_PROTO = "Mail.receive.protocol";
	public static final String RECV_PORT  = "Mail.receive.port";
	public static final String RECV_USER  = "Mail.receive.user";
	public static final String RECV_PASS  = "Mail.receive.password";
	public static final String RECV_ROOT  = "Mail.receive.root";
	public static final String RECV_HOST  = "Mail.receive.host";
	public static final String RECV_DEBUG = "Mail.receive.debug";
}
//@@@@@@//
//email/MailLister.java
//@@@@@@//
import java.util.Properties;
import javax.mail.*;
import javax.mail.internet.*;

import com.darwinsys.lang.StringFormat;
import com.darwinsys.util.FileProperties;

/**
* List all available folders.
*/
public class MailLister {
	static StringFormat fromFmt = 
		new StringFormat(20, StringFormat.JUST_LEFT);
	static StringFormat subjFmt = 
		new StringFormat(40, StringFormat.JUST_LEFT);

	public static void main(String[] argv) throws Exception {
		String fileName = MailConstants.PROPS_FILE_NAME;
		String protocol = null;
		String host = null;
		String user = null;
		String password = null;
		String root = null;

		// If argc == 1, assume it's a Properties file.
		if (argv.length == 1) {
			fileName = argv[0];
			FileProperties fp = new FileProperties(fileName);
			fp.load();
			protocol = fp.getProperty(MailConstants.RECV_PROTO);
			host = fp.getProperty(MailConstants.RECV_HOST);
			user = fp.getProperty(MailConstants.RECV_USER);
			password = fp.getProperty(MailConstants.RECV_PASS);
			root = fp.getProperty(MailConstants.RECV_ROOT);
		}
		// If not, assume listing all args in long form.
		else if (argv.length == 5) {
			protocol = argv[0];
			host = argv[1];
			user = argv[2];
			password = argv[3];
			root = argv[4];
		}
		// Otherwise give up.
		else {
			System.err.println(
				"Usage: MailLister protocol host user pw root");
			System.exit(0);
		}


		boolean recursive = false;

		// Start with a Session object, as usual
		Session session = Session.getDefaultInstance(
			System.getProperties(), null);
		session.setDebug(false);

		// Get a Store object for the given protocol
		Store store = session.getStore(protocol);
		store.connect(host, user, password);

		// Get Folder object for root, and list it
		// If root name = "", getDefaultFolder(), else getFolder(root)
		Folder rf;
		if (root.length() != 0) {
			System.out.println("Getting folder " + root + ".");
			rf = store.getFolder(root);
		} else {
			System.out.println("Getting default folder.");
			rf = store.getDefaultFolder();
		}
		rf.open(Folder.READ_WRITE);

		if (rf.getType() == Folder.HOLDS_FOLDERS) {
			Folder[] f = rf.list();
			for (int i = 0; i < f.length; i++)
				listFolder(f[i], "", recursive);
		} else
				listFolder(rf, "", false);
	}

	static void listFolder(Folder folder, String tab, boolean recurse)
	throws Exception {
		folder.open(Folder.READ_WRITE);
		System.out.println(tab + "Name: " + folder.getName() + '(' +
			folder.getFullName() + ')');
		if (!folder.isSubscribed())
			System.out.println(tab + "Not Subscribed");
		if ((folder.getType() & Folder.HOLDS_MESSAGES) != 0) {
			if (folder.hasNewMessages())
				System.out.println(tab + "Has New Messages");
			else
				System.out.println(tab + "No New Messages");
			Message[] msgs = folder.getMessages();
			for (int i=0; i<msgs.length; i++) {
				Message m = msgs[i];
				Address from = m.getFrom()[0];
				String fromAddress;
				if (from instanceof InternetAddress)
					fromAddress = ((InternetAddress)from).getAddress();
				else
					fromAddress = from.toString();
				StringBuffer sb = new StringBuffer();
				fromFmt.format(fromAddress, sb, null);
				sb.	append("  ");
				subjFmt.format(m.getSubject(), sb, null);
				System.out.println(sb.toString());
			}
		}
		if ((folder.getType() & Folder.HOLDS_FOLDERS) != 0) {
			System.out.println(tab + "Is Directory");
		if (recurse) {
			Folder[] f = folder.list();
			for (int i=0; i < f.length; i++)
				listFolder(f[i], tab + "", recurse);
			}
		}
	}
}
//@@@@@@//
//email/MailReaderBean.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.tree.*;
import javax.swing.event.*;
import javax.mail.*;
import javax.mail.internet.*;

/**
 * Display a mailbox or mailboxes.
 * This is the generic version in javasrc/email, split off from
 * JabaDex because of the latter's domain-specific "implements module" stuff.
 * @version $Id: MailReaderBean.java,v 1.17 2001/03/14 23:59:09 ian Exp $
 */
public class MailReaderBean extends JSplitPane {

	private JTextArea bodyText;

	/* Construct a mail reader bean with all defaults.
	 */
	public MailReaderBean() throws Exception {
		this("smtp", "mailhost", "user", "nopasswd", "/");
	}

	/* Construct a mail reader bean with all values. */
    public MailReaderBean(
		String protocol,
		String host,
		String user,
		String password,
		String rootName)
	throws Exception {

		super(VERTICAL_SPLIT);

		boolean recursive = false;

		// Start with a Mail Session object
		Session session = Session.getDefaultInstance(
			System.getProperties(), null);
		session.setDebug(false);

		// Get a Store object for the given protocol
		Store store = session.getStore(protocol);
		store.connect(host, user, password);

		// Get Folder object for root, and list it
		// If root name = "", getDefaultFolder(), else getFolder(root)
		FolderNode top;
		if (rootName.length() != 0) {
			// System.out.println("Getting folder " + rootName + ".");
			top = new FolderNode(store.getFolder(rootName));
		} else {
			// System.out.println("Getting default folder.");
			top = new FolderNode(store.getDefaultFolder());
		}
		if (top == null || !top.f.exists()) {
			System.out.println("Invalid folder " + rootName);
			return;
		}

		if (top.f.getType() == Folder.HOLDS_FOLDERS) {
			Folder[] f = top.f.list();
			for (int i = 0; i < f.length; i++)
				listFolder(top, new FolderNode(f[i]), recursive);
		} else
				listFolder(top, top, false);

		// Now that (all) the foldernodes and treenodes are in,
		// construct a JTree object from the top of the list down,
		// make the JTree scrollable (put in JScrollPane),
		// and add it as the MailComposeBean's Northern child.
		JTree tree = new JTree(top);
		JScrollPane treeScroller = new JScrollPane(tree);
		treeScroller.setBackground(tree.getBackground());
		this.setTopComponent(treeScroller);

		// The Southern (Bottom) child is a textarea to display the msg.
		bodyText = new JTextArea(15, 80);
		this.setBottomComponent(new JScrollPane(bodyText));

		// Add a notification listener for the tree; this will
		// display the clicked-upon message
		TreeSelectionListener tsl = new TreeSelectionListener() {
			public void valueChanged(TreeSelectionEvent evt) {
				Object[] po = evt.getPath().getPath();	// yes, repeat it.
				Object o = po[po.length - 1];	// last node in path
				if (o instanceof FolderNode) {
					// System.out.println("Select folder " + o.toString());
					return;
				}
				if (o instanceof MessageNode) {
					bodyText.setText("");
					try {
						Message m = ((MessageNode)o).m;

						bodyText.append("To: ");
						Object[] tos = m.getAllRecipients();
						for (int i=0; i<tos.length; i++) {
							bodyText.append(tos[i].toString());
							bodyText.append(" ");
						}
						bodyText.append("\n");

						bodyText.append("Subject: " + m.getSubject() + "\n");
						bodyText.append("From: ");
						Object[] froms = m.getFrom();
						for (int i=0; i<froms.length; i++) {
							bodyText.append(froms[i].toString());
							bodyText.append(" ");
						}
						bodyText.append("\n");

						bodyText.append("Date: " + m.getSentDate() + "\n");
						bodyText.append("\n");

						bodyText.append(m.getContent().toString());

						// Start reading at top of message(!)
						bodyText.setCaretPosition(0);
					} catch (Exception e) {
						bodyText.append(e.toString());
					}
				} else 
					System.err.println("UNEXPECTED SELECTION: " + o.getClass());
			}
		};
		tree.addTreeSelectionListener(tsl);
	}

	static void listFolder(FolderNode top, FolderNode folder, boolean recurse) throws Exception {
		// System.out.println(folder.f.getName() + folder.f.getFullName());
		if ((folder.f.getType() & Folder.HOLDS_MESSAGES) != 0) {
			Message[] msgs = folder.f.getMessages();
			for (int i=0; i<msgs.length; i++) {
				MessageNode m = new MessageNode(msgs[i]);
				Address from = m.m.getFrom()[0];
				String fromAddress;
				if (from instanceof InternetAddress)
					fromAddress = ((InternetAddress)from).getAddress();
				else
					fromAddress = from.toString();
				top.add(new MessageNode(msgs[i]));
			}
		}
		if ((folder.f.getType() & Folder.HOLDS_FOLDERS) != 0) {
			if (recurse) {
				Folder[] f = folder.f.list();
				for (int i=0; i < f.length; i++)
					listFolder(new FolderNode(f[i]), top, recurse);
				}
		}
	}

	/* Test unit - main program */
	public static void main(String[] args) throws Exception {
		final JFrame jf = new JFrame("MailReaderBean");
		String mbox = "/var/mail/ian";
		if (args.length > 0)
			mbox = args[0];
		MailReaderBean mb = new MailReaderBean("mbox", "localhost",
			"", "", mbox);
		jf.getContentPane().add(mb);
		jf.setSize(640,480);
		jf.setVisible(true);
		jf.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
			jf.setVisible(false);
			jf.dispose();
			System.exit(0);
			}
		});
	}
}
//@@@@@@//
//email/MailtoButton.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.util.*;

/** 
 * MailtoButton -- look like a mailto, but not visible to spiders.
 *
 * @author	Copyright 1995, 1997 Ian F. Darwin,
 * <A HREF="mailto:http://www.darwinsys.com/">http://www.darwinsys.com/</A>,
 * <A HREF="http:www.darwinsys.com/">http://www.darwinsys.com</A>.
 * @version	$Id: MailtoButton.java,v 1.5 2004/02/09 03:33:48 ian Exp $
 */
public class MailtoButton extends Applet {
	/** The label that is to appear in the button */
	protected String label = null;
	/** The width and height */
	protected int width, height;
	/** The string form of the URL to jump to */
	protected String targetName, targetHost;
	/** The URL to jump to when the button is pushed. */
	protected URL targetURL;
	/** The name of the font */
	protected String fontName;
	protected String DEFAULTFONTNAME = "helvetica";
	/** The font */
	protected Font theFont;
	/** The size of the font */
	protected int fontSize = 18;
	/** The HTML PARAM for the user account -- keep it short */
	private String TARGET1 = "U";	// for User 
	/** The HTML PARAM for the hostname -- keep it short */
	private String TARGET2 = "H";	// for Host 
	// Dummy
	private String BOGON1 = "username";	// happy strings-ing, SPAM perps
	private String BOGON2 = "hostname";	// ditto.
	/** The string for the Subject line, if any */
	private String subject;

	/** Called from the browser to set up. We want to throw various
	 * kinds of exceptions but the API predefines that we don't, so we
	 * limit ourselves to the ubiquitous IllegalArgumentException.
	 */
	public void init() {
		// System.out.println("In LinkButton::init");
		try {
			if ((targetName = getParameter(TARGET1)) == null)
				throw new IllegalArgumentException(
					"TARGET parameter REQUIRED");
			if ((targetHost = getParameter(TARGET2)) == null)
				throw new IllegalArgumentException(
					"TARGET parameter REQUIRED");

			String theURL = "mailto:" + targetName + "@" + targetHost;

			subject = getParameter("subject");
			if (subject != null)
				theURL += "?subject=" + subject;

			targetURL = new URL(theURL);

		} catch (MalformedURLException rsi) {
			throw new IllegalArgumentException("MalformedURLException " +
				rsi.getMessage());
		}


		label = getParameter("label");	// i.e., "Send feedback"
		if (label == null)
				throw new IllegalArgumentException("LABEL is REQUIRED");

		// Now handle font stuff.
		fontName = getParameter("font");
		if (fontName == null)
			fontName = DEFAULTFONTNAME;
		String s;
		if ((s = getParameter("fontsize")) != null)
			fontSize = Integer.parseInt(s);
		if (fontName != null || fontSize != 0) {
			// System.out.println("Name " + fontName + ", size " + fontSize);
			theFont = new Font(fontName, Font.BOLD, fontSize);
		}
		
		Button b = new Button(label);
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (targetURL != null) {
					// showStatus("Going to " + target);
					getAppletContext().showDocument(targetURL);
				}
			}
		});
		if (theFont != null)
			b.setFont(theFont);
		add(b);
	}
	
	/** Give Parameter info the the AppletViewer, just for those
	 * writing HTML without hardcopy documentation :-)
	 */
	public String[][] getParameterInfo() {
		String info[][] = {
			{ "label",		"string",	"Text to display" },
			{ "fontname",	"name",		"Font to display it in" },
			{ "fontsize",	"10-30?",	"Size to display it at" },

			// WARNING - these intentionally lie, to mislead spammers who
			// are incautious enough to download and run (or strings) the
			// .class file for this Applet.

			{ "username",	"email-account",
				"Where do you want your mail to go today? Part 1" },
			{ "hostname",	"host.domain",
				"Where do you want your mail to go today? Part 2" },
			{ "subject",	"subject line",
				"What your Subject: field will be." },
		};
		return info;
	}
}
//@@@@@@//
//email/MessageNode.java
//@@@@@@//
import javax.mail.*;
import javax.mail.internet.*;
import javax.swing.tree.*;

import com.darwinsys.lang.StringFormat;

/** A Mutable Tree Node that is also a Message. */
public class MessageNode extends DefaultMutableTreeNode {
	Message m;

	StringFormat fromFmt = new StringFormat(20, StringFormat.JUST_LEFT);
	StringFormat subjFmt = new StringFormat(30, StringFormat.JUST_LEFT);

	MessageNode(Message m) {
		this.m = m;
	}

	public String toString() {
		try {
			Address from = m.getFrom()[0];

			String fromAddress;
			if (from instanceof InternetAddress)
				fromAddress = ((InternetAddress)from).getAddress();
			else
				fromAddress = from.toString();

			StringBuffer sb = new StringBuffer();
			fromFmt.format(fromAddress, sb, null);
			sb.	append("  ");
			subjFmt.format(m.getSubject(), sb, null);
			return sb.toString();
		} catch (Exception e) {
			return e.toString();
		}
	}
}
//@@@@@@//
//email/MimeHandler.java
//@@@@@@//
import javax.activation.*;
import java.awt.datatransfer.*;
import java.io.*;

/** Provide a truly minimalist demonstration of using JAF (aka
 * javax.activation, the Java Activation Framework) to read one
 * object and classify it.
 */
public class MimeHandler {

	class PlainHandler implements DataContentHandler {
		private DataFlavor[] taste = {
			new DataFlavor("text/plain", "Plain text"),
			new DataFlavor("text/html", "HTML text")
		};

		public DataFlavor[] getTransferDataFlavors() {
			return taste;
		}

		public Object getTransferData(DataFlavor fl, DataSource ds)
			throws UnsupportedFlavorException, java.io.IOException {
			// XXX
			return null;
		}
		public Object getContent(DataSource ds)
			throws java.io.IOException {
			BufferedReader is =
				new BufferedReader(new InputStreamReader(ds.getInputStream()));
			StringBuffer sb = new StringBuffer();
			int ch;
			while ((ch = is.read()) != -1)
				sb.append((char)ch);
			return sb.toString();
		}
		public void writeTo(Object o, String s, OutputStream os)
			throws java.io.IOException {
			//XXX
			return;
		}
	}

	class MyDataContentHandlerFactory implements DataContentHandlerFactory {
		public DataContentHandler createDataContentHandler(String mimeType){
			DataContentHandler dch = null;

			if ("text/plain".equals(mimeType)) {
				return new PlainHandler();
			} else if ("text/html".equals(mimeType)) {
				return new PlainHandler();
			} else {
				String mesg = "No handler for " + mimeType;
				throw new IllegalArgumentException(mesg);
			}
		}
	}

	public static void main(String[] args) throws IOException {
		MimeHandler mh = new MimeHandler();

		mh.process(args[0]);
	}

	private void process(String fn) throws IOException {
		DataSource ds = new FileDataSource(fn);

		DataHandler dh = new DataHandler(ds);

		dh.setDataContentHandlerFactory(new MyDataContentHandlerFactory());

		Object data = dh.getContent();

		System.out.println("Content=" + data);
		if (data != null)
			System.out.println("Type   =" + data.getClass().getName());
	}
}
//@@@@@@//
//email/ReadHeaders.java
//@@@@@@//
import java.io.*;

/**
 * Read a file return mail headers one at a time.
 */
public class ReadHeaders {
	protected BufferedReader is;

	/** Construct */
	public ReadHeaders(BufferedReader f) {
		is = f;
	}

	/** Main program showing how to use it */
    public static void main(String[] av) {
        switch(av.length) {
            case 0: 
				ReadHeaders r = new ReadHeaders(
					new BufferedReader(
                        new InputStreamReader(System.in))); 
				printit(r);
				break;
            default:
				for (int i=0; i<av.length; i++)
                    try {
						ReadHeaders rr = new ReadHeaders(
							new BufferedReader(new FileReader(av[i])));
						printit(rr);
                    } catch (FileNotFoundException e) {
                        System.err.println(e);
                    }
				break;
        }
    }

	/** Simple demo showing how to use it */
	public static void printit(ReadHeaders r) {
		while (r.more())  {
			Header h = r.next();
			System.out.println(h.type + " = " + h.text);
		}
	}

	String inputLine;

    /** check to see if more headers available */
    public boolean more() {
		if (is == null)
			return false;
        try {

            inputLine = is.readLine();
			if (inputLine == null || inputLine.length() == 0) {
				is.close();
				is = null;
			}
        } catch (IOException e) {
            System.out.println("IOException: " + e);
			is = null;
			return false;
        }
		return true;
    }

	public Header next() {
		int pos = inputLine.indexOf(":");
		if (pos < 0)
			return new Header("??", inputLine);
		return new Header(
			inputLine.substring(0, pos),
			inputLine.substring(pos + 1));
	}
}

//@@@@@@//
//email/Sender.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.mail.*;
import javax.mail.internet.*; 

/** sender -- send an email message.
 * @author Ian F. Darwin
 * @version $Id: Sender.java,v 1.2 2000/11/25 17:55:00 ian Exp $
 */
public class Sender {

	/** The message recipient. */
	protected String message_recip = "spam-magnet@darwinsys.com";
	/* What's it all about, Alfie? */
	protected String message_subject = "Re: your mail";
	/** The message CC recipient. */
	protected String message_cc = "nobody@erewhon.com";
	/** The message body */
	protected String message_body =
		"I am unable to attend to your message, as I am busy sunning" +
		"myself on the beach in Maui, where it is warm and peaceful." +
		"Perhaps when I return I'll get around to reading your mail." +
		"Or perhaps not.";

	/** The JavaMail session object */
	protected Session session;
	/** The JavaMail message object */
	protected Message mesg;

	/** Do the work: send the mail to the SMTP server.  */
	public void doSend() {

		// We need to pass info to the mail server as a Properties, since
		// JavaMail (wisely) allows room for LOTS of properties...
		Properties props = new Properties();

		// Your LAN must define the local SMTP server as "mailhost"
		// for this simple-minded version to be able to send mail...
		props.put("mail.smtp.host", "mailhost");

		// Create the Session object
		session = Session.getDefaultInstance(props, null);
		session.setDebug(true);		// Verbose!
		
		try {
			// create a message
			mesg = new MimeMessage(session);

			// From Address - this should come from a Properties...
			mesg.setFrom(new InternetAddress("nobody@host.domain"));

			// TO Address 
			InternetAddress toAddress = new InternetAddress(message_recip);
			mesg.addRecipient(Message.RecipientType.TO, toAddress);

			// CC Address
			InternetAddress ccAddress = new InternetAddress(message_cc);
			mesg.addRecipient(Message.RecipientType.CC, ccAddress);

			// The Subject
			mesg.setSubject(message_subject);

			// Now the message body.
			mesg.setText(message_body);
			// XXX I18N: use setText(msgText.getText(), charset)
			
			// Finally, send the message!
			Transport.send(mesg);

		} catch (MessagingException ex) {
			while ((ex = (MessagingException)ex.getNextException()) != null) {
				ex.printStackTrace();
			}
		}
	}

	/** Simple test case driver */
	public static void main(String[] av) {
		Sender sm = new Sender();
		sm.doSend();
	}
}
//@@@@@@//
//email/Sender2.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.mail.*;
import javax.mail.internet.*; 

import com.darwinsys.lang.GetOpt;

/** sender -- send an email message.
 * If you give more than one file, each file will be sent to the
 * same recipient with the same subject, so you generally don't want to.
 * @author Ian F. Darwin
 * @version $Id: Sender2.java,v 1.8 2004/03/20 20:52:35 ian Exp $
 */
public class Sender2 {

	/** The message recipient. */
	protected String message_recip;
	/* What's it all about, Alfie? */
	protected String message_subject;
	/** The message CC recipient. */
	protected String message_cc;
	/** The message body */
	protected String message_body;

	/** The JavaMail session object */
	protected Session session;
	/** The JavaMail message object */
	protected Message mesg;

	/** Properties object used to pass props into the MAIL API */
	Properties props = new Properties();

	/** Construct a Sender2 object */
	public Sender2() throws MessagingException {

		// Your LAN must define the local SMTP as "mailhost"
		// for this simple-minded version to be able to send mail...
		props.put("mail.smtp.host", "mailhost");
		finish();
	}

	/** Construct a Sender2 object.
	 * @param hostName - the name of the host to send to/via.
	 */
	public Sender2(String hostName) throws MessagingException {

		props.put("mail.smtp.host", hostName);
		finish();
	}

	private void finish() {

		// Create the Session object
		session = Session.getDefaultInstance(props, null);
		// session.setDebug(true);		// Verbose!
		
		// create a message
		mesg = new MimeMessage(session);
	}

	public void sendFile(String fileName) throws MessagingException {
		// Now the message body.
		setBody(message_body);
			
		sendFile();
	}

	/** Send the file with no filename, assuming you've already called
	 * the setBody() method.
	 */
	public void sendFile() {
		try {
			
			// Finally, send the message! (use static Transport method)
			Transport.send(mesg);

		} catch (MessagingException ex) {
			while ((ex = (MessagingException)ex.getNextException()) != null) {
				ex.printStackTrace();
			}
		}
	}

	/** Stub for providing help on usage
	 * You can write a longer help than this, certainly.
	 */
	protected static void usage(int returnValue) {
		System.err.println("Usage: Sender2 [-t to][-c cc][-f from][-s subj] file ...");
		System.exit(returnValue);
	}

	public void addRecipient(String message_recip) throws MessagingException {
		// TO Address 
		InternetAddress toAddress = new InternetAddress(message_recip);
		mesg.addRecipient(Message.RecipientType.TO, toAddress);
	}

	public void addCCRecipient(String message_cc) throws MessagingException { 
		// CC Address
		InternetAddress ccAddress = new InternetAddress(message_cc);
		mesg.addRecipient(Message.RecipientType.CC, ccAddress);
	}

	public void setFrom(String sender) throws MessagingException {
		// From Address - this should come from a Properties...
		mesg.setFrom(new InternetAddress(sender));
	}

	public void setSubject(String message_subject) throws MessagingException {
		// The Subject
		mesg.setSubject(message_subject);
	}

	/** Set the message body. */
	public void setBody(String message_body) throws MessagingException {
		mesg.setText(message_body);
		// XXX I18N: use setText(msgText.getText(), charset)
	}

	/** Driver to parse options and control Sender */
	public static void main(String[] args) {
		try {
			Sender2 sm = new Sender2();
			GetOpt go = new GetOpt("c:f:t:s:");
			char c;
			while ((c =go.getopt(args)) != 0) {
				switch(c) {
				case 'h':
					// XXX sm.setMailHost();
					sm.props.put("mail.smtp.host", go.optarg());
					break;
				case 't':
					sm.addRecipient(go.optarg());
					break;
				case 'c':
					sm.addCCRecipient(go.optarg());
					break;
				case 'f':
					sm.setFrom(go.optarg());
					break;
				case 's':
					sm.setSubject(go.optarg());
					break;
				default:
					System.err.println("Unknown option character " + c);
					usage(1);
				}
			}
			if (go.getOptInd() == args.length) {
				sm.sendFile("(standard input)");
			} else for (int i=go.getOptInd(); i<args.length; i++)
				sm.sendFile(args[i]);
		} catch (MessagingException e) {
			System.err.println(e);
		}
	}
}
//@@@@@@//
//email/SendMime.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.mail.*;
import javax.mail.internet.*; 

import com.darwinsys.util.FileProperties;

/** SendMime -- send a multi-part MIME email message.
 * @author Ian F. Darwin
 * @version $Id: SendMime.java,v 1.8 2003/05/31 21:18:35 ian Exp $
 */
public class SendMime {

	/** The message recipient. */
	protected String message_recip = "spam-magnet@darwinsys.com";
	/* What's it all about, Alfie? */
	protected String message_subject = "Re: your mail";
	/** The message CC recipient. */
	protected String message_cc = "nobody@erewhon.com";
	/** The text/plain message body */
	protected String message_body =
		"I am unable to attend to your message, as I am busy sunning " +
		"myself on the beach in Maui, where it is warm and peaceful. " +
		"Perhaps when I return I'll get around to reading your mail. " +
		"Or perhaps not.";
	/* The text/html data. */
	protected String html_data = 
		"<HTML><HEAD><TITLE>My Goodness</TITLE></HEAD>" +
		"<BODY><P>You <EM>do</EM> look a little " +
		"<font color=green>GREEN</FONT>" +
		"around the edges..." +
		"</BODY></HTML>";

	/** The JavaMail session object */
	protected Session session;
	/** The JavaMail message object */
	protected Message mesg;

	/** Do the work: send the mail to the SMTP server.  */
	public void doSend() throws IOException, MessagingException {

		// We need to pass info to the mail server as a Properties, since
		// JavaMail (wisely) allows room for LOTS of properties...
		FileProperties props = 
			new FileProperties(MailConstants.PROPS_FILE_NAME);

		// Copy the value of Mail.send.host into mail.smtp.host
		props.setProperty("mail.smtp.host", 
			props.getProperty(MailConstants.SEND_HOST));

		// Create the Session object
		session = Session.getDefaultInstance(props, null);
		session.setDebug(true);		// Verbose!
		
		try {
			// create a message
			mesg = new MimeMessage(session);

			// From Address - this should come from a Properties...
			mesg.setFrom(new InternetAddress("nobody@host.domain"));

			// TO Address 
			InternetAddress toAddress = new InternetAddress(message_recip);
			mesg.addRecipient(Message.RecipientType.TO, toAddress);

			// CC Address
			InternetAddress ccAddress = new InternetAddress(message_cc);
			mesg.addRecipient(Message.RecipientType.CC, ccAddress);

			// The Subject
			mesg.setSubject(message_subject);

			// Now the message body.
			Multipart mp = new MimeMultipart();

			BodyPart textPart = new MimeBodyPart();
			textPart.setText(message_body);	// sets type to "text/plain"

			BodyPart pixPart = new MimeBodyPart();
			pixPart.setContent(html_data, "text/html");

			// Collect the Parts into the MultiPart
			mp.addBodyPart(textPart);
			mp.addBodyPart(pixPart);

			// Put the MultiPart into the Message
			mesg.setContent(mp);
			
			// Finally, send the message!
			Transport.send(mesg);

		} catch (MessagingException ex) {
			System.err.println(ex);
			ex.printStackTrace(System.err);
		}
	}

	/** Simple test case driver */
	public static void main(String[] av) throws Exception {
		SendMime sm = new SendMime();
		sm.doSend();
	}
}
//@@@@@@//
//email/SMTPException.java
//@@@@@@//
/** This is like an IOException, but it includes a Sendmail-style error
 * number in addition to the error message String.
 */
public class SMTPException extends java.io.IOException {
	int ret;

	SMTPException(int ret, String s) {
		super(s);
		this.ret = ret;
	}
	int getCode() {
		return ret;
	}
}
//@@@@@@//
//email/SmtpTalk.java
//@@@@@@//
import java.io.*;
import java.net.*;
import java.util.*;

/**
 * SMTP talker class, usable standalone (as a SendMail(8) backend)
 * or inside applications such as JabaDex that need to send mail..
 *
 * OBSOLETE!! Use javax.mail instead, now that it's available!
 *
 * Needs more parameterization - bit of a hack to start.
 * Should use same interface as Mailer (subclass, and override doSend()).
 *
 * @author	Ian Darwin
 * @version	$Id: SmtpTalk.java,v 1.10 2002/10/26 13:53:45 ian Exp $
 */
public class SmtpTalk implements SysExits {
	BufferedReader is;
	PrintStream os;
	private boolean debug = true;
	private String host;

	/** A simple main program showing the class in action.
	 *
	 * TODO generalize to accept From arg, read msg on stdin
	 */
	public static void main(String[] argv) {
		if (argv.length != 2) {
			System.err.println("Usage: java SmtpTalk host user");
			System.exit(EX_USAGE);
		}

		try {
			SmtpTalk st = new SmtpTalk(argv[0]);

			System.out.println("SMTP Talker ready");

			st.converse("MAILER-DAEMON@daroad.darwinsys.com", 
				argv[1], "Test message", "Hello there");
		} catch (SMTPException ig) {
			System.err.println(ig.getMessage());
			System.exit(ig.getCode());
		}
	}

	/** Constructor taking a server hostname as argument.
	 */
	SmtpTalk(String server) throws SMTPException {
		host = server;
		try {
			Socket s = new Socket(host, 25);
			is = new BufferedReader(
				new InputStreamReader(s.getInputStream()));
			os = new PrintStream(s.getOutputStream());
		} catch (NoRouteToHostException e) {
			die(EX_TEMPFAIL, "No route to host " + host);
		} catch (ConnectException e) {
			die(EX_TEMPFAIL, "Connection Refused by " + host);
		} catch (UnknownHostException e) {
			die(EX_NOHOST, "Unknown host " + host);
		} catch (IOException e) {
			die(EX_IOERR, "I/O error setting up socket streams\n" + e);
		}
	}

	/** Send a command with an operand */
	protected void send_cmd(String cmd, String oprnd) {
		send_cmd(cmd + " " + oprnd);
	}

	/* Send a command with no operand */
	protected void send_cmd(String cmd) {
		if (debug)
			System.out.println(">>> " + cmd);
		os.print(cmd + "\r\n");
	}

	/** Send_text sends the body of the message. */
	public void send_text(String text) {
		os.print(text + "\r\n");
	}

	/** Expect (read and check for) a given reply */
	protected boolean expect_reply(String rspNum) throws SMTPException {
		String s = null;
		try {
			s = is.readLine();
		} catch(IOException e) {
			die(EX_IOERR,"I/O error reading from host " + host + " " + e);
		}
		if (debug) System.out.println("<<< " + s);
		return s.startsWith(rspNum + " ");
	}

	/** Convenience routine to print message & exit, like
	 * K&P error(), perl die(), ...
	 * @param ret Numeric value to pass back
	 * @param msg Error message to be printed on stdout.
	 */
	protected void die(int ret, String msg) throws SMTPException {
		throw new SMTPException(ret, msg);
	}

	/** send one Mail message to one or more recipients via smtp 
	 * to server "host".
	 */
	public void converse(String sender, String recipients,
		String subject, String body) throws SMTPException {

		if (!expect_reply("220")) die(EX_PROTOCOL,
			"did not get SMTP greeting");

		send_cmd("HELO", "darwinsys.com");
		if (!expect_reply("250")) die(EX_PROTOCOL,
			"did not ack our HELO");

		send_cmd("MAIL", "From:<"+sender+">");	// no spaces!
		if (!expect_reply("250")) die(EX_PROTOCOL,
			"did not ack our MAIL command");

		StringTokenizer st = new StringTokenizer(recipients);
		while (st.hasMoreTokens()) {
			String r = st.nextToken();
			send_cmd("RCPT", "To:<" + r + ">");
			if (!expect_reply("250")) die(EX_PROTOCOL,
				"didn't ack RCPT " + r);
		}
		send_cmd("DATA");
		if (!expect_reply("354")) die(EX_PROTOCOL,"did not want our DATA!");

		send_text("From: " + sender);
		send_text("To: " + recipients);
		send_text("Subject: " + subject);
		send_text("");
		send_text(body + "\r");
	
		send_cmd(".");
		if (!expect_reply("250")) die(EX_PROTOCOL,"Mail not accepted");

		send_cmd("QUIT");
		if (!expect_reply("221")) die(EX_PROTOCOL,"Other end not closing down");
	}
}
//@@@@@@//
//email/SysExits.java
//@@@@@@//
/*
 * Copyright (c) 1987, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)sysexits.h	8.1 (Berkeley) 6/2/93
 */

/**
 *  SYSEXITS.H -- Exit status codes for system programs.
 *
 *  <P>Converted from a C header file to a Java Interface, for inclusion
 *  in SMTP software. The Interface defines a bunch of public static
 *  final int constants, but no methods, so it works much like a C-language
 *  #include with just #define'd numbers...
 *
 *	<P>This include file attempts to categorize possible error
 *	exit statuses for system programs, notably delivermail
 *	and the Berkeley network.
 *
 *	<P>Error numbers begin at EX__BASE to reduce the possibility of
 *	clashing with other exit statuses that random programs may
 *	already return.  The meaning of the codes is approximately
 *	as follows:
 *
 *	<P>EX_USAGE -- The command was used incorrectly, e.g., with
 *		the wrong number of arguments, a bad flag, a bad
 *		syntax in a parameter, or whatever.
 *	<P>EX_DATAERR -- The input data was incorrect in some way.
 *		This should only be used for user's data & not
 *		system files.
 *	<P>EX_NOINPUT -- An input file (not a system file) did not
 *		exist or was not readable.  This could also include
 *		errors like "No message" to a mailer (if it cared
 *		to catch it).
 *	<P>EX_NOUSER -- The user specified did not exist.  This might
 *		be used for mail addresses or remote logins.
 *	<P>EX_NOHOST -- The host specified did not exist.  This is used
 *		in mail addresses or network requests.
 *	<P>EX_UNAVAILABLE -- A service is unavailable.  This can occur
 *		if a support program or file does not exist.  This
 *		can also be used as a catchall message when something
 *		you wanted to do doesn't work, but you don't know
 *		why.
 *	<P>EX_SOFTWARE -- An internal software error has been detected.
 *		This should be limited to non-operating system related
 *		errors as much as possible.
 *	<P>EX_OSERR -- An operating system error has been detected.
 *		This is intended to be used for such things as "cannot
 *		fork", "cannot create pipe", or the like.  It includes
 *		things like getuid returning a user that does not
 *		exist in the passwd file.
 *	<P>EX_OSFILE -- Some system file (e.g., /etc/passwd, /etc/utmp,
 *		etc.) does not exist, cannot be opened, or has some
 *		sort of error (e.g., syntax error).
 *	<P>EX_CANTCREAT -- A (user specified) output file cannot be
 *		created.
 *	<P>EX_IOERR -- An error occurred while doing IO on some file.
 *	<P>EX_TEMPFAIL -- temporary failure, indicating something that
 *		is not really an error.  In sendmail, this means
 *		that a mailer (e.g.) could not create a connection,
 *		and the request should be reattempted later.
 *	<P>EX_PROTOCOL -- the remote system returned something that
 *		was "not possible" during a protocol exchange.
 *	<P>EX_NOPERM -- You did not have sufficient permission to
 *		perform the operation.  This is not intended for
 *		file system problems, which should use NOINPUT or
 *		CANTCREAT, but rather for higher level permissions.
 */

public interface SysExits {
	/** successful termination */
	public static final int EX_OK		=  0;

	/** base value for error messages */
	public static final int EX__BASE	=  64;

	/** command line usage error */
	public static final int EX_USAGE	=  64;
	/** data format error */
	public static final int EX_DATAERR	=  65;
	/** cannot open input */
	public static final int EX_NOINPUT	=  66;
	/** addressee unknown */
	public static final int EX_NOUSER	=  67;
	/** host name unknown */
	public static final int EX_NOHOST	=  68;
	/** service unavailable */
	public static final int EX_UNAVAILABLE	=  69;
	/** internal software error */
	public static final int EX_SOFTWARE	= 70;
	/** system error (e.g., can't fork) */
	public static final int EX_OSERR	= 71;
	/** critical OS file missing */
	public static final int EX_OSFILE	= 72;
	/** can't create (user) output file */
	public static final int EX_CANTCREAT	= 73;
	/** input/output error */
	public static final int EX_IOERR	= 74;
	/** temp failure; user is invited to retry */
	public static final int EX_TEMPFAIL	= 75;
	/** remote error in protocol */
	public static final int EX_PROTOCOL	= 76;
	/** permission denied */
	public static final int EX_NOPERM	= 77;
	/** configuration error */
	public static final int EX_CONFIG	= 78;

	/* maximum listed value */
	public static final int EX__MAX	= 78;;
}
//@@@@@@//
//email/TestOpenMailRelay.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.mail.*;
import javax.mail.internet.*; 

/** TestOpenMailRelay -- send self-returning SPAM to check for relay sites.
 * @author Ian F. Darwin
 * @version $Id: TestOpenMailRelay.java,v 1.13 2004/03/20 20:52:35 ian Exp $
 */
public class TestOpenMailRelay {

	/** Where to refer people that find the test messages on their system. */
	public final static String RSS_SITE = "http://mail-abuse.org/rss/";

	/** Where the test messages will be collected. */
	public final static String MY_TARGET = "spam-magnet@darwinsys.com";

	/** Driver to parse options and control Sender */
	public static void main(String[] args) throws IOException {
		if (args.length == 0) {
			new TestOpenMailRelayGUI().setVisible(true);
		} else {
			for (int i=0; i<args.length; i++) {
				process(args[i]);
			}
		}
	}

	/** Try the given mail server, writing output to System.out */
	public static void process(String suspect_relay) {
		process(suspect_relay, System.out);
	}

	/** Try the given mail server, writing output to the given PrintStream */
	public static void process(String suspect_relay, PrintStream pw) {
		pw.println("processs: trying: " + suspect_relay);
		try {
			// Redirect all output from mail API to the given stream.
			System.setOut(pw);
			System.setErr(pw);
			Sender2 sm = new Sender2(suspect_relay);
			sm.addRecipient("nobody@erewhon.moc");
			sm.setFrom(MY_TARGET);
			sm.setSubject("Testing for open mail relay, see " + RSS_SITE);
			sm.setBody("This mail is an attempt to confirm that site " +
				suspect_relay + "\n" +
				"is in fact an open mail relay site.\n" +
				"For more information on the problem of open mail relays,\n" +
				"please visit site " + RSS_SITE + "\n" +
				"Please join the fight against spam by closing all open mail relays!\n" +
				"If this open relay has been closed, please accept our thanks.\n");
			sm.sendFile();
		} catch (MessagingException e) {
			pw.println(e);
		} catch (Exception e) {
			pw.println(e);
		}
	}
}
//@@@@@@//
//email/TestOpenMailRelayGUI.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;

/** GUI for TestOpenMailRelay, lets you run it multiple times in one JVM
 * to avoid startup delay.
 *
 * Starts each in its own Thread for faster return to ready state.
 *
 * Uses PipedI/OStreams to capture system.out/err into a window.
 */
public class TestOpenMailRelayGUI extends JFrame {

	public static void main(String unused[]) throws IOException {
		new TestOpenMailRelayGUI().setVisible(true);
	}

	/** The one-line textfield for the user to type Host name/IP */
	protected JTextField hostTextField;
	/** The push button to start a test; a field so can disable/enable it. */
	protected JButton goButton;
	/** Multi-line text area for results. */
	protected JTextArea results;
	/** The piped stream for the main class to write into "results" */
	protected PrintStream ps;
	/** The piped stream to read from "ps" into "results" */
	protected BufferedReader iis;

	/** This inner class is the action handler both for pressing
	 * the "Try" button and also for pressing <ENTER> in the text
	 * field. It gets the IP name/address from the text field
	 * and passes it to process() in the main class. Run in the
	 * GUI Dispatch thread to avoid messing the GUI. -- tmurtagh.
	 */
	ActionListener runner = new ActionListener() {
		public void actionPerformed(ActionEvent evt) {
			goButton.setEnabled(false);
			SwingUtilities.invokeLater(
				new Thread() {
					public void run() {
						String host = hostTextField.getText().trim();
						ps.println("Trying " + host);
						TestOpenMailRelay.process(host, ps);
						goButton.setEnabled(true);
					}
				});
		}
	};

	/** Construct a GUI and some I/O plumbing to get the output
	 * of "TestOpenMailRelay" into the "results" textfield.
	 */
	public TestOpenMailRelayGUI() throws IOException {
		super("Tests for Open Mail Relays");
		PipedInputStream is;
		PipedOutputStream os;
		JPanel p;
		Container cp = getContentPane();
		cp.add(BorderLayout.NORTH, p = new JPanel());

		// The entry label and text field.
		p.add(new JLabel("Host:"));
		p.add(hostTextField = new JTextField(10));
		hostTextField.addActionListener(runner);

		p.add(goButton = new JButton("Try"));
		goButton.addActionListener(runner);

		JButton cb;
		p.add(cb = new JButton("Clear Log"));
		cb.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				results.setText("");
			}
		});
		JButton sb;
		p.add(sb = new JButton("Save Log"));
		sb.setEnabled(false);

		results = new JTextArea(20, 60);
		// Add the text area to the main part of the window (CENTER).
		// Wrap it in a JScrollPane to make it scroll automatically.
		cp.add(BorderLayout.CENTER, new JScrollPane(results));

		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		pack();			// end of GUI portion

		// Create a pair of Piped Streams.
		is = new PipedInputStream();
		os = new PipedOutputStream(is);

		iis = new BufferedReader(new InputStreamReader(is, "ISO8859_1"));
		ps = new PrintStream(os);

		// Construct and start a Thread to copy data from "is" to "os".
		new Thread() {
			public void run() {
				try {
					String line;
					while ((line = iis.readLine()) != null) {
						results.append(line);
						results.append("\n");
					}
				} catch(IOException ex) {
					JOptionPane.showMessageDialog(null,
						"*** Input or Output error ***\n" + ex,
						"Error",
						JOptionPane.ERROR_MESSAGE);
				}
			}
		}.start();
	}
}
//@@@@@@//
//environ/GetEnv.java
//@@@@@@//
public class GetEnv {
	public static void main(String[] argv) {
		System.out.println("System.getenv(\"PATH\") = " + System.getenv("PATH"));
	}
}
//@@@@@@//
//environ/GetOptDemo.java
//@@@@@@//
import com.darwinsys.lang.GetOpt;

/** Demonstrate the modern way of using GetOpt. This allows a subset of
 * <pre>UNIX sort options: sort -n -o outfile infile1 infile2</pre>
 * which means: sort numerically (-n), writing to file "outfile" (-o
 * outfile), sort from infile1 and infile2.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: GetOptDemo.java,v 1.9 2003/10/17 14:24:55 ian Exp $
 */
public class GetOptDemo {
	public static void main(String[] args) {
		GetOpt go = new GetOpt("hno:");
		boolean numeric_option = false;
		String outFileName = "(standard output)";
		char c;
		while ((c = go.getopt(args)) != GetOpt.DONE) {
			switch(c) {
			case 'h':
				doHelp(0);
				break;
			case 'n':
				numeric_option = true;
				break;
			case 'o':
				outFileName = go.optarg();
				break;
			default:
				System.err.println("Unknown option character " + c);
				doHelp(1);
			}
		}
		System.out.print("Options: ");
		System.out.print("Numeric: " + numeric_option + ' ');
		System.out.print("Output: " + outFileName + "; ");
		System.out.print("Inputs: ");
		if (go.getOptInd() == args.length) {
			doFile("(standard input)");
		} else for (int i = go.getOptInd(); i < args.length; i++) {
			doFile(args[i]);
		}
		System.out.println();
	}

	/** Stub for providing help on usage
	 * You can write a longer help than this, certainly.
	 */
	static void doHelp(int returnValue) {
		System.err.println("Usage: GetOptDemo [-h][-n][-o outfile] file ...");
		System.exit(returnValue);
	}

	/** Stub to demonstrate processing one file. */
	static void doFile(String fileName) {
		System.out.print(fileName + ' ');
	}
}
//@@@@@@//
//environ/GetOptDemoNew.java
//@@@@@@//
import com.darwinsys.lang.GetOpt;
import com.darwinsys.lang.GetOptDesc;
import java.util.*;

/** Demonstrate the modern way of using GetOpt. This allows a subset of
 * <pre>UNIX sort options: sort -n -o outfile infile1 infile2</pre>
 * which means: sort numerically (-n), writing to file "outfile" (-o
 * outfile), sort from infile1 and infile2.
 */
public class GetOptDemoNew {
	public static void main(String[] argv) {
		boolean numeric_option = false;
		boolean errs = false;
		String outputFileName = null;

		GetOptDesc options[] = {
			new GetOptDesc('n', "numeric", false),
			new GetOptDesc('o', "output-file", true),
		};
		GetOpt parser = new GetOpt(options);
		Map optionsFound = parser.parseArguments(argv);
		Iterator it = optionsFound.keySet().iterator();
		while (it.hasNext()) {
			String key = (String)it.next();
			char c = key.charAt(0);
			switch (c) {
				case 'n':
					numeric_option = true;
					break;
				case 'o':
					outputFileName = (String)optionsFound.get(key);
					break;
				case '?':
					errs = true;
					break;
				default:
					throw new IllegalStateException(
					"Unexpected option character: " + c);
			}
		}
		if (errs) {
			System.err.println("Usage: GetOptDemo [-n][-o file][file...]");
		}
		System.out.print("Options: ");
		System.out.print("Numeric: " + numeric_option + ' ');
		System.out.print("Output: " + outputFileName + "; ");
		System.out.print("Input files: ");
		Iterator files = parser.getFilenameList().iterator();
		while (files.hasNext()) {
			System.out.print(files.next());
			System.out.print(' ');
		}
		System.out.println();
	}
}
//@@@@@@//
//environ/GetOptSimple.java
//@@@@@@//
import com.darwinsys.lang.GetOpt;

/** Trivial demonstration of GetOpt, the old way. If -h present, print help.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: GetOptSimple.java,v 1.4 2004/02/09 03:33:48 ian Exp $
 */
public class GetOptSimple {
	public static void main(String[] args) {
		GetOpt go = new GetOpt("h");
		char c;
		while ((c = go.getopt(args)) != 0) {
			switch(c) {
			case 'h':
				helpAndExit(0);
				break;
			default:
				System.err.println("Unknown option in " +
					args[go.getOptInd()-1]);
				helpAndExit(1);
			}
		}
		System.out.println();
	}

	/** Stub for providing help on usage
	 * You can write a longer help than this, certainly.
	 */
	static void helpAndExit(int returnValue) {
		System.err.println("This would tell you how to use this program");
		System.exit(returnValue);
	}
}
//@@@@@@//
//environ/GetVersion.java
//@@@@@@//
public class GetVersion {
	public static void main(String[] args) {
		System.out.println(System.getProperty("java.specification.version"));
	}
}
//@@@@@@//
//environ/SysPropDemo.java
//@@@@@@//
import java.io.IOException;
import java.util.*;

/**
 * List one or more item(s) from System Properties
 */
public class SysPropDemo {
	public static void main(String[] argv) throws IOException {
		if (argv.length == 0)
			System.getProperties().store(System.out, "System Properties:");
		else for (int i=0; i<argv.length; i++) {
			String s = argv[i];
		 	System.out.println(s + " = " + 
				System.getProperties().getProperty(s));
		}
	}
}
//@@@@@@//
//environ/SysPropSet.java
//@@@@@@//
import java.util.*;
/**
 * Try adding one or more item(s) to class path.
 */
public class SysPropSet {

	static Properties p = System.getProperties();

	public static void main(String[] argv) {
		System.out.println("System Properties:");
		System.out.println("java.class.path now = " + getClassPath());
		p.setProperty("java.class.path",
			 getClassPath() + ';' + "C:/jdk1.2/lib/tools.jar");
		System.out.println("java.class.path now = " + getClassPath());
		try {
			Class.forName("sun.tools.javap.JavaP");
		} catch (Exception e) {
			System.err.println(e);
			return;
		}
		System.out.println("Got it!!");
	}
	
	static String getClassPath() {
		return p.getProperty("java.class.path", null);
	}
}
//@@@@@@//
//environ/TestJDK11.java
//@@@@@@//
/** Test for JDK >= 1.1 */
public class TestJDK11 {
	public static void main(String[] a) {
		// Check for JDK >= 1.1
		try {
			Class.forName("java.lang.reflect.Constructor");
		} catch (ClassNotFoundException e) {
			String failure = 
				"Sorry, but this version of MyApp needs \n" +
				"a Java Runtime based on Java JDK 1.1 or later";
			System.err.println(failure);
			throw new IllegalArgumentException(failure);
		}
		System.out.println("Happy to report that this is JDK1.1");
		// rest of program would go here...
		return;
	}
}
//@@@@@@//
//graphics/ColorName.java
//@@@@@@//
import java.awt.Color;

/** A simple class for looking up Java AWT Color Names; I got tired
 * of including this code in every Applet that needed it!
 * (yes, this IS a hint to JavaSoft.).
 * @author	Ian Darwin, delinted by Bill Heinze
 */
public class ColorName {
	/** The list of known color names and their corresponding colors */
	protected static ColorNameMap map[] = {
		new ColorNameMap("white", Color.white),
		new ColorNameMap("yellow", Color.yellow),
		new ColorNameMap("orange", Color.orange),
		new ColorNameMap("red", Color.red),
		new ColorNameMap("blue", Color.blue),
		new ColorNameMap("green", Color.green),
		new ColorNameMap("pink", Color.pink),
		new ColorNameMap("cyan", Color.cyan),
		new ColorNameMap("magenta", Color.magenta),
		new ColorNameMap("gray", Color.gray),
		new ColorNameMap("lightGray", Color.lightGray),
		new ColorNameMap("darkGray", Color.darkGray),
		new ColorNameMap("black", Color.black),
	};

	/** Lookup a given string
	 * @returns	The java.awt.Color corresponding, or null.
	 */
	public static Color lookup(String c) {
		if (c == null)
			return null;
		if (c.charAt(0) == '#')			// hex encoding
			return Color.decode(c);
		for (int i=0; i<map.length; i++)
			if (c.equalsIgnoreCase(map[i].color))
				return map[i].jColor;
		return null;
	}

	/** Just a test */
	public static void main(String[] a) {
		test("WhItE");
		test("Ucky Purple Pink Spots");
		test(null);
		test("#c0d0e0");
	}
	public static void test(String s) {
		System.out.println('"' + s + '"' + " returns " + ColorName.lookup(s));
	}
}

/** A class to map from color names to java.awt.Color */
class ColorNameMap {
	ColorNameMap(String c, Color jc) {
		color = c;
		jColor = jc;
	}
	String color;
	Color  jColor;
}
//@@@@@@//
//graphics/Digitizer.java
//@@@@@@//
import java.awt.Container;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;

import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JList;

/**
 * Digitizer - load an Image and let you click on it.
 */
public class Digitizer extends JComponent {
	Container cp;
	ImageView iv;

	/** Construct an Digitizer viewer, given a filename. */
	public Digitizer(String fname) {

		// GUI SETUP

		cp = this;
		cp.setLayout(new GridLayout(1, 0, 10, 10));

		iv = new ImageView("foo");
		cp.add(iv);

		JList list = new JList();
		cp.add(list);

		Grapher gr = new Grapher();
		cp.add(gr);

		// EVENT SETUP
		MouseClicker mickey = new MouseClicker();
		iv.addMouseListener(mickey);
		iv.addMouseMotionListener(mickey);
	}

	public void loadImage() {
		iv.loadImage();
	}

	public static void main(String[] arg) {
		System.out.println("Digitizer 0.0");
		if (arg.length != 1) {
			System.err.println("Usage: Digitizer file [...]");
		} else {
			for (int i=0; i<arg.length; i++) {
				JFrame jf = new JFrame("Digitizer");
				Digitizer d = new Digitizer(arg[i]);
				jf.getContentPane().add(d);
				d.loadImage();
				jf.pack();
				jf.setVisible(true);
			}
		}
	}

	/** This class is both a MouseListener and a MouseMotionListener */
	class MouseClicker extends MouseAdapter implements MouseMotionListener {

		/** Mouse pressed (i.e., clicked and released). */
		public void mousePressed(MouseEvent evt) {
			System.out.println("[" + evt.getX() + "," + evt.getY() + "]");
		}

		/** Mouse moved with action button down.
		 *  Required by MouseMotionListener
		 */
		public void mouseDragged(MouseEvent evt)   {
		}

		/** Mouse moved with action button up.
		 *  Required by MouseMotionListener
		 */
		public void mouseMoved(MouseEvent evt) {
		}
	}
}
//@@@@@@//
//graphics/DrawImageDemo.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

public class DrawImageDemo extends JComponent {

	Image myImage = null;

	public void paint(Graphics g) {
		g.drawImage(myImage, 0, 0, this);
	}
}
//@@@@@@//
//graphics/DrawStringDemo.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

public class DrawStringDemo extends JComponent {
	int textX = 10, textY = 20;

	public void paint(Graphics g) {
		g.drawString("Hello Java", textX, textY);
	}

	public Dimension getPreferredSize() {
		return new Dimension(100, 100);
	}
}

//@@@@@@//
//graphics/DrawStringDemo2.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

public class DrawStringDemo2 extends JComponent {
	//-
	String message = "Hello Java";

	/** Paint is called (by AWT) when it's time to draw the text. */
	public void paint(Graphics g) {
		// Get the current Font, and ask it for its FontMetrics.
		FontMetrics fm = getFontMetrics(getFont());

		// Use the FontMetrics to get the width of the String.
		// Subtract this from width, divide by 2, that's our starting point.
		int textX = (getSize().width - fm.stringWidth(message))/2;
		if (textX<0)		// If string too long, start at 0
			textX = 0;

		// Same as above but for the height
		int textY = (getSize().height - fm.getAscent())/2 - fm.getDescent();
		if (textY < 0)
			textY = getSize().height - fm.getDescent() - 1;

		// Now draw the text at the computed spot.
		g.drawString(message, textX, textY);
	}
	//-

	public Dimension getPreferredSize() {
		return new Dimension(100, 100);
	}
}

//@@@@@@//
//graphics/DropShadow.java
//@@@@@@//
import java.applet.*;
import java.awt.*;

/** 
 * DropShadow -- show overlapped painting.
 *
 * @author	Copyright 1995, 1997 Ian F. Darwin,
 * <A HREF="mailto:http://www.darwinsys.com/">http://www.darwinsys.com/</A>,
 * <A HREF="http:www.darwinsys.com/">http://www.darwinsys.com</A>.
 * @version	$Id: DropShadow.java,v 1.6 2004/02/09 03:33:48 ian Exp $
 */
public class DropShadow extends Applet {
	/** The label that is to appear in the window */
	protected String theLabel = null;
	/** The width and height */
	protected int width, height;
	/** The name of the font */
	protected String fontName;
	/** The font */
	protected Font theFont;
	/** The size of the font */
	protected int fontSize = 18;
	/** The offset for the drop shadow */
	protected int theOffset = 3;
	/** True if we got all required parameters */
	protected boolean inittedOK = false;

	/** Called from the browser to set up. We want to throw various
	 * kinds of exceptions but the API predefines that we don't, so we
	 * limit ourselves to the ubiquitous IllegalArgumentException.
	 */
	public void init() {
		// System.out.println("In DropShadow init()");

		theLabel = getParameter("label");
		if (theLabel == null)
				throw new IllegalArgumentException("LABEL is REQUIRED");
		// Now handle font stuff.
		fontName = getParameter("fontname");
		if (fontName == null)
				throw new IllegalArgumentException("FONTNAME is REQUIRED");
		String s;
		if ((s = getParameter("fontsize")) != null)
			fontSize = Integer.parseInt(s);
		if (fontName != null || fontSize != 0) {
			theFont = new Font(fontName, Font.BOLD + Font.ITALIC, fontSize);
			System.out.println("Name " + fontName + ", font " + theFont);
		}
		if ((s = getParameter("offset")) != null)
			theOffset = Integer.parseInt(s);
		setBackground(Color.green);
		inittedOK = true;
	}

	/** Paint method showing drop shadow effect */
	public void paint(Graphics g) {
		if (!inittedOK)
			return;
		g.setFont(theFont);
		g.setColor(Color.black);
		g.drawString(theLabel, theOffset+30, theOffset+50);
		g.setColor(Color.white);
		g.drawString(theLabel, 30, 50);
	}
	
	/** Give Parameter info to the AppletViewer, just for those
	 * writing HTML without hardcopy documentation :-)
	 */
	public String[][] getParameterInfo() {
		String info[][] = {
			{ "label",		"string",	"Text to display" },
			{ "fontname",	"name",		"Font to display it in" },
			{ "fontsize",	"10-30?",	"Size to display it at" },
		};
		return info;
	}
}
//@@@@@@//
//graphics/FontDemo.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

/** Finds and displays available fonts
 * <p>
 * TODO: should be a JTable with the text name in one column and the demo
 * in a JLabel in the other.
 * @author	Ian Darwin (original)
 */
public class FontDemo extends JComponent {
	/** The list of Fonts */
	protected String[] fontNames;
	/** The fonts themselves */
	protected Font[] fonts;
	/** How much space between each name */
	static final int YINCR = 20;

	/** Construct a FontDemo -- Sets title and gets 
	 * array of fonts on the system
	 */
	public FontDemo() {

		Toolkit toolkit = Toolkit.getDefaultToolkit();
		// For JDK 1.1: returns about 10 names (Serif, SansSerif, etc.)
		// fontNames = toolkit.getFontList();
		// For JDK 1.2: a much longer list; most of the names that come
		// with your OS (e.g., Arial, Lucida, Lucida Bright, Lucida Sans...)
		fontNames = GraphicsEnvironment.getLocalGraphicsEnvironment().
			getAvailableFontFamilyNames();
		fonts = new Font[fontNames.length];
	}

	public Dimension getPreferredSize() {
		return new Dimension(500, fontNames.length * YINCR);
	}

	/** Draws the font names in its font.
	 * Called by AWT when painting is needed
	 * Does lazy evaluation of Font creation, caching the results
	 * (without this, scrolling performance suffers even on a P3-750).
	 */
	public void paint(Graphics g) {
		for (int i=0; i<fontNames.length; i+=1) {
			if (fonts[i] == null) {
				fonts[i] = new Font(fontNames[i], Font.BOLD, 14);
			}
			g.setFont(fonts[i]);
			int x = 20;
			int y = 20 + (YINCR * i);
			g.drawString(fontNames[i], x, y);
		}
	}

	/** Simple main program to start it running */
	public static void main(String[] args) {
		JFrame f = new JFrame("Font Demo");
		f.getContentPane().add(new JScrollPane(new FontDemo()));
		f.setSize(600, 700);
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}
//@@@@@@//
//graphics/FontDemoLabel.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

/** FontDemo lists the system fonts and provides a sample of each one */
public class FontDemoLabel extends JFrame {
	String fl[];
	JPanel p;

	public FontDemoLabel() {
		super("Font Demo - Label");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Container cp = getContentPane();

		// get font name list
		fl = GraphicsEnvironment.getLocalGraphicsEnvironment().
			getAvailableFontFamilyNames();

		// IGNORE the setLayout and North/South stuff...
		// we will discuss it in a few pages!

		cp.setLayout(new BorderLayout()); 
		cp.add(BorderLayout.NORTH, new Label("Number of Fonts = " + fl.length,
			Label.CENTER));
		cp.add(BorderLayout.CENTER, p = new JPanel());
		p.setLayout(new GridLayout(5, 0, 5, 5));

		for (int i = 0; i<fl.length; i++) {
			JLabel lab;

			// The crux of the matter: for each font name,
			// create a label using the name as the text,
			// AND set the font to be the named font!
			p.add(lab = new JLabel(fl[i]));
			lab.setFont(new Font(fl[i], Font.ITALIC | Font.BOLD, 14));
		}
		pack();
	}

	public static void main(String[] av) {
		new FontDemoLabel().setVisible(true);
	}
}
//@@@@@@//
//graphics/FontLister.java
//@@@@@@//
import java.awt.*;

/** Print the list of available fonts. */
public class FontLister {

	public static void main(String[] av) {

		// A list of fonts, the 1.0 way.
		// Commented out to supporess deprecation warnings.
		// Toolkit t = Toolkit.getDefaultToolkit();
		// printList("the 1.0 way", t.getFontList());

		// The 1.2 way, using getAvailableFontFamilyNames().
		printList("the 1.2 way", 
				GraphicsEnvironment.getLocalGraphicsEnvironment().
				getAvailableFontFamilyNames());

		// Calling getFontList methods activates the AWT Event thread, so:
		System.exit(0);
	}

	protected static void printList(String title, String[] list) {

		System.out.println("Number of Fonts " + title + " = " + list.length);

		for (int i = 0; i<list.length; i++)
			System.out.println("Font " + i + " = " + list[i]);
	}
}
//@@@@@@//
//graphics/GetImage.java
//@@@@@@//
/*
 * For Applet, invoke as:
 * <applet code="GetImage" width="100" height="100">
 * </applet>
 * For Application, just run it (has own main).
 */

import java.awt.Graphics;
import java.awt.Image;
import java.net.URL;

import javax.swing.JApplet;
import javax.swing.JFrame;

/** This program, which can be an Applet or an Application,
 * shows a form of Toolkit.getImage() which works the same
 * in either Applet or Application!
 */
public class GetImage extends JApplet {

	Image image;

	public void init() {
		loadImage();
	}

	public void loadImage() {
		// Applet-only version:
		// Image = getImage(getCodeBase(), "Duke.gif");
		
		// Portable version: getClass().getResource() works in either
		// applet or application, 1.1 or 1.3, returns URL for file name.
		URL url = getClass().getResource("Duke.gif");
		image = getToolkit().getImage(url);
		// Shorter portable version: same but avoids temporary variables
		// image = getToolkit().getImage(getClass().getResource("Duke.gif"));
	}

	public void paint(Graphics g) {
		g.drawImage(image, 20, 20, this);
	}

	public static void main(String[] args) {
		JFrame f = new JFrame("GetImage");
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		GetImage myApplet = new GetImage();
		f.getContentPane().add(myApplet);
		myApplet.init();
		f.setSize(100, 100);
		f.setVisible(true);
		myApplet.start();
	}
}
//@@@@@@//
//graphics/GfxDemo.java
//@@@@@@//
import java.awt.*;

/**
 * Graphics Demo for Learning Tree Course 471/478
 */
public class GfxDemo extends Frame {
	int width, height;

	GfxDemo(String s) {
		setTitle(s);
		width=400;
		height=300;
		setSize(width, height);
	}
	GfxDemo(String s, int w, int h) {
		setTitle(s);
		setSize(width=w, height=h);	// a short form
	}

	public void paint(Graphics g) {
		g.setColor(Color.red);
		g.fillRect(0, 0, width/2, height/2);
		g.setColor(Color.blue);
		g.drawString("Hello World of Blue", (width/2)+10, (height/2)+10);
	}

	public static void main(String[] a) {
		GfxDemo xyz = new GfxDemo("Default Size");
		xyz.setVisible(true);

		new GfxDemo("Smaller", 100,100).setVisible(true);
	}
}

//@@@@@@//
//graphics/GfxDemo2.java
//@@@@@@//
import java.awt.*;

/**
 * Fancier, Canvas-based Graphics Demo for Learning Tree Course 471/478
 * We use a subclass of Canvas to do the drawing; GfxDemo2 merely
 * creates a Frame and adds the Canvas to it!
 * @author	Ian Darwin, http://www.darwinsys.com/
 */
public class GfxDemo2 extends Frame {
	/* Construct a GfxDemo2 given its title, width and height.
	 * Uses a GridBagLayout to make the GfxDemoCanvas resize properly.
	 */
	GfxDemo2(String title, int w, int h) {
		setTitle(title);

		// Start of Layout stuff (ignore until AWT GUI chapter!)
		GridBagLayout gbl = new GridBagLayout();
		setLayout(gbl);
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.fill = GridBagConstraints.BOTH;
		gbc.anchor = GridBagConstraints.CENTER;
		gbc.weightx = gbc.weighty = 1.0;

		// Now create a GfxDemoCanvas and add it to the Frame.
		GfxDemoCanvas xyz = new GfxDemoCanvas(w, h);
		gbl.setConstraints(xyz, gbc);
		add(xyz);

		// Normal end ... pack it up!
		pack();
	}
	GfxDemo2(String title) {
		this(title, 300, 300);
	}

	public static void main(String[] a) {
		new GfxDemo2("Default Size").setVisible(true);
		new GfxDemo2("Smaller", 100, 100).setVisible(true);
	}
}
//@@@@@@//
//graphics/GfxDemoCanvas.java
//@@@@@@//
import java.awt.*;

/**
 * Fancier, Canvas-based Graphics Demo for Learning Tree Course 471/478
 * This subclass of Canvas does the drawing;
 * GfxDemo2 merely creates a Frame and adds the Canvas to it,
 * while PrintDemoGFx creates one of these and calls its paint()
 * method with a Printer Graphics object.
 *
 * @author	Ian Darwin, http://www.darwinsys.com/
 */
public class GfxDemoCanvas extends Canvas {
	int width, height;

	GfxDemoCanvas(int w, int h) {
		setSize(width=w, height=h);
	}

	public Dimension getPreferredSize() {
		return new Dimension(width, height);
	}

	public void paint(Graphics g) {
		width = getSize().width;
		height = getSize().height;
		g.setColor(Color.black);
		g.drawRect(0, 0, width-1, height-1);
		g.setColor(Color.red);
		g.fillRect(0, 0, width/2, height/2);
		g.setColor(Color.blue);
		g.drawString("Welcome to My Blue Heaven", (width/2)+10, (height/2)+10);
	}
}
//@@@@@@//
//graphics/GradientFill.java
//@@@@@@//
import java.awt.*;

/** Fill a Polygon with a colored gradient */
public class GradientFill extends Component {
	/** The points we draw */
	Polygon p;
	/** The gradient we paint with */
	GradientPaint gp;

	public void paint(Graphics g) {
		Graphics2D g2 = (Graphics2D)g;
		g2.draw(p);
		gp = new GradientPaint(50.0f, 50.0f, Color.red,
			75.0f, 75.0f, Color.green, true);
		g2.setPaint(gp);
		g2.fill(p);
	}

	/** Construct the drawing object */
	public GradientFill() {
		p = new Polygon();
		// make a triangle.
		p.addPoint(0,100);
		p.addPoint(200,0);
		p.addPoint(200,200);
	}

	public Dimension getPreferredSize() {
		return new Dimension(210, 210);
	}
} 
//@@@@@@//
//graphics/Grapher.java
//@@@@@@//
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.geom.Point2D;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JFrame;
import javax.swing.JPanel;

import com.darwinsys.util.Debug;

/** Simple Graphing program.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Grapher.java,v 1.15 2004/05/28 02:01:30 ian Exp $
 */
public class Grapher extends JPanel {
	/** Multiplier for range to allow room for a border */
	public final static double BORDERFACTOR = 1.1f;

	/** The list of Point points. */
	protected List data;

	/** The minimum and maximum X values */
	protected double minx = Integer.MAX_VALUE, maxx = Integer.MIN_VALUE;
	/** The minimum and maximum Y values */
	protected double miny = Integer.MAX_VALUE, maxy = Integer.MIN_VALUE;
	/** The range of X and Y values */
	protected double xrange, yrange;

	public Grapher() {
		data = new ArrayList();
		figure();
	}

	/** Set the list data from a list of Strings, where the
	 * x coordinate is incremented automatically, and the y coordinate
	 * is made from the String in the list.
	 */
	public void setListDataFromYStrings(List newData) {
		data.clear();
		for (int i=0; i < newData.size(); i++) {
			Point2D p = new Point2D.Double();
			p.setLocation(i, java.lang.Double.parseDouble((String)newData.get(i)));
			data.add(p);
		}
		figure();
	}

	/** Set the list from an existing List, as from GraphReader.read() */
	public void setListData(List newData) {
		data = newData;
		figure();
	}

	/** Compute new data when list changes */
	private void figure() {
		// find min & max
        for (int i=0 ; i < data.size(); i++) {
			Point2D d = (Point2D)data.get(i);
			if (d.getX() < minx) minx = d.getX();
			if (d.getX() > maxx) maxx = d.getX();
			if (d.getY() < miny) miny = d.getY();
			if (d.getY() > maxy) maxy = d.getY();
        }

		// Compute ranges
		xrange = (maxx - minx) * BORDERFACTOR;
		yrange = (maxy - miny) * BORDERFACTOR;
		Debug.println("range", "minx,x,r = " + minx +' '+ maxx +' '+ xrange);
		Debug.println("range", "miny,y,r = " + miny +' '+ maxy +' '+ yrange);
	}

	/** Called when the window needs painting.
	 * Computes X and Y range, scales.
	 */
    public void paintComponent(Graphics g) {
		super.paintComponent(g);
		Dimension s = getSize();
		if (data.size() < 2) {
			g.drawString("Insufficient data: " + data.size(), 10, 40);
			return;
		}

		// Compute scale factors
		double xfact =  s.width  / xrange;
		double yfact =  s.height / yrange;

		// Scale and plot the data
        for (int i=0 ; i < data.size(); i++) {
			Point2D d = (Point2D)data.get(i);
			double x = (d.getX() - minx) * xfact;
			double y = (d.getY() - miny) * yfact;
			Debug.println("point", "AT " + i + " " + d + "; " +
				"x = " + x + "; y = " + y);
			// Draw a 5-pixel rectangle centered, so -2 both x and y.
			// AWT numbers Y from 0 down, so invert:
			g.drawRect(((int)x)-2, s.height-2-(int)y, 5, 5);
		}
    }

	public Dimension getPreferredSize() {
		return new Dimension(150, 150);
	}

	public static void main(String[] args) throws IOException {
		final JFrame f = new JFrame("Grapher");
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Grapher grapher = new Grapher();
		f.setContentPane(grapher);
		f.setLocation(100, 100);
		f.pack();
		List data = null;
		if (args.length == 0)
			data = GraphReader.read("Grapher.dat");
		else {
			String fileName = args[0];
			if ("-".equals(fileName)) {
				data = GraphReader.read(new InputStreamReader(System.in), "System.in");
			} else {
				data = GraphReader.read(fileName);
			}
		}
		grapher.setListData(data);
		f.setVisible(true);
	}
}
//@@@@@@//
//graphics/GraphReader.java
//@@@@@@//
import java.awt.geom.Point2D;
import java.io.FileReader;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

/** GraphReader is a helper class for Grapher, that reads various formats.
 * (At present, only a list of x,y points from a text file).
 */
public class GraphReader {

	/** Read data points from the named file. Each line has an x and a y coordinate.
	 * @throws IllegalArgumentException on bad or insufficient data
	 * @throws IOException if the file doesn't exist or is unreadable.
	 */
	public static List read(String fileName) throws IOException {
		return read(new FileReader(fileName), fileName);
	}
	
	/** Read data points from an opened Reader. Each line has an x and a y coordinate.
	 * @throws IllegalArgumentException on bad or insufficient data
	 * @throws IOException if the file doesn't exist or is unreadable.
	 */
	public static List read(Reader reader, String fileName) throws IOException {
		LineNumberReader is = new LineNumberReader(reader);

		List data = new ArrayList();

		String txt;
	
		// Read the file a line at a time, parse it, save the data.
		while ((txt = is.readLine()) != null) {
			StringTokenizer st = new StringTokenizer(txt);
			try {
				Point2D p = new Point2D.Double();
				p.setLocation(Float.parseFloat(st.nextToken()),
					Float.parseFloat(st.nextToken()));
				data.add(p);
			} catch(NumberFormatException nfe) {
				throw new IllegalArgumentException("Invalid number " + nfe + 
						" on line " + is.getLineNumber());
			}
		}

		if (data.size() < 2) {
			throw new IllegalArgumentException(
				"GraphReader.read: " + fileName + ": Not enough data points!");
		}
		return data;
	}
}
//@@@@@@//
//graphics/GridImageCanvas.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;

/**
 * GridImageCanvas - a rectangular grid of images
 */
public class GridImageCanvas extends JPanel {
	/** The LayoutManager. We provide it, not the user */
	protected LayoutManager lm = null;
	/** The list of Images */
	protected Vector vi = new Vector();
	/** The name of each Image */
	protected Vector vs = new Vector();
	/** The Panel, to manage the grid */
	Panel grid;
	/** The label, for showStatus */
	Label status;

	/** Construct a GridImageCanvas */
	GridImageCanvas() {
		setBackground(Color.red);
		grid = new Panel();
		status = new Label("Status here");
		setLayout(new BorderLayout());
		add(BorderLayout.CENTER, grid);
		add(BorderLayout.SOUTH, status);
	}

	/** Main program to allow interactive use */
	public static void main(String[] argv) {
		System.out.println("GridImageCanvas demo starting...");
		if (argv.length == 0)
			throw new IllegalArgumentException("Usage: GridImageCanvas image...");
		final Frame f = new Frame("GridImageCanvas");
		f.setLayout(new FlowLayout());
        f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				f.setVisible(false);
				f.dispose();
				System.exit(0);
			}
		});
		GridImageCanvas gic;
		f.add(gic = new GridImageCanvas());
		for (int i=0; i<argv.length; i++) {
			Image im = Toolkit.getDefaultToolkit().getImage(argv[i]);
			gic.addImage(im, argv[i]);
		}
		gic.doLayout();
		f.pack();
		f.show();
	}
	public void addImage(Image i, String s) {
		vi.addElement(i);
		vs.addElement(s);
	}
	/** We do all the Layout setup here, then call Panel.doLayout() */
	public void doLayout() {
		// doLayout called more than once?
		if (lm != null) {
			super.doLayout();
			return;
		}
		int l = vi.size();
		if (l == 0) {
			throw new IllegalArgumentException("doLayout before addImage");
		}
		if (l < 4) {
			throw new IllegalArgumentException("doLayout with <4 images");
		}
		double d = Math.sqrt((double)l);
		int w;
		if (d%1 != 0.0){
			w = ((int)d)+1;
		} else
			w = (int)d;
System.out.println("N="+l+";sqrt="+d+";gridLayout("+w+","+w+");");
		grid.setLayout(lm = new GridLayout(w, w));
		for (int i=0; i<l; i++) {
			ImageCanvas ic = new ImageCanvas((Image)vi.elementAt(i),
					(String)vs.elementAt(i));
			grid.add(ic);
		}
		super.doLayout();
	}

	/** dummy add(), to ensure add is NOT called directly.
	 @exception	java.lang.IllegalArgumentException	This class does its own adding; use addImage() instead.
	 */
	public Component add(Component c) {
			throw new IllegalArgumentException("add not allowed here");
	}

	public void showStatus(String s) {
		status.setText(s);
	}

	/** Inner class ImageCanvas - helper class, 
	 * used only by GraphicImageCanvas, to store
	 * an image and a String, paint the Image
	 * When the mouse is in our window, we showStatus() the String.
	 */
	class ImageCanvas extends JComponent {
		final int PAD = 3;
		String name;
		Image im = null;
		int w, h;
		ImageCanvas(Image i, String s) {
			name = s;
			im = i;
			MediaTracker mt = new MediaTracker(this);
			mt.addImage(im, 0);
			try {
				mt.waitForID(0);
			} catch(InterruptedException e) {
				throw new IllegalArgumentException(
					"Unexpected InterruptedException");
			}
			if (mt.isErrorID(0)) {
				throw new IllegalArgumentException(
					"Couldn't load image " + s);
			}
			addMouseListener(new MouseAdapter() {
				public void mouseEntered(MouseEvent e) {
					showStatus(name);
				}
				public void mouseExited(MouseEvent e) {
					showStatus("");
				}
			});
			setSize(w = im.getWidth(this), h = im.getHeight(this));
			repaint();
		}
		
		public Dimension getMinimumSize() {
			// System.out.println("getMinimumSize() returns ("+w+","+h+");");
			return new Dimension(w, h);
		}
		public Dimension getPreferredSize() {
			// System.out.println("getPreferredSize() returns ("+w+","+h+");");
			return new Dimension(w+PAD, h+PAD);
		}
		public Dimension getMaximumSize() {
			// System.out.println("getMaximumSize() returns ("+w+","+h+");");
			return new Dimension(w, h);
		}
		public void paint(Graphics g) {
			if (im == null) {
				g.setColor(Color.red);
				g.fillRect(0, 0, w, h);
			} else
				g.drawImage(im, 0, 0, this);
		}
	}
}
//@@@@@@//
//graphics/Grids.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;

/**
 * Program to draw grids.
 * @author	Ian Darwin, http://www.darwinsys.com/
 */
class GridsCanvas extends Canvas {
	int width, height;
	int rows;
	int cols;

	GridsCanvas(int w, int h, int r, int c) {
		setSize(width=w, height=h);
		rows = r;
		cols = c;
	}

	public void paint(Graphics g) {
		int i;
		width = getSize().width;
		height = getSize().height;
	
		// draw the rows
		int rowHt = height/(rows);
		for (i = 0; i < rows; i++)
			g.drawLine(0, i*rowHt, width, i*rowHt);

		// draw the columns
		int rowWid = width/(cols);
		for (i = 0; i < cols; i++)
			g.drawLine(i*rowWid, 0, i*rowWid, height);
	}
}

/** This is the demo class. */
public class Grids extends Frame {
	/* Construct a GfxDemo2 given its title, width and height.
	 * Uses a GridBagLayout to make the Canvas resize properly.
	 */
	Grids(String title, int w, int h, int rows, int cols) {
		setTitle(title);

		// Now create a Canvas and add it to the Frame.
		GridsCanvas xyz = new GridsCanvas(w, h, rows, cols);
		add(xyz);

        addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});

		// Normal end ... pack it up!
		pack();
	}

	public static void main(String[] a) {
		new Grids("Test", 300, 300, 5, 10).setVisible(true);
	}
}
//@@@@@@//
//graphics/ImageView.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import java.net.*;

/**
 * Standalone Image Viewer - works with any AWT-supported format.
 */
public class ImageView extends JComponent {
	/** The Image object */
	protected Image im;
	/** Size of the image */
	protected int width, height;
	/** The graphical component */
	protected Container cp;
	/** The name of the image file */
	protected String fileName;

	/** Construct an ImageView viewer, given a filename. */
	public ImageView(String fileName) {
		this.fileName = fileName;
		cp = this;

	}

	public void loadImage() {

		URL url = getClass().getResource(fileName);
		im = Toolkit.getDefaultToolkit().getImage(url);

		// ----- This part omitted from course notes for brevity -----
		// Use a MediaTracker to show the "best"? way of waiting
		// for an image to load, and how to check for errors.
		MediaTracker mt = new MediaTracker(this);
		mt.addImage(im, 0);
		try {
			mt.waitForID(0);
		} catch(InterruptedException e) {
			System.err.println("Unexpected interrupt in waitForID!");
			return;
		}
		if (mt.isErrorID(0)) {
			System.err.println("Couldn't load image file " + fileName);
			return;
		}

		// Now that we know the image has been loaded,
		// it is safe to take its width and height.
		// ----- End of part omitted from course notes for brevity -----
		width = im.getWidth(this);
		height = im.getHeight(this);
		setSize(width, height);
	}

	public void paint(Graphics g) {
		g.drawImage(im, 0, 0, this);
	}

	public static void main(String[] arg) {
		if (arg.length == 0) {
			System.err.println("Usage: ImageView file [...]");
		} else {
			for (int i=0; i<arg.length; i++) {
				JFrame jf = new JFrame("ImageView: " + arg[i]);
				ImageView iv = new ImageView(arg[i]);
				jf.getContentPane().add(iv);
				iv.loadImage();
				jf.setSize(iv.getSize());
				jf.setVisible(true);
			}
		}
	}
}
//@@@@@@//
//graphics/JMFPlayer.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import javax.swing.*;
import java.net.*;
import java.io.*;
import java.util.*;
import javax.media.*;

/**
 * Demonstrate simple code to play a movie with Java Media Framework.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: JMFPlayer.java,v 1.9 2004/02/09 03:21:20 ian Exp $
 */
public class JMFPlayer extends JPanel implements ControllerListener {

    /** The player object */
    Player thePlayer = null;
    /** The parent Frame we are in. */
	JFrame parentFrame = null;
	/** Our contentpane */
	Container cp;
    /** The visual component (if any) */
    Component visualComponent = null;
    /** The default control component (if any) */
    Component controlComponent = null;
	/** The name of this instance's media file. */
	String mediaName;
	/** The URL representing this media file. */
	URL theURL;

	/** Construct the player object and the GUI. */
	public JMFPlayer(JFrame pf, String media) {
		parentFrame = pf;
		mediaName = media;
		// cp = getContentPane();
		cp = this;
		cp.setLayout(new BorderLayout());
		try {
			theURL = new URL(getClass().getResource("."), mediaName);
			thePlayer = Manager.createPlayer(theURL);
			thePlayer.addControllerListener(this);
		} catch (MalformedURLException e) {
			System.err.println("JMF URL creation error: " + e);
		} catch (Exception e) {
			System.err.println("JMF Player creation error: " + e);
			return;
		}
		System.out.println("theURL = " + theURL);

		// Start the player: this will notify our ControllerListener.
		thePlayer.start();		// start playing
	}

	/** Called to stop the audio, as from a Stop button or menuitem */
	public void stop() {
		if (thePlayer == null)
			return;
		thePlayer.stop();		// stop playing!
		thePlayer.deallocate();	// free system resources
	}

	/** Called when we are really finished (as from an Exit button). */
	public void destroy() {
		if (thePlayer == null)
			return;
		thePlayer.close();
	}

	/** Called by JMF when the Player has something to tell us about. */
	public synchronized void controllerUpdate(ControllerEvent event) {
		// System.out.println("controllerUpdate(" + event + ")");
		if (event instanceof RealizeCompleteEvent) {
			if ((visualComponent = thePlayer.getVisualComponent()) != null)
					cp.add(BorderLayout.CENTER, visualComponent);
			if ((controlComponent = 
				thePlayer.getControlPanelComponent()) != null)
					cp.add(BorderLayout.SOUTH, controlComponent);
			// re-size the main window
			if (parentFrame != null) {
				parentFrame.pack();
				parentFrame.setTitle(mediaName);
			}
		}
	}

	public static void main(String[] argv) {
		JFrame f = new JFrame("JMF Player Demo");
		Container frameCP = f.getContentPane();
		JMFPlayer p = new JMFPlayer(f, argv.length == 0 ?
			"file:///C:/music/midi/beet5th.mid" : argv[0]);
		frameCP.add(BorderLayout.CENTER, p);
		f.setSize(200, 200);
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}
//@@@@@@//
//graphics/Layers.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

/**
 * Layers - Try to use "alpha values (transparency) to draw in layers.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version	$Id: Layers.java,v 1.5 2004/02/09 03:33:49 ian Exp $
 */
public class Layers extends JFrame {
	int width, height;

	Layers(String s) {
		this(s, 400, 300);
	}
	Layers(String s, int w, int h) {
		setTitle(s);
		setSize(width=w, height=h);	// a short form
		setBackground(Color.black);
		setDefaultCloseOperation(EXIT_ON_CLOSE);
	}

	public void paint(Graphics g) {
		Color c1 = new Color(200,100,100, 50);	// r, g, b, a
		Color c2 = new Color(100,200,000,128);
		Color c3 = new Color(100,200,000,255);
		g.setColor(c1);
		g.fillRect(0, 0, width/2, height/2);
		g.setColor(c2);
		g.fillRect(width/4, height/4, width/2, height/2);
		g.setColor(c3);
		g.fillRect(width/3, height/3, width/4, height/4);
	}

	public static void main(String[] a) {
		new Layers("Default Size").setVisible(true);
		new Layers("Smaller", 100,100).setVisible(true);
	}
}

//@@@@@@//
//graphics/MemImage.java
//@@@@@@//
import java.awt.*;
import java.awt.image.*;

/** MemImage is an in-memory icon showing a Color gradient. */
public class MemImage extends Component {

	/** Demo main program, showing two ways to use it.
	 * Create a small MemImage and set it as this Frame's iconImage. 
	 * Also display a larger version of the same image in the Frame.
	 */
	public static void main(String[] av) {
		Frame f = new Frame("MemImage.java");
		f.add(new MemImage());
		f.setIconImage(new MemImage(16,16).getImage());
		f.pack();
		f.setVisible(true);
	}

	/** The image */
	private Image img;
	/** The image width */
	private int w;
	/** The image height */
	private int h;

	/** Construct a MemImage with a default size */
	public MemImage() {
		this(100,100);
	}

	/** Construct a MemImage with a specified width and height */
	public MemImage(int w, int h) {
		this.w = w;
        this.h = h;
        int pix[] = new int[w * h];
        int index = 0;
        for (int y = 0; y < h; y++) {
            int red = (y * 255) / (h - 1);
            for (int x = 0; x < w; x++) {
                int blue = (x * 255) / (w - 1);
                pix[index++] = (255 << 24) | (red << 16) | blue;
            }
        }
        img = createImage(new MemoryImageSource(w, h, pix, 0, w));
		setSize(getPreferredSize());
	}

	/** Getter for the Image */
	public Image getImage() {
		return img;
	}

	public Dimension getPreferredSize() {
		return new Dimension(w, h);
	}
	public void paint(Graphics g) {
		g.drawImage(img, 0, 0, getSize().width, getSize().height, this);
	}
}
//@@@@@@//
//graphics/MouseDrag.java
//@@@@@@//
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

/** MouseDrag -- implement simple mouse drag in a window.
 */
public class MouseDrag extends Component 
		implements MouseListener, MouseMotionListener {
	/** The Image we are to paint */
	Image curImage;
	/** Kludge for showStatus */
	static Label status;
	/** true if we are in drag */
	boolean inDrag = false;
	/** starting location of a drag */
	int startX = -1, startY = -1;
	/** current location of a drag */
	int curX = -1, curY = -1;

	// "main" method
	public static void main(String[] av) {
		JFrame f = new JFrame("Mouse Dragger");
		Container cp = f.getContentPane();

		if (av.length < 1) {
			System.err.println("Usage: MouseDrag imagefile");
			System.exit(1);
		}
		Image im = Toolkit.getDefaultToolkit().getImage(av[0]);

		// create a MouseDrag object
		MouseDrag j = new MouseDrag(im);

		cp.setLayout(new BorderLayout());
		cp.add(BorderLayout.NORTH,
			new Label("Hello, and welcome to the world of Java"));
		cp.add(BorderLayout.CENTER, j);
		cp.add(BorderLayout.SOUTH, status = new Label());
		status.setSize(f.getSize().width, status.getSize().height);
		f.pack();
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}

	// "Constructor" - creates the object
	public MouseDrag(Image i) {
		super();
		curImage = i;
		setSize(300,200);
		addMouseListener(this);
		addMouseMotionListener(this);
	}

	public void showStatus(String s) {
		status.setText(s);
	}

	// Five methods from MouseListener:
	/** Called when the mouse has been clicked on a component. */
	public void mouseClicked(MouseEvent e)  {
	}

	/** Called when the mouse enters a component. */
	public void mouseEntered(MouseEvent e)  {
	}

	/** Called when the mouse exits a component. */
	public void mouseExited(MouseEvent e)  {
	}

	/** Called when the mouse has been pressed. */
	public void mousePressed(MouseEvent e)  {
		Point p = e.getPoint();
		System.err.println("mousePressed at " + p);
		startX = p.x; startY = p.y;
		inDrag = true;
	}

	/** Called when the mouse has been released. */
	public void mouseReleased(MouseEvent e)  {
		inDrag = false;
		System.err.println("SELECTION IS " + startX + "," +
			startY + " to " + curX + "," + curY);
	}

	// And two methods from MouseMotionListener:
	public void mouseDragged(MouseEvent e) {
		Point p = e.getPoint();
		// System.err.println("mouse drag to " + p);
		showStatus("mouse Dragged to " + p);
		curX = p.x; curY = p.y;
		if (inDrag) {
			repaint();
		}
	}

	public void paint(Graphics g) {
		int w = curX - startX, h = curY - startY;
		Dimension d = getSize();
		g.drawImage(curImage, 0, 0, d.width, d.height, this);
		if (startX < 0 || startY < 0)
			return;
		System.err.println("paint:drawRect @[" + startX +"," + startY +
			"] size " + w + "x" + h);
		g.setColor(Color.red);
		g.fillRect(startX, startY, w, h);
	}

	public void mouseMoved(MouseEvent e) {
		showStatus("mouse Moved to " + e.getPoint());
	}
	
}
//@@@@@@//
//graphics/MouseDragClip.java
//@@@@@@//
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

/** MouseDragClip -- implement simple mouse drag in a window.
 * Speed up by using clipping regions.
 * <p>
 * This version "works" for very simple cases (only drag down
 * and to the right, never move up or back :-) ).
 *
 * @author	Ian Darwin, http://www.darwinsys.com/
 */
public class MouseDragClip extends Canvas 
		implements MouseListener, MouseMotionListener {
	/** The Image we are to paint */
	Image curImage;
	/** Kludge for showStatus */
	static Label status;
	/** true if we are in drag */
	boolean inDrag = false;
	/** starting location of a drag */
	int startX = -1, startY = -1;
	/** current location of a drag */
	int curX = -1, curY = -1;
	/** Previous ending of current drag */
	int oldX, oldY;
	/** Start of previous selection, if completed, else -1 */
	int oldStartX = -1, oldStartY = -1;
	/** Size of previous selection, if completed, else -1 */
	int oldWidth = -1, oldHeight = -1;

	// "main" method
	public static void main(String[] av) {
		JFrame f = new JFrame("Mouse Dragger");
		Container cp = f.getContentPane();

		if (av.length < 1) {
			System.err.println("Usage: MouseDragClip imagefile");
			System.exit(1);
		}
		Image im = Toolkit.getDefaultToolkit().getImage(av[0]);

		// create a MouseDragClip object
		MouseDragClip j = new MouseDragClip(im);

		cp.setLayout(new BorderLayout());
		cp.add(BorderLayout.NORTH,
			new Label("Hello, and welcome to the world of Java"));
		cp.add(BorderLayout.CENTER, j);
		cp.add(BorderLayout.SOUTH, status = new Label());
		status.setSize(f.getSize().width, status.getSize().height);
		f.pack();
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}

	/** Construct the MouseDragClip object, given an Image */
	public MouseDragClip(Image i) {
		super();
		curImage = i;
		setSize(300,200);
		addMouseListener(this);
		addMouseMotionListener(this);
	}

	public void showStatus(String s) {
		status.setText(s);
	}

	// Five methods from MouseListener:
	/** Called when the mouse has been clicked on a component. */
	public void mouseClicked(MouseEvent e)  {
	}
	/** Called when the mouse enters a component. */
	public void mouseEntered(MouseEvent e)  {
	}
	/** Called when the mouse exits a component. */
	public void mouseExited(MouseEvent e)  {
	}
	/** Called when the mouse has been pressed. */
	public void mousePressed(MouseEvent e)  {
		Point p = e.getPoint();
		System.err.println("mousePressed at " + p);
		startX = p.x; startY = p.y;
		inDrag = true;
	}

	/** Called when the mouse has been released. */
	public void mouseReleased(MouseEvent e)  {
		inDrag = false;
		System.err.println("SELECTION IS " + startX + "," +
			startY + " to " + curX + "," + curY);
		oldX = -1;
		oldStartX = startX;
		oldStartY = startY;
		oldWidth = curX - startX;
		oldHeight = curY - startY;
	}

	// And two methods from MouseMotionListener:
	public void mouseDragged(MouseEvent e) {
		Point p = e.getPoint();
		// showStatus("mouse dragged to " + p);
		curX = p.x; curY = p.y;
		if (inDrag) {
			repaint();
		}
	}

	/** This update() overrides Component's, to call paint()
	 * <I>without</I> clearing the screen (which has our
	 * main image on it, after all!
	 */
	public void update(Graphics g) {
		paint(g);
	}

	public void paint(Graphics g) {
		int w = curX - startX, h = curY - startY;
		Dimension d = getSize();
		if (!inDrag) {	// probably first time through(?)
			g.drawImage(curImage, 0, 0, d.width, d.height, this);
			return;
		}
		System.err.println("paint:drawRect @[" + startX +"," + startY +
			"] size " + w + "x" + h);
		// Restore the old background, if previous selection
		if (oldStartX != -1) {
			g.setClip(oldStartX, oldStartY, oldWidth+1, oldHeight+1);
			g.drawImage(curImage, 0, 0, d.width, d.height, this);
			oldStartX = -1;
		}
		// Restore the background from previous motions of current drag
		if (oldX != -1) {
			g.setClip(startX, startY, w, h);
			g.drawImage(curImage, 0, 0, d.width+1, d.height+1, this);
		}
		// Draw the new rectangle
		g.setClip(0, 0, d.width, d.height);
		g.setColor(Color.red);
		g.drawRect(startX, startY, w, h);
		oldX = curX; oldY = curY;
	}

	/** Invoked when the mouse moves; just update the status line 
	 * with the new coordinates.
	 */
	public void mouseMoved(MouseEvent e) {
		showStatus("[" + e.getPoint().x + "," +
				 e.getPoint().y + "]");
	}
}
//@@@@@@//
//graphics/PaintComponent.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

public class PaintComponent extends JPanel {
	int rectX = 20, rectY = 30;
	int rectWidth = 50, rectHeight = 50;

	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		g.setColor(Color.red);
		g.fillRect(rectX, rectY, rectWidth, rectHeight);
	}

	public Dimension getPreferredSize() {
		return new Dimension(100, 100);
	}
}

//@@@@@@//
//graphics/PaintDemo.java
//@@@@@@//
import java.awt.*;

public class PaintDemo extends Component {
	int rectX = 20, rectY = 30;
	int rectWidth = 50, rectHeight = 50;

	public void paint(Graphics g) {
		g.setColor(Color.red);
		g.fillRect(rectX, rectY, rectWidth, rectHeight);
	}

	public Dimension getPreferredSize() {
		return new Dimension(100, 100);
	}
}

//@@@@@@//
//graphics/PaintMethods.java
//@@@@@@//
import java.awt.Graphics;

import javax.swing.JFrame;
import javax.swing.JLabel;

/** Standalone GUI program that shows paint, repaint, and update */
public class PaintMethods extends JLabel {

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		final JFrame f = new JFrame("PaintMethods demo");
		f.getContentPane().add("Center", new PaintMethods("Testing 1 2 3"));
		f.pack();
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}

	public PaintMethods(String s) {
		super(s);
	}

	public void paint(Graphics g) {
		System.out.println("Paint");
		super.paint(g);
	}
	public void repaint() {
		System.out.println("repaint");
		super.repaint();
	}
	public void update(Graphics g) {
		System.out.println("update");
		super.update(g);
	}
}
//@@@@@@//
//graphics/PixCanvas.java
//@@@@@@//
import java.awt.*;

/**
 * PixCanvas - a helper class for PhotoUI, or any other
 * program that needs to store and display Images.
 * Originally written as part of the "Photo manipulation GUI" for JabaDex
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $DarwinSys 1.1$
 */
public class PixCanvas extends Canvas {
	Image im;
	int wid, ht;

	/** Construct a PixCanvas, given a width and height */
	PixCanvas(int w, int h) {
		setSize(wid=w, ht=h);
	}

	/** Construct a PixCanvas, given an Image name */
	PixCanvas(String fn) {
		setImage(fn);
		setSize(im.getWidth(this), im.getHeight(this));
	}

	/** Set the image to a given filename */
	public void setImage(String fn) {
		if (fn == null)
			return;
		// Only the Application version of getImage shown here
		Image i = Toolkit.getDefaultToolkit().getImage(fn);
		setImage(i);
	}

	/** Set the image to a given Image object */
	public void setImage(Image i) {
		if (i == null)
			return;
		im = i;

		// ----- This part omitted from course notes for brevity -----
		// Use a MediaTracker to show the "best"? way of waiting
		// for an image to load, and how to check for errors.
		MediaTracker mt = new MediaTracker(this);
		mt.addImage(im, 0);
		try {
			mt.waitForID(0);
		} catch(InterruptedException e) {
			throw new IllegalArgumentException(
				"Unexpected InterruptedException");
		}
		if (mt.isErrorID(0)) {
			throw new IllegalArgumentException(
				"Couldn't load image");
		}
		// Now that we know the image has been loaded,
		// it is safe to paint it onto the screen.
		// ----- End of part omitted from course notes for brevity -----
		repaint();
	}

	/** Return how big we'd like to be. If image loaded, use its size.
	 * If not, use 200, 100 (why not?).
	 */
	public Dimension getPreferredSize() {
		if (im == null || im.getWidth(this) < 0 || im.getHeight(this) < 0)
			return new Dimension(200, 100);
		return new Dimension(im.getWidth(this), im.getHeight(this));
	}

	/** Actually draw the Image onto the screen */
	public void paint(Graphics g) {
		if (im == null) {
			g.setColor(Color.red);
			g.fillRect(0, 0, wid, ht);
		} else
			g.drawImage(im, 0, 0, this);
	}
}
//@@@@@@//
//graphics/PolygonFill.java
//@@@@@@//
import java.awt.*;

/** Fill a Polygon */
public class PolygonFill extends Component {
	/** The points we draw */
	Polygon p;

	public void paint(Graphics g) {
		g.setColor(Color.black);
		g.drawPolygon(p);
		g.setColor(Color.gray);
		g.fillPolygon(p);
	}

	/** Construct the drawing object */
	public PolygonFill() {
		p = new Polygon();
		// make a triangle.
		p.addPoint(0,100);
		p.addPoint(200,0);
		p.addPoint(200,200);
	}
	public Dimension getPreferredSize() {
		return new Dimension(210, 210);
	}
} 
//@@@@@@//
//graphics/PrintDemo0.java
//@@@@@@//
import java.awt.*;
import java.util.*;

/**
 * PrintDemo0 -- Print Demo Program - JDK1.1 Version
 *      Prints three pages (or so).
 */
public class PrintDemo0 extends Frame {
	protected static final int NPAGES = 3;

	/** main program: instantiate and run. */
	public static void main(String[] av) {
		PrintDemo0 pd = new PrintDemo0();
		pd.setVisible(true);
		pd.print(NPAGES);
	}

	public void print(int nPages) {
		PrintJob pjob = null;	// refers to whole print job
		Graphics pg = null;	// refers to current page

		System.out.println("Getting PrintJob");
		pjob = getToolkit().getPrintJob(this,
			"Printing Test", (Properties)null);
		if (pjob == null)          // User cancelled??
			return;

		// Just get and show dimensions; should use in x,y calcs.
		Dimension pDim = pjob.getPageDimension();
		int pRes = pjob.getPageResolution();
		System.out.println("Page size " + pDim + "; Res " + pRes);

		// Print up to "np" number of pages
		for (int pgNum=1; pgNum<=nPages; pgNum++) {
			System.out.println("Starting page # " + pgNum);
			pg = pjob.getGraphics();
			if (pg == null) 	// ??
				return;
			pg.setColor(Color.black);
			pg.setFont(new Font("Times", Font.PLAIN, 12));
			pg.drawString("Hello World", 100, 100);
			pg.drawString("Page" + pgNum, 300, 300);
			pg.dispose(); // flush page
			System.out.println("All done with page " + pgNum);
		}
		pjob.end();	// total end of print job.
		pjob = null;	// avoid redundant calls to pjob.end()
		return;
	}
}
//@@@@@@//
//graphics/PrintDemo1.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.util.*;

/**
 * PrintDemo1 -- Print Demo Program - JDK1.1 Version
 *      Prints three pages (or so).
 */
public class PrintDemo1 extends Frame implements ActionListener {
	/** The number of pages to print */
	protected static final int NPAGES = 3;
	/** The actual number of pages */
	protected int nPages;
	/** The PrintJob object */
	PrintJob pjob = null;	// refers to whole print job

	/** main program: instantiate and show. */
	public static void main(String[] av) {
		PrintDemo1 p;
		if (av.length>0)
			p = new PrintDemo1(Integer.parseInt(av[0]));
		else
			p = new PrintDemo1();
		p.setVisible(true);
	}

	/** Construct a PrintDemo1 with given number of pages */
	PrintDemo1(int i) {
		nPages = i;
		setLayout(new FlowLayout());
		Button b;
		add(b = new Button("Print"));
		b.addActionListener(this);
		add(b = new Button("Quit"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (pjob != null)	// if quit while printing!
					pjob.end();
				System.exit(0);
			}
		});
		pack();
	}
	/** Construct a PrintDemo1 with default values */
	PrintDemo1() {
		this(NPAGES);
	}

	/** Action handler does the work of the printing test. */
	public void actionPerformed(ActionEvent evt) {
		Graphics pg = null;	// refers to current page
		System.out.println("Doing print");
		pjob = getToolkit().getPrintJob(this,
			"Printing Test", (Properties)null);
		if (pjob == null)          // User cancelled??
			return;
		Dimension pDim = pjob.getPageDimension();
		int pRes = pjob.getPageResolution();
		System.out.println("Page size " + pDim + "; Res " + pRes);
		// Print up to NPAGES
		for (int pgNum=0; pgNum<nPages; pgNum++) {
			System.out.println("Starting page # " + pgNum);
			pg = pjob.getGraphics();
			if (pg == null) 	// ??
				return;
			// setColor needed on Solaris (a bug!?)
			pg.setColor(Color.black);
			pg.setFont(new Font("Helvetica", Font.PLAIN, 48));
			pg.drawString("Hello World", 200, 200);
			pg.drawString("Page " + pgNum, 300, 300);
			System.out.println("Disposing of page " + pgNum);
			pg.dispose(); // flush page
			System.out.println("Disposed of page " + pgNum);
		}
		pjob.end();	// total end of print job.
		pjob = null;	// avoid redundant calls to pjob.end()
	}
}
//@@@@@@//
//graphics/PrintDemoGfx.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.awt.print.*;
import javax.swing.*;

/** PrintDemoGfx -- Construct and print a GfxDemoCanvas. 
 * Java 2 VERSION, using a PrinterJob.
 */
public class PrintDemoGfx {
	final boolean quiet;

	/** Simple demo main program. */
	public static void main(String[] av) throws PrinterException {
		boolean quiet = false;
		if (av.length > 0 && av[0].startsWith("-q"))
			quiet = true;
		new PrintDemoGfx(quiet);
	}

	public PrintDemoGfx(boolean q) {
		quiet = q;
		final JFrame f = new JFrame("Printing Test Dummy Frame");

		// Construct the object we want to print. Contrived:
		// this object would already exist in a real program.
		final GfxDemoCanvas thing = new GfxDemoCanvas(400, 300);

		f.getContentPane().add(thing, BorderLayout.CENTER);

		JButton printButton = new JButton("Print");
		f.getContentPane().add(printButton, BorderLayout.SOUTH);

		printButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				try {
					PrinterJob pjob = PrinterJob.getPrinterJob();
					pjob.setJobName("DemoGfx - Graphics Demo Printout");
					pjob.setCopies(1);
					// Tell the print system how to print our pages.
					pjob.setPrintable(new Printable() {
						/** called from the printer system to print each page */
						public int print(Graphics pg, PageFormat pf, int pageNum) {
							if (pageNum>0)		// we only print one page
								return Printable.NO_SUCH_PAGE;	// ie., end of job

							// Now (drum roll please), ask "thing" to paint itself
							// on the printer, by calling its paint() method with 
							// a Printjob Graphics instead of a Window Graphics.
							thing.paint(pg);

							// Tell print system that the page is ready to print
							return Printable.PAGE_EXISTS;
						}
					});

					if (!quiet && pjob.printDialog() == false)	// choose printer
						return;				// user cancelled

					pjob.print();			 // Finally, do the printing.
				} catch (PrinterException pe) {
					JOptionPane.showMessageDialog(f,
						"Printer error" + pe, "Printing error",
						JOptionPane.ERROR_MESSAGE);
				}
			}
		});

		f.pack();
		f.setVisible(true);
	}
}
//@@@@@@//
//graphics/PrintDemoGfx1_1.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** PrintDemoGfx -- Construct and print a GfxDemoCanvas.  
 * JDK1.1 VERSION, using the older PrintJob.
 */
public class PrintDemoGfx1_1 {

	/** Simple demo main program. */
	public static void main(String[] av) {
		final JFrame f = new JFrame("Printing Test Dummy Frame");

		// Construct the object we want to print. Contrived:
		// this object would already exist in a real program.
		final GfxDemoCanvas thing = new GfxDemoCanvas(500, 300);

		f.getContentPane().add(thing, BorderLayout.CENTER);

		JButton printButton = new JButton("Print");
		f.getContentPane().add(printButton, BorderLayout.SOUTH);

		printButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

				PrintJob pjob = Toolkit.getDefaultToolkit().getPrintJob(f,
					"Printing Test", null);

				if (pjob == null)
					return;				// user cancelled

				// Fetch the Print Graphics object
				Graphics pg = pjob.getGraphics();

				// Now (drum roll please), ask "thing" to paint itself
				// on the printer, by calling its paint() method with 
				// a Printjob Graphics instead of a Window Graphics.
				thing.paint(pg);
				pg.dispose(); // end of this page
				pjob.end();	// end of print job.
			}
		});

		f.pack();
		f.setVisible(true);
	}
}
//@@@@@@//
//graphics/PrintFile.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.*;

/**
 * PrintFile -- Print a file named onthe command line
 */
public class PrintFile extends Frame {
	/** The number of pages to print */
	protected static final int NPAGES = 3;
	/** The actual number of pages */
	protected int nPages;
	/** The PrintJob object */
	PrintJob pjob = null;	// refers to whole print job

	/** main program: instantiate and show. */
	public static void main(String[] av) {
		PrintFile p = new PrintFile();
		p.setVisible(true);
		if (av.length==0)
			p.print(new InputStreamReader(System.in));
		else
			for (int i=0; i<av.length; i++)
				p.print(av[i]);
		p.setVisible(false);
		p.dispose();
		System.exit(0);
	}

	/** Construct a PrintDemo1 with given Filename */
	PrintFile() {
		setLayout(new FlowLayout());
		Button b;
		add(b = new Button("Cancel"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (pjob != null)	// if quit while printing!
					pjob.end();
				System.exit(0);
			}
		});
		pack();
	}

	/** Print a file by name */
	public void print(String fn) {
		// open it, call the other guy 
		FileReader ifile = null;
		try {
			ifile = new FileReader(fn);
		} catch (FileNotFoundException fnf) {
			System.err.println("File not found!");
		}
		print(ifile);
	}

	/** Print a file by File */
	public void print(Reader ifile) {
		BufferedReader is = new BufferedReader(ifile);
		Graphics g = null;	// refers to current page
		System.out.println("Doing print");
		pjob = getToolkit().getPrintJob(this,
			"Printing Test", (Properties)null);
		if (pjob == null)          // User cancelled??
			return;
		Dimension pDim = pjob.getPageDimension();
		int pRes = pjob.getPageResolution();
		System.out.println("Page size " + pDim + "; Res " + pRes);
		g = pjob.getGraphics();
		g.setColor(Color.black);
		g.setFont(new Font("SansSerif", Font.PLAIN, 12));
		if (g == null) 	// ??
			return;
		int y = 100;
		String line;
		try {
			while ((line = is.readLine()) != null) {
				g.drawString(line, 10, y+=18);
			}
		} catch (IOException e) {
			System.err.println(e);
		}
		// g.drawString("Page " + pgNum, 300, 300);
		g.dispose(); // flush page
		pjob.end();	// total end of print job.
		pjob = null;	// avoid redundant calls to pjob.end()
	}
}
//@@@@@@//
//graphics/SoundPlay.java
//@@@@@@//
import java.applet.*;
import java.net.*;

/** Simple program to try out the "new Sound" stuff in JDK1.2 --
 * allows Applications, not just Applets, to play Sound.
 */
public class SoundPlay {
	static String defSounds[] = {
		"file:///javasrc/graphics/test.wav",
		"file:///music/midi/Beet5th.mid",
	};
	public static void main(String[] av) {
		if (av.length == 0)
			main(defSounds);
		else for (int i=0;i<av.length; i++) {
			System.out.println("Starting " + av[i]);
			try {
				URL snd = new URL(av[i]);
				// open to see if works or throws exception, close to free fd's
				// snd.openConnection().getInputStream().close();
				Applet.newAudioClip(snd).play();
			} catch (Exception e) {
				System.err.println(e);
			}
	 	}
		// With this call, program exits before/during play.
		// Without it, on some versions, program hangs forever after play.
		// System.exit(0);
	}
}
//@@@@@@//
//graphics/TextFormat.java
//@@@@@@//
import java.awt.Component;
import java.awt.Container;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.font.FontRenderContext;
import java.awt.font.LineBreakMeasurer;
import java.awt.font.TextAttribute;
import java.awt.font.TextLayout;
import java.text.AttributedString;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import javax.swing.JFrame;

/** A display of text, formatted by us instead of by AWT/Swing.
 * <P>
 * This program is distributed under the terms of the accompanying
 * COPYRIGHT.txt file (which is NOT the GNU General Public License).
 * Please read it. Your use of the software constitutes acceptance
 * of the terms in the COPYRIGHT.txt file.
 * @author Ian F. Darwin
 * @version $Id: TextFormat.java,v 1.3 2004/03/26 03:34:30 ian Exp $
 */
public class TextFormat extends Component {

	/** The text of this line */
	protected String text;
	/** The Font */
	protected Font font;
	/** The TextLayouts corresponding to "text" */
	List layouts;

	public Font getFont() {
		return font;
	}

	public void setFont(Font f) {
		font = f;
	}

	public String getText() {
		return text;
	}
	public void setText(String t) {
		text = t;
	}

	public void paint(Graphics g) {
		if (text == null || text.length() == 0)
			return;
		if (layouts == null)
			getLayouts(g);

		Point pen = new Point(0, 0);
		Graphics2D g2d = (Graphics2D)g;
		g2d.setColor(java.awt.Color.black);	// or a property
		g2d.setFont(font);

		Iterator it = layouts.iterator();
		while (it.hasNext()) {
			TextLayout layout = (TextLayout) it.next();
			pen.y += (layout.getAscent());
			g2d.setFont(font);
			layout.draw(g2d, pen.x, pen.y);
			pen.y += layout.getDescent();
			//pen.y += leading;
		}
	}

	/** Lazy evaluation of the List of TextLayout objects corresponding
	 * to this MText. Some things are approximations!
	 */
	private void getLayouts(Graphics g) {
		layouts = new ArrayList();

		Point pen = new Point(10, 20);
		Graphics2D g2d = (Graphics2D) g;
		FontRenderContext frc = g2d.getFontRenderContext();

		AttributedString attrStr = new AttributedString(text);
		attrStr.addAttribute(TextAttribute.FONT, font, 0, text.length());   
		LineBreakMeasurer measurer = new LineBreakMeasurer(
			attrStr.getIterator(), frc);
		float wrappingWidth;

		wrappingWidth = getSize().width - 15;

		while (measurer.getPosition() < text.length()) {
			TextLayout layout = measurer.nextLayout(wrappingWidth);
			layouts.add(layout);
		}
	}

	public static void main(String[] args) {
		JFrame jf = new JFrame("Demo");
		Container cp = jf.getContentPane();
		TextFormat tl = new TextFormat();
		tl.setFont(new Font("SansSerif", Font.BOLD, 42));
		tl.setText("The quick brown fox jumped over the lazy cow");
		cp.add(tl);
		jf.setSize(300, 200);
		jf.setVisible(true);
	}
}
//@@@@@@//
//graphics/TexturedText.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import javax.swing.*;

/** Text with a Texture
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: TexturedText.java,v 1.5 2004/02/09 03:33:49 ian Exp $
 */
public class TexturedText extends JComponent {
	/** The image we draw in the texture */
	protected BufferedImage bim; 
	/** The texture for painting. */
	TexturePaint tp;
	/** The string to draw. */
	String mesg = "Stripey";
	/** The font */
	Font myFont = new Font("Lucida Regular", Font.BOLD, 72);

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create a TexturedText object, tell it to show up
		final Frame f = new Frame("TexturedText");
		TexturedText comp = new TexturedText();
		f.add(comp);
		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				f.setVisible(false);
				f.dispose();
				System.exit(0);
			}
		});
		f.pack();
		f.setLocation(200, 200);
		f.setVisible(true);
	}

	protected static Color[] colors = {
		Color.red, Color.blue, Color.yellow,
	};

	/** Construct the object */
	public TexturedText() {
		super();
		setBackground(Color.white);
		int width = 8, height = 8;
		bim = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
		Graphics2D g2 = bim.createGraphics();
		for (int i=0; i<width; i++) {
			g2.setPaint(colors[(i/2)%colors.length]);
			g2.drawLine(0, i, i, 0);
			g2.drawLine(width-i, height, width, height-i);
		}
		Rectangle r = new Rectangle(0, 0, bim.getWidth(), bim.getHeight());
		tp = new TexturePaint(bim, r);
	}

	public void paint(Graphics g) {
		Graphics2D g2 = (Graphics2D)g;
		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
			RenderingHints.VALUE_ANTIALIAS_ON);
		g2.setPaint(tp);
		g2.setFont(myFont);
		g2.drawString(mesg, 20, 100);
	}

	public Dimension getMinimumSize() {
	 	return new Dimension(250, 100);
	}

	public Dimension getPreferredSize() {
	 	return new Dimension(320, 150);
	}
}
//@@@@@@//
//graphics/TiledImageComponent.java
//@@@@@@//
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Label;
import java.awt.TextField;

import javax.swing.JFrame;

import com.darwinsys.util.Debug;

/**
 * Demo of tiling an Image across a component; draw the image repeatedly
 * in the paint() method.
 * @version $Id: TiledImageComponent.java,v 1.8 2004/05/28 02:02:30 ian Exp $
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 */
public class TiledImageComponent extends Container {
	protected TextField nameTF, passTF, domainTF;
	protected Image im;
	public static final String DEFAULT_IMAGE_NAME = "background.gif";

	/** Set things up nicely. */
	public TiledImageComponent() {
		Label l;

		setLayout(new FlowLayout());
		add(l = new Label("Name:", Label.CENTER));
		add(nameTF=new TextField(10));

		add(l = new Label("Password:", Label.CENTER));
		add(passTF=new TextField(10));
		passTF.setEchoChar('*');

		add(l = new Label("Domain:", Label.CENTER));
		add(domainTF=new TextField(10));

		im = getToolkit().getImage(DEFAULT_IMAGE_NAME);
	}

	/** paint()  - just tile the background.  */
	public void paint(Graphics g) {
		if (im == null)
			return;
		int iw = im.getWidth(this), ih=im.getHeight(this);
		if (iw < 0 || ih < 0)	// image not ready
			return;				// live to try again later.
		int w = getSize().width, h = getSize().height;

		for (int i = 0; i<=w; i+=iw) {
			for (int j = 0; j<=h; j+=ih) {
				Debug.println("draw", "drawImage(im,"+i+","+j+")");
				g.drawImage(im, i, j, this);
			}
		}
	}

	public static void main(String[] av) {
		JFrame f = new JFrame("TiledImageComponent Demo");
		f.getContentPane().add(new TiledImageComponent());
		f.setSize(200, 200);
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}

//@@@@@@//
//graphics/TTFontApplet.java
//@@@@@@//
import java.awt.Container;

import javax.swing.JApplet;
import javax.swing.JLabel;

/** Create a TTFontDemo label in an Applet.
 * @version $Id: TTFontApplet.java,v 1.2 2004/03/26 03:34:31 ian Exp $
 */
public class TTFontApplet extends JApplet {

	/** Initialize the GUI */
	public void init() {

		String message = getParameter("message");
		if (message == null) 
			message = "TrueType Font Demonstration Applet";

		String fontFileName = getParameter("fontFileName");
		if (fontFileName == null)
			fontFileName = "Kellyag_.ttf";
		Container cp = getContentPane();
		try {
			cp.add(new TTFontDemo(fontFileName, message));
		} catch (Exception ex) {
			cp.add(new JLabel(ex.toString(), JLabel.CENTER));
			ex.printStackTrace();
		}
	}
}
//@@@@@@//
//graphics/TTFontDemo.java
//@@@@@@//
import java.awt.*;
import java.io.*;
import javax.swing.*;

/** Demo of making TrueType font usable in Java. This is a way cool facility
 * because it means you can have "application-specific" fonts in Java;
 * your application can have its own distinctive font that the user does
 * NOT have to install into the JRE before you can use it.
 * (of course they can install it if they have privileges and want to).
 * <p>
 * Must remain Swing-based despite problems on older systems, since
 * apparently only Swing components can use TTF fonts in this implementation.
 * <p>
 * Did NOT work for me in Applet nor JApplet due to
 * security problems (requires to create a temp file). Could be made
 * to work by providing a policy file.
 * @author	Ian Darwin
 * @since 1.3
 */
public class TTFontDemo extends JLabel {

	/** Construct a TTFontDemo -- Create a Font from TTF.
	 */
	public TTFontDemo(String fontFileName, String text)
	throws IOException, FontFormatException {
		super(text, JLabel.CENTER);

		setBackground(Color.white);

		// First, see if we can load the font file.
		InputStream is = this.getClass().getResourceAsStream(fontFileName);
		if (is == null) {
			throw new IOException("Cannot open " + fontFileName);
		}

		// createFont makes a 1-point font, bit hard to read :-)
		Font ttfBase = Font.createFont(Font.TRUETYPE_FONT, is);

		// So scale it to 24 pt.
		Font ttfReal = ttfBase.deriveFont(Font.PLAIN, 24);

		setFont(ttfReal);
	}

	/** Simple main program for TTFontDemo */
	public static void main(String[] args) throws Exception {

		String DEFAULT_MESSAGE = 
			"What hath man wrought? Or at least rendered?";
		String DEFAULT_FONTFILE =
			"Kellyag_.ttf";
		String message = args.length == 1 ? args[0] : DEFAULT_MESSAGE;
		JFrame f = new JFrame("TrueType Font Demo");

		TTFontDemo ttfd = new TTFontDemo(DEFAULT_FONTFILE, message);
		f.getContentPane().add(ttfd);

		f.setBounds(100, 100, 700, 250);
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}
//@@@@@@//
//gui/arraylisttable/ArrayListTableDatum.java
//@@@@@@//
package arraylisttable;

/** Class to hold a name and a value from a Properties; the
 * ArrayList contains one of these per Properties entry.
 * Needs to be a non-inner class only to allow the Panel
 * to constructs instances of it.
 */
public class ArrayListTableDatum {
	String name;
	String value;
	/** Constructor used below */
	public ArrayListTableDatum(String n, String v) {
		name = n; value = v;
	}
	/** public no-arg constructor, req'd for Add operation */
	public ArrayListTableDatum() { }
}
//@@@@@@//
//gui/arraylisttable/ArrayListTableSimple.java
//@@@@@@//
package arraylisttable;

import javax.swing.*;
import java.util.*;

import com.darwinsys.swingui.ArrayListTableModel;
import com.darwinsys.swingui.ArrayListTablePanel;

/** Simple demo of the com.darwinsys.swingui.ArrayListTable{Model,Panel}.
 * The "data" is an ArrayList made from the System Properties
 */
public class ArrayListTableSimple extends JFrame {

	/** inner class for TableModel */
	class Model extends ArrayListTableModel {

		/** This defines the order of the columns. Must agree with columnClasses */
		protected String[] myColumnNames = { "Name", "Value" };
	
		protected Class[] myColumnClasses = { String.class, String.class };

		/** Return the width of the table */
		public int getColumnCount() { return 2; }

		/** Construct a Model given the ArrayList */
		public Model(ArrayList m) {
			super(m);
			columnNames = myColumnNames;
			columnClasses = myColumnClasses;
		}

		/** Returns a data value for the cell at row, col  */
		public Object getValueAt(int row, int col)  {

			ArrayListTableDatum current = (ArrayListTableDatum)getCached(row);
			switch(col) {
				case 0: return current.name;
				case 1: return current.value;
				default: 
					System.out.println("ERROR getValueAt(" + row + "," + col + "); invalid");
					return null;
			}
		}

		/** Set a data value for the cell at row, col */
		public void setValueAt(Object val, int row, int col)  {

			ArrayListTableDatum current = (ArrayListTableDatum)getCached(row);
			switch(col) {
				case 0: current.name = (String)val;
				case 1: current.value = (String)val;
			}
		}
	}

	/** Construct the main program's GUI */
	public ArrayListTableSimple() {
		super("ArrayListTableSimple");

		// Create empty ArrayList
		ArrayList data = new ArrayList();

		// Get the System Properties
		Properties p = System.getProperties();

		// Get an Iterator for the sorted set of keys in p
		Iterator it = new TreeMap(p).keySet().iterator();

		// Copy them into the ArrayList
		while (it.hasNext()) {
			String key = (String)it.next();
			String val = p.getProperty(key);
			data.add(new ArrayListTableDatum(key, val));
		}

		// Make the Model and View
		Model m = new Model(data);
		JPanel v = new ArrayListTablePanel(ArrayListTableDatum.class, data, m);

		// Make it show up in this JFrame
		setContentPane(new JScrollPane(v));
		pack();

		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}

	public static void main(String[] args) {
		new ArrayListTableSimple().setVisible(true);
	}
}
//@@@@@@//
//gui/BordLayDemo.java
//@@@@@@//
import java.util.*;
import java.awt.*;

/** BorderLayout demo. Also shows off BitSet class from java.util.
 * <P>Do <B>not</B> assume from this demo that BorderLayout forces
 * e.g., East and West to be same width, or North and South to be
 * same height. See BordLayDemo2 for counter examples.
 */
public class BordLayDemo extends Frame {
	String cp[] = { "", "North", "East", "South", "West", "Center" };
	static final int   NORTH=1, EAST=2, SOUTH=3, WEST=4, CENTER=5;

	BordLayDemo(String s, BitSet b) {
		super(s);
		setLayout(new BorderLayout());
		for (int i = 1; i<=5; i++)
			if (b.get(i))
				add(new Button(cp[i]), cp[i]);
		pack();
		setVisible(true);
	}

	public static void main(String[] av) {
		BitSet b = new BitSet();
		b.set(NORTH);
		b.set(EAST);
		b.set(SOUTH);
		b.set(WEST);
		b.set(CENTER);
		new BordLayDemo("All", b);

		b.clear(CENTER);
		new BordLayDemo("Compass", b);

		b.set(CENTER);
		b.clear(NORTH);
		b.clear(SOUTH);
		new BordLayDemo("Horizontal", b);

	}
}

//@@@@@@//
//gui/BordLayDemo2.java
//@@@@@@//
import java.util.*;
import java.awt.*;

/** BorderLayout demo. East and West have different widths, and North
 * and South have different heights.
 */
public class BordLayDemo2 extends Frame {
	String cp[] = { "", "North", "East", "South", "West", "Center" };
	static final int   NORTH=1, EAST=2, SOUTH=3, WEST=4, CENTER=5;
	MyCanvas canvases[] = { null,
		new MyCanvas(cp[NORTH], 100, 150, Color.red),
		new MyCanvas(cp[EAST ], 100, 100, Color.green),
		new MyCanvas(cp[SOUTH], 100, 100, Color.red),
		new MyCanvas(cp[WEST ], 100, 100, Color.blue),
		new MyCanvas(cp[CENTER], 10, 10,  Color.black),
	};

	BordLayDemo2(String s, BitSet b) {
		super(s);
		setLayout(new BorderLayout());
		for (int i = 1; i<=5; i++)
			if (b.get(i))
				add(canvases[i], cp[i]);
		pack();
		setVisible(true);
	}

	public static void main(String[] av) {
		BitSet b = new BitSet();
		b.set(NORTH);
		b.set(EAST);
		b.set(SOUTH);
		b.set(WEST);
		b.set(CENTER);
		new BordLayDemo2("All", b);

		b.clear(CENTER);
		new BordLayDemo2("Compass", b);

		b.set(CENTER);
		b.clear(NORTH);
		b.clear(SOUTH);
		new BordLayDemo2("Horizontal", b);

		b.set(NORTH);
		b.set(SOUTH);
		b.clear(EAST);
		b.clear(WEST);
		new BordLayDemo2("Vertical", b);
	}
}
//@@@@@@//
//gui/BordLayPanel.java
//@@@@@@//
import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.Label;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;

/**
 * BordLayPanel.java - BorderLayout with a Panel
 * @author	Ian Darwin, http://www.darwinsys.com/, for Learning Tree Course 478
 */
public class BordLayPanel extends Frame {
	TextField fileName;
	TextArea main;
	Label status;

	public static void main(String[] av) {
		new BordLayPanel().setVisible(true);
	}

	BordLayPanel() {
		super("BordLayPanel");
		Panel p;
		Button b;
		setLayout(new BorderLayout());
		add(BorderLayout.NORTH,  p = new Panel());
			p.setLayout(new FlowLayout());
			p.add(new Label("FileName:"));
			p.add(fileName  = new TextField(40));
			p.add(b = new Button("Load"));
			// now you need to add an action listener to the button
		add(BorderLayout.CENTER, main = new TextArea(24,80));
		add(BorderLayout.SOUTH,  status = new Label(""));
		pack();
		
		// Don't forget to add a window listener so the quit control works
	}

	/** Simulate applet.showStatus() for Frame-based applications */
	public void showStatus(String msg) {
		if (msg == null)
			msg = "";
		status.setText(msg);
	}
}
//@@@@@@//
//gui/ButtonDemo.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/** Demonstrate use of Button */
public class ButtonDemo extends Applet implements ActionListener {
	Button	b1;

	public ButtonDemo() {
		add(b1 = new Button("A button"));
		b1.addActionListener(this);
	}

	public void actionPerformed(ActionEvent event) {
		showStatus("Thanks for pushing my button!");
	}
}
//@@@@@@//
//gui/ButtonDemo2a.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/** Demonstrate use of two buttons, using a single ActionListener,
 * being the class itself.
 */
public class ButtonDemo2a extends Applet implements ActionListener {
	Button b1, b2;

	public void init() {
		add(b1 = new Button("A button"));
		b1.addActionListener(this);

		add(b2 = new Button("Another button"));
		b2.addActionListener(this);
	}

	public void actionPerformed(ActionEvent e) {
		if (e.getSource() == b1)
			showStatus("Thanks for pushing my first button!");
		else
			showStatus("Thanks for pushing my second button!");
	}
}
//@@@@@@//
//gui/ButtonDemo2b.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/** Demonstrate use of two buttons, using a single ActionListener 
 * made of a named inner class
 */
public class ButtonDemo2b extends Applet {
	Button b1, b2;
	ActionListener handler = new ButtonHandler();

	public void init() {
		add(b1 = new Button("A button"));
		b1.addActionListener(handler);

		add(b2 = new Button("Another button"));
		b2.addActionListener(handler);
	}

	class ButtonHandler implements ActionListener {
		public void actionPerformed(ActionEvent e) {
			if (e.getSource() == b1)
				showStatus("Thanks for pushing my first button!");
			else
				showStatus("Thanks for pushing my second button!");
		}
	}
}
//@@@@@@//
//gui/ButtonDemo2c.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/** Demonstrate use of Button */
public class ButtonDemo2c extends Applet {
	Button	b;

	public void init() {
		add(b = new Button("A button"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				showStatus("Thanks for pushing my first button!");
			}
		});
		add(b = new Button("Another button"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				showStatus("Thanks for pushing my second button!");
			}
		});
	}
}
//@@@@@@//
//gui/ButtonDemoPanel.java
//@@@@@@//
/*
 <APPLET CODE=ButtonDemoPanel WIDTH=234 HEIGHT=123>
 </APPLET>
 */

import java.applet.*;
import java.awt.*;

/** Demonstrate two buttons with a Panel for Layout.
 * This version is longer than the one in the course notes;
 * it only differs by the inclusion of background colors.
 */
public class ButtonDemoPanel extends Applet {
	Button applyB, exitB;
	public void init() {
		setBackground(Color.cyan);		// see Graphics chapter.
		Panel p = new Panel();
		p.setBackground(Color.red);
		p.add(applyB = new Button("Apply"));
		applyB.setBackground(Color.white);
		p.add(exitB = new Button("Exit"));
		exitB.setForeground(Color.red);
		add(p);  // add (connect) "p" to "this", the Applet
	}
}
//@@@@@@//
//gui/cardlayout/CardLayDemo.java
//@@@@@@//
package cardlayout;

/* CardLayout Demo: Login Applet */

import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/** Switchable interface lets us call back the Applet, instead of
 * having global variables (in other languages) or passing lots of
 * extra stuff into the ImgPanel constructor
 */
interface Switchable {
	void gotoNext(String target);
}

/** ImgPanel holds an Image and optional TextField, jumps to next */
class ImgPanel extends Panel {
	/** The background Image */
	Image im;
	/* Size of the Images */
	final int WIDTH = 216;
	final int HEIGHT= 144;
	/** The container */
	Switchable applet;
	/** The label for the next panel in the series (CardLayout
	 * switches based on name string, not reference to a GUI component.
	 */
	String next;
	/** Our entry field */
	TextField fld = null;
	/** Our pushbutton */
	Button butt = null;

	/** Construct an ImagePanel */
	ImgPanel(Switchable theApplet, Image image, String theNextPanelName) {
		super();

		applet	= theApplet;
		im		= image;
		next	= theNextPanelName;

		if (theNextPanelName == null)
			return;

		GridBagLayout gridbag = new GridBagLayout();
		GridBagConstraints cL = new GridBagConstraints(),
			cR = new GridBagConstraints();
		cL.gridx = 0; cL.gridwidth = 1;
		cR.gridx = 1; cR.gridwidth = GridBagConstraints.REMAINDER;
		cR.weightx = 1.0; cL.weightx = 4.0;
		cR.weighty = cL.weighty = 0.8;
		cR.gridheight = cL.gridheight = GridBagConstraints.REMAINDER;
		cR.anchor = GridBagConstraints.SOUTHWEST;
		cL.anchor = GridBagConstraints.SOUTHEAST;
		setLayout(gridbag);

		// Add the textfield at the left side
		fld = new TextField(8);
		gridbag.setConstraints(fld, cL);
		add(fld);

		// Add the OK button at the right side
		butt = new Button("OK");
		gridbag.setConstraints(butt, cR);
		add(butt);

		// Give it an ActionListener to move on to the next page
		butt.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (fld.getText().length() > 0)
					applet.gotoNext(next);
			}
		});
	}

	/** Set this panel's text field to hidden echo */
	public void setNoEcho() {
		if (fld != null)
			fld.setEchoChar('*');
	}
	/* override update() to not clear, which reduces flicker */
	public void update(Graphics g) {
		paint(g);
	}

	/* Draw the background */
	public void paint(Graphics g) {
		g.drawImage(im, 0, 0, this);
	}

	/* urge the Layout Mangler to make us the same size as our background */
	public Dimension getPreferredSize() {
		return new Dimension(WIDTH, HEIGHT);
	}

	public Dimension getMinimumSize() {
		return getPreferredSize();
	}
}

/** CardLayDemo -- Prototype of a Login Dialog for an Applet
 *
 * @author Ian F. Darwin
 * @version 1.0, July, 1997
 */
public class CardLayDemo extends Applet implements Switchable {
	private ImgPanel loginP, passwdP, welcomeP; 
	CardLayout cardlay;

	/** Initialize the CardLayDemo applet. */
	public void init() {
		// Main panel (managed by CardLayout) is details
		// for either Login, Passwd or Welcome! screen.

		setLayout(cardlay = new CardLayout()); 

		/* create each Panel. */
		add("login",
			loginP = new ImgPanel(this, 
				getImage(getCodeBase(), "loginLogin.gif"), "passwd"));
		add("passwd",
			passwdP = new ImgPanel(this, 
				getImage(getCodeBase(), "loginPasswd.gif"), "welcome"));
		passwdP.setNoEcho();
		add("welcome",
			welcomeP = new ImgPanel(this, 
				getImage(getCodeBase(), "loginWelcome.gif"), null));
	}

	public void start() { 
		gotoNext("login");		// gotta start somewhere
	}

	/** Switch to the next panel */
	public void gotoNext(String gotoLabel) {
		cardlay.show(this, gotoLabel);
	}
}
//@@@@@@//
//gui/cardlayout/CardLayDemo1.java
//@@@@@@//
package cardlayout;

import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/** Simpler CardLayout demo: cycles through some labels.
 * @author Ian Darwin
 * @version $Id: CardLayDemo1.java,v 1.3 2004/03/21 00:44:36 ian Exp $
 */
public class CardLayDemo1 extends Applet {
	CardLayout cardlay;
        Panel panel;
	Button b1;
	int cardno = 0;
	final int NCARDS = 4;
	String labels[] = new String[NCARDS];

	public void init() {

		panel = new Panel();
		cardlay = new CardLayout();
		b1 = new Button("Next");
		b1.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				if (++cardno >= NCARDS)
					cardno = 0;
				cardlay.show(panel, labels[cardno]);
			}
		});
		labels[0] = "Card One";
		labels[1] = "Card Two";
		labels[2] = "Card Three";
		labels[3] = "Card Four";

		panel.setLayout(cardlay);
		for (int i=0; i<NCARDS; i++)
			panel.add(labels[i], new Label(labels[i]));
		cardlay.show(panel, labels[0]);

		setLayout(new BorderLayout());
		add("Center", panel);
		add("South", b1);
	}
}
//@@@@@@//
//gui/cardlayout/CardLayDemo2.java
//@@@@@@//
package cardlayout;

import java.awt.*;
import java.awt.event.*;

/**
 * PrintPanel is the base for an open-ended series of classes
 * that implement printing of one type. We provide two examples 
 * to start: First prints a phone book, second prints labels, etc.
 * To add more, for example a Mail List/Form Letter Merge,
 * define a class for it below and insert in the "add" loop
 * in the main constructor.
 */
abstract class PrintPanel extends Panel {
	/** Returns the string to use in a Choice to display this panel */
	public abstract String getChoice();
	/** Print the data in the format for this type of printout */
	public abstract void doPrint();
}

/** PhonesPanel extends PrintPanel to provide the UI for printing
 * a user's phone book.
 */
class PhonesPanel extends PrintPanel {
	PhonesPanel() {
		super();
		setBackground(Color.red);
		setLayout(new FlowLayout());
		add(new Label("Tab markers at edge of page?"));
		add(new Checkbox());
		add(new Label("Each letter starts page?"));
		add(new Checkbox());
	}
	public String getChoice() {
		return "Phone Book";
	}
	public void doPrint() {
		// code here to print Phone book
	}
}


/** LabelsPanel extends PrintPanel to provide the UI for printing
 * name and address labels
 */
class LabelsPanel extends PrintPanel {
	LabelsPanel() {
		super();
		setBackground(Color.green);
		setLayout(new GridLayout(3,2));
		add(new Label("Left Offset:"));
		add(new TextField(5));
		add(new Label("Rows:"));
		add(new TextField(5));
		add(new Label("Cols:"));
		add(new TextField(5));
	}
	public String getChoice() {
		return "Labels";
	}
	public void doPrint() {
		// code here to print Labels
	}
}

/** CardLayDemo2 -- Prototype of a Print Dialog for JabaDex
 *
 * @author Ian F. Darwin
 * @version 0.0, September, 1996
 */
public class CardLayDemo2 extends Frame {
	PrintPanel[] pps = new PrintPanel[2];
	private int runType = 0;
	private Choice runTypeChoice;

	private Panel tp, mainP, bp;	// top, middle, bottom.
	CardLayout cardlay;

	private Button printButton, 
		sampleButton, cancelButton;

	/** Construct a Print dialog. */
	CardLayDemo2(String title) {
		super(title);


		// Top panel (tp) has choices for labels/phonebook/etc.
		// and paper size.
		// Middle panel (mainP, managed by CardLayout) is details
		// for either Labels or Phonebook
		//	Shows either a PhonesPanel or a LabelsPanel or ...
		// Bottom panel (bp) has Print/Preview/Cancel buttons.
		tp = new Panel();
		tp.setLayout(new FlowLayout());

		mainP = new Panel();
		mainP.setLayout(cardlay = new CardLayout()); 

		tp.add(runTypeChoice = new Choice());
		runTypeChoice.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent e) {
				runType = runTypeChoice.getSelectedIndex();
				cardlay.show(mainP, pps[runType].getChoice());
			}
		});

		/* create one instance of each PrintPanel type. */
		pps[0] = new PhonesPanel();
		pps[1] = new LabelsPanel();

		/* Add each print type to the choice and to mainP */
		for (int i=0; i<pps.length; i++) {
			runTypeChoice.add(pps[i].getChoice());
			mainP.add(pps[i].getChoice(), pps[i]);
		}

		cardlay.show(mainP, pps[runType].getChoice());

		// Bottom has a Panel with push buttons
		bp = new Panel();
		bp.setLayout(new FlowLayout());
		bp.add(printButton = new Button("Print"));
		printButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				doPrint(true);
				setVisible(false);
				System.exit(0);
			}
		});
		bp.add(sampleButton = new Button("Print Sample"));
			sampleButton.setEnabled(false);
		bp.add(cancelButton = new Button("Cancel"));
		cancelButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.out.println("Printing canceled");
				setVisible(false);
				System.exit(0);
			}
		});

		setLayout(new BorderLayout());
		add(tp, BorderLayout.NORTH);
		add(mainP, BorderLayout.CENTER);
		add(bp, BorderLayout.SOUTH);

		pack();

        addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
        	// If windowClosing() does setVisible and dispose, 
			// then the close action completes
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
	}


	/** Print the current list.  */
	protected void doPrint(boolean toRealDevice) {

		// open a PrintStream to the printer device to file on disk.
		// PrintStream pf = ...

		// call the appropriate doPrint()
		// pps[runType].doPrint(pf);

		System.err.println("Print completed");
	}

	public static void main(String[] args) {

		// Generate some data...
		// ...

		// pop up the print dialog to print it
		(new CardLayDemo2("Print Tester")).setVisible(true);
	}
}
//@@@@@@//
//gui/ChoiceDemo.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/** Demonstrate use of Choice; also Font, action(), Event, ... */
public class ChoiceDemo extends Applet {
	Button	b1;
	Choice	cl;
	Label	myLabel;

	/** init: set a font, initialize UI components. */
	public void init() {
		setLayout(new FlowLayout());

		String pSize = getParameter("fontsize"); 
		if (pSize == null)
			pSize = "12";
		// System.out.println("Fontsize is " + pSize);
		Font f = new Font("Helvetica", Font.PLAIN, Integer.parseInt(pSize));
		setFont(f);
   
		/* Build the UI */
		add(cl = new Choice()) ;
		cl.setFont(f);	// ignored?
		cl.addItem("Whipping Cream");
		cl.addItem("Icing Sugar");
		cl.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent event) {
				Apply();
			}
		});
		add(b1 = new Button("Apply"));
		b1.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				Apply();
			}
		});
		myLabel  = new Label("Please Choose Something", Label.CENTER);
		add(myLabel);
	}

	/** Return information about this applet. */
	public String getAppletInfo() {
		return "ChoiceDemo Applet, Version 0, Copyright Learning Tree International";
	}

	/** Return list of allowable parameters. */
	public String[][] getParameterInfo() {
		String param_info[][] = {
			{"fontsize",    "10-20",    "Size of font"},
		};
		return param_info;
	}

	private void Apply() {
		String item = cl.getSelectedItem();
		myLabel.setText(item);
	}
}
//@@@@@@//
//gui/ClipboardTest.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.awt.datatransfer.*;

/** Taken from the Sun documentation on Clipboard API */
public class ClipboardTest extends Frame 
                           implements ClipboardOwner, ActionListener {

    TextArea srcText, dstText;
    Button copyButton, pasteButton;

    Clipboard clipboard = getToolkit().getSystemClipboard();

    public ClipboardTest() {
        super("Clipboard Test");
        GridBagLayout gridbag = new GridBagLayout();
        GridBagConstraints c = new GridBagConstraints();
        setLayout(gridbag);

        srcText = new TextArea(8, 32);
        c.gridwidth = 2;
        c.anchor = GridBagConstraints.CENTER;
        gridbag.setConstraints(srcText, c);
        add(srcText);

        copyButton = new Button("Copy Above");
        copyButton.setActionCommand("copy");
        copyButton.addActionListener(this);
        c.gridy = 1;
        c.gridwidth = 1;
        gridbag.setConstraints(copyButton, c);
        add(copyButton);

        pasteButton = new Button("Paste Below");
        pasteButton.setActionCommand("paste");
        pasteButton.addActionListener(this);
        pasteButton.setEnabled(false);
        c.gridx = 1;
        gridbag.setConstraints(pasteButton, c);
        add(pasteButton);

        dstText = new TextArea(8, 32);
        c.gridx = 0;
        c.gridy = 2;
        c.gridwidth = 2;
        gridbag.setConstraints(dstText, c);
        add(dstText); 

        pack();
    }

    public void actionPerformed(ActionEvent evt) {
        String cmd = evt.getActionCommand();

        if (cmd.equals("copy")) { 
           // Implement Copy operation
           String srcData = srcText.getText();
           if (srcData != null) {
                StringSelection contents = new StringSelection(srcData);
                clipboard.setContents(contents, this);
                pasteButton.setEnabled(true);
            }
        } else if (cmd.equals("paste")) {
            // Implement Paste operation
            Transferable content = clipboard.getContents(this);
            if (content != null) {
                try {
                    String dstData = (String)content.getTransferData(
                                                DataFlavor.stringFlavor);
                    dstText.append(dstData);
                } catch (Exception e) {
                    System.out.println("Couldn't get contents in format: "+
                           DataFlavor.stringFlavor.getHumanPresentableName()); 
                }
             }
        }
    }
    public void lostOwnership(Clipboard clipboard, Transferable contents) {
       System.out.println("Clipboard contents replaced");
    }
     public static void main(String[] args) {
        ClipboardTest test = new ClipboardTest();
        test.setVisible(true);
     }
}
//@@@@@@//
//gui/ColorChooser.java
//@@@@@@//
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

/* 
 * ColorChooser - JColorChooser demo.
 * JColorChooser can be used in three ways:
 * <UL><LI>Construct it and place it in a panel;
 * <LI>Call its ConstructDialog() and get a JDialog back
 * <LI>Call its showDialog() and get back the chosen color
 * </UL>
 * @version $Id: ColorChooser.java,v 1.7 2004/03/08 01:38:17 ian Exp $
 */
public class ColorChooser extends JFrame
{
    JColorChooser cc;
    JDialog cd;
    MyCanvas demo;
	Container cPane;

    public ColorChooser() {
        super("Ian Darwin's Color Demo");
        JButton jButton;
		cPane = getContentPane();
        cPane.add(jButton = new JButton("Choose Color..."), BorderLayout.NORTH);
		jButton.setToolTipText("Click here to see the Color Chooser");
        jButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent actionEvent)
			{
				ColorChooser.this.cd.setVisible(true);
			}
		});
        cPane.add(demo = new MyCanvas(300,150), BorderLayout.CENTER);
		demo.setToolTipText("This is the last color you chose");
        pack();
        addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent windowEvent)
			{
				System.exit(0);
			}
		});
        cd = JColorChooser.createDialog(this,
			"Ian Darwin's Color PopUp",
			true,
			cc = new JColorChooser(getBackground()),
			new ActionListener() {
				public void actionPerformed(ActionEvent actionEvent) {
					ColorChooser.this.demo.setBackground(cc.getColor());
				}
			},
			new ActionListener() {
				public void actionPerformed(ActionEvent actionEvent)
				{
					ColorChooser.this.demo.setBackground(getBackground());
				}
			});
	}

    public static void main(String[] astring)
    {
        new ColorChooser().setVisible(true);
    }
}

//@@@@@@//
//gui/ContentPane.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

public class ContentPane extends JFrame {
	public ContentPane() {
		Container cp = getContentPane();
		// now add Components to "cp"...
	}
}
//@@@@@@//
//gui/datatransfer/Dropper.java
//@@@@@@//
package datatransfer;

import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Iterator;
import java.util.List;

import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.TransferHandler;

/**
 * Dropper - show File Drop Target from Drag-n-Drop
 * 
 * @version $Id: Dropper.java,v 1.1 2004/04/10 00:12:25 ian Exp $
 */
public class Dropper extends JFrame {

	/**
	 * Construct trivial GUI and connect a TransferHandler to it.
	 */
	public Dropper() {
		super("Drop Target");

		JComponent cp = (JComponent) getContentPane();
		cp.setTransferHandler(new MyFileTransferHandler()); // see below

		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(150, 150);
	}

	/** Instantiate and show the GUI */
	public static void main(String[] args) {
		new Dropper().setVisible(true);
	}
}

/** Non-public class to handle filename drops */
class MyFileTransferHandler extends TransferHandler {

	/**
	 * @see javax.swing.TransferHandler#canImport(javax.swing.JComponent,
	 *      java.awt.datatransfer.DataFlavor[])
	 */
	public boolean canImport(JComponent arg0, DataFlavor[] arg1) {
		for (int i = 0; i < arg1.length; i++) {
			DataFlavor flavor = arg1[i];
			if (flavor.equals(DataFlavor.javaFileListFlavor)) { 
				System.out.println("canImport: JavaFileList FLAVOR: " + flavor);
				return true;
			}
			if (flavor.equals(DataFlavor.stringFlavor)) { 
				System.out.println("canImport: String FLAVOR: " + flavor);
				return true;
			}
			System.err.println("canImport: Rejected Flavor: " + flavor);
		}
		// Didn't find any that match, so:
		return false;
	}

	/**
	 * Do the actual import.
	 * 
	 * @see javax.swing.TransferHandler#importData(javax.swing.JComponent,
	 *      java.awt.datatransfer.Transferable)
	 */
	public boolean importData(JComponent comp, Transferable t) {
		DataFlavor[] flavors = t.getTransferDataFlavors();
		System.out.println("Trying to import:" + t);
		System.out.println("... which has " + flavors.length + " flavors.");
		for (int i = 0; i < flavors.length; i++) {
			DataFlavor flavor = flavors[i];
			try {
				if (flavor.equals(DataFlavor.javaFileListFlavor)) {
					System.out.println("importData: FileListFlavor");

					List l = 
						(List) t.getTransferData(DataFlavor.javaFileListFlavor);
					Iterator iter = l.iterator();
					while (iter.hasNext()) {
						File file = (File) iter.next();
						System.out.println("GOT FILE: " + file.getCanonicalPath());
						// Now do something with the file...
					}
					return true;
				} else if (flavor.equals(DataFlavor.stringFlavor)) {
					System.out.println("importData: String Flavor");
					String fileOrURL = (String)t.getTransferData(flavor);
					System.out.println("GOT STRING: " + fileOrURL);
					try {
						URL url = new URL(fileOrURL);
						System.out.println("Valid URL: " + url.toString());
						// Do something with the contents...
						return true;
					} catch (MalformedURLException ex) {
						System.err.println("Not a valid URL");
						return false;
					}
					// now do something with the String.

				} else {
					System.out.println("importData rejected: " + flavor);
					// Don't return; try next flavor.
				}
			} catch (IOException ex) {
				System.err.println("IOError getting data: " + ex);
			} catch (UnsupportedFlavorException e) {
				System.err.println("Unsupported Flavor: " + e);
			}
		}
		// If you get here, I didn't like the flavor.
		Toolkit.getDefaultToolkit().beep();
		return false;
	}
}
//@@@@@@//
//gui/datatransfer/Transfer.java
//@@@@@@//
package datatransfer;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;

/**
 * Demonstrate various aspects of Swing "data transfer".
 * @author Ian Darwin, http://www.darwinsys.com
 * @author Jonathan Fuerth, http://www.SQLPower.ca
 */
public class Transfer extends JFrame {
	public static void main(String[] args) {
		new Transfer().setVisible(true);
	}

	private JTextField tf;
	private JLabel l;
	private JComboBox propertyComboBox;

	public Transfer() {

		// Establish the GUI
		Container cp = new Box(BoxLayout.X_AXIS);
		setContentPane(cp);
		JPanel firstPanel = new JPanel();
		propertyComboBox = new JComboBox();
		propertyComboBox.addItem("text");
		propertyComboBox.addItem("font");
		propertyComboBox.addItem("background");
		propertyComboBox.addItem("foreground");
		firstPanel.add(propertyComboBox);
		cp.add(firstPanel);
		cp.add(Box.createGlue());

		tf = new JTextField("Hello");
		tf.setForeground(Color.RED);
		tf.setDragEnabled(true);
		cp.add(tf);

		cp.add(Box.createGlue());

		l = new JLabel("Hello");
		l.setBackground(Color.YELLOW);
		cp.add(l);

		cp.add(Box.createGlue());

		JSlider stryder = new JSlider(SwingConstants.VERTICAL);
		stryder.setMinimum(10);
		stryder.setValue(14);
		stryder.setMaximum(72);
		stryder.setMajorTickSpacing(10);
		stryder.setPaintTicks(true);

		cp.add(stryder);
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setSize(500, 300);

		// Add Listeners and Converters
		setMyTransferHandlers((String)propertyComboBox.getSelectedItem());

		// Mousing in the Label starts a Drag.
		MouseListener myDragListener = new MouseAdapter() {
			public void mousePressed(MouseEvent e) {
				JComponent c = (JComponent)e.getSource();
				TransferHandler handler = c.getTransferHandler();
				handler.exportAsDrag(c, e, TransferHandler.COPY);
			}
		};
		l.addMouseListener(myDragListener);

		// Selecting in the ComboBox makes that the property that is xfered.
		propertyComboBox.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ce) {
				JComboBox bx = (JComboBox)ce.getSource();
				String prop = (String)bx.getSelectedItem();
				setMyTransferHandlers(prop);
			}
		});

		// Typing a word and pressing enter in the TextField tries
		// to set that as the font name.
		tf.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				JTextField jtf = (JTextField)evt.getSource();
				String fontName = jtf.getText();
				Font font = new Font(fontName, Font.BOLD, 18);
				tf.setFont(font);
			}
		});

		// Setting the Slider sets that font into the textfield.
		stryder.addChangeListener(new ChangeListener() {
			public void stateChanged(ChangeEvent evt)  {
				JSlider sl = (JSlider)evt.getSource();
				Font oldf = tf.getFont();
				Font newf = oldf.deriveFont((float)sl.getValue());
				tf.setFont(newf);
			}
		});

	}

	private void setMyTransferHandlers(String s) {
		TransferHandler th = new TransferHandler(s);
		tf.setTransferHandler(th);
		l.setTransferHandler(th);
	}
}
//@@@@@@//
//gui/ErrorHandler.java
//@@@@@@//
/** This class is usable by AWT to handle exceptions.
 * System.setProperty("sun.awt.exception.handler", "ErrorHandler");
 * This usage is documented in the source code up to 1.4Beta for
 * java.awt.EventDispatchThread. This class exists in all standard
 * implementations (try "javap java.awt.EventQueueDispatchThread"), but
 * is not public so there's no javadoc.  NOTE: there is
 * a strong admonition that the interface WILL be changed in future.
 * <p>
 * In real life this could be part of your application, and can
 * do almost anything. The error handler itself does not need
 * to import awt, awt.event, swing, or anything else.
 *
 * @author	Ian Darwin
 * @version	$Id: ErrorHandler.java,v 1.4 2003/08/24 12:31:03 ian Exp $
 */
public class ErrorHandler extends java.lang.Object {

	/** Default constructor must exist (I know it's the default;
	 * this is here in case somebody adds any other constructor).
	 */
	public ErrorHandler() {
		System.out.println("CONSTRUCTED");
	}

	public void handle(Throwable t) {
		System.err.println("Hey, I caught it!");
		System.err.println(t.toString());
	}
}
//@@@@@@//
//gui/ErrorHandlerTest.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** Contrived program showing how to catch Exceptions
 * that occur on the event dispatching thread. Define the System 
 * property "sun.awt.exception.handler" to name a class with a method
 * <pre>public void handle(Throwable t)</pre>.
 * <p>
 * That really is all you have to do to catch GUI Exceptions.
 * But it may change at any time (hence the name sun.awt...).
 * @author Ian Darwin.
 */
public class ErrorHandlerTest extends JFrame {

	/** A fairly banal GUI, just to show interaction.
	 */
	ErrorHandlerTest() {
		super("GUI");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Container cp = getContentPane();
		JButton bx = new JButton("Throw!");
		bx.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				throw new IllegalArgumentException("foo");
			}
		});
		cp.add(bx);
		setBounds(200, 200, 200, 100);
	}

	public static void main(String[] args) {
		// Tell AWT to invoke my Handler.
		System.setProperty("sun.awt.exception.handler", "ErrorHandler");

		// Now create and show the GUI.
		new ErrorHandlerTest().setVisible(true);
	}
}
//@@@@@@//
//gui/FieldEdit.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/**
 * FieldEdit - an Applet to validate data as it's being entered.
 *
 * Not very general: a 52 minute hack to show the mechanics of editing.
 *
 * Does try to leave the cursor in exactly the right position.
 *
 * @author Ian Darwin, http://www.darwinsys.com/
 * @author Bjorn Gudehus, gothic@celestica.com
 */
public class FieldEdit extends Applet {
	/** The label to display the type of thing we're editing */
	private Label myLabel;
	/** The textfield to enter */
	private TextField textField;

	/** Init() is an Applet method used to set up the GUI and listeners */
	public void init() {
		add(myLabel = new Label("Hex:"));
		add(textField = new TextField(10));
		textField.addTextListener(new TextListener() {
			public void textValueChanged(TextEvent ev) {
				int caret = -1;
				TextField tf = FieldEdit.this.textField;
				String s = tf.getText();
				StringBuffer sb = new StringBuffer();
				System.out.println("Text->" + s);
				for (int i=0; i<s.length(); i++) {
					char c = s.charAt(i);
					if (Character.digit(c, 16) >= 0)
						sb.append(c);
					else
						caret = tf.getCaretPosition()-1;
				}
				if (caret >= 0) {
					tf.setText(sb.toString());
					tf.setCaretPosition(caret);
					Toolkit.getDefaultToolkit().beep();
				}
			}
		});
	}
}
//@@@@@@//
//gui/FileDialogDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;

public class FileDialogDemo extends Frame {
	FileDialog fc;

	/** Construct a FileDialogDemo */ 
	FileDialogDemo() {
		super("FileDialogDemo");
		setSize(200, 200);

		// Construct, but don't show, the file dialog.
		fc = new FileDialog(this, "Choose a file", FileDialog.LOAD);
		// Set its starting directory to the root, not where we run it
		// (just to show that there are some methods you can call on it).
		fc.setDirectory("C:\\");

		Button b;
		add(b = new Button("Browse..."));	// Create and add a Button
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				// Make the dialog appear, and wait for it.
				fc.setVisible(true);
				// If we get here, user either chose a file or did CANCEL.
				String fn = fc.getFile();
				if (fn == null)
					System.out.println("You cancelled the choice");
				else
					System.out.println("You chose " + fn);
			}
		});
	}

	/** main test program: construct the Frame and show it */
	public static void main(String[] a) {
		new FileDialogDemo().setVisible(true);
	}
}
//@@@@@@//
//gui/FileTree.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import javax.swing.tree.*;
import javax.swing.event.*;
import java.io.*;
import java.util.*;

/**
 * Display a file system in a JTree view
 *
 * @version $Id: FileTree.java,v 1.9 2004/02/23 03:39:22 ian Exp $
 * @author Ian Darwin
 */
public class FileTree extends JPanel 
{ 
	/** Construct a FileTree */
    public FileTree(File dir) {
		setLayout(new BorderLayout());

		// Make a tree list with all the nodes, and make it a JTree
		JTree tree = new JTree(addNodes(null, dir));

		// Add a listener
		tree.addTreeSelectionListener(new TreeSelectionListener() {
			public void valueChanged(TreeSelectionEvent e) {
				DefaultMutableTreeNode node =
					(DefaultMutableTreeNode)e.getPath().getLastPathComponent();
				System.out.println("You selected " + node);
			}
		});

		// Lastly, put the JTree into a JScrollPane.
		JScrollPane scrollpane = new JScrollPane();
		scrollpane.getViewport().add(tree);
		add(BorderLayout.CENTER, scrollpane);
    }

	/** Add nodes from under "dir" into curTop. Highly recursive. */
	DefaultMutableTreeNode addNodes(DefaultMutableTreeNode curTop, File dir) {
		String curPath = dir.getPath();
		DefaultMutableTreeNode curDir = new DefaultMutableTreeNode(curPath);
		if (curTop != null) {	// should only be null at root
			curTop.add(curDir);
		}
		Vector ol = new Vector();
		String[] tmp = dir.list();
		for (int i=0; i<tmp.length; i++)
			ol.addElement(tmp[i]);
		Collections.sort(ol, String.CASE_INSENSITIVE_ORDER);
		File f;
		Vector files = new Vector();
		// Make two passes, one for Dirs and one for Files. This is #1.
		for (int i=0; i<ol.size(); i++) {
			String thisObject = (String)ol.elementAt(i);
			String newPath;
			if (curPath.equals("."))
				newPath = thisObject;
			else
				newPath = curPath + File.separator + thisObject;
			if ((f = new File(newPath)).isDirectory())
				addNodes(curDir,  f);
			else
				files.addElement(thisObject);
		}
		// Pass two: for files.
		for (int fnum=0; fnum<files.size(); fnum++)
			curDir.add(new DefaultMutableTreeNode(files.elementAt(fnum)));
		return curDir;
	}

	public Dimension getMinimumSize() {
		return new Dimension(200, 400);
	}

	public Dimension getPreferredSize() {
		return new Dimension(200, 400);
	}

	/** Main: make a Frame, add a FileTree */
    public static void main(String[] av) {

		JFrame frame = new JFrame("FileTree");
		frame.setForeground(Color.black);
		frame.setBackground(Color.lightGray);
		Container cp = frame.getContentPane();

		if (av.length == 0) {
			cp.add(new FileTree(new File(".")));
		} else {
			cp.setLayout(new BoxLayout(cp, BoxLayout.X_AXIS));
			for (int i=0; i<av.length; i++)
				cp.add(new FileTree(new File(av[i])));
		}

		frame.pack();
		frame.setVisible(true);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}
//@@@@@@//
//gui/FlowLayoutSimple.java
//@@@@@@//
import java.awt.FlowLayout;

import javax.swing.JButton;
import javax.swing.JFrame;

/** Just a Frame
 * @version $Id: FlowLayoutSimple.java,v 1.2 2004/02/23 03:39:22 ian Exp $
 */
public class FlowLayoutSimple extends JFrame {
	JButton quitButton;

	/** Construct the object including its GUI */
	public FlowLayoutSimple() {
		super("JFrameSimple");

		getContentPane().setLayout(new FlowLayout());
		getContentPane().add(quitButton = new JButton("Start"));
		getContentPane().add(quitButton = new JButton("Stop"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));
		getContentPane().add(quitButton = new JButton("Exit"));

		// Set up so that "Close" will exit the program
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		pack();
	}

	public static void main(String[] args) {
		new FlowLayoutSimple().setVisible(true);
	}
}
//@@@@@@//
//gui/FontChooser.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** A font selection dialog.
 * <p>Note: can take a long time to start up on systems
 * with (literally) hundreds of fonts.
 * TODO change list to JList, add a SelectionChangedListener to preview.
 * @author	Ian Darwin
 * @version $Id: FontChooser.java,v 1.19 2004/03/20 20:44:56 ian Exp $
 */
public class FontChooser extends JDialog {

	// Results:

	/** The font the user has chosen */
	protected Font resultFont;
	/** The resulting font name */
	protected String resultName;
	/** The resulting font size */
	protected int resultSize;
	/** The resulting boldness */
	protected boolean isBold;
	/** The resulting italicness */
	protected boolean isItalic;

	// Working fields

	/** Display text */
	protected String displayText = "Qwerty Yuiop";
	/** The list of Fonts */
	protected String fontList[];
	/** The font name chooser */
	protected List fontNameChoice;
	/** The font size chooser */
	protected List fontSizeChoice;
	/** The bold and italic choosers */
	Checkbox bold, italic;

	/** The list of font sizes */
	protected String fontSizes[] = {
		"8", "10", "11", "12", "14", "16", "18", "20", "24",
		"30", "36", "40", "48", "60", "72"
		};
	/** The index of the default size (e.g., 14 point == 4) */
	protected static final int DEFAULT_SIZE = 4;
	/** The display area. Use a JLabel as the AWT label doesn't always
	 * honor setFont() in a timely fashion :-)
	 */
	protected JLabel previewArea;

	/** Construct a FontChooser -- Sets title and gets 
	 * array of fonts on the system. Builds a GUI to let
	 * the user choose one font at one size.
	 */
	public FontChooser(Frame f) {
		super(f, "Font Chooser", true);

		Container cp = getContentPane();

		Panel top = new Panel();
		top.setLayout(new FlowLayout());

		fontNameChoice = new List(8);
		top.add(fontNameChoice);

		Toolkit toolkit = Toolkit.getDefaultToolkit();
		// For JDK 1.1: returns about 10 names (Serif, SansSerif, etc.)
		// fontList = toolkit.getFontList();
		// For JDK 1.2: a much longer list; most of the names that come
		// with your OS (e.g., Arial), plus the Sun/Java ones (Lucida, 
		// Lucida Bright, Lucida Sans...)
		fontList = GraphicsEnvironment.getLocalGraphicsEnvironment().
			getAvailableFontFamilyNames();

		for (int i=0; i<fontList.length; i++)
			fontNameChoice.add(fontList[i]);
		fontNameChoice.select(0);

		fontSizeChoice = new List(8);
		top.add(fontSizeChoice);

		for (int i=0; i<fontSizes.length; i++)
			fontSizeChoice.add(fontSizes[i]);
		fontSizeChoice.select(DEFAULT_SIZE);

		cp.add(top, BorderLayout.NORTH);

		Panel attrs = new Panel();
		top.add(attrs);
		attrs.setLayout(new GridLayout(0,1));
		attrs.add(bold  =new Checkbox("Bold", false));
		attrs.add(italic=new Checkbox("Italic", false));

		previewArea = new JLabel(displayText, JLabel.CENTER);
		previewArea.setSize(200, 50);
		cp.add(previewArea, BorderLayout.CENTER);

		Panel bot = new Panel();

		JButton okButton = new JButton("Apply");
		bot.add(okButton);
		okButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				previewFont();
				dispose();
				setVisible(false);
			}
		});

		JButton pvButton = new JButton("Preview");
		bot.add(pvButton);
		pvButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				previewFont();
			}
		});

		JButton canButton = new JButton("Cancel");
		bot.add(canButton);
		canButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				// Set all values to null. Better: restore previous.
				resultFont = null;
				resultName = null;
				resultSize = 0;
				isBold = false;
				isItalic = false;

				dispose();
				setVisible(false);
			}
		});

		cp.add(bot, BorderLayout.SOUTH);

		previewFont(); // ensure view is up to date!

		pack();
		setLocation(100, 100);
	}

	/** Called from the action handlers to get the font info,
	 * build a font, and set it.
	 */
	protected void previewFont() {
		resultName = fontNameChoice.getSelectedItem();
		String resultSizeName = fontSizeChoice.getSelectedItem();
		int resultSize = Integer.parseInt(resultSizeName);
		isBold = bold.getState();
		isItalic = italic.getState();
		int attrs = Font.PLAIN;
		if (isBold) attrs = Font.BOLD;
		if (isItalic) attrs |= Font.ITALIC;
		resultFont = new Font(resultName, attrs, resultSize);
		// System.out.println("resultName = " + resultName + "; " +
		//		 "resultFont = " + resultFont);
		previewArea.setFont(resultFont);
		pack();				// ensure Dialog is big enough.
	}

	/** Retrieve the selected font name. */
	public String getSelectedName() {
		return resultName;
	}
	/** Retrieve the selected size */
	public int getSelectedSize() {
		return resultSize;
	}

	/** Retrieve the selected font, or null */
	public Font getSelectedFont() {
		return resultFont;
	}

	/** Simple main program to start it running */
	public static void main(String[] args) {
		final JFrame f = new JFrame("FontChooser Startup");
		final FontChooser fc = new FontChooser(f);
		final Container cp = f.getContentPane();
		cp.setLayout(new GridLayout(0, 1));	// one vertical column

		JButton theButton = new JButton("Change font");
		cp.add(theButton);

		final JLabel theLabel = new JLabel("Java is great!", JLabel.CENTER);
		cp.add(theLabel);

		// Now that theButton and theLabel are ready, make the action listener
		theButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				fc.setVisible(true);
				Font myNewFont = fc.getSelectedFont();
				System.out.println("You chose " + myNewFont);
				theLabel.setFont(myNewFont);
				f.pack();		// adjust for new size
				fc.dispose();
			}
		});

		f.setSize(150, 100);
		f.setVisible(true);
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}
//@@@@@@//
//gui/FrameDemo.java
//@@@@@@//
import java.awt.*;

/** Make a Frame with two Panels.
 * @version $Id: FrameDemo.java,v 1.4 2004/03/08 01:38:17 ian Exp $
 */
public class FrameDemo extends Frame {
	/** "main program" method - construct and show */
	public static void main(String[] av) {
		new FrameDemo().setVisible(true);
	}

	/** Construct the object including its GUI */
	public FrameDemo() {
		setTitle("FrameDemo");
		Panel top_frame = new Panel();
		top_frame.add(new Label("User"));
		top_frame.add(new TextField(10));
		top_frame.add(new Label("Password"));
		top_frame.add(new TextField(10));
		add(top_frame, BorderLayout.NORTH);
		Panel bottom_frame = new Panel();
		bottom_frame.add(new Button("OK"));
		bottom_frame.add(new Button("Cancel"));
		add(bottom_frame, BorderLayout.SOUTH);
		pack();
	}
}
//@@@@@@//
//gui/FrameIcon.java
//@@@@@@//
import java.awt.*;

public class FrameIcon {

	/** Demo main program, showing two ways to use it.
	 * Create a small MemImage and set it as this Frame's iconImage. 
	 * Also display a larger version of the same image in the Frame.
	 */
	public static void main(String[] av) {
		Frame f = new Frame("FrameIcon");
		Image im = 
			Toolkit.getDefaultToolkit().getImage("FrameIcon.gif");
		f.setIconImage(im);
		f.setSize(100, 100);
		f.setLocation(200, 200);
		f.setVisible(true);
	}
}
//@@@@@@//
//gui/FXTrack.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
import java.net.*;
import java.text.*;
import java.util.*;

/**
 * Simple Applet to track a Fedex shipment without having to wait
 * for all of FedEx's bloated images to download.
 *
 * @Note: The URL used was garnered empirically, is not documented,
 * and is subject to change without notice! USE AT OWN RISK.
 *
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: FXTrack.java,v 1.4 2004/02/09 03:33:49 ian Exp $
 */

public class FXTrack extends Applet {
	GregorianCalendar gc = new GregorianCalendar(); // today
	DecimalFormat nf = new DecimalFormat("00");
	String shipDate;
	/** The choice item for destination country */
	Choice destChooser;

	ActionListener handler = new ActionListener() {
		public void actionPerformed(ActionEvent e) {
			URL destURL = null;
			try {
				destURL = new URL("http://www.fedex.com/cgi-bin/track_it?" +
				"&kurrent_airbill=" + numField.getText() + "|" +
					destChooser.getSelectedItem() + "|" + shipDate +
					// following boilerplate seems needed
					"&language=english&cntry_code=us&state=0");
			} catch (MalformedURLException err) {
				System.err.println("Error!\n" + err);
				showStatus("Error, look in Java Console for details!");
			}
			// debug...
			System.out.println("URL = " + destURL);

			// "And then a miracle occurs..."
			FXTrack.this.getAppletContext().showDocument(destURL);
		}
	};

	protected Button goButton;
	protected TextField numField;

	public void init() {
		setBackground(Color.pink);
		setLayout(new GridLayout(3,2));
		add(new Label("Dest. Country:", Label.RIGHT));
		add(destChooser = new Choice());
		destChooser.add("ca");
		destChooser.select(0);
		destChooser.add("sv");
		destChooser.add("uk");
		destChooser.add("us");
		add(new Label("Waybill #", Label.RIGHT));
		add(numField = new TextField(12));
		numField.addActionListener(handler);
		add(new Label());	// filler, for grid
		add(goButton = new Button("Go for it!"));
		goButton.addActionListener(handler);

		gc.roll(Calendar.DAY_OF_MONTH, false);			// yesterday
		shipDate = 	// mmddyy format
			nf.format(gc.get(Calendar.MONTH)+1) +		/* zero-based */
			nf.format(gc.get(Calendar.DAY_OF_MONTH)) +
			nf.format(gc.get(Calendar.YEAR)%100);
	}
}
//@@@@@@//
//gui/GlassExample.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/* Demonstrate use of GlassPane in JWindow & friends.
 * Buttons enable/disable it.
 * @author Eckstein et al, in the O'Reilly book "Java Swing"
 */
public class GlassExample {

	/** Construct a Splash screen with the given image */
	public static void main(String[] args) {
		JFrame f = new JFrame("GlassPane");
		
		final JPanel p1 = new JPanel();
		p1.add(new JLabel("GlassPane Example"));
		JButton show = new JButton("Show");
		p1.add(show);
		p1.add(new JButton("No-op"));
		f.getContentPane().add(p1);

		final JPanel glass = (JPanel)f.getGlassPane();

		glass.setVisible(true);
		glass.setLayout(new GridBagLayout());
		JButton glassButton = new JButton("Hide");
		glass.add(glassButton);

		f.setSize(150, 80);
		f.setVisible(true);

		boolean debug = false;
		if (debug) {
			System.out.println("Button is " + glassButton);
			System.out.println("GlassPane is " + glass);
		}

		// Add actions to the buttons...

		// show button (re-)shows the glass pane.
		show.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				glass.setVisible(true);
				p1.repaint();
			}
		});
		// hide button hides the Glass Pane to show what's under.
		glassButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				glass.setVisible(false);
				p1.repaint();
			}
		});
	}

}
//@@@@@@//
//gui/GoToPage.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** Implement a simple "Go To Page" dialog
 * Row one: "Go to Page", textfield
 * second OK, Cancel buttons.
 */
public class GoToPage extends Dialog {
	/** TextField used to enter the number */
	protected TextField tf;
	/** The OK button */
	protected JButton ok;
	/** The cancel button */
	protected JButton can;

	/** Construct a GoToPage window (no actions yet) */
	public GoToPage(JFrame f, String title) {
		super(f);
		setTitle(title);

		Label l = new Label("Page Number:");
		tf = new TextField(4);
		tf.setText("1");
		// set the text initially selected so you can easily overtype it
		tf.selectAll();

		ok = new JButton("OK");
		can = new JButton("Cancel");

		Panel top = new Panel();
		top.add(l);
		top.add(tf);

		Panel bottom = new Panel();
		bottom.add(ok);
		bottom.add(can);

		add(BorderLayout.NORTH, top);
		add(BorderLayout.SOUTH, bottom);

		pack();
	}

	protected int getValue() {
		int i = Integer.parseInt(tf.getText());
		return i;
	}

	public static void main(String[] unused) {
		final JFrame f = new JFrame("Page Dialog Test");
		JButton b;
		f.getContentPane().add(b = new JButton("Show Dialog"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				new GoToPage(f, "GoToPage Demo").setVisible(true);
			}
		});
		f.pack();
		f.setVisible(true);
	}
}
//@@@@@@//
//gui/GridLayDemo.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

/** Simple GridLayout demo program. */
public class GridLayDemo extends Applet implements ActionListener {
	public void init() {
		Button b;
		setLayout(new GridLayout(2,3));
		add(b=new Button("B1"));
		b.addActionListener(this);
		add(b=new Button("B2"));
		b.addActionListener(this);
		add(b=new Button("B3"));
		b.addActionListener(this);
		add(b=new Button("C1"));
		b.addActionListener(this);
		add(b=new Button("C2"));
		b.addActionListener(this);
		add(b=new Button("C3"));
		b.addActionListener(this);
	}
	public void actionPerformed(ActionEvent ev) {
		showStatus("You pressed " + ev.getActionCommand());
	}
}
//@@@@@@//
//gui/HelpDemo.java
//@@@@@@//
import java.io.*;

/**
 * ExecDemoHelp shows how to use the Win32 "start" command to load a help file.
 * Written long before JavaHelp API, which probably should be use instead.
 */
public class HelpDemo {
	/** A simple main program, to show calling help(). */
	public static void main(String[] av) throws IOException { 
		new HelpDemo().help();
		return;
	}

	/** 
	 * help() -- start a help viewer.
	 * On Win32, we use the "start" command.
	 * For UNIX, we'll try for Netscape or HotJava in the user's path.
	 * For the Mac, not sure what we'll do.
	 */
	public void help() throws IOException {

		// A Runtime object has methods for dealing with the OS
		Runtime r = Runtime.getRuntime();
		// A process object tracks one external running process
		Process p;
		
		// Start Netscape from Java Applications (not Applets though)
		p = r.exec("c:/windows/command/start.exe HelpDemo.htm");

		return;
	}
}
//@@@@@@//
//gui/JColorDemo.java
//@@@@@@//
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

/* 
 * Colors - demo of Swing JColorChooser.
 * Swing's JColorChooser can be used in three ways:
 * <ul>
 * <li>Construct it and place it in a panel;</li>
 * <li>Call its createDialog() and get a JDialog back;</li>
 * <li>Call its showDialog() and get back the chosen color.</li>
 * </ul>
 * <p>We use the last method, as it's the simplest, and is how
 * you'd most likely use it in a real application.
 *
 * @version $Id: JColorDemo.java,v 1.11 2004/02/23 03:39:22 ian Exp $
 * Originally appeared in the Linux Journal, 1999.
 */
public class JColorDemo extends JFrame
{
	/** A canvas to display the color in. */
    protected JLabel demo;

	/** Constructor - set up the entire GUI for this program */
    public JColorDemo() {
        super("Swing Color Demo");
		Container cp = getContentPane();
        JButton jButton;
        cp.add(jButton = new JButton("Change Color..."), BorderLayout.NORTH);
		jButton.setToolTipText("Click here to see the Color Chooser");
        jButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent actionEvent)
			{
				Color ch = JColorChooser.showDialog(
					JColorDemo.this,				// parent
					"Swing Demo Color Popup",	// title
					demo.getForeground());			// default
				System.out.println("Your selected color is " + ch);
				if (ch != null) {
					demo.setForeground(ch);
					demo.repaint();
				}
			}
		});
        cp.add(BorderLayout.CENTER, demo = 
			new JLabel("Your One True Color", JLabel.CENTER));
		demo.setToolTipText("This is the last color you chose");
        pack();
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}

	/** good old main */
    public static void main(String[] argv)
    {
        new JColorDemo().setVisible(true);
    }
}
//@@@@@@//
//gui/JFileChooserDemo.java
//@@@@@@//
import javax.swing.*;
import java.awt.event.*;
import java.io.*;

/** A simple demo of a JFileChooser in action. */
public class JFileChooserDemo extends JPanel {

	/** Constructor */
	public JFileChooserDemo(JFrame f) {
		final JFrame frame = f;
		final JFileChooser chooser = new JFileChooser();

		// If want the user to select only directories, use this.
		// Default is to allow selection of files only.
		// Note if you set the selection mode to DIRECTORIES_ONLY,
		// it no longer displays any files, even with the file view.

		// chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

		// If want it to only show certain file types, use a FileFilter.
		// N.B. JFileFilter is not in javax.swing; it is my implementation
		// of interface javax.swing.filechooser.FileFilter, and is similar
		// to the ExtentionFilter in demo/jfc accompanying the J2SE SDK.
		JFileFilter filter = new JFileFilter();
		filter.addType("java");
		filter.addType("class");
		filter.addType("jar");
		filter.setDescription("Java-related files");
		chooser.addChoosableFileFilter(filter);
		JButton b = new JButton("Choose file...");
		add(b);
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			int returnVal = chooser.showOpenDialog(frame);
			if (returnVal == JFileChooser.APPROVE_OPTION) {
				File file = chooser.getSelectedFile();
				System.out.println("You chose a " + 
					(file.isFile() ? "file" : "directory") +
					" named: " + file.getPath());
			} else {
				System.out.println("You did not choose a filesystem object.");
			}
			}
		});
	}


	public static void main(String[] args) {
		JFrame f = new JFrame("JFileChooser Demo");
		f.getContentPane().add(new JFileChooserDemo(f));
		f.pack();
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.setVisible(true);
	}
}
//@@@@@@//
//gui/JFileFilter.java
//@@@@@@//
import java.io.File;
import java.util.*;

/** A simple FileFilter class that works by filename extension,
 * like the one in the JDK demo called ExampleFileFilter, which
 * has been announced to be supported in a future Swing release.
 */
class JFileFilter extends javax.swing.filechooser.FileFilter {
	protected String description;
	protected ArrayList exts = new ArrayList();

	public void addType(String s) {
		exts.add(s);
	}

	/** Return true if the given file is accepted by this filter. */
	public boolean accept(File f) {
		// Little trick: if you don't do this, only directory names
		// ending in one of the extentions appear in the window.
		if (f.isDirectory()) {
			return true;

		} else if (f.isFile()) {
			Iterator it = exts.iterator();
			while (it.hasNext()) {
				if (f.getName().endsWith((String)it.next()))
					return true;
			}
		}

		// A file that didn't match, or a weirdo (e.g. UNIX device file?).
		return false;
	}

	/** Set the printable description of this filter. */
	public void setDescription(String s) {
		description = s;
	}
	/** Return the printable description of this filter. */
	public String getDescription() {
		return description;
	}
}
//@@@@@@//
//gui/JFrameDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** Just a Frame
 * @version $Id: JFrameDemo.java,v 1.13 2004/03/20 20:44:05 ian Exp $
 */
public class JFrameDemo extends JFrame {
	JButton quitButton;

	/** Construct the object including its GUI */
	public JFrameDemo() {
		super("JFrameDemo");
		Container cp = getContentPane();
		cp.add(quitButton = new JButton("Exit"));

		// Set up so that "Close" will exit the program, 
		// not just close the JFrame.
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		// This "action handler" will be explained later in the chapter.
		quitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
			
		pack();
	}
	public static void main(String[] args) {
		new JFrameDemo().setVisible(true);
	}
}
//@@@@@@//
//gui/JFrameDemoMain.java
//@@@@@@//
public class JFrameDemoMain {
	// We need a main program to instantiate and show.
	public static void main(String[] args) {
		new JFrameDemo().setVisible(true);
	}
}
//@@@@@@//
//gui/JFrameDemoSafe.java
//@@@@@@//
import java.awt.EventQueue;
import javax.swing.JFrame;

/** Create a JFrame class in a thread-safe way.
 * <br/>
 * See http://java.sun.com/developer/JDCTechTips/2003/tt1208.html.
 */
public class JFrameDemoSafe {
	// We need a main program to instantiate and show.
	public static void main(String[] args) {

		// Create the GUI (variable is final because used by inner class).
		final JFrame demo = new JFrameDemo();

		// Create a Runnable to set the main visible, and get Swing to invoke.
        EventQueue.invokeLater(new Runnable() {
			public void run() {
				demo.setVisible(true);
			}
		});
	}
}
//@@@@@@//
//gui/JFrameFlowLayout.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

public class JFrameFlowLayout extends JFrame {
	public JFrameFlowLayout() {
		Container cp = getContentPane();

		// Make sure it has a FlowLayout layoutmanager.
		cp.setLayout(new FlowLayout());

		// now add Components to "cp"...
		cp.add(new JLabel("Wonderful?"));
		cp.add(new JButton("Yes!"));
		pack();
	}

	// We need a main program to instantiate and show.
	public static void main(String[] args) {
		new JFrameFlowLayout().setVisible(true);
	}
}
//@@@@@@//
//gui/JFrameSimple.java
//@@@@@@//
import javax.swing.JButton;
import javax.swing.JFrame;

/** Just a Frame
 * @version $Id: JFrameSimple.java,v 1.2 2004/02/23 03:39:22 ian Exp $
 */
public class JFrameSimple extends JFrame {
	JButton quitButton;

	/** Construct the object including its GUI */
	public JFrameSimple() {
		super("JFrameSimple");

		getContentPane().add(quitButton = new JButton("Exit"));

		// Set up so that "Close" will exit the program
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		pack();
	}

	public static void main(String[] args) {
		new JFrameSimple().setVisible(true);
	}
}
//@@@@@@//
//gui/JIFrameDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/**
 * Internal Frames Demo
 * @version $Id: JIFrameDemo.java,v 1.4 2003/07/15 01:46:47 ian Exp $
 */
public class JIFrameDemo {

	/* Main View */
	public static void main(String[] a) {
		final JFrame jf = new JFrame("JIFrameDemo Main Window");

        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
		screenSize.width -= 42;
		screenSize.height -= 42;
		jf.setSize(screenSize);
		jf.setLocation(20, 20);

		JMenuBar mb = new JMenuBar();
		jf.setJMenuBar(mb);
		JMenu fm = new JMenu("File");
		mb.add(fm);
		JMenuItem mi;
		fm.add(mi = new JMenuItem("Exit"));
		mi. addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.exit(0);
			}
		});

		JDesktopPane dtp = new JDesktopPane();
		//dtp.setBackground(Color.GREEN);
		jf.setContentPane(dtp);

		JInternalFrame mboxFrame = 
			new JInternalFrame("Mail Reader", true, true, true, true);
		JLabel reader = new JLabel("Mail Reader Would Be Here");
		mboxFrame.setContentPane(reader);
		mboxFrame.setSize(400, 300);
		mboxFrame.setLocation(50, 50);
		mboxFrame.setVisible(true);
		dtp.add(mboxFrame);

		JInternalFrame compFrame = 
			new JInternalFrame("Compose Mail", true, true, true, true);
		JLabel composer = new JLabel("Mail Compose Would Be Here");
		compFrame.setContentPane(composer);
		compFrame.setSize(300, 200);
		compFrame.setLocation(200, 200);
		compFrame.setVisible(true);
		dtp.add(compFrame);

		JInternalFrame listFrame = 
			new JInternalFrame("Users", true, true, true, true);
		JLabel list = new JLabel("List of Users Would Be Here");
		listFrame.setContentPane(list);
		listFrame.setLocation(400, 400);
		listFrame.setSize(500, 200);
		listFrame.setVisible(true);
		dtp.add(listFrame);

		jf.setVisible(true);
        jf.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
			jf.setVisible(false);
			jf.dispose();
			System.exit(0);
			}
		});
	}
}
//@@@@@@//
//gui/JLabelHTMLDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** Show a JLabel containing HTML.
 * @version $Id: JLabelHTMLDemo.java,v 1.2 2004/03/20 20:44:07 ian Exp $
 */
public class JLabelHTMLDemo extends JFrame {

	/** Construct the object including its GUI */
	public JLabelHTMLDemo() {
		super("JLabelHTMLDemo");
		Container cp = getContentPane();

		JButton component = new JButton(
			"<html>" +
			"<body bgcolor='white'>" +
			"<h1><font color='red'>Welcome</font></h1>" +
			"<p>This button will be formatted according to the usual " +
			"HTML rules for formatting of paragraphs.</p>" +
			"</body></html>");

		component.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				System.out.println("Thank you!");
			}
		});
		cp.add(BorderLayout.CENTER, component);

		setSize(200, 400);

		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
	public static void main(String[] args) {
		new JLabelHTMLDemo().setVisible(true);
	}
}
//@@@@@@//
//gui/JListDemo.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import javax.swing.event.*;
import java.util.*;

/** Demonstrate Swing "JList" ScrollingList.
 */
public class JListDemo extends JFrame {
	JList list = null;

	JListDemo(String s) {
		super(s);
		Container cp = getContentPane();
		cp.setLayout(new FlowLayout());
		ArrayList data = new ArrayList();
		data.add("Hi");
		data.add("Hello");
		data.add("Goodbye");
		data.add("Adieu");
		data.add("Adios");
		list = new JList(data.toArray());
		list.addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent evt) {
				if (evt.getValueIsAdjusting())
					return;
				System.out.println("Selected from " +
					evt.getFirstIndex() + " to " + evt.getLastIndex());
			}
		});
		cp.add(list, BorderLayout.CENTER);
	}

	public static void main(String[] s) {
		JListDemo l = new JListDemo("Greetings");
		l.pack();
		l.setVisible(true);
	}
}
//@@@@@@//
//gui/JListModelDemo.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import javax.swing.event.*;

/** Demonstrate Swing "JList" ListModel
 * @author Ian Darwin
 * @author Tweaked by Jonathan Fuerth of SQLPower.ca
 */
public class JListModelDemo extends JListDemo {

	JListModelDemo(String s) {
		super(s);
		ListModel lm = new StaticListModel();
		list.setModel(lm);
		list.setCellRenderer(new MyCellRenderer());
		setDefaultCloseOperation(EXIT_ON_CLOSE);
	}

	public static void main(String[] s) {
		JListModelDemo l = new JListModelDemo("ListModel");
		l.pack();
		l.setVisible(true);
	}

	class MyCellRenderer extends JLabel implements ListCellRenderer {

		/* Get the Renderer for a given List Cell.
		 * This is the only method defined by ListCellRenderer.
		 * If the object is already a component, keep it, else
		 * toString it and wrap it in a JLabel.
		 * Reconfigure the Component each time we're called
		 * to accord for whether it's selected or not.
		 */
		public Component getListCellRendererComponent
			(
			 JList list,
			 Object value,            // value to display
			 int index,               // cell index
			 boolean isSelected,      // is the cell selected
			 boolean cellHasFocus)    // the list and the cell have the focus
		{
			Component c = null;
			if (value == null) {
				c = new JLabel("(null)");
			} else if (value instanceof Component) {
				c = (Component) value;
			} else {
				c = new JLabel(value.toString());
			}
			
			if ( isSelected ) {
				c.setBackground(list.getSelectionBackground());
				c.setForeground(list.getSelectionForeground());
			} else {
				c.setBackground(list.getBackground());
				c.setForeground(list.getForeground());
			}

			if ( c instanceof JComponent ) {
				((JComponent)c).setOpaque(true);
			}

			return c;
		}
	}

	class StaticListModel implements ListModel {
		private final Object[] data = {
			"Hello",
			new Object(),
			new java.util.Date(),
			new JLabel("Hello world!"),
			this,
		};

		public Object getElementAt(int index) {
			return data[index];
		}

		public int getSize() {
			return data.length;
		}

		public void addListDataListener(ListDataListener ldl) {
			// since the list never changes, we don't need this :-)
		}

		public void removeListDataListener(ListDataListener ldl) {
			// since the list never changes, we don't need this :-)
		}
	}
}

//@@@@@@//
//gui/JOptionDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/**
 * Demonstrate JOptionPane
 * @author Ian Darwin
 */
public class JOptionDemo extends JFrame {

	// Constructor
	JOptionDemo(String s) {
		super(s);

		Container cp = getContentPane();
		cp.setLayout(new FlowLayout());

		JButton b = new JButton("Give me a message");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				JOptionPane.showMessageDialog(
					JOptionDemo.this,
					"This is your message: etaoin shrdlu", "Coded Message",
					JOptionPane.INFORMATION_MESSAGE);
			}
		});
		cp.add(b);

		b = new JButton("Goodbye!");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.exit(0);
			}
		});
		cp.add(b);

		// size the main window
		pack();
	}

	public static void main(String[] arg) {
		JOptionDemo x = new JOptionDemo("Testing 1 2 3...");
		x.setVisible(true);
	}
}
//@@@@@@//
//gui/JTextAreaDemo.java
//@@@@@@//
import java.awt.Container;
import javax.swing.*;

public class JTextAreaDemo {
	public static void main(String[] args) {
		JFrame jf = new JFrame("whoo");
		Container cp = jf.getContentPane();
		cp.add(new JTextArea(10, 10));
		jf.pack();
		jf.setVisible(true);
	}
}
//@@@@@@//
//gui/JTreeDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.tree.*;

/** Simple JFC JTree demo
 * @version $Id: JTreeDemo.java,v 1.4 2002/08/25 01:31:29 ian Exp $
 */
public class JTreeDemo extends JFrame {
	JButton addButton, quitButton;
	JTree myTree;
	DefaultMutableTreeNode root, child;

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create a JTreeDemo object, tell it to show up
		new JTreeDemo().setVisible(true);
	}

	/** Construct the object including its GUI */
	public JTreeDemo() {
		super("JTreeDemo");
		Container cp = getContentPane();
		cp.setLayout(new BorderLayout());

		root = new DefaultMutableTreeNode("root");

		child = new DefaultMutableTreeNode("Colors"); 
		root.add(child);
		child.add(new DefaultMutableTreeNode("Cyan"));
		child.add(new DefaultMutableTreeNode("Magenta"));
		child.add(new DefaultMutableTreeNode("Yellow"));
		child.add(new DefaultMutableTreeNode("Black"));

		myTree = new JTree(root);

		// cp.add(BorderLayout.CENTER, myTree);
		//JScrollPane scroller = new JScrollPane();
		//scroller.getViewport().add(myTree);
		JScrollPane scroller = new JScrollPane(myTree);
		cp.add(BorderLayout.CENTER, scroller);

		cp.add(BorderLayout.NORTH, addButton = new JButton("Add"));
		addButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {

			// Insert more nodes into the tree
			child = new DefaultMutableTreeNode("Flavors");
			child.add(new DefaultMutableTreeNode("Java"));
			child.add(new DefaultMutableTreeNode("Espresso"));
			child.add(new DefaultMutableTreeNode("Hey Joe!"));
			child.add(new DefaultMutableTreeNode("Charcoal"));
			child.add(new DefaultMutableTreeNode("Paint Remover"));

			// Notify the model, which will add it and create an event, and
			// send it up the tree...

			((DefaultTreeModel)myTree.getModel()).insertNodeInto(child, root, 0);
			}
		});

		cp.add(BorderLayout.SOUTH, quitButton = new JButton("Exit"));
		quitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
		pack();
	}
}
//@@@@@@//
//gui/JTreeSimple.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** Simple JFC JTree Simple application, showing default tree contents.
 * Note that the JTree will display a silly demo with not Model provided.
 * @version $Id: JTreeSimple.java,v 1.2 2004/02/23 03:39:22 ian Exp $
 */
public class JTreeSimple extends JFrame {
	JButton addButton, quitButton;
	JTree myTree;

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create a JTreeSimple object, tell it to show up
		new JTreeSimple().setVisible(true);
	}

	/** Construct the object including its GUI */
	public JTreeSimple() {
		super("JTreeSimple");
		Container cp = getContentPane();
		cp.setLayout(new BorderLayout());

		myTree = new JTree();

		JScrollPane scroller = new JScrollPane(myTree);
		cp.add(BorderLayout.CENTER, scroller);

		cp.add(BorderLayout.SOUTH, quitButton = new JButton("Exit"));
		quitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		pack();
	}
}
//@@@@@@//
//gui/ListDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;

/** Demonstrate old AWT ScrollingList.
 * Note: You should normally use a Swing JList instead.
 */
public class ListDemo extends Frame {
	List list = null;

	ListDemo(String s) {
		super(s);
		setLayout(new FlowLayout());
		list = new List(10, false);
		list.add("Hello");
		list.add("Goodbye");
		list.addItemListener(new ItemListener() {
			public void itemStateChanged(ItemEvent e) {
				System.out.println("Selected: " + list.getSelectedItem());
			}
		});

		add(list);
	}

	public static void main(String[] s) {
		ListDemo l = new ListDemo("Up and down the list");
		l.pack();
		l.setVisible(true);
	}
}
//@@@@@@//
//gui/ListenerReuse.java
//@@@@@@//
// Demonstrate a listener being reused.

import java.awt.*;
import java.awt.event.*;

public class ListenerReuse extends Frame {
	public ListenerReuse() {
		Button b = new Button("Save");
		add(b);
		MenuBar mb = new MenuBar();
		setMenuBar(mb);
		Menu fm = new Menu("File");
		mb.add(fm);
		MenuItem mi = new MenuItem("Save");
		fm.add(mi);

		// Construct the ActionListener, and keep a reference to it.
		ActionListener saver = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.out.println("Saving your file...");
				// In real life we would call the doSave() method 
				// in the main class, something like this:
				// mainProg.doSave();
			}
		};
		// Register the actionListener with the Button
		b.addActionListener(saver);
		// And now register the same actionListener with the MenuItem
		mi.addActionListener(saver);
		pack();
	}

	/** Main just calls the above */
	public static void main(String[] a) {
		ListenerReuse lr = new ListenerReuse();
		lr.setVisible(true);
	}
}
//@@@@@@//
//gui/LNFSwitcher.java
//@@@@@@//
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.ButtonGroup;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JRadioButton;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;

/**
 * A Look-and-feel switcher.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version	$Id: LNFSwitcher.java,v 1.7 2004/03/07 04:03:15 ian Exp $
 */
public class LNFSwitcher {
	/** The frame. */
	protected JFrame theFrame;
	/** Its content pane */
	protected Container cp;

	/** Start with the Java look-and-feel, if possible */
	final static String PREFERREDLOOKANDFEELNAME =
		"javax.swing.plaf.metal.MetalLookAndFeel";
	protected String curLF = PREFERREDLOOKANDFEELNAME;
	protected JRadioButton previousButton;

	/** Construct a program... */
	public LNFSwitcher() {
		super();
		theFrame = new JFrame("LNF Switcher");
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		cp = theFrame.getContentPane();
		cp.setLayout(new FlowLayout());

		ButtonGroup bg = new ButtonGroup();

		JRadioButton bJava = new JRadioButton("Java");
		bJava.addActionListener(new LNFSetter(
			"javax.swing.plaf.metal.MetalLookAndFeel", bJava));
		bg.add(bJava);
		cp.add(bJava);

		JRadioButton bMSW  = new JRadioButton("MS-Windows");
		bMSW.addActionListener(new LNFSetter(
			"com.sun.java.swing.plaf.windows.WindowsLookAndFeel", bMSW));
		bg.add(bMSW);
		cp.add(bMSW);

		JRadioButton bMotif = new JRadioButton("Motif");
		bMotif.addActionListener(new LNFSetter(
			"com.sun.java.swing.plaf.motif.MotifLookAndFeel", bMotif));
		bg.add(bMotif);
		cp.add(bMotif);

		JRadioButton bMac = new JRadioButton("Sun-MacOS");
		bMac.addActionListener(new LNFSetter(
			"com.sun.java.swing.plaf.mac.MacLookAndFeel", bMac));
		bg.add(bMac);
		cp.add(bMac);

		String defaultLookAndFeel = UIManager.getSystemLookAndFeelClassName();
		// System.out.println(defaultLookAndFeel);
		JRadioButton bDefault = new JRadioButton("Default");
		bDefault.addActionListener(new LNFSetter(
			 defaultLookAndFeel, bDefault));
		bg.add(bDefault);
		cp.add(bDefault);

		(previousButton = bDefault).setSelected(true);

		theFrame.pack();
		theFrame.setVisible(true);
	}

	/* Class to set the Look and Feel on a frame */
	class LNFSetter implements ActionListener {
		String theLNFName;
		JRadioButton thisButton;

		/** Called to setup for button handling */
		LNFSetter(String lnfName, JRadioButton me) {
			theLNFName = lnfName;
			thisButton = me;
		}

		/** Called when the button actually gets pressed. */
		public void actionPerformed(ActionEvent e) {
			try {
				UIManager.setLookAndFeel(theLNFName);
				SwingUtilities.updateComponentTreeUI(theFrame);
				theFrame.pack();
			} catch (Exception evt) {
				JOptionPane.showMessageDialog(null,
					"setLookAndFeel didn't work: " + evt,
					"UI Failure", JOptionPane.INFORMATION_MESSAGE);
				previousButton.setSelected(true);		// reset the GUI to agree
			}
			previousButton = thisButton;
		}
	}

	public static void main(String[] argv) {
		new LNFSwitcher();
	}
}
//@@@@@@//
//gui/MenuCascade.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/**
 * Demonstrate Cascading Menus
 * for students of Learning Tree Course 471/478
 *
 * @author Ian Darwin
 */
public class MenuCascade extends JFrame {
	JMenuBar mb;
	JMenu fm, om, hm;	// File, Options, Help
	JMenu opSubm;		// Options Sub-Menu
	JMenuItem mi;

	// Constructor
	MenuCascade(String s) {
		super("MenuCascade: " + s);

		Container cp = getContentPane();
		cp.setLayout(new FlowLayout());

		mb = new JMenuBar();
		setJMenuBar(mb);

		// The File Menu...
		fm = new JMenu("File");
			fm.add(mi = new JMenuItem("Open"));
			mi.addActionListener(defaultHandler);
			fm.add(mi = new JMenuItem("Close"));
			mi.addActionListener(defaultHandler);
			fm.addSeparator();
			fm.add(mi = new JMenuItem("Exit"));
			mi.addActionListener(defaultHandler);
			mi.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					System.exit(0);
				}
			});
		mb.add(fm);

		// The Options Menu...
		om = new JMenu("Options");
			opSubm = new JMenu("SubOptions");
			opSubm.add(mi = new JMenuItem("Alpha"));
			mi.addActionListener(defaultHandler);
			opSubm.add(mi = new JMenuItem("Gamma"));
			mi.addActionListener(defaultHandler);
			opSubm.add(mi = new JMenuItem("Delta"));
			mi.addActionListener(defaultHandler);
			om.add(opSubm);
		mb.add(om);

		// The Help Menu...
		hm = new JMenu("Help");
			hm.add(mi = new JMenuItem("About"));
			mi.addActionListener(defaultHandler);
			mi.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					JOptionPane.showMessageDialog(
					MenuCascade.this,
					"Version 0", "Version 0",
					JOptionPane.INFORMATION_MESSAGE);
				}
			});
			hm.add(mi = new JMenuItem("Topics"));
			mi.addActionListener(defaultHandler);
		mb.add(hm);

		// the main window
		cp.add(new MyCanvas("Menu Demo Window", 200, 150));
		pack();
	}

	ActionListener defaultHandler = new ActionListener() {
		public void actionPerformed(ActionEvent e) {
			System.out.println("You chose " + e.getActionCommand());
		}
	};

	public static void main(String[] arg) {
		MenuCascade mb = new MenuCascade("Testing 1 2 3...");
		mb.setVisible(true);
	}
}
//@@@@@@//
//gui/MenuDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;

/**
 * Demonstrate Menus and the MenuBar class/MenuContainer interface
 *
 * This version uses 1.1 action handling and MenuShortcut. The action
 * handling is incomplete; realistically, each MenuItem would have its
 * own, task-specific ActionListener; this would handle the MenuShortcuts
 * and the CheckboxMenuItems correctly.
 *
 * @author Ian Darwin
 */
public class MenuDemo
		extends Frame
				implements ActionListener, ItemListener {
	MenuBar mb;
	/** File, Options, Help */
	Menu fm, om, hm;
	/** Options Sub-Menu */
	Menu opSubm;
	/** The MenuItem for exiting. */
	MenuItem exitItem;
	/** An option that can be on or off. */
	CheckboxMenuItem cb;

	// Constructor
	MenuDemo(String s) {
		super("MenuDemo: " + s);

		Container cp = this;
		cp.setLayout(new FlowLayout());

		mb = new MenuBar();
		setMenuBar(mb);		// Frame implements MenuContainer

		MenuItem mi;
		// The File Menu...
		fm = new Menu("File");
			fm.add(mi = new MenuItem("Open", new MenuShortcut('O')));
			mi.addActionListener(this);
			fm.add(mi = new MenuItem("Close", new MenuShortcut('W')));
			mi.addActionListener(this);
			fm.addSeparator();
			fm.add(mi = new MenuItem("Print", new MenuShortcut('P')));
			mi.addActionListener(this);
			fm.addSeparator();
			fm.add(mi = new MenuItem("Exit", new MenuShortcut('Q')));
			exitItem = mi;			// save for action handler
			mi.addActionListener(this);
		mb.add(fm);

		// The Options Menu...
		om = new Menu("Options");
			cb = new CheckboxMenuItem("AutoSave");
			cb.setState(true);
			cb.addItemListener(this);
			om.add(cb);
			opSubm = new Menu("SubOptions");
			opSubm.add(new MenuItem("Alpha"));
			opSubm.add(new MenuItem("Gamma"));
			opSubm.add(new MenuItem("Delta"));
			om.add(opSubm);
		mb.add(om);

		// The Help Menu...
		hm = new Menu("Help");
			hm.add(mi = new MenuItem("About"));
			mi.addActionListener(this);
			hm.add(mi = new MenuItem("Topics"));
			mi.addActionListener(this);
		mb.add(hm);
		mb.setHelpMenu(hm);		// needed for portability (Motif, etc.).

		// the main window
		cp.add(new MyLabel("Menu Demo Window", 200, 150));
		pack();
	}

	/** Handle action events. */
	public void actionPerformed(ActionEvent evt) {
		// System.out.println("Event " + evt);
		String cmd;
		if ((cmd = evt.getActionCommand()) == null)
			System.out.println("You chose a menu shortcut");
		else
			System.out.println("You chose " + cmd);
		Object cmp = evt.getSource();
		// System.out.println("Source " + cmp);
		if (cmp == exitItem)
			System.exit(0);
	}

	/** The CheckBoxMenuItems send a different message */
	public void itemStateChanged(ItemEvent e) {
		System.out.println("AutoSave is set " + cb.getState());
	}

	public static void main(String[] arg) {
		new MenuDemo("Testing 1 2 3...").setVisible(true);
	}
}
//@@@@@@//
//gui/MenuShortcuts.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/**
 * Demonstrate JMenu shortcuts and accelerators.
 *
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: MenuShortcuts.java,v 1.4 2004/02/09 03:33:50 ian Exp $
 */
public class MenuShortcuts extends JFrame implements ActionListener {
	/** The menubar */
	JMenuBar mb;
	/** File, Options, Help */
	JMenu fm, om, hm;
	/** Options Sub-JMenu */
	JMenu opSubm;
	/** The JMenuItem for exiting. */
	JMenuItem exitItem;

	// Constructor
	MenuShortcuts(String s) {
		super("JMenuShortcuts: " + s);
		mb = new JMenuBar();
		setJMenuBar(mb);		// Frame implements JMenuContainer

		Container cp = getContentPane();
		JMenuItem mi;
		// The File JMenu...
		fm = new JMenu("File");
		fm.setMnemonic('F');
			fm.add(mi = new JMenuItem("Open", 'O'));
			mi.addActionListener(this);
			fm.add(mi = new JMenuItem("Close", 'W'));
			mi.addActionListener(this);
			fm.addSeparator();

			fm.add(mi = new JMenuItem("Print", 'P'));
			mi.setAccelerator(KeyStroke.getKeyStroke(
				KeyEvent.VK_R, Event.ALT_MASK));

			mi.addActionListener(this);
			fm.addSeparator();
			fm.add(mi = new JMenuItem("Exit", 'Q'));
			exitItem = mi;			// save for action handler
			mi.addActionListener(this);
		mb.add(fm);

		// The Options JMenu...
		om = new JMenu("Options");
			om.add(new JMenuItem("Alpha"));
			om.add(new JMenuItem("Gamma"));
			om.add(new JMenuItem("Delta"));
		mb.add(om);

		// The Help JMenu...
		hm = new JMenu("Help");
			hm.add(mi = new JMenuItem("About"));
			mi.addActionListener(this);
			hm.add(mi = new JMenuItem("Topics"));
			mi.addActionListener(this);
		mb.add(hm);
		// mb.setHelpMenu(hm);	// needed for portability (Motif, etc.).

		// the main window
		cp.add(new MyLabel("Menu Demo Window", 200, 150));
		pack();
	}

	/** Handle action events. */
	public void actionPerformed(ActionEvent evt) {
		// System.out.println("Event " + evt);
		String cmd;
		if ((cmd = evt.getActionCommand()) == null)
			System.out.println("You chose a menu shortcut");
		else
			System.out.println("You chose " + cmd);
		Object cmp = evt.getSource();
		// System.out.println("Source " + cmp);
		if (cmp == exitItem)
			System.exit(0);
	}

	public static void main(String[] arg) {
		new MenuShortcuts("Testing 1 2 3...").setVisible(true);
	}
}
//@@@@@@//
//gui/MoreChoices.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

/** Demo to show a way of having "More Choices/Less Choices"
 * in a pop-up window. The secret is to call pack() again
 * each time you add/subtract the bottom panel.
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: MoreChoices.java,v 1.3 2004/02/09 03:33:50 ian Exp $
 */
public class MoreChoices extends JFrame {
	Container cp;
	boolean unsavedChanges = false;
	JButton moreOrLessButton;
	JPanel  moreOrLessPanel;
	ActionListener more;
	ActionListener less;

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create a MoreChoices object, tell it to show up
		JFrame jf = new MoreChoices();
		jf.setLocation(100, 100);	// get away from screen corner,
							// since on some OSes a main window at 0,0 may be
							// partly obscured (e.g. notebook with PowerPanel
		jf.setVisible(true);
	}

	/** Construct the object including its GUI */
	public MoreChoices() {
		super("More Choices");
		// cp = getContentPane();
		cp = this;
		cp.setLayout(new BorderLayout());

		ButtonsPanel bp = new ButtonsPanel();
		cp.add(BorderLayout.NORTH, bp);

		// Construct the more/less switcher
		less = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cp.remove(moreOrLessPanel);
				pack();
				moreOrLessButton.setText("More Choices");
				moreOrLessButton.removeActionListener(less);
				moreOrLessButton.addActionListener(more);
			}
		};
		more = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				cp.add(BorderLayout.SOUTH, moreOrLessPanel);
				pack();
				moreOrLessButton.setText("Fewer Choices");
				moreOrLessButton.removeActionListener(more);
				moreOrLessButton.addActionListener(less);
			}
		};
		bp.add(moreOrLessButton = new JButton("More Choices"));
		// Initial state is to add more choices
		moreOrLessButton.addActionListener(more);

		moreOrLessPanel = new ChoicesPanel();

		// Finally a frame closer
		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
			
		pack();
	}

	/** The panel that appears when you press More Choices.
	 * This is a toy; in a real application, this would likely
	 * be a separate full "public class".
	 */
	class ChoicesPanel extends JPanel {
		ChoicesPanel() {
			setBorder(BorderFactory.createEtchedBorder());
			add(new JCheckBox("Happiness"));
			add(new JCheckBox("Satisfaction"));
			add(new JCheckBox("Contentment"));
		}
	}

	/** The Panel that contains the More/Less button. It is just
	 * here to override getPreferredSize so that we can
	 * avoid "jitter" (i.e., the width changing); i.e., we must
	 * ensure that the main panel and the ChoicePanel have the
	 * same width
	 */
	class ButtonsPanel extends JPanel {
		public Dimension getPreferredSize() {
			// System.out.println("In ButtonsPanel.getPreferredSize()");
			// For height, use our normal height
			int dHeight = moreOrLessButton.getPreferredSize().height + 5 + 5;
			// For witdh, use the included Panel's width
			int dWidth  = moreOrLessPanel.getPreferredSize().width;
			// Combine them; that's the result we need.
			return new Dimension(dWidth, dHeight);
		}
	}
}
//@@@@@@//
//gui/MultiListeners.java
//@@@@@@//
import java.awt.event.*;
import javax.swing.*;

/** Demo I wrote in response to a student request for how to have
 * multiple listeners (Bobs) that are already on-screen added as listeners
 * to a newly-created pushbutton (Fred).
 */
public class MultiListeners {
	public static void main(String[] args) { 
		Bob b1 = new Bob();
		b1.setVisible(true);
		Bob b2 = new Bob();
		b2.setVisible(true);
		ActionListener[] bobs = { b1, b2};

		Fred f1 = new Fred(bobs);
		f1.setVisible(true);
	}
}
class Fred extends JFrame {
	JButton okbutton = new JButton("OK");
	public Fred(ActionListener[] bobs) {
		getContentPane().add(okbutton);
		for (int i=0; i<bobs.length; i++) {
			okbutton.addActionListener(bobs[i]);
		}
	}
}
class Bob extends JFrame implements ActionListener {
	protected JLabel statusLabel = new JLabel("     ");
	public Bob() {
		getContentPane().add(statusLabel);
	}
	public void actionPerformed(ActionEvent e) {
		statusLabel.setText("OK");
	}
}
//@@@@@@//
//gui/MVC/Model.java
//@@@@@@//
package MVC;

import java.util.*;
import javax.swing.event.*;

public class Model {
	private List list = new ArrayList();

	public void add(String s) {
		list.add(s);
		fireChange();
	}

	public List getData() {
		return list;
	}

	// Sun recommends using javax.swing.EventListenerList, but this is easier
	List changeListeners = new ArrayList();

	public void addChangeListener(ChangeListener cl) {
		changeListeners.add( cl);
	}

	public void removeChangeListener(ChangeListener cl) {
		changeListeners.remove(cl);
	}

	protected void fireChange() {
		ChangeEvent evt = new ChangeEvent(this);
		for (int i = 0; i < changeListeners.size(); i++) {
			ChangeListener cl = (ChangeListener)changeListeners.get(i);
			cl.stateChanged(evt);
		}
	}
}
//@@@@@@//
//gui/MVC/MVCDemo.java
//@@@@@@//
package MVC;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;

/** MVC Implementation
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: MVCDemo.java,v 1.3 2004/03/21 00:44:36 ian Exp $
 */
public class MVCDemo {

	/** "main program" method - construct and show */
	public static void main(String[] av) {

		// Create the data model
		final Model model = new Model();

		// create a JFrame to hold it all.
		final JFrame f = new JFrame("MVC");
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container cp = f.getContentPane();

		JPanel tp = new JPanel();
		cp.add(tp, BorderLayout.NORTH);

		tp.add(new JLabel("New value:"));
		final JTextField tf = new JTextField(10);
		tp.add(tf);
		tf.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				model.add(tf.getText());
				tf.setText("");
			}
		});

		JPanel p = new JPanel();

		// The first View is a JTextArea subclassed to have
		// an easy way of setting the data from a java.util.List
		final TextView tv = new TextView();
		model.addChangeListener(new ChangeListener() {
			public void stateChanged(ChangeEvent evt) {
				Object o = evt.getSource();
				Model m = (Model) o;
				tv.setListData(m.getData());
			}
		});

		tv.setBackground(Color.RED);
		tv.setSize(100, 100);
		p.add(tv);

		// The second View is the simplistic Grapher program from
		// the Java Cookbook "Graphics" chapter (../graphics/Grapher.java)
		final Grapher vv = new Grapher();
		model.addChangeListener(new ChangeListener() {
			public void stateChanged(ChangeEvent evt) {
				Object o = evt.getSource();
				Model m = (Model) o;
				vv.setListData(m.getData());
			}
		});
		vv.setBackground(Color.YELLOW);
		vv.setSize(100, 100);
		p.add(vv);

		cp.add(p, BorderLayout.CENTER);

		f.pack();
		f.setLocation(100, 100);
		f.setVisible(true);
		
	}
}
//@@@@@@//
//gui/MVC/TextView.java
//@@@@@@//
package MVC;

import javax.swing.*;
import java.util.List;

public class TextView extends JTextArea {
	public TextView() {
		super(20, 20);
	}
	
	public void setListData(List l) {
		setText("");
		for (int i=0; i< l.size(); i++) {
			append((String)l.get(i));
			append("\n");
		}
	}
}
//@@@@@@//
//gui/MVCLoop.java
//@@@@@@//
// Investigate if you can get into a loop with a Swing-based MVC app;
// in particular, if you do setSelectedIndex on a choice, does it
// generate a secondary event?  Push the button and see!

// If it does, you must be careful to avoid event propagation loops.

// This example doesn't show it, but you can loop with other implementations.
// For example, if a changed() method updates the model's data.

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class MVCLoop {
	public static void main(String[] a) {
		Button b;
		final JComboBox ch;
		JFrame f = new JFrame("Testing");
		Container cp = f.getContentPane();
		cp.setLayout(new FlowLayout());

		b = new Button("Set");
		ch = new JComboBox();

		cp.add(b);
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				int cur = ch.getSelectedIndex();
				int len = ch.getItemCount();
				cur++;
				cur %= len;
				ch.setSelectedIndex(cur);
			}
		});

		ch.addItem("En/ett");
		ch.addItem("Zwei");
		ch.addItem("Tres");
		ch.addItem("Four");
		ch.addItem("Funf");
		ch.addItem("Seis");
		ch.addItem("Siete");
		ch.addItem("Octo");
		cp.add(ch);
		ch.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.out.println(e);
			}
		});

		f.pack();
		f.setVisible(true);
	}
}
//@@@@@@//
//gui/MyCanvas.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

/**
 * Dummy Canvas class, to represent the real main part of an application *
 * Just subclasses JLabel.
 * @author Ian Darwin, http://www.darwinsys.com
 */

public class MyCanvas extends JLabel {
	protected int width, height;
	protected int pad;

	MyCanvas(int w, int h) {
		this("", w, h);
	}

	MyCanvas(String l, int w, int h) {
		super(l, JLabel.CENTER);
		width = w; height = h;
	}
	MyCanvas(String l, int w, int h, Color c) {
		this(l, w, h);
		setBackground(c);
	}

	public Dimension getPreferredSize() {
		return new Dimension(width+pad, height+pad);
	}
}
//@@@@@@//
//gui/MyLabel.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

/**
 * Dummy Canvas class, to represent the real main part of an application *
 *
 * @author Ian Darwin, http://www.darwinsys.com
 */

class MyLabel extends JLabel {
	int width, height;
	int pad;

	MyLabel(int w, int h) {
		this("", w, h);
	}
	MyLabel(String l, int w, int h) {
		super(l, JLabel.CENTER);
		width = w; height = h;
	}
	MyLabel(String l, int w, int h, Color c) {
		this(l, w, h);
		setBackground(c);
	}

	public Dimension getMinimumSize() {
		return new Dimension(width, height);
	}

	public Dimension getPreferredSize() {
		return new Dimension(width+pad, height+pad);
	}
}
//@@@@@@//
//gui/ObservDemo.java
//@@@@@@//
import java.util.*;

/**
 * A simple demo of Observable->Observer
 *
 * @author Ian Darwin
 * @version $Id: ObservDemo.java,v 1.3 2003/12/29 19:52:22 ian Exp $
 */
public class ObservDemo extends Object {
	MyView view;
	MyModel model;

	public ObservDemo() {

		view = new MyView();

		model = new MyModel(); 
		model.addObserver(view);

	}

	public static void main(String[] av) {
		ObservDemo me = new ObservDemo();
		me.demo();
	}

	public void demo() {
		model.changeSomething();
	}

	/** The Observer normally maintains a view on the data */
	class MyView implements Observer {
		/** For now, we just print the fact that we got notified. */
		public void update( Observable obs, Object x ) {
			System.out.println("update(" + obs + "," + x + ");");
		}
	}

	/** The Observable normally maintains the data */
	class MyModel extends Observable {
		public void changeSomething() {
			// Notify observers of change
			setChanged();
			notifyObservers();
		}
	}
}
//@@@@@@//
//gui/PopupDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;

/** Provide a pop-up menu using a Frame.
 * On most platforms, changing the mouse "settings" changes how the
 * isPopupTrigger() method behaves instantly - which is as it should be!
 */
public class PopupDemo extends Frame {
	/** "main" method - for testing. */
	public static void main(String[] av) {
		new PopupDemo("Hello").setVisible(true);
	}

	/** Construct the main program */
	public PopupDemo(String title) {
		super(title);

		setLayout(new FlowLayout());
		add(new PopupContainer(
			"Hello, and welcome to the world of Java"));
		pack();
		setVisible(true);
	}
}

/* A component to demonstrate use of PopupMenu.
 * The user has to ask for the menu to popup in Java's
 * platform-dependant way (e.g., right mouse click on X Windows, MS-Windows).
 *
 * Alternately, you could watch for keypress events and provide
 * your own platform-independant keyboard popup menu character
 * such as M for Menu (not CTRL/M; Mac's don't have a CTRL key).
 */
class PopupContainer extends Component {
	PopupMenu m;
	PopupContainer(String s) {
		m = new PopupMenu(s);
		m.add(new MenuItem("Open"));
		m.add(new MenuItem("Close"));
		MenuItem qB;
		m.add(qB = new MenuItem("Exit"));
		class Quitter implements ActionListener {
			public void actionPerformed(ActionEvent e) {
				System.exit(0);
			}
		}
		qB.addActionListener(new Quitter());

		add(m);		// add Popup to Component

		enableEvents(AWTEvent.MOUSE_EVENT_MASK);
	}


	public void processMouseEvent(MouseEvent me) {
			System.err.println("MouseEvent: " + me);
			if (me.isPopupTrigger())
				m.show(this, me.getX(), me.getY());
			else
				super.processMouseEvent(me);
	};

	/** Compute our minimum size */
	public Dimension getMinimumSize() {
		return new Dimension(200, 200);
	}

	final int PREF_PAD=10;

	/** Computer our best size */
	public Dimension getPreferredSize() {
		Dimension d = getMinimumSize();
		return new Dimension(d.width+PREF_PAD, d.height+PREF_PAD);
	}

	/** Computer our maximum allowed size */
	public Dimension getMaximumSize() {
		Dimension d = getMinimumSize();
		return new Dimension(d.width*2, d.height*2);
	}
}
//@@@@@@//
//gui/ProgressMeterStrmDemo.java
//@@@@@@//
import javax.swing.*;
import java.io.*;

/**
 * Demonstrate ProgressMeterInputStream.
 *
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version	$Id: ProgressMeterStrmDemo.java,v 1.5 2004/02/23 03:39:22 ian Exp $
 */
public class ProgressMeterStrmDemo extends JFrame implements Runnable {

	public void readTheFile() throws IOException {
		// OK, we're going to read a file. Do it...
		FileInputStream is = new FileInputStream("index.htm");
		BufferedReader ds = new BufferedReader(
			new InputStreamReader(
				new ProgressMonitorInputStream(this,
					"Loading...", new FileInputStream("index.htm"))));

		// Now read it...
		String line;
		while ((line = ds.readLine()) != null) {
			if (System.getProperties().getProperty("debug.lines")!=null)
				System.err.println("Read this line: " + line);
			try {
				Thread.sleep(200);		// slow it down a bit.
			} catch(InterruptedException e) {
				return;
			}
		}
		// Close file, since it was opened.
		ds.close();
	}

	/** We use a separate "thread" (see Threads chapter) to do the reading,
	 * so the GUI can run independantly (since we have "sleep" calls to make
	 * it appear to run more slowly).
	 */
	public void run() {
		try {
			readTheFile();
		} catch (EOFException nme) {
			return;
		} catch (IOException e) {
			System.err.println(e.toString());
			return;
		}
	}

	public ProgressMeterStrmDemo() {
		new Thread(this).start();
	}

	public static void main(String[] av) {
		ProgressMeterStrmDemo demo = new ProgressMeterStrmDemo();
		demo.setSize(100, 100);
		demo.getContentPane().add(new JLabel("ProgressMeterStrmDemo"));
		demo.pack();
		demo.setVisible(true);

	} 
}
//@@@@@@//
//gui/SaveDialog.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/*
 * Simple Save Dialog demo.
 * @version $Id: SaveDialog.java,v 1.4 2000/11/25 17:54:19 ian Exp $
 */
public class SaveDialog extends JFrame {
	boolean unsavedChanges = false;
	Button quitButton;

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create a SaveDialog object, tell it to show up
		new SaveDialog().setVisible(true);
	}

	/** Construct the object including its GUI */
	public SaveDialog() {
		super("SaveDialog");
		Container cp = getContentPane();
		cp.setLayout(new FlowLayout());
		cp.add(new Label("Press this button to see the Quit dialog: "));
		cp.add(quitButton = new Button("Quit"));
		quitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.out.println("In Exit Button's action handler");
				if (okToQuit()) {
					setVisible(false);
					dispose();
					System.exit(0);
				}
			}
		});
		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});

		pack();
	}
	boolean okToQuit() {
		String[] choices = {
			"Yes, Save and Quit", "No, Quit without saving", "CANCEL"
		};
		int result = JOptionPane.showOptionDialog(this,
			"You have unsaved changes. Save before quitting?", "Warning",
			JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE, 
			null, choices, choices[0]);

			// Use of "null" as the Icon argument is contentious... the
			// document says you can pass null, but it does seem to
			// generate a lot of blather if you do, something about
			// a NullPointerException :-) ...

		if (result >= 0)
			System.out.println("You clicked " + choices[result]);

		switch(result) {
		case -1:
			System.out.println("You killed my die-alog - it died");
			return false;
		case 0:	// save and quit
			System.out.println("Saving...");
			// mainApp.doSave();
			return true;
		case 1:	// just quit
			return true;
		case 2:	// cancel
			return false;
		default:
			throw new IllegalArgumentException("Unexpected return " + result);
		}
	}
}
//@@@@@@//
//gui/Score.java
//@@@@@@//
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.text.*;

/** Class to display and update a Scoreboard for a Quiz game.
 */
public class Score {
	protected JFrame f;
	/** The left text field */
	JTextField lst;
	/** The right-hand text field */
	JTextField rst;
	/** A formatter for all the numbers */
	DecimalFormat df = new DecimalFormat("000");

	/** Construct the GUI */
	Score() {
		JButton b;
		f = new JFrame("Score");

		JMenuBar mb = new JMenuBar();
		JMenuItem mi;

		JMenu fm = new JMenu("File");
		fm.add(mi = new JMenuItem("Quit"));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				System.exit(0);
			}
		});
		mb.add(fm);

		JMenu em = new JMenu("Edit");
		em.add(mi = new JMenuItem("Reset"));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				lst.setText(df.format(0));
				rst.setText(df.format(0));
			}
		});
		mb.add(em);
		f.setJMenuBar(mb);

		Container cp = f.getContentPane();
		cp.setLayout(new FlowLayout());
		Font bigF = new Font("helvetica", Font.BOLD, 128);
		cp.add(lst = new JTextField(df.format(0)));
		lst.setFont(bigF);

		cp.add(b = new JButton("+"));
		b.addActionListener(new Adder(lst, 1));

		cp.add(rst = new JTextField(df.format(0)));
		rst.setFont(bigF);

		cp.add(b = new JButton("+"));
		b.addActionListener(new Adder(rst, 1));

		f.addKeyListener(new KeyAdapter() {
			public void keyPressed(KeyEvent e) {
				//System.out.println(e);
				switch(e.getKeyChar()) {
					case 'l': case 'L': incr(lst); break;
					case 'r': case 'R': incr(rst); break;
					// XXX "Q" should require a JOptionPane confirmation...
					case 'Q': System.exit(0); break;
				} 
			}
		});

		f.pack();
	}

	/** Little convenience routine, so we can be used like JFrame */
	public void setVisible(boolean b) {
		f.setVisible(b);
	}

	/** Inner class to update one score by one amount. */
	class Adder implements ActionListener {
		JTextField textfield;
		int increment;
		public Adder(JTextField tf, int incr) {
			textfield = tf;
			increment = incr;
		}
		public void actionPerformed(ActionEvent e) {
			incr(textfield, increment);
		}
	}

	protected void incr(JTextField j) {
		incr(j, 1);
	}

	protected void incr(JTextField j, int incr) {
		String t = j.getText().trim();
		int i = 0;
		try {
			i = Integer.parseInt(t);
		} catch (NumberFormatException e) {
			System.out.println("BLATZ");
		}
		j.setText(df.format(i + incr));
	}

	public static void main(String[] args) {
		new Score().setVisible(true);
	}
}
//@@@@@@//
//gui/SpinnerDemo.java
//@@@@@@//
import java.awt.Container;
import java.awt.GridLayout;
import javax.swing.*;

/**
 * Demonstrate the Swing "Spinner" control.
 * @author ian
 */
public class SpinnerDemo {

	public static void main(String[] args) {
		JFrame jf = new JFrame("It Spins");
		Container cp = jf.getContentPane();
		cp.setLayout(new GridLayout(0,1));

		// Create a JSpinner using one of the pre-defined SpinnerModels
		JSpinner dates = new JSpinner(new SpinnerDateModel());
		cp.add(dates);

		// Create a JSPinner using a SpinnerListModel. 
		String[] data = { "One", "Two", "Three" };
		JSpinner js = new JSpinner(new SpinnerListModel(data));
		cp.add(js);

		jf.setSize(100, 80);
		jf.setVisible(true);
	}
}

//@@@@@@//
//gui/StyledText.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import javax.swing.text.*;

public class StyledText {
	public static void main(String args[]) throws BadLocationException {
		JFrame jf = new JFrame("StyledText");
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Container cp = jf.getContentPane();

		JTextPane pane = new JTextPane();
		SimpleAttributeSet set = new SimpleAttributeSet();
		StyleConstants.setBold(set, true);

		// Set the attributes before adding text
		pane.setCharacterAttributes(set, true);
		pane.setText("Eine ");

		set = new SimpleAttributeSet();
		StyleConstants.setItalic(set, true);
		StyleConstants.setForeground(set, Color.red);
		StyleConstants.setBackground(set, Color.blue);

		Document doc = pane.getStyledDocument();
		doc.insertString(doc.getLength(), "Kleine ", set);

		set = new SimpleAttributeSet();
		StyleConstants.setFontSize(set, 24);

		doc.insertString(doc.getLength(), "Nachtmusic", set);

		JScrollPane scrollPane = new JScrollPane(pane);
		cp.add(scrollPane, BorderLayout.CENTER);

		jf.setSize(400, 300);
		jf.setVisible(true);
	}
}

//@@@@@@//
//gui/TabPaneDemo.java
//@@@@@@//
import javax.swing.*;

public class TabPaneDemo {
	protected JTabbedPane tabPane;
	public TabPaneDemo() {
		tabPane = new JTabbedPane();
		tabPane.add(new JLabel("One", JLabel.CENTER), "First");
		tabPane.add(new JLabel("Two", JLabel.CENTER), "Second");
	}

	public static void main(String[] a) {
		JFrame f = new JFrame("Tab Demo");
		f.getContentPane().add(new TabPaneDemo().tabPane);
		f.setSize(120, 100);
		f.setVisible(true);
	}
}
//@@@@@@//
//gui/ThreadBasedCatcher.java
//@@@@@@//
import java.awt.Container;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;

/**
 * ThreadBasedCatcher - Demonstrate catching uncaught exceptions 
 * thrown in an unrelated Thread.
 * @author ian
 * @verion $Id: ThreadBasedCatcher.java,v 1.2 2004/03/20 20:43:27 ian Exp $
 */
public class ThreadBasedCatcher extends JFrame{

	public static void main(String[] args) {
		new ThreadBasedCatcher().setVisible(true);
	}
	public ThreadBasedCatcher(){
		Container cp = getContentPane();
		JButton crasher = new JButton("Crash");
		cp.add(crasher);
		crasher.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent e){
				throw new RuntimeException("You asked for it");
			}
		});
		Thread.setDefaultUncaughtExceptionHandler(
				new Thread.UncaughtExceptionHandler(){
					public void uncaughtException(Thread t, Throwable ex){
						System.out.println(
							"You crashed thread " + t.getName());
						System.out.println(
							"Exception was: " + ex.toString());
					}
				});
		pack();
	}
}
//@@@@@@//
//gui/UndoDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.undo.*;

/** Simple GUI demo of UndoManager and friends.
 * @author Ian Darwin http://www.darwinsys.com/
 */
public class UndoDemo extends JFrame {

	JTextArea ta;
	UndoManager um;

	/** Simple main program that just constructs and shows the GUI */
	public static void main(String[] files) {
		new UndoDemo().setVisible(true);
	}

	/** Construct a GUI that demonstrates use of UndoManager */
	public UndoDemo() {

		Container cp = getContentPane();
		cp.add(ta = new JTextArea(20, 60), BorderLayout.CENTER);
		JPanel bp;
		cp.add(bp = new JPanel(), BorderLayout.SOUTH);

		// Create a javax.swing.undo.UndoManager; this is an amazing class that
		// keeps a Stack of UndoableEdits and lets you invoke them;
		// by registering it as a Listener on the TextComponent.Document,
		// the Document will create the UndoableEdit objects and send them
		// to the UndoManager. Between them they do ALL the work!
		um = new UndoManager();
		ta.getDocument().addUndoableEditListener(um);

		// Create the buttons
		JButton cutButton, copyButton, pasteButton, undoButton, redoButton;
		bp.add(cutButton = new JButton("Cut"));
		cutButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				ta.cut();
			}
		});

		bp.add(copyButton = new JButton("Copy"));
		copyButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				ta.copy();
			}
		});

		bp.add(pasteButton = new JButton("Paste"));
		pasteButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				ta.paste();
			}
		});
		bp.add(undoButton = new JButton("UnDo"));
		undoButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (um.canUndo()) {
					um.undo();
				} else {
					warn("Can't undo");
				}
			}
		});
		bp.add(redoButton = new JButton("ReDo"));
		redoButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (um.canRedo()) {
					um.redo();
				} else {
					warn("Can't redo");
				}
			}
		});
		pack();
		setDefaultCloseOperation(EXIT_ON_CLOSE);
	}

	void warn(String msg) {
		JOptionPane.showMessageDialog(this,
			"Warning: " + msg, "Warning",
			JOptionPane.WARNING_MESSAGE);
	}
}
//@@@@@@//
//gui/Unicode.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.text.*;
import java.util.*;

// THIS VERSION USES SWING -- Could probably just change
// all occurrences of JLabel/JButton to Label/Button for AWT.
import javax.swing.*;

/** Unicode - show a page of Unicode characters.
 * BUG: Times throws a bunch of exceptions on page 2 and 3, that can
 * not be caught as they occur in the AWT thread. On some platforms.
 *
 * TODO - remove GoToPage as a dialog, move its textfield into main GUI.
 *
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: Unicode.java,v 1.7 2004/02/09 03:33:50 ian Exp $
 */
public class Unicode extends JFrame {

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create a Unicode object, tell it to show up
		new Unicode().setVisible(true);
	}

	protected final int COLUMNS = 16, ROWS = 16;
	/** the unicode char at start of current page */
	protected int startNum = 0;
	protected final int QUADSIZE = ROWS * COLUMNS;
	/** the buttons that display the characters */
	protected JLabel buttons[][] = new JLabel[COLUMNS][ROWS];
	/** the font name display */
	protected JLabel fontName;
	/** the row labels, in a column at the left */
	protected JLabel rowLabs[] = new JLabel[ROWS];
	/** The page chooser pop-up */
	protected GoToPage gotoPageUI;
	/** How git to make the font samples */
	protected final int FONTSIZE = 8;

	/** Construct the object including its GUI */
	public Unicode() {
		super("Unicode");

		Container cp = getContentPane();

		// Used both for Buttons and Menus
		ResourceBundle b = ResourceBundle.getBundle("UnicodeWidgets");

		JButton quitButton, nextButton, prevButton;
		Panel p = new Panel();
		// Make a grid, add one for labels.
		p.setLayout(new GridLayout(ROWS+1, COLUMNS+1));
		DecimalFormat df2d = new DecimalFormat("00");

		// Add first row, just column labels.
		p.add(new JLabel(""));
		for (int i = 0; i<COLUMNS; i++)
			p.add(new JLabel(Integer.toString(i, 16), JLabel.CENTER));

		// Add subsequent rows, each with an offset label
		for (int i = 0; i<ROWS; i++) {
			JLabel l = new JLabel("0000");	// room for max, i.e. \uFFFF
			p.add(l);
			rowLabs[i] = l;
			for (int j = 0 ; j < COLUMNS; j++) {
				JLabel pb = new JLabel(" ");
				buttons[j][i] = pb;
				p.add(pb);
			}
		}

		// ActionListeners for jumping around; used by buttons and menus
		ActionListener firster = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				gotoPage(startNum = 0);
			}
		};
		ActionListener previouser = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			if (startNum > 0)
				gotoPage(startNum -= QUADSIZE);
			}
		};
		ActionListener nexter = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			if (startNum < 65535)
				gotoPage(startNum += QUADSIZE);
			}
		};
		ActionListener laster = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				gotoPage(65536 - QUADSIZE);
			}
		};

		cp.add(BorderLayout.NORTH, p);
		fontName = new JLabel("Default font", JLabel.CENTER);
		cp.add(BorderLayout.CENTER, fontName);
		Panel q = new Panel();
		cp.add(BorderLayout.SOUTH, q);
		q.add(prevButton = mkButton(b, "page.prev"));
		prevButton.addActionListener(previouser);

		q.add(nextButton = mkButton(b, "page.next"));
		nextButton.addActionListener(nexter);

		q.add(quitButton = mkButton(b, "exit"));
		quitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});

		MenuItem mi;		// used in various spots

		MenuBar mb = new MenuBar();
		setMenuBar(mb);

		String titlebar;
		try { titlebar = b.getString("program"+".title"); }
		catch (MissingResourceException e) { titlebar="Unicode Demo"; }
		setTitle(titlebar);

		ActionListener fontSelector = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				String font = e.getActionCommand();
				mySetFont(font, FONTSIZE);
			}
		};

		Menu fontMenu = mkMenu(b, "font");
		// String[] fontList = Toolkit.getDefaultToolkit().getFontList();
		String[] fontList = GraphicsEnvironment.getLocalGraphicsEnvironment().
			getAvailableFontFamilyNames();
		for (int i=0; i<fontList.length; i++) {
			fontMenu.add(mi = new MenuItem(fontList[i]));
			mi.addActionListener(fontSelector);
		}
		mb.add(fontMenu);

		gotoPageUI = new GoToPage("Unicode Page");
		centre(gotoPageUI);

		Menu vm = mkMenu(b,  "page");
		vm.add(mi = mkMenuItem(b, "page", "first"));
		mi.addActionListener(firster);
		vm.add(mi = mkMenuItem(b, "page", "prev"));
		mi.addActionListener(previouser);
		vm.add(mi = mkMenuItem(b, "page", "next"));
		mi.addActionListener(nexter);
		vm.add(mi = mkMenuItem(b, "page", "last"));
		mi.addActionListener(laster);
		vm.add(mi = mkMenuItem(b, "page", "goto"));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				Unicode.this.gotoPageUI.setVisible(true);
			}
		});
		mb.add(vm);

		Menu hm = mkMenu(b,  "help");
		hm.add(mi = mkMenuItem(b, "help", "about"));
		mb.setHelpMenu(hm);		// needed for portability (Motif, etc.).

		pack();
		// After packing the Frame, centre it on the screen.
		centre(this);

		// start at a known place
		mySetFont(fontList[0], FONTSIZE);
		gotoPage(startNum);
	} // End of huge Constructor

	private void mySetFont(String font, int sz) {
		fontName.setText("Font = " + font);
		Font f = new Font(font, Font.PLAIN, sz);
		for (int i = 0; i<ROWS; i++) {
			for (int j = 0; j<COLUMNS; j++)
				buttons[i][j].setFont(f);
		}
		repaint();
	}

	public void centre(Window c) {
		Dimension us = c.getSize(), 
			them = Toolkit.getDefaultToolkit().getScreenSize();
		int newX = (them.width - us.width) / 2;
		int newY = (them.height- us.height)/ 2;
		c.setLocation(newX, newY);
	}

	/** Go to a given page of Unicode. 
	 * At present the parameter is a code value, but it should be a page #.
	 */
	private void gotoPage(int startNum) {
		// System.out.println("startAt(" + startNum + ")");
		char chars[] = new char[1];
		for (int i = 0; i<ROWS; i++) {
			JLabel l = rowLabs[i];
			// System.out.println("i=" + i + ", JLabel=" + l);
			l.setText(Integer.toString(startNum+(i*COLUMNS), 16));
			// l.validate();		// size may be too big now
			for (int j = 0; j<COLUMNS; j++) {
				chars[0] = (char)(startNum+((j*ROWS)+i));
				JLabel b = buttons[i][j];
				b.setText(new String(chars));
			}
		}
		repaint();
	}

	/** Convenience routine to make a Button */
	public JButton mkButton(ResourceBundle b, String name) {
		String label;
		try { label = b.getString(name+".label"); }
		catch (MissingResourceException e) { label=name; }
		return new JButton(label);
	}

	/** Convenience routine to make a Menu */
	public Menu mkMenu(ResourceBundle b, String name) {
		String menuLabel;
		try { menuLabel = b.getString(name+".label"); }
		catch (MissingResourceException e) { menuLabel=name; }
		return new Menu(menuLabel);
	}

	/** Convenience routine to make a MenuItem */
	public MenuItem mkMenuItem(ResourceBundle b, String menu, String name) {
		String miLabel;
		try { miLabel = b.getString(menu + "." + name + ".label"); }
		catch (MissingResourceException e) { miLabel=name; }
		String key = null;
		try { key = b.getString(menu + "." + name + ".key"); }
		catch (MissingResourceException e) { key=null; }

		if (key == null)
			return new MenuItem(miLabel);
		else
			return new MenuItem(miLabel, new MenuShortcut(key.charAt(0)));
	}

	/** Implement a simple "Go To Page" dialog
	 * Row one: "Go to Page", textfield
	 * second OK, Cancel buttons.
	 */
	class GoToPage extends Frame {
		/** TextField used to enter the number */
		protected JTextField tf;
		/** The OK button */
		protected Button ok;
		/** The cancel button */
		protected Button can;

		/** Construct a GoToPage window (no actions yet) */
		public GoToPage(String title) {
			setTitle(title);
			Container cp = getContentPane();

			Label l = new Label("Quadrant number (hex):");
			tf = new JTextField(4);
			tf.setText("1");
			// set the text initially selected so you can easily overtype it
			tf.selectAll();

			ok = new Button("OK");
			can = new Button("Cancel");
			can.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					setVisible(false);
				}
			});

			ActionListener doIt = new ActionListener() {
				public void actionPerformed(ActionEvent e) {

					int n = -1;
					try {
						n = getValue();
					} catch(IllegalArgumentException notANumber) {
						// handled below
					}
					if (n >= 0 && n <= 255) {
						gotoPage(startNum = n*QUADSIZE);
						setVisible(false);
					} else
						Toolkit.getDefaultToolkit().beep();
				}
			};
			ok.addActionListener(doIt);
			tf.addActionListener(doIt);

			Panel top = new Panel();
			top.add(l);
			top.add(tf);

			Panel bottom = new Panel();
			bottom.add(ok);
			bottom.add(can);

			cp.add(BorderLayout.NORTH, top);
			cp.add(BorderLayout.SOUTH, bottom);

			pack();
		}

		protected int getValue() {
			int i = Integer.parseInt(tf.getText(), 16);
			return i;
		}
	}
}
//@@@@@@//
//gui/URLButton.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.net.*;

/**
 * URLButton -- a Button-like object that jumps to a URL.
 * MUST have an Applet parent since we use Applet methods.
 */
public class URLButton extends Label implements MouseListener {
	/** Applet parent, for showStatus() and showDocument(). */
	Applet parent;
	/** Text to display in label() */
	String t;
	/** URL to jump to mouseReleased mouseEnter() */
	URL u;

	/** Construct a URLButton given a URL */
	URLButton(Applet parent, String t, URL u) {
		super(t);
		this.parent = parent;
		this.t = t;
		this.u = u;
		addMouseListener(this);
	}

	/** paint() method just draws a box around us */
	public void paint(Graphics g) {
		// super.paint(graphics g);
		Dimension d = getSize();
		g.drawRect(0, 0, d.width-1, d.height-1);
	}

	/** When mouse enters, showStatus of URL */
	public void mouseEntered(MouseEvent e) {
		parent.showStatus(u.toExternalForm());
	}
	/** When mouse enters, clear showStatus */
	public void mouseExited(MouseEvent e) {
		parent.showStatus("");
	}
	/** When the button is pressed, go for it! */
	public void mousePressed(MouseEvent e) {
		parent.showStatus("Showing document at URL " + u);

		parent.getAppletContext().showDocument(u);
		// No error checking on showDocument() -- the
		// browser will honk at the user if the link
		// is invalid. We should open "u" ourselves,
		// check the open, and close it. Or not...
	}
	/** NotUsed */
	public void mouseClicked(MouseEvent e) {
		parent.showStatus("in mouseClicked");
	}
	/** NotUsed */
	public void mouseReleased(MouseEvent e) {
		parent.showStatus("in mouseReleased");
	}
}
//@@@@@@//
//gui/Welcome.java
//@@@@@@//
import javax.swing.*;
import java.awt.*;

/** This program displays a simple pre-fab welcome sign.
 */
public class Welcome extends JComponent {

	/** The main program or entry point. */
	public static void main(String[] args) {
		JFrame f = new JFrame("Welcome");
		f.getContentPane().add(new Welcome());
		f.pack();
		f.setVisible(true);
	}

	/** The font used to display the text */
	Font f;

	/** Construct the program */
	public Welcome() {
		f = new Font("Helvetica", Font.BOLD, 100);
		setBackground(Color.white);
	}

	/** Do the drawing (called automagically by window system when needed) */
	public void paint(Graphics g) {
		g.setColor(Color.white);
		Dimension d = getSize();
		g.fill3DRect(0, 0, d.width-1, d.height-1, true);
		g.setFont(f);
		g.setColor(Color.red);
		g.drawString("Welcome", 100, 150);
		g.drawString("to",	240, 275);
		g.drawString("Java",	160, 400);
	}

	/** Say how big we'd like to be (value hardcoded for now) */
	public Dimension getPreferredSize() {
		return new Dimension(700,500);
	}
}//@@@@@@//
//gui/WinClose2.java
//@@@@@@//
import javax.swing.*;

/* Show an example of closing a JFrame.
 * @author Ian Darwin
 * @version $Id: WinClose2.java,v 1.4 2002/02/16 23:22:48 ian Exp $
 */
public class WinClose2 {

	/* Main method */
	public static void main(String[] argv) {
		JFrame f = new JFrame("WinClose");
		f.setSize(200, 100);
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.setVisible(true);
	}
}
//@@@@@@//
//gui/WindowCloserDemo.java
//@@@@@@//
import java.awt.Frame;
import java.awt.Label;
import com.darwinsys.swingui.WindowCloser;


/* Show an example of closing a Window.
 * @version $Id: WindowCloserDemo.java,v 1.1 2004/03/20 20:45:27 ian Exp $
 */
public class WindowCloserDemo {

	/* Main method */
	public static void main(String[] argv) {
		Frame f = new Frame("Close Me");
		f.add(new Label("Try Titlebar Close", Label.CENTER));
		f.setSize(100, 100);
		f.setVisible(true);
		f.addWindowListener(new WindowCloser(f, true));
	}
}
//@@@@@@//
//gui/WindowDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;

/* Show an example of closing a Window.
 * @author Ian Darwin
 * @version $Id: WindowDemo.java,v 1.2 2000/11/25 17:55:19 ian Exp $
 */
public class WindowDemo extends Frame {

	public static void main(String[] argv) {
		Frame f = new WindowDemo();
		f.setVisible(true);
	}
	public WindowDemo() {
		setSize(200, 100);
		addWindowListener(new WindowDemoAdapter());
	}

	/** Named Inner class that closes a Window. */
	class WindowDemoAdapter extends WindowAdapter {
		public void windowClosing(WindowEvent e) {
			// whimsy - close randomly, ~ 1 times in 3
			if (Math.random() > 0.666) {
				System.out.println("Goodbye!");
				WindowDemo.this.setVisible(false);	// window will close
				WindowDemo.this.dispose();		// and be freed up.
				System.exit(0);
			} 
			System.out.println("You asked me to close, but not to I chose.");
		}
	}
}
//@@@@@@//
//gui/WindowDemo2.java
//@@@@@@//
import javax.swing.*;
import java.awt.event.*;

/* Show an example of closing a Window.
 * @author Ian Darwin
 * @version $Id: WindowDemo2.java,v 1.3 2004/02/23 03:39:23 ian Exp $
 */
public class WindowDemo2 extends JFrame {

	public static void main(String[] argv) {
		JFrame f = new WindowDemo2();
		f.setVisible(true);
	}
	public WindowDemo2() {
		setSize(200, 100);
		setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowDemoAdapter());
	}

	/** Named Inner class that closes a Window. */
	class WindowDemoAdapter extends WindowAdapter {
		public void windowClosing(WindowEvent e) {
			// whimsy - close randomly, ~ 1 times in 3
			if (Math.random() > 0.666) {
				System.out.println("Goodbye!");
				WindowDemo2.this.setVisible(false);	// window will close
				WindowDemo2.this.dispose();		// and be freed up.
				System.exit(0);
			} 
			System.out.println("You asked me to close, but not to I chose.");
		}
	}
}
//@@@@@@//
//i18n/BusCard.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;

import com.darwinsys.swingui.I18N;

/** Display your business-card information in a Java window.
 *
 * This is a first attempt. The next version should use a GridBagLayout.
 * @author Ian F. Darwin
 * @version $Id: BusCard.java,v 1.11 2004/02/09 03:25:05 ian Exp $
 */
public class BusCard extends JFrame {

	JLabel nameTF;
	JComboBox jobChoice;
	JButton B1, B2, B3, B4;

	/** "main program" method - construct and show */
	public static void main(String[] av) {

		// create a BusCard object, tell it to show up
		new BusCard().setVisible(true);
	}

	/** Construct the object including its GUI */
	public BusCard() {
		super();

		Container cp = getContentPane();

		cp.setLayout(new GridLayout(0, 1));

		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});

		JMenuBar mb = new JMenuBar();
		setJMenuBar(mb);

		ResourceBundle b = ResourceBundle.getBundle("BusCard");

		JMenu aMenu;
		aMenu = I18N.mkMenu(b, "filemenu");
		mb.add(aMenu);
		JMenuItem mi = I18N.mkMenuItem(b, "filemenu", "exit");
		aMenu.add(mi);
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.exit(0);
			}
		});
		aMenu = I18N.mkMenu(b, "editmenu");
		mb.add(aMenu);
		aMenu = I18N.mkMenu(b, "viewmenu");
		mb.add(aMenu);
		aMenu = I18N.mkMenu(b, "optionsmenu");
		mb.add(aMenu);
		aMenu = I18N.mkMenu(b, "helpmenu");
		mb.add(aMenu);
		//mb.setHelpMenu(aMenu);		// needed for portability (Motif, etc.).

		setTitle(I18N.getString(b, "card"+".company", "TITLE"));

		JPanel p1 = new JPanel();
		p1.setLayout(new GridLayout(0, 1, 50, 10));

		nameTF = new JLabel("My Name", JLabel.CENTER);
		nameTF.setFont(new Font("helvetica", Font.BOLD, 18));
		nameTF.setText(I18N.getString(b, "card"+".myname", "MYNAME"));
		p1.add(nameTF);

		jobChoice = new JComboBox();
		jobChoice.setFont(new Font("helvetica", Font.BOLD, 14));

		// Get Job Titles ofrom the Properties file loaded into "b"!
		String next;
		int i=1;
		do {
			next = I18N.getString(b, "job_title" + i++, null);
			if (next != null)
				jobChoice.addItem(next);
		} while (next != null);
		p1.add(jobChoice);

		cp.add(p1);

		JPanel p2 = new JPanel();
		p2.setLayout(new GridLayout(2, 2, 10, 10));

		B1 = new JButton();
		B1.setText(I18N.getString(b, "button1.label", "BUTTON LABEL"));
		p2.add(B1);

		B2 = new JButton();
		B2.setText(I18N.getString(b, "button2.label", "BUTTON LABEL"));
		p2.add(B2);

		B3 = new JButton();
		B3.setText(I18N.getString(b, "button3.label", "BUTTON LABEL"));
		p2.add(B3);

		B4 = new JButton();
		B4.setText(I18N.getString(b, "button4.label", "BUTTON LABEL"));
		p2.add(B4);
		cp.add(p2);

		pack();
	}
}
//@@@@@@//
//i18n/DefaultLocale.java
//@@@@@@//
import java.io.*;
import java.text.*;
import java.util.*;

/** Print the default locale */
public class DefaultLocale {

	public static void main(String[] av) { 
		Locale l = Locale.getDefault();
		System.out.println("Today's Locale is " + l);
	}
}
//@@@@@@//
//i18n/JiltBefore.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/**
 * Simple Menu and Window interface - not Internationalized.
 * @author Ian Darwin
 */
public class JiltBefore
		extends JFrame
				implements ActionListener {
	JMenuBar mb;
	/** File, Options, Help */
	JMenu fm, om, hm;
	/** Options Sub-Menu */
	JMenu opSubm;
	/** The JMenuItem for exiting. */
	JMenuItem exitItem;

	// Constructor
	JiltBefore(String s) {
		super("JiltBefore: " + s);

		Container cp = getContentPane();
		cp.setLayout(new FlowLayout());

		mb = new JMenuBar();
		setJMenuBar(mb);

		JMenuItem mi;
		// The File Menu...
		fm = new JMenu("File");
			fm.add(mi = new JMenuItem("Open"));
			mi.addActionListener(this);
			fm.add(mi = new JMenuItem("Close"));
			mi.addActionListener(this);
			fm.addSeparator();
			fm.add(mi = new JMenuItem("Print"));
			mi.addActionListener(this);
			fm.addSeparator();
			fm.add(mi = new JMenuItem("Exit"));
			exitItem = mi;			// save for action handler
			mi.addActionListener(this);
		mb.add(fm);

		// The Options Menu...
		om = new JMenu("Options");
			fm.add(mi = new JMenuItem("Enable"));
			opSubm = new JMenu("SubOptions");
			opSubm.add(new JMenuItem("Alpha"));
			opSubm.add(new JMenuItem("Gamma"));
			opSubm.add(new JMenuItem("Delta"));
			om.add(opSubm);
		mb.add(om);

		// The Help Menu...
		hm = new JMenu("Help");
			hm.add(mi = new JMenuItem("About"));
			mi.addActionListener(this);
			hm.add(mi = new JMenuItem("Topics"));
			mi.addActionListener(this);
		mb.add(hm);
		// mb.setHelpMenu(hm);		// needed for portability (Motif, etc.).

		// the main window
		cp.add(new JLabel("Menu Demo Window"));
		// pack();
		setSize(250, 200);
	}

	/** Handle action events. */
	public void actionPerformed(ActionEvent evt) {
		// System.out.println("Event " + evt);
		String cmd;
		if ((cmd = evt.getActionCommand()) == null)
			System.out.println("You chose a menu shortcut");
		else
			System.out.println("You chose " + cmd);
		Object cmp = evt.getSource();
		// System.out.println("Source " + cmp);
		if (cmp == exitItem)
			System.exit(0);
	}

	public static void main(String[] arg) {
		new JiltBefore("Testing 1 2 3...").setVisible(true);
	}
}
//@@@@@@//
//i18n/JOptionDemo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;

import com.darwinsys.swingui.I18N;

/**
 * I18N'd JOptionPane
 * @author Ian Darwin
 */
public class JOptionDemo extends JFrame {

	ResourceBundle rb;

	// Constructor
	JOptionDemo(String s) {
		super(s);

		Container cp = getContentPane();
		cp.setLayout(new FlowLayout());

		rb = ResourceBundle.getBundle("Widgets");

		JButton b = I18N.mkButton(rb, "getButton");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				JOptionPane.showMessageDialog(
					JOptionDemo.this,
					rb.getString("dialog1.text"),
					rb.getString("dialog1.title"),
					JOptionPane.INFORMATION_MESSAGE);
			}
		});
		cp.add(b);

		b = I18N.mkButton(rb, "goodbye");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.exit(0);
			}
		});
		cp.add(b);

		// the main window
		setSize(200, 150);
		pack();
	}

	public static void main(String[] arg) {
		JOptionDemo x = new JOptionDemo("Testing 1 2 3...");
		x.setVisible(true);
	}
}
//@@@@@@//
//i18n/ListLocales.java
//@@@@@@//
import java.util.Locale;

public class ListLocales {
	public static void main(String[] args) {
		Locale[] ll = Locale.getAvailableLocales();
		for (int i=0; i<ll.length; i++)
			System.out.println(ll[i]);
	}
}
//@@@@@@//
//i18n/MenuIntl.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;

/** This is a partly-internationalized version of MenuDemo.
 * To try it out, use
 *		java MenuIntl
 *		java -Duser.language=es MenuIntl
 */
public class MenuIntl extends JFrame {

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create an MenuIntl object, tell it to show up
		new MenuIntl().setVisible(true);
	}

	/** Construct the object including its GUI */
	public MenuIntl() {
		super("MenuIntlTest");
		JMenuItem mi;		// used in various spots

		Container cp = getContentPane();
		cp.setLayout(new FlowLayout());
		JLabel lab;
		cp.add(lab = new JLabel());

		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
		JMenuBar mb = new JMenuBar();
		setJMenuBar(mb);

		ResourceBundle b = ResourceBundle.getBundle("Menus");

		String titlebar;
		try { titlebar = b.getString("program"+".title"); }
		catch (MissingResourceException e) { titlebar="MenuIntl Demo"; }
		setTitle(titlebar);

		String message;
		try { message = b.getString("program"+".message"); }
		catch (MissingResourceException e) { 
			message="Welcome to the world of Java";
		}
		lab.setText(message);

		JMenu fm = mkMenu(b, "file");
		fm.add(mi = mkMenuItem(b, "file", "open"));
		// In finished code there would be a call to
		// mi.addActionListener(...) after *each* of 
		// these mkMenuItem calls!
		fm.add(mi = mkMenuItem(b, "file", "new"));
		fm.add(mi = mkMenuItem(b, "file", "save"));
		fm.add(mi = mkMenuItem(b, "file", "exit"));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				MenuIntl.this.setVisible(false);
				MenuIntl.this.dispose();
				System.exit(0);
			}
		});
		mb.add(fm);

		JMenu vm = mkMenu(b,  "view");
		vm.add(mi = mkMenuItem(b, "view", "tree"));
		vm.add(mi = mkMenuItem(b, "view", "list"));
		vm.add(mi = mkMenuItem(b, "view", "longlist"));
		mb.add(vm);

		JMenu hm = mkMenu(b,  "help");
		hm.add(mi = mkMenuItem(b, "help", "about"));
		// mb.setHelpMenu(hm);	// needed for portability (Motif, etc.).

		// the main window
		JLabel jl = new JLabel("Menu Demo Window");
		jl.setSize(200, 150);
		cp.add(jl);
		pack();
	}

	/** Convenience routine to make a JMenu */
	public JMenu mkMenu(ResourceBundle b, String name) {
		String menuLabel;
		try { menuLabel = b.getString(name+".label"); }
		catch (MissingResourceException e) { menuLabel=name; }
		return new JMenu(menuLabel);
	}

	/** Convenience routine to make a JMenuItem */
	public JMenuItem mkMenuItem(ResourceBundle b, String menu, String name) {
		String miLabel;
		try { miLabel = b.getString(menu + "." + name + ".label"); }
		catch (MissingResourceException e) { miLabel=name; }
		String key = null;
		try { key = b.getString(menu + "." + name + ".key"); }
		catch (MissingResourceException e) { key=null; }

		if (key == null)
			return new JMenuItem(miLabel);
		else
			return new JMenuItem(miLabel, key.charAt(0));
	}

}
//@@@@@@//
//i18n/MenuIntl2.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;

import com.darwinsys.swingui.I18N;

/** This is a partly-internationalized version of MenuDemo.
 * To try it out, use
 *		java MenuIntl2
 *		java -Duser.language=es MenuIntl2
 */
public class MenuIntl2 extends JFrame {

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create an MenuIntl object, tell it to show up
		new MenuIntl2().setVisible(true);
	}

	/** Construct the object including its GUI */
	public MenuIntl2() {
		super("MenuIntlTest");
		JMenuItem mi;		// used in various spots

		Container cp = getContentPane();
		cp.setLayout(new FlowLayout());
		JLabel lab;
		cp.add(lab = new JLabel());

		addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
		JMenuBar mb = new JMenuBar();
		setJMenuBar(mb);

		ResourceBundle rb = ResourceBundle.getBundle("Widgets");

		String titlebar;
		try { titlebar = rb.getString("program"+".title"); }
		catch (MissingResourceException e) { titlebar="MenuIntl2 Demo"; }
		setTitle(titlebar);

		String message;
		try { message = rb.getString("program"+".message"); }
		catch (MissingResourceException e) { 
			message="Welcome to the world of Java";
		}
		lab.setText(message);

		JMenu fm = I18N.mkMenu(rb, "file");
		fm.add(mi = I18N.mkMenuItem(rb, "file", "open"));
		fm.add(mi = I18N.mkMenuItem(rb, "file", "new"));
		fm.add(mi = I18N.mkMenuItem(rb, "file", "save"));
		fm.add(mi = I18N.mkMenuItem(rb, "file", "exit"));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				MenuIntl2.this.setVisible(false);
				MenuIntl2.this.dispose();
				System.exit(0);
			}
		});
		mb.add(fm);

		JMenu vm = I18N.mkMenu(rb,  "view");
		vm.add(mi = I18N.mkMenuItem(rb, "view", "tree"));
		vm.add(mi = I18N.mkMenuItem(rb, "view", "list"));
		vm.add(mi = I18N.mkMenuItem(rb, "view", "longlist"));
		mb.add(vm);

		JMenu hm = I18N.mkMenu(rb,  "help");
		hm.add(mi = I18N.mkMenuItem(rb, "help", "about"));
		// mb.setHelpMenu(hm);	// needed for portability (Motif, etc.).

		// the main window
		JLabel myLabel = new JLabel("Menu Demo Window");
		myLabel.setSize(200, 150);
		getContentPane().add(myLabel);
		pack();
	}
}
//@@@@@@//
//i18n/MessageFormatDemo.java
//@@@@@@//
import java.text.*;

public class MessageFormatDemo {

	static Object[] data = {
			new java.util.Date(),
			"myfile.txt",
			"could not be opened"
	};

	public static void main(String[] args) {
		String result = MessageFormat.format(
			"At {0,time} on {0,date}, {1} {2}.", data);
		System.out.println(result);
	}
}
//@@@@@@//
//i18n/MessageFormatDemoIntl.java
//@@@@@@//
import java.text.*;
import java.util.*;

public class MessageFormatDemoIntl {

	static Object[] data = {
			new Date(),
			"myfile.txt",
			null
	};

	public static void main(String[] args) {
		ResourceBundle rb = ResourceBundle.getBundle("Widgets");
		data[2] = rb.getString("filedialogs.cantopen.string");
		String result = MessageFormat.format(
			rb.getString("filedialogs.cantopen.format"), data);
		System.out.println(result);
	}
}
//@@@@@@//
//i18n/OneButton.java
//@@@@@@//
import javax.swing.*;
import java.util.*;

/**
 * Create one button, internationalizedly.
 */
public class OneButton extends JFrame {

	public static void main(String[] args) {
		new OneButton().setVisible(true);
	}

	public OneButton() {
		ResourceBundle rb = ResourceBundle.getBundle("Widgets");
		String label = null;
		try {
			label = rb.getString("exit.label");
		} catch (MissingResourceException e) {
			label="Exit"; // fallback
		}
		this.add(new JButton(label));
	}
}
//@@@@@@//
//i18n/SetLocale.java
//@@@@@@//
import java.text.*;
import java.util.*;

/** Change the default locale */
public class SetLocale {
	public static void main(String[] args) {

		switch (args.length) {
		case 0:
			Locale.setDefault(Locale.FRANCE);
			break;
		case 1:
			throw new IllegalArgumentException();
		case 2:
			Locale.setDefault(new Locale(args[0], args[1]));
			break;
		default:
			System.out.println("Usage: SetLocale [language [country]]");
			// FALLTHROUGH
		}

		DateFormat df = DateFormat.getInstance();
		NumberFormat nf = NumberFormat.getInstance();

		System.out.println(df.format(new Date()));
		System.out.println(nf.format(123.4567));
	}
}
//@@@@@@//
//i18n/ShowDate.java
//@@@@@@//
import java.text.*;
import java.util.*;

public class ShowDate {
	public static void main(String[] args) {
		DateFormat df = DateFormat.getDateTimeInstance(
			DateFormat.MEDIUM, DateFormat.MEDIUM, Locale.CANADA_FRENCH);
		System.out.println(df.format(new Date()));
	}
}
//@@@@@@//
//i18n/UseDefaultLocale.java
//@@@@@@//
import java.text.*;
import java.util.*;

/** Format some values using the default locale */
public class UseDefaultLocale {
	public static void main(String[] args) {

		DateFormat df = DateFormat.getInstance();
		NumberFormat nf = NumberFormat.getInstance();

		System.out.println(df.format(new Date()));
		System.out.println(nf.format(123.4567));
	}
}
//@@@@@@//
//i18n/UseLocales.java
//@@@@@@//
import java.text.*;
import java.util.*;

/** Use some locales
 * choices or -Duser.lang= or -Duser.region=.
 */
public class UseLocales {
	public static void main(String[] args) {

		Locale frLocale = Locale.FRANCE;	// predefined
		Locale ukLocale = new Locale("en", "UK");	// English, UK version

		DateFormat defaultDateFormatter = DateFormat.getDateInstance(
			DateFormat.MEDIUM);
		DateFormat frDateFormatter = DateFormat.getDateInstance(
			DateFormat.MEDIUM, frLocale);
		DateFormat ukDateFormatter = DateFormat.getDateInstance(
			DateFormat.MEDIUM, ukLocale);

		Date now = new Date();
		System.out.println("Default: " + ' ' +
			defaultDateFormatter.format(now));
		System.out.println(frLocale.getDisplayName() + ' ' +
			frDateFormatter.format(now));
		System.out.println(ukLocale.getDisplayName() + ' ' +
			ukDateFormatter.format(now));
	}
}
//@@@@@@//
//introspection/APIFormatter.java
//@@@@@@//
import java.io.*;
import java.util.*;
import java.util.zip.*;

/**
 * <p>
 * APIFormatter reads one or more Zip files, gets all entries from each
 * and, for each entry that ends in ".class", loads it with Class.forName()
 * and hands it off to a doClass(Class c) method declared in a subclass.
 * <br/>TODO<br/>
 * Use GETOPT to control doingStandardClasses, verbosity level, etc.
 * @author	Ian Darwin, Ian@DarwinSys.com
 * @version	$Id: APIFormatter.java,v 1.6 2004/03/14 14:00:34 ian Exp $
 */
public abstract class APIFormatter {

	/** True if we are doing classpath, so only do java. and javax. */
	protected static boolean doingStandardClasses = true;
	
	protected int doArgs(String[] argv) throws IOException {
		/** Counter of fields/methods printed. */
		int n = 0;

		// TODO: options
		// -b - process bootclasspath
		// -c - process classpath (default)
		// -s - only process "java." and "javax."

		if (argv.length == 0) {
			// No arguments, look in CLASSPATH
			String s = System.getProperty("java.class.path");
			//  break apart with path sep.
			String pathSep = System.getProperty("path.separator");
			StringTokenizer st = new StringTokenizer(s, pathSep);
			// Process each zip in classpath
			while (st.hasMoreTokens()) {
				String thisFile = st.nextToken();
				System.err.println("Trying path " + thisFile);
				if (thisFile.endsWith(".zip") || thisFile.endsWith(".jar"))
					processOneZip(thisFile);
			}
		} else {
			// We have arguments, process them as zip/jar files
			// doingStandardClasses = false;
			for (int i=0; i<argv.length; i++)
				processOneZip(argv[i]);
		}

		return n;
	}

	/** For each Zip file, for each entry, xref it */
	public void processOneZip(String fileName) throws IOException {
			List entries = new ArrayList();
			ZipFile zipFile = null;

			try {
				zipFile = new ZipFile(new File(fileName));
			} catch (ZipException zz) {
				throw new FileNotFoundException(zz.toString() + fileName);
			}
			Enumeration all = zipFile.entries();

			// Put the entries into the List for sorting...
			while (all.hasMoreElements()) {
				ZipEntry zipEntry = (ZipEntry)all.nextElement();
				entries.add(zipEntry);
			}

			// Sort the entries (by class name)
			// Collections.sort(entries);

			// Process all the entries in this zip.
			Iterator it = entries.iterator();
			while (it.hasNext()) {
				ZipEntry zipEntry = (ZipEntry)it.next();
				String zipName = zipEntry.getName();

				// Ignore package/directory, other odd-ball stuff.
				if (zipEntry.isDirectory()) {
					continue;
				}

				// Ignore META-INF stuff
				if (zipName.startsWith("META-INF/")) {
					continue;
				}

				// Ignore images, HTML, whatever else we find.
				if (!zipName.endsWith(".class")) {
					continue;
				}

				// If doing CLASSPATH, Ignore com.* which are "internal API".
			// 	if (doingStandardClasses && !zipName.startsWith("java")){
			// 		continue;
			// 	}
			
				// Convert the zip file entry name, like
				//	java/lang/Math.class
				// to a class name like
				//	java.lang.Math
				String className = zipName.replace('/', '.').
					substring(0, zipName.length() - 6);	// 6 for ".class"

				// Now get the Class object for it.
				Class c = null;
				try {
					c = Class.forName(className);
				} catch (ClassNotFoundException ex) {
					System.err.println("Error: " + ex);
				}

				// Hand it off to the subclass...
				doClass(c);
			}
	}

	/** Format the fields and methods of one class, given its name.
	 */
	protected abstract void doClass(Class c) throws IOException;
}
//@@@@@@//
//introspection/AppletAdapter.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.io.*;
import java.net.*;
import java.util.*;

/*
 * AppletAdaptor: partial implementation of AppletStub and AppletContext.
 *
 * This code is far from finished, as you will see.
 *
 * @author	Ian Darwin, http://www.darwinsys.com/, for Learning Tree Course 478
 */
public class AppletAdapter extends Panel implements AppletStub, AppletContext {
	/** The status window at the bottom */
	Label status = null;

	/** Construct the GUI for an Applet Status window */
	AppletAdapter() {
		super();

		// Must do this very early on, since the Applet's
		// Constructor or its init() may use showStatus()
		add(status = new Label());

		// Give "status" the full width
		status.setSize(getSize().width, status.getSize().height);

		showStatus("AppletAdapter constructed");	// now it can be said
	}

	/****************** AppletStub ***********************/
	/** Called when the applet wants to be resized.  */
	public void appletResize(int w, int h) {
		// applet.setSize(w, h);
	}

	/** Gets a reference to the applet's context.  */
	public AppletContext getAppletContext() {
		return this;
	}

	/** Gets the base URL.  */
	public URL getCodeBase() {
		return getClass().getResource(".");
	}

	/** Gets the document URL.  */
	public URL getDocumentBase() {
		return getClass().getResource(".");
	}

	/** Returns the value of the named parameter in the HTML tag.  */
	public String getParameter(String name) {
		String value = null;
		return value;
	}
	/** Determines if the applet is active.  */
	public boolean isActive() {
		return true;
	}

	/************************ AppletContext ************************/

	/** Finds and returns the applet with the given name. */
	public Applet getApplet(String an) {
		return null;
	}

	/** Finds all the applets in the document */
	public Enumeration getApplets()  {
		class AppletLister implements Enumeration {
			public boolean hasMoreElements() {
				return false;
			}
			public Object nextElement() {
				return null;
			}
		}
		return new AppletLister();
	}

	/** Create an audio clip for the given URL of a .au file */
	public AudioClip getAudioClip(URL u) {
		return null;
	}

	/** Look up and create an Image object that can be paint()ed */
	public Image getImage(URL u)  {
		return null;
	}

	/** Request to overlay the current page with a new one - ignored */
	public void showDocument(URL u) {
	}

	/** as above but with a Frame target */
	public void showDocument(URL u, String frame)  {
	}

	/** Called by the Applet to display a message in the bottom line */
	public void showStatus(String msg) {
		if (msg == null)
			msg = "";
		status.setText(msg);
	}

	/* StreamKey stuff - new in JDK1.4 */
	Map streamMap = new HashMap();

	/** Associate the stream with the key. */
	public void setStream(String key, InputStream stream) throws IOException {
		streamMap.put(key, stream);
	}

	public InputStream getStream(String key) {
		return (InputStream)streamMap.get(key);
	}

	public Iterator getStreamKeys() {
		return streamMap.keySet().iterator();
	}
}
//@@@@@@//
//introspection/AppletViewer.java
//@@@@@@//
import java.applet.Applet;
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import javax.swing.JFrame;

/*
 * AppletViewer - a simple Applet Viewer program.
 * @author	Ian Darwin, http://www.darwinsys.com/
 */
public class AppletViewer {
	/** The main Frame of this program */
	JFrame f;
	/** The AppletAdapter (gives AppletStub, AppletContext, showStatus) */
	static AppletAdapter aa = null;
	/** The name of the Applet subclass */
	String appName = null;
	/** The Class for the actual applet type */
	Class ac = null;
	/** The Applet instance we are running, or null. Can not be a JApplet
	 * until all the entire world is converted to JApplet. */
	Applet ai = null;
	/** The width of the Applet */
	final int WIDTH = 250;
	/** The height of the Applet */
	final int HEIGHT = 200;

	/** Main is where it all starts. 
	 * Construct the GUI. Load the Applet. Start it running.
	 */
	public static void main(String[] av) {
		new AppletViewer(av.length==0?"HelloApplet":av[0]);
	}

	/** Construct the GUI for an Applet Viewer */
	AppletViewer(String appName) {
		super();

		this.appName = appName;

		f = new JFrame("AppletViewer");
		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				f.setVisible(false);
				f.dispose();
				System.exit(0);
			}
		});
		Container cp = f.getContentPane();
		cp.setLayout(new BorderLayout());

		// Instantiate the AppletAdapter which gives us
		// AppletStub and AppletContext.
		if (aa == null)
			aa = new AppletAdapter();

		// The AppletAdapter also gives us showStatus.
		// Therefore, must add() it very early on, since the Applet's
		// Constructor or its init() may use showStatus()
		cp.add(BorderLayout.SOUTH, aa);

		showStatus("Loading Applet " + appName);

		loadApplet(appName , WIDTH, HEIGHT);	// sets ac and ai
		if (ai == null)
			return;

		// Now right away, tell the Applet how to find showStatus et al.
		ai.setStub(aa);

		// Connect the Applet to the Frame.
		cp.add(BorderLayout.CENTER, ai);

		Dimension d = ai.getSize();
		d.height += aa.getSize().height;
		f.setSize(d);
		f.setVisible(true);		// make the Frame and all in it appear

		showStatus("Applet " + appName + " loaded");

		// Here we pretend to be a browser!
		ai.init();
		ai.start();
	}

	/*
	 * Load the Applet into memory. Should do caching.
	 */
	void loadApplet(String appletName, int w, int h) {
		// appletName = ... extract from the HTML CODE= somehow ...;
		// width = 		ditto
		// height = 		ditto
		try {
			// get a Class object for the Applet subclass
			ac = Class.forName(appletName);
			// Construct an instance (as if using no-argument constructor)
			ai = (Applet) ac.newInstance();
		} catch(ClassNotFoundException e) {
			showStatus("Applet subclass " + appletName + " did not load");
			return;
		} catch (Exception e ){
			showStatus("Applet " + appletName + " did not instantiate");
			return;
		}
		ai.setSize(w, h);
	}

	public void showStatus(String s) {
		aa.getAppletContext().showStatus(s);
	}
}
//@@@@@@//
//introspection/ClassForName.java
//@@@@@@//
import java.awt.Frame;

/** Demonstrate "classFor" to create an instance of an object. */
public class ClassForName {
	public static void main(String[] av) {
		Class  c = null;
		Object o = null;
		try {
			// Load the class, return a Class for it
			c = Class.forName("java.awt.Frame");
			// Construct an object, as if new Type()
			o = c.newInstance();
		} catch (Exception e) {
			System.err.println("That didn't work. " +
				" Try something else" + e);
		}
		if (o != null && o instanceof Frame) {
			Frame f = (Frame)o;
			f.setTitle("Testing");
			f.setVisible(true);
		} else throw new 
			IllegalArgumentException("Huh? What gives?");
	}
}
//@@@@@@//
//introspection/ClassKeyword.java
//@@@@@@//
import java.util.*;
/**
 * Show the class keyword and getClass() method in action.
 * The class keyword can be applied to any type known at compile time.
 * 
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ClassKeyword.java,v 1.4 2004/02/09 03:33:51 ian Exp $
 */
public class ClassKeyword {
	public static void main(String[] argv) {
		//+
		System.out.println("Trying the ClassName.class keyword:");
		System.out.println("Object class: " + Object.class);
		System.out.println("String class: " + String.class);
		System.out.println("String[] class: " + String[].class);
		System.out.println("Calendar class: " + Calendar.class);
		System.out.println("Current class: " + ClassKeyword.class);
		System.out.println("Class for int: " + int.class);
		System.out.println();

		System.out.println("Trying the instance.getClass() method:");
		System.out.println("Sir Robin the Brave".getClass());
		System.out.println(Calendar.getInstance().getClass());
		//-
	}
}
//@@@@@@//
//introspection/ClassLoaderDemo0.java
//@@@@@@//
import java.lang.reflect.*;
import java.util.*;

/**
 * Simple Demonstration of a ClassLoader
 * WILL NOT COMPILE OUT OF THE BOX -- WILL ONLY WORK AS PART OF
 * THE CLASSLOADER EXERCISE. See ClassLoader1 for a working version.
 */
public class ClassLoaderDemo0 extends ClassLoader {
	/** The Hashtable to keep track of classes, to avoid re-loading them */
	protected Hashtable cache = new Hashtable();

	/** INSERT HERE THE RESULT OF DUMPING DEMO.CLASS */
	byte[] data /* = ... */;
	int dataLength;

	/** END OF INSERTION OF THE RESULT OF DUMPING DEMO.CLASS */

	/** "load", that is, generate, the data for the class */
	private byte[] genClassData(String name) {
		if (dataLength != data.length)	// EXPECT COMPILE ERROR in javasrc
			throw new IllegalArgumentException(
				"data corrupt, " + dataLength + "!=" + data.length);
		byte[] bd = new byte[data.length];
		for (int i=0; i<bd.length; i++)
			bd[i] = (byte)data[i];
		return bd;
	}

	public synchronized Class loadClass(String name, boolean resolve) 
			throws ClassNotFoundException { 
		Class c = (Class)cache.get(name);
		if (c == null) {
			// System.out.println("loadClass: About to genClassData " + name);
			byte mydata[] = genClassData(name);
			// System.out.println("loadClass: About to defineClass " + name);
			c = defineClass(name, mydata, 0, mydata.length);
			System.out.println("loadClass: storing " + name + " in cache.");
			cache.put(name, c);
		} else
			System.out.println("loadClass: found " + name + " in cache.");
		if (resolve) {
			System.out.println("loadClass: About to resolveClass " + name);
			resolveClass(c);
		}
		return c;
	}

	public static void main(String[] argv) {
		System.out.println("ClassLoaderDemo starting");
		ClassLoaderDemo0 loader = new ClassLoaderDemo0();
		Class c = null;
		Object demo;
		try {
			/* Load the "Demo" class from memory */

			System.out.println("About to load class  Demo");
			c = loader.loadClass("Demo", true);
			System.out.println("About to instantiate class Demo");
			demo = c.newInstance();
			System.out.println("Got Demo class loaded: " + demo);

			/* Now try to call a method */

			Method mi = c.getMethod("test", null);
			mi.invoke(demo, null);

		} catch (InvocationTargetException e) {
			// The invoked method threw an exception. We get it
			// wrapped up inside another exception, hence the
			// extra call here:
			e.getTargetException().printStackTrace();
			System.out.println("Could not run test method");
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("Could not run test method");
		}
	}
}
//@@@@@@//
//introspection/ClassLoaderDemo1.java
//@@@@@@//
import java.lang.reflect.*;
import java.util.*;

/**
 * Demonstration of a ClassLoader
 */
public class ClassLoaderDemo1 extends ClassLoader {
	/** The Hashtable to keep track of classes, to avoid re-loading them */
	protected Hashtable cache = new Hashtable();
	/** data's expected length */
	private final int dataLength = 433;
	/** data, obtained by dumping a compiled .class file */
	private int[] data = {
		202, 254, 186, 190, 0, 3, 0, 45, 0, 31, 
		8, 0, 20, 7, 0, 17, 7, 0, 25, 7, 
		0, 26, 7, 0, 27, 10, 0, 4, 0, 9, 
		9, 0, 5, 0, 10, 10, 0, 3, 0, 11, 
		12, 0, 14, 0, 12, 12, 0, 28, 0, 22, 
		12, 0, 29, 0, 13, 1, 0, 3, 40, 41, 
		86, 1, 0, 21, 40, 76, 106, 97, 118, 97, 
		47, 108, 97, 110, 103, 47, 83, 116, 114, 105, 
		110, 103, 59, 41, 86, 1, 0, 6, 60, 105, 
		110, 105, 116, 62, 1, 0, 4, 67, 111, 100, 
		101, 1, 0, 13, 67, 111, 110, 115, 116, 97, 
		110, 116, 86, 97, 108, 117, 101, 1, 0, 4, 
		68, 101, 109, 111, 1, 0, 9, 68, 101, 109, 
		111, 46, 106, 97, 118, 97, 1, 0, 10, 69, 
		120, 99, 101, 112, 116, 105, 111, 110, 115, 1, 
		0, 10, 72, 101, 108, 108, 111, 32, 74, 97, 
		118, 97, 1, 0, 15, 76, 105, 110, 101, 78, 
		117, 109, 98, 101, 114, 84, 97, 98, 108, 101, 
		1, 0, 21, 76, 106, 97, 118, 97, 47, 105, 
		111, 47, 80, 114, 105, 110, 116, 83, 116, 114, 
		101, 97, 109, 59, 1, 0, 14, 76, 111, 99, 
		97, 108, 86, 97, 114, 105, 97, 98, 108, 101, 
		115, 1, 0, 10, 83, 111, 117, 114, 99, 101, 
		70, 105, 108, 101, 1, 0, 19, 106, 97, 118, 
		97, 47, 105, 111, 47, 80, 114, 105, 110, 116, 
		83, 116, 114, 101, 97, 109, 1, 0, 16, 106, 
		97, 118, 97, 47, 108, 97, 110, 103, 47, 79, 
		98, 106, 101, 99, 116, 1, 0, 16, 106, 97, 
		118, 97, 47, 108, 97, 110, 103, 47, 83, 121, 
		115, 116, 101, 109, 1, 0, 3, 111, 117, 116, 
		1, 0, 7, 112, 114, 105, 110, 116, 108, 110, 
		1, 0, 4, 116, 101, 115, 116, 0, 33, 0, 
		2, 0, 4, 0, 0, 0, 0, 0, 2, 0, 
		9, 0, 30, 0, 12, 0, 1, 0, 15, 0, 
		0, 0, 37, 0, 2, 0, 0, 0, 0, 0, 
		9, 178, 0, 7, 18, 1, 182, 0, 8, 177, 
		0, 0, 0, 1, 0, 21, 0, 0, 0, 10, 
		0, 2, 0, 0, 0, 9, 0, 8, 0, 8, 
		0, 1, 0, 14, 0, 12, 0, 1, 0, 15, 
		0, 0, 0, 29, 0, 1, 0, 1, 0, 0, 
		0, 5, 42, 183, 0, 6, 177, 0, 0, 0, 
		1, 0, 21, 0, 0, 0, 6, 0, 1, 0, 
		0, 0, 7, 0, 1, 0, 24, 0, 0, 0, 
		2, 0, 18
	};

	/** "load", that is, make up, the data for the class */
	private byte[] genClassData(String name) {
		if (dataLength != data.length)
			throw new IllegalArgumentException("data corrupt");
		byte[] bd = new byte[data.length];
		for (int i=0; i<bd.length; i++)
			bd[i] = (byte)data[i];
		return bd;
	}

	public synchronized Class loadClass(String name, boolean resolve) 
			throws ClassNotFoundException { 
		/** We can expect to be called to resolve at least demo's
		 * superclass (java.lang.Object). Fortunatetely, we can just
		 * use super.findSystemClass() to load such things...
		 */
		if (name.startsWith("java.")) {
			System.out.println("loadClass: SystemLoading " + name);
			return findSystemClass(name);
		}
		Class c = (Class)cache.get(name);
		if (c == null) {
			System.out.println("loadClass: About to genClassData " + name);
			byte mydata[] = genClassData(name);
			System.out.println("loadClass: About to defineClass " + name);
			c = defineClass(name, mydata, 0, mydata.length);
			System.out.println("loadClass: storing " + name + " in cache.");
			cache.put(name, c);
		} else
			System.out.println("loadClass: found " + name + " in cache.");
		if (resolve) {
			System.out.println("loadClass: About to resolveClass " + name);
			resolveClass(c);
		}
		return c;
	}

	public static void main(String[] argv) {
		System.out.println("ClassLoaderDemo1 starting");
		ClassLoaderDemo1 loader = new ClassLoaderDemo1();
		Class c = null;
		Object demo;
		try {
			/* Load the "Demo" class from memory */

			System.out.println("About to load class  Demo");
			c = loader.loadClass("Demo", true);
			System.out.println("About to instantiate class Demo");
			demo = c.newInstance();
			System.out.println("Got Demo class loaded: " + demo);

			/* Now try to call a method */

			Method mi = c.getMethod("test", null);
			mi.invoke(demo, null);

		} catch (InvocationTargetException e) {
			// The invoked method threw an exception. We get it
			// wrapped up inside another exception, hence the
			// extra call here:
			e.getTargetException().printStackTrace();
			System.out.println("Could not run test method");
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("Could not run test method");
		}

		/** Try to load some arbitrary class, to see if our
		 * ClassLoader gets called.
		 */
		System.out.println("Trying to load an unrelated class");
		java.awt.image.DirectColorModel jnk = new java.awt.image.DirectColorModel(24,8,8,8);
		System.out.println("Load an unrelated class - was your ClassLoader called?");

		/** Try to instantiate a second ClassLoader */
		System.out.println("Trying to install another ClassLoader");
		ClassLoaderDemo1 loader2 = new ClassLoaderDemo1();
		System.out.println("Instantiated another ClassLoader...");
	}
}
//@@@@@@//
//introspection/Cookies.java
//@@@@@@//
/**
 * This is the part of the Cookies application that loads
 * the user-defined subclass.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Cookies.java,v 1.3 2004/02/09 03:33:51 ian Exp $
 */
public class Cookies {
	public static void main(String[] argv) {
		System.out.println("Cookies Application Version 0.0");
		Cooklet cooklet = null;
		String cookletClassName = argv[0];
		try {
			Class cookletClass = Class.forName(cookletClassName);
			Object cookletObject = cookletClass.newInstance();
			cooklet = (Cooklet)cookletObject;
		} catch (Exception e) {
			System.err.println("Error " + cookletClassName + e);
		}
		cooklet.initialize();
		cooklet.work();
		cooklet.terminate();
	}
}
//@@@@@@//
//introspection/Cooklet.java
//@@@@@@//
/** A simple class, just to provide the list of methods that 
 * users need to provide to be usable in our application.
 * Note that the class is abstract so you must subclass it,
 * but the methods are non-abstract so you don't have to provide
 * dummy versions if you don't need a particular functionality.
 * @version $Id: Cooklet.java,v 1.1 2000/01/23 16:24:59 ian Exp $
 */
public abstract class Cooklet {

	/** The initialization method. The Cookie application will
	 * call you here (AFTER calling your no-argument constructor)
	 * to allow you to initialize your code
	 */
	public void initialize() {
	}

	/** The work method. The cookie application will call you
	 * here when it is time for you to start cooking.
	 */
	public void work() {
	}

	/** The termination method. The cookie application will call you
	 * here when it is time for you to stop cooking and shut down
	 * in an orderly fashion.
	 */
	public void terminate() {
	}
}
//@@@@@@//
//introspection/CrossRef.java
//@@@@@@//
import java.io.*;
import java.util.*;
import java.lang.reflect.*;

/**
 * CrossRef prints a cross-reference about all classes named in argv.
 * For each class, all public fields and methods are listed.
 * "Reflectance" is used to look up the information.
 *
 * It is expected that the output will be post-processed e.g.,
 * with sort and awk/perl. Try: 
	java CrossRef | 
		uniq | # squeeze out polymorphic forms early
		sort | awk '$2=="method" { ... }' > crossref-methods.txt
 * The part in "{ ... }" is left as an exercise for the reader. :-(
 *
 * @author	Ian Darwin, Ian@DarwinSys.com
 * @version	$Id: CrossRef.java,v 1.16 2003/04/08 20:01:44 ian Exp $
 */
public class CrossRef extends APIFormatter {

	/** Simple main program, construct self, process each .ZIP file
	 * found in CLASSPATH or in argv.
	 */
	public static void main(String[] argv) throws IOException {
		CrossRef xref = new CrossRef();
		xref.doArgs(argv);
	}

	/**
	 * Print the fields and methods of one class.
	 */
	protected void doClass(Class c) {
		int i, mods;
		startClass(c);
		try {
			Field[] fields = c.getDeclaredFields();
			Arrays.sort(fields, new Comparator() {
				public int compare(Object o1, Object o2) {
					return ((Field)o1).getName().compareTo(((Field)o2).getName());
				}
			});
			for (i = 0; i < fields.length; i++) {
				Field field = (Field)fields[i];
				if (!Modifier.isPrivate(field.getModifiers()))
					putField(field, c);
				// else System.err.println("private field ignored: " + field);
			}

			Method methods[] = c.getDeclaredMethods();
			// Arrays.sort(methods);
			for (i = 0; i < methods.length; i++) {
				if (!Modifier.isPrivate(methods[i].getModifiers()))
					putMethod(methods[i], c);
				// else System.err.println("pvt: " + methods[i]);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		endClass();
	}

	/** put a Field's information to the standard output.  */
	protected void putField(Field fld, Class c) {
		println(fld.getName() + " field " + c.getName() + " ");
	}

	/** put a Method's information to the standard output.  */
	protected void putMethod(Method method, Class c) {
		String methName = method.getName();
		println(methName + " method " + c.getName() + " ");
	}

	/** Print the start of a class. Unused in this version,
	 * designed to be overridden */
	protected void startClass(Class c) {
	}

	/** Print the end of a class. Unused in this version,
	 * designed to be overridden */
	protected void endClass() {
	}

	/** Convenience routine, short for System.out.println */
	protected final void println(String s) {
		System.out.println(s);
	}
}
//@@@@@@//
//introspection/CrossRefXML.java
//@@@@@@//
import java.io.*;
import java.lang.reflect.*;

/** This class subclasss CrossRef to output the information in XML.
 * @version $Id: CrossRefXML.java,v 1.3 2003/05/31 21:18:36 ian Exp $
 */
public class CrossRefXML extends CrossRef {

	public static void main(String[] argv) throws IOException {
		CrossRef xref = new CrossRefXML();
		xref.doArgs(argv);
	}

	/** Print the start of a class.
	 */
	protected void startClass(Class c) {
		println("<class><classname>" + c.getName() + "</classname>");
	}

	protected void putField(Field fld, Class c) {
		println("<field>" + fld + "</field>");
	}

	/** put a Method's information to the standard output.
	 * Marked protected so you can override it (hint, hint).
	 */
	protected void putMethod(Method method, Class c) {
		println("<method>" + method + "</method>");
	}

	/** Print the end of a class. 
	 */
	protected void endClass() {
		println("</class>");
	}
}
//@@@@@@//
//introspection/DemoCooklet.java
//@@@@@@//
public class DemoCooklet extends Cooklet {
	public void work() {
		System.out.println("I am busy baking cookies.");
	}
	public void terminate() {
		System.out.println("I am shutting down my ovens now.");
	}
}
//@@@@@@//
//introspection/FindField.java
//@@@@@@//
import java.lang.reflect.*;
import java.util.*;

/** This class shows using Reflection to get a field from another class. */
public class FindField {

	public static void main(String[] unused) 
	throws NoSuchFieldException, IllegalAccessException {

		// Create instance of FindField
		FindField gf = new FindField();

		// Create instance of target class (YearHolder defined below).
		Object o = new YearHolder();

		// Use gf to extract a field from o.
		System.out.println("The value of 'currentYear' is: " +
			gf.intFieldValue(o, "currentYear"));
	}

	int intFieldValue(Object o, String name)
	throws NoSuchFieldException, IllegalAccessException {
		Class c = o.getClass();
		Field fld = c.getField(name);
		int value = fld.getInt(o);
		return value;
	}
}

/** This is just a class that we want to get a field from */
class YearHolder {
	/** Just a field that is used to show getting a field's value. */
	public int currentYear = Calendar.getInstance().get(Calendar.YEAR);
}
//@@@@@@//
//introspection/GetMethod.java
//@@@@@@//
import java.lang.reflect.*;

/** This class is just here to give us something to work on,
 * with a println() call that will prove we got here. */
class X {
	public void work(String s) {
		System.out.println("Working on \"" + s + "\"");
	}
}

/**
 * Get a given method, and invoke it.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: GetMethod.java,v 1.3 2004/02/09 03:33:51 ian Exp $
 */
public class GetMethod {

	public static void main(String[] argv) {
		try {
			Class clX = X.class; // or Class.forName("X");
			// To find a method we need the array of matching Class types.
			Class[] argTypes = {
				String.class
			};

			// Now find a Method object for the given method.
			Method worker = clX.getMethod("work", argTypes);

			// To INVOKE the method, we need its actual arguments, as an array.
			Object[] theData = {
				"Chocolate Chips"
			};

			// The obvious last step: invoke the method.
			worker.invoke(new X(), theData);
		} catch (Exception e) {
			System.err.println("Invoke() failed: " + e);
		}
	}
}
//@@@@@@//
//introspection/HelloApplet.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

/**
 * HelloApplet is a simple applet that toggles a message
 * when you click on a Draw button.
 */
public class HelloApplet extends JApplet {

	/** The flag which controls drawing the message. */
	protected boolean requested;

	/** init() is an Applet method called by the browser to initialize */
	public void init() {
		JButton b;
		requested = false;
		Container cp = (Container)getContentPane();
		cp.setLayout(new FlowLayout());
		cp.add(b = new JButton("Draw/Don't Draw"));
		b.addActionListener(new ActionListener() {
			/*  Button - toggle the state of the "requested" flag, to draw or
			 *  not to draw.
			 */
			public void actionPerformed(ActionEvent e) {
				String arg = e.getActionCommand();
				// Invert the state of the draw request.
				requested = !requested;
				do_the_work();
			}
		});
	}

	/** paint() is an AWT Component method, called when the 
	 *  component needs to be painted.
	 */
	public void do_the_work() {
		/* If the Draw button is selected, draw something */
		if (requested) {
			showStatus("Welcome to Java!");
		} else {
			showStatus("");	// retract welcome? :-)
		}
	}
}
//@@@@@@//
//introspection/ListMethods.java
//@@@@@@//
import java.lang.reflect.*;

/**
 * List the Constructors and methods
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ListMethods.java,v 1.3 2004/02/09 03:33:51 ian Exp $
 */
public class ListMethods {
	public static void main(String[] argv) throws ClassNotFoundException {
		if (argv.length == 0) {
			System.err.println("Usage: ListMethods className");
			return;
		}
		Class c = Class.forName(argv[0]);
		Constructor[] cons = c.getConstructors();
		printList("Constructors", cons);
		Method[] meths = c.getMethods();
		printList("Methods", meths);
	}
	static void printList(String s, Object[] o) {
		System.out.println("*** " + s + " ***");
		for (int i=0; i<o.length; i++)
			System.out.println(o[i].toString());
	}
}
//@@@@@@//
//introspection/MyJavaP.java
//@@@@@@//
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

/**
 * JavaP prints structural information about classes.
 * For each class, all public fields and methods are listed.
 * The "Reflection" API is used to look up the information.
 *
 * @version	$Id: MyJavaP.java,v 1.6 2004/03/14 17:45:51 ian Exp $
 */
public class MyJavaP {

	/** Simple main program, construct self, process each class name
	 * found in argv.
	 */
	public static void main(String[] argv) {
		MyJavaP pp = new MyJavaP();

		if (argv.length == 0) {
			System.err.println("Usage: MyJavaP className [...]");
			System.exit(1);
		} else for (int i=0; i<argv.length; i++)
			pp.doClass(argv[i]);
	}

	/** Format the fields and methods of one class, given its name.
	 */
	protected void doClass(String className) {

		try {
			Class c = Class.forName(className);
			System.out.println(Modifier.toString(c.getModifiers()) + ' ' + c + " {");

			int mods;
			Field fields[] = c.getDeclaredFields();
			for (int i = 0; i < fields.length; i++) {
				if (!Modifier.isPrivate(fields[i].getModifiers())
				 && !Modifier.isProtected(fields[i].getModifiers()))
					System.out.println("\t" + fields[i]);
			}
			Constructor[] constructors = c.getConstructors();
			for (int j = 0; j < constructors.length; j++) {
				Constructor constructor = constructors[j];
				System.out.println("\t" + constructor);
				
			}
			Method methods[] = c.getDeclaredMethods();
			for (int i = 0; i < methods.length; i++) {
				if (!Modifier.isPrivate(methods[i].getModifiers())
				 && !Modifier.isProtected(methods[i].getModifiers()))
					System.out.println("\t" + methods[i]);
			}
			System.out.println("}");
		} catch (ClassNotFoundException e) {
			System.err.println("Error: Class " + 
				className + " not found!");
		} catch (Exception e) {
			System.err.println(e);
		}
	}
}
//@@@@@@//
//introspection/Packages.java
//@@@@@@//
/**
 * Show the Packages. Requires JDK1.2.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Packages.java,v 1.4 2004/02/09 03:33:51 ian Exp $
 */
public class Packages {
	public static void main(String[] argv) {
		//+
		java.lang.Package[] all = java.lang.Package.getPackages();
		for (int i=0; i<all.length; i++)
			System.out.println(all[i]);
		//-
	}
}
//@@@@@@//
//introspection/PrimsDotClass.java
//@@@@@@//
import java.lang.reflect.Method;

/**
 * Show that you can, in fact, take the .class of a primitive.
 */
public class PrimsDotClass {

	public static void main(String[] args) {
		Class c = int.class;
		System.out.println(c.getName());
		Method[] methods = c.getMethods();
		System.out.println(c.getName() + " has " + methods.length + " methods");
	}
}
//@@@@@@//
//introspection/Reflect1.java
//@@@@@@//
import java.lang.reflect.*;

/**
 * Reflect1 shows the information about the class named in argv[0].
 * "Reflectance" is used to look up that information.
 */
public class Reflect1 {
	public static void main(String[] args)
	{
		new Reflect1().run(args);
	}
	public void run(String classes[]) {
		for (int i=0; i<classes.length; i++)
			try {
				Class c = Class.forName(classes[i]);
				Method methods[] = c.getMethods();
				for (int m = 0; m < methods.length; m++)
					System.out.println(methods[m].toString());
			} catch (ClassNotFoundException e) {
				System.err.println("Error: Class " + 
					classes[i] + " not found!");
			} catch (Exception e) {
				System.err.println(e);
			}
	}
}

//@@@@@@//
//introspection/RevEngAPI.java
//@@@@@@//
import java.io.*;
import java.lang.reflect.*;

/** Make up a compilable version of a given Sun or other API, 
 * so developers can compile against it without a licensed copy. In Sun's case,
 * all public API info is public on Sun's web site, so this does not disclose
 * anything that is Sun Confidential.
 * <p>This is a clean-room implementation: I did not look at the code
 * for Sun's javap or any similar tool in preparing this program.
 * XXX TODO:<ul>
 * <li>Class printing: add superclasses.
 * <li>Collapse common code in printing Constructors and Methods
 * <li>Method printing: add exceptions
 * <li>Arguments: Handle arrays (names begin [L)
 * <li>Provide default (0, false, null) based on type; use in return statements
 *		and in assigment to protected final variables.
 * </ul>
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: RevEngAPI.java,v 1.11 2004/05/30 01:43:43 ian Exp $
 */
public class RevEngAPI extends APIFormatter {

	public static void main(String[] argv) throws Exception {
		new RevEngAPI().doArgs(argv);
	}

	private final static String PREFIX_ARG = "arg";
	/** Make up names like "arg0" "arg1", etc. */
	private String mkName(String name, int number) {
		return new StringBuffer(name).append(number).toString();
	}

	/** NOT THREAD SAFE */
	private String className;
	private int classNameOffset;

	/** Generate a .java file for the outline of the given class. */
	public void doClass(Class c) throws IOException {
		className = c.getName();
		// pre-compute offset for stripping package name
		classNameOffset = className.lastIndexOf('.') + 1;

		// Inner class
		if (className.indexOf('$') != -1)
			return;

		// get name, as String, with . changed to /
		String slashName = className.replace('.','/');
		String fileName = slashName + ".java";

		System.out.println(className + " --> " + fileName);

		String dirName = slashName.substring(0, slashName.lastIndexOf("/"));
		new File(dirName).mkdirs();

		// create the file.
		PrintWriter out = new PrintWriter(new FileWriter(fileName));

		out.println("// Generated by RevEngAPI for class " + className);

		// If in a package, say so.
		Package pkg;
		if ((pkg = c.getPackage()) != null) {
			out.println("package " + pkg.getName() + ';');
			out.println();
		}
		// print class header
		int cMods = c.getModifiers();
		printMods(cMods, out);
		out.print("class ");
		out.print(trim(c.getName()));
		out.print(' ');
		// XXX get superclass 
		out.println('{');

		// print constructors
		Constructor[] ctors = c.getDeclaredConstructors();
		for (int i=0; i< ctors.length; i++) {
			if (i == 0) {
				out.println();
				out.println("\t// Constructors");
			}
			Constructor cons = ctors[i];
			int mods = cons.getModifiers();
			if (Modifier.isPrivate(mods))
				continue;
			out.print('\t');
			printMods(mods, out);
			out.print(trim(cons.getName()) + "(");
			Class[] classes = cons.getParameterTypes();
			for (int j = 0; j<classes.length; j++) {
				if (j > 0) out.print(", ");
				out.print(trim(classes[j].getName()) + ' ' + 
						mkName(PREFIX_ARG, j));
			}
			out.println(") {");
			out.print("\t}");
		}

		// print method names
		Method[] mems = c.getDeclaredMethods();
		for (int i=0; i< mems.length; i++) {
			if (i == 0) {
				out.println();
				out.println("\t// Methods");
			}
			Method m = mems[i];
			if (m.getName().startsWith("access$"))
				continue;
			int mods = m.getModifiers();
			if (Modifier.isPrivate(mods))
				continue;
			out.print('\t');
			printMods(mods, out);
			out.print(m.getReturnType());
			out.print(' ');
			out.print(trim(m.getName()) + "(");
			Class[] classes = m.getParameterTypes();
			for (int j = 0; j<classes.length; j++) {
				if (j > 0) out.print(", ");
				out.print(trim(classes[j].getName()) + ' ' + 
						mkName(PREFIX_ARG, j));
			}
			out.println(") {");
			out.println("\treturn " + defaultValue(m.getReturnType()) + ';');
			out.println("\t}");
		}

		// print fields
		Field[] flds = c.getDeclaredFields();
		for (int i=0; i< flds.length; i++) {
			if (i == 0) {
				out.println();
				out.println("\t// Fields");
			}
			Field f = flds[i];
			int mods = f.getModifiers();
			if (Modifier.isPrivate(mods))
				continue;
			out.print('\t');
			printMods(mods, out);
			out.print(trim(f.getType().getName()));
			out.print(' ');
			out.print(f.getName());
			if (Modifier.isFinal(mods)) {
				try {
					out.print(" = " + f.get(null));
				} catch (IllegalAccessException ex) {
					out.print("; // " + ex.toString());
				}
			}
			out.println(';');
		}
		out.println("}");
		//out.flush();
		out.close();
	}

	private String trim(String theName) {
		return theName.startsWith(className) ?
			theName.substring(classNameOffset) : theName;
	}

	private class ModInfo {
		int val;
		String name;
		ModInfo(int v, String n) {
			val = v;
			name = n;
		}
	}

	private ModInfo[] modInfo = {
		new ModInfo(16, "final"),
		new ModInfo(2, "private"),
		new ModInfo(1, "public"),
		new ModInfo(4, "protected"),
		new ModInfo(1024, "abstract"),
		new ModInfo(8, "static"),
		new ModInfo(32, "synchronized"),
		new ModInfo(256, "native"),
		new ModInfo(128, "transient"),
		new ModInfo(64, "volatile"),
		new ModInfo(2048, "strict"),
	};

	private void printMods(int mods, PrintWriter out) {
		for (int i=0; i < modInfo.length; i++) {
			if ((mods & modInfo[i].val) == modInfo[i].val) {
				out.print(modInfo[i].name);
				out.print(' ');
			}
		}
	}

	private String defaultValue(Class c) {
		if (c.getName().equals("boolean"))
			return "false";
		// XXX else if object type return null;
		else return "0";
	}

	public void startFile() {
		// XXX save filename as project name
	}

	public void endFile() {
		// XXX generate a trivial "build.xml" for Ant to create the jar file.
	}
}
//@@@@@@//
//introspection/Simple.java
//@@@@@@//
import java.lang.reflect.*;
import java.util.*;

/**
 * Show a couple of things you can do with a Class object.
 * @author Ian F. Darwin, ian darwinsys.com
 * @version $Id: Simple.java,v 1.1 2002/10/26 14:34:28 ian Exp $
 */
public class Simple {
	public static void main(String[] argv) throws Exception {
		Class c = Class.forName("java.util.Date");

		Date d = (Date)c.newInstance();
		System.out.println("Today is " + d);

		System.out.println("d is of class " + c.getName());

		Method[] methods = c.getMethods();
		// Just print the first few to avoid filling the screen.
		for (int i=0; i<10; i++)
			System.out.println(methods[i].toString());
	}
}
//@@@@@@//
//io/AisNotA.java
//@@@@@@//
/** Show that 'A' is not always (printed as) 'A'.
 */
public class AisNotA {
	public static void main(String[] String) {
		int a = 'A';
		System.out.println(a);
	}
}
//@@@@@@//
//io/AllTests.java
//@@@@@@//
import junit.framework.Test;
import junit.framework.TestSuite;

/**
 * @author ian
 */
public class AllTests {
	public static void main(String[] args) {
		junit.textui.TestRunner.run(AllTests.suite());
	}
	public static Test suite() {
		TestSuite suite = new TestSuite("Test for default package");
		//$JUnit-BEGIN$
		suite.addTestSuite(FortranLineReaderTest.class);
		suite.addTestSuite(IndentContLineReaderTest.class);
		//$JUnit-END$
		return suite;
	}
}
//@@@@@@//
//io/BadNewline.java
//@@@@@@//
/**
 * DON'T DO THIS. THIS IS BAD CODE.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: BadNewline.java,v 1.3 2004/02/08 23:57:29 ian Exp $
 */
public class BadNewline {
	//+
	String myName;
	public static void main(String[] argv) {
		BadNewline jack = new BadNewline("Jack Adolphus Schmidt, III");
		System.out.println(jack);
	}
	/**
	 * DON'T DO THIS. THIS IS BAD CODE.
	 */
	public String toString() {
		return "BadNewlineDemo@" + hashCode() + "\n" + myName;
	}

	// The obvious Constructor is not shown for brevity; it's in the code
	//-
	/* Constructor */
	public BadNewline(String s) {
		myName = s;
	}
}
//@@@@@@//
//io/CalcToken.java
//@@@@@@//
/** These are the kinds of tokens that are in the input.
 */
public enum CalcToken {

	NUMBER, NAME, ASSIGN, PLUS, MINUS, MULTIPLY, DIVIDE, PRINT;

}
//@@@@@@//
//io/CatFile.java
//@@@@@@//
import java.io.*;

/**
 * Read a file and print, using BufferedReader and System.out
 */
public class CatFile {

    public static void main(String[] av) {
        CatFile c = new CatFile();
        if (av.length == 0)
            c.process(new BufferedReader(
					new InputStreamReader(System.in)));
		else for (int i=0; i<av.length; i++)
			try {
				c.process(new BufferedReader(new FileReader(av[i])));
			} catch (FileNotFoundException e) {
				System.err.println(e);
			}
    }

    /** print one file, given an open BufferedReader */
    public void process(BufferedReader is) {
        try {
            String inputLine;

            while ((inputLine = is.readLine()) != null) {
                System.out.println(inputLine);
            }
            is.close();
        } catch (IOException e) {
            System.out.println("IOException: " + e);
        }
    }
}
//@@@@@@//
//io/CatStdin.java
//@@@@@@//
import java.io.*;

/**
 * Read and print, using BufferedReader from System.in, onto System.out
 */
public class CatStdin {

    public static void main(String[] av) {
        CatFile c = new CatFile();
        try {
            BufferedReader is = new BufferedReader(new InputStreamReader(System.in));
            String inputLine;

            while ((inputLine = is.readLine()) != null) {
                System.out.println(inputLine);
            }
            is.close();
        } catch (IOException e) {
            System.out.println("IOException: " + e);
        }
    }
}
//@@@@@@//
//io/CharMode.java
//@@@@@@//
import java.io.*;

/**
 * Read a file in character mode - maximally inefficient.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: CharMode.java,v 1.3 2004/02/08 23:57:29 ian Exp $
 */
public class CharMode {
	public static void main(String[] argv) throws IOException {
		//+
		BufferedReader is = new BufferedReader(
			new InputStreamReader(System.in));

		int c;
		while ((c=is.read()) != -1) {
			System.out.print((char)c);
		}
		//-
	}
}
//@@@@@@//
//io/ContLineReader.java
//@@@@@@//
import java.io.*;

/**
 * Subclass of LineNumberReader, parent of others, to allow reading of
 * continued lines using the readLine() method. The other Reader methods
 * (readInt()) etc.) must not be used. Must subclass to provide the actual
 * implementation of readLine().
 * 
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: ContLineReader.java,v 1.4 2004/03/07 17:27:04 ian Exp $
 */
public abstract class ContLineReader extends LineNumberReader {
	/** Line number of first line in current (possibly continued) line */
	protected int firstLineNumber = 0;
	/** True if handling continuations, false if not; false == "PRE" mode */
	protected boolean doContinue = true;

	/** Set the continuation mode */
	public void setContinuationMode(boolean b) {
		doContinue = b;
	}

	/** Get the continuation mode */
	public boolean getContinuationMode() {
		return doContinue;
	}

	/** Read one (possibly continued) line, stripping out the \ that
	 * marks the end of each line but the last in a sequence.
	 */
	public abstract String readLine() throws IOException;

	/** Read one real line. Provided as a convenience for the
	 * subclasses, so they don't embarass themselves trying to
	 * call "super.readLine()" which isn't very practical...
	 */
	public String readPhysicalLine() throws IOException {
		return super.readLine();
	}

	// Can NOT override getLineNumber in this class to return the # 
	// of the beginning of the continued line, since the subclasses
	// all call super.getLineNumber...
	
	/** Construct a ContLineReader with the default input-buffer size. */
	public ContLineReader(Reader in)  {
		super(in);
	}

	/** Construct a ContLineReader using the given input-buffer size. */
	public ContLineReader(Reader in, int sz)  {
		super(in, sz);
	}

	// Methods that do NOT work - redirect straight to parent

	/** Read a single character, returned as an int. */
	public int read() throws IOException {
		return super.read();
	}

	/** Read characters into a portion of an array. */
	public int read(char[] cbuf, int off, int len) throws IOException {
		return super.read(cbuf, off, len);
	}

	public boolean markSupported() {
		return false;
	}
}
//@@@@@@//
//io/EscapeContLineReader.java
//@@@@@@//
import java.io.*;

/** Subclass of LineNumberReader to allow reading of lines continued
 * with an escape character.
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: EscapeContLineReader.java,v 1.7 2004/02/08 23:57:29 ian Exp $
 */
public class EscapeContLineReader extends ContLineReader {
	/** The default escape character. */
	public static final char ESCAPE = '\\';
	/** The actual escape character. */
	protected char escape = ESCAPE;
	/** EOF flag, needed since we use super.readLine() several places */
	protected boolean hitEOF = false;

	/** Line number of first line in current (possibly continued) line */
	public int getLineNumber() {
		return firstLineNumber;
	}

	/** Read one (possibly continued) line, stripping out the \ that
	 * marks the end of each line but the last in a sequence.
	 */
	public String readLine() throws IOException {
		// Read the first line, save its contents in the StringBuffer
		// and its line number in firstLineNumber.
		String s = readPhysicalLine();
		if (s == null)
			hitEOF = true;
		if (hitEOF)
			return null;
		StringBuffer sb = new StringBuffer(s);
		firstLineNumber = super.getLineNumber();

		// Now read as many continued lines as there are.
		while (sb.length() > 0 && 
			sb.charAt(sb.length() - 1) == escape) {
			sb.setLength(sb.length() - 1); 	// Kill the escape
			// sb.deleteCharAt(sb.length() - 1);// Java 2 - kill it
			String nextPart = readPhysicalLine();
			if (nextPart == null) {
				hitEOF = true;
				throw new IOException(
					"EOF within continued line at line " +
					firstLineNumber);
			}
			sb.append(' ').append(nextPart);	// and add line.
		}
		return sb.toString();
	}

	/** Construct a EscapeContLineReader with the default input-buffer size. */
	public EscapeContLineReader(Reader in)  {
		super(in);
	}

	/** Construct a EscapeContLineReader using the given input-buffer size. */
	public EscapeContLineReader(Reader in, int sz)  {
		super(in, sz);
	}

	/** Construct an EscapeContLineReader given a Reader and a
	 * non-default escape character.
	 */
	public EscapeContLineReader(Reader in, char esc)  {
		super(in);
		escape = esc;
	}


	protected static String sampleTxt = 
		"Some lines of text to test the LineReader class.\n" +
		"This second line is continued with backslash.\\\n" +
		"This is a  backslash continuation.\\\n" +
		"So is this\n" +
		"This line should be the third output line.\n" +
		"EXPECT THE NEXT LINE TO THROW AN IOException\n" +
		"This tests for line ending in \\";

	public static void main(String[] argv) throws IOException {
		EscapeContLineReader is = new EscapeContLineReader(
			new StringReader(sampleTxt));
		String aLine;
		while ((aLine = is.readLine()) != null) {
			System.out.println(is.getLineNumber() + ": " + aLine);
		}
		is.close();
	}
}
//@@@@@@//
//io/FormatterDates.java
//@@@@@@//
import java.util.Formatter;
import java.util.Date;
import java.util.Calendar;

/** Demonstrate some usage patterns and format-code examples 
 * of the Formatter class (new in J2SE 1.5).
 */
public class FormatterDates {
	public static void main(String[] args) {

		// Format number as dates e.g., 2004-06-28
		System.out.printf("%1$4d-%2$02d-%3$2d%n", 2004, 6, 28);

		// Format fields directly from a Date object: multiple fields from "1$"
		// (hard-coded formatting for Date not advisable; see I18N chapter)
		Date today = Calendar.getInstance().getTime();
		System.out.printf("Today is %1$tB %1$td, %1$tY%n", today);	// e.g., July 4, 2004
	}
}
//@@@@@@//
//io/FormatterDemo.java
//@@@@@@//
import java.util.Formatter;

/** Demonstrate some usage patterns and format-code examples 
 * of the Formatter class (new in J2SE 1.5).
 */
public class FormatterDemo {
	public static void main(String[] args) {

		// The arguments to all these format methods consist of
		// a format code String and 1 or more arguments.
		// Each format code consists of the following:
		// % - code lead-in
		// N$ - which parameter number (1-based) after the code
		// N - field width
		// L - format letter (d: decimal(int); f: float; s: general; many more)
		// For the full(!) story, see javadoc for java.util.Formatter.

		Formatter fmtr = new Formatter();
		Object result = fmtr.format("%1$04d - the year of %2$f", 1951, Math.PI);
		System.out.println(result);

		// A shorter way of doing things. But this
		// way you must provide the newline delimiter
		System.out.format("%1$04d - the year of %2$f%n", 1951, Math.PI);

		// So is this
		System.out.printf("%1$04d - the year of %2$f%n", 1951, Math.PI);

		// Format doubles with more control
		System.out.printf("PI is about %1$4.2f", Math.PI);
	}
}
//@@@@@@//
//io/FortranLineReader.java
//@@@@@@//
import java.io.*;

/** Subclass of LineNumberReader to read Fortran-style lines.
 * Fortran statements, as well as I can remember them, are like:
 * NNNNNXDDDDDDDDDDDDDDDDDD
 * C...........................
 * where NNNNN is a 1-5 digit statement number, or spaces
 *	X is a continuation character, which must be in column 6
 *	DDD is executable statement
 *	... is commentary.
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: FortranLineReader.java,v 1.4 2004/03/01 01:42:20 ian Exp $
 */
public class FortranLineReader extends ContLineReader {
	public static final char COMMENT_CHAR = 'C';

	/** Line number of first line in current (possibly continued) line */
	public int getLineNumber() {
		return firstLineNumber;
	}

	/** EOF flag, needed since we use super.readLine() several places */
	protected boolean hitEOF = false;
	/** The statement number portion */
	protected String statementNum;

	/** Read one (possibly continued) line, save its text (columns 6-71)
	 * in the StringBuffer, its statement number in statementNum,
	 * and its line number in firstLineNumber.
	 */
	public String readLine() throws IOException {
		// Read the first line. 
		String s = readPhysicalLine();
		if (s == null)
			hitEOF = true;
		if (hitEOF)
			return null;
		if (s.charAt(0) == COMMENT_CHAR) {
			statementNum = null;
			return s;
		}

		statementNum = s.substring(0,5);
		StringBuffer sb = new StringBuffer(s.substring(6));
		firstLineNumber = super.getLineNumber();

		// Now read as many continued lines as there are.
		while (s.charAt(5) != ' ') {
			s = readPhysicalLine();
			if (s == null) {
				hitEOF = true;
				return sb.toString();	// Gak! EOF within continued line
			}
			// add rest of line.
			sb.append(' ').append(s.substring(6));
		}
		return sb.toString();
	}

	/** Returns true if the current logical line contains a statement # */
	public boolean hasStatementNumber() {
		return	statementNum != null &&
			statementNum.trim().length() > 0;
	}

	/** Return the statement number of the current logical line. */
	public int getStatementNumber() {
		return Integer.parseInt(statementNum.trim());
	}

	/** Construct a FortranLineReader with the default input-buffer size. */
	public FortranLineReader(Reader in)  {
		super(in);
	}

	/** Construct a FortranLineReader using the given input-buffer size. */
	public FortranLineReader(Reader in, int sz)  {
		super(in, sz);
	}

}
//@@@@@@//
//io/FortranLineReaderTest.java
//@@@@@@//
import java.io.IOException;
import java.io.StringReader;

import junit.framework.TestCase;

/**
 * @author ian
 */
public class FortranLineReaderTest extends TestCase {
	public static void main(String[] args) {
		//junit.textui.TestRunner.run(FortranLineReaderTest.suite());
	}

	protected static String sampleTxt = 
		"C      This is a comment.\n" +
		"12345xdouble precision x = " +
		"      sqrt(3.14159)\n" +
		"      This should be non-continued.\n" +
		"  3   This is statement 3 and line 3.";

	public void testReading() throws IOException {
		FortranLineReader is = new FortranLineReader(
			new StringReader(sampleTxt));
		String aLine;
		while ((aLine = is.readLine()) != null) {
			if (is.hasStatementNumber())
				System.out.println("\tStatement number: " +
					is.getStatementNumber());
			System.out.println(is.getLineNumber() + ": " + aLine);
		}
		is.close();
	}
}
//@@@@@@//
//io/GetMark.java
//@@@@@@//
import java.io.*;

/** GetMark -- get marked lines.
 * <p>
 * GetMark is a general tool for including/excluding parts of a file.
 * It can be used, for example, to extract parts of a file for use
 * in documentation, or to delete parts of a file such as the working
 * part of a solution.
 * <p>
 * The marks that it looks for are simple, and can be left in the
 * master source (they never print). The mark //+ (as looked for
 * with line.trim().equals("//+) in Java) begins printing, and the
 * opposite mark //- stops printing.
 * <p>
 * So, for a course exercise, you would develop the working
 * solution and comment it neatly, and add a //- mark after the TODO
 * comments but before the working solution, and a //+ mark after it.
 * For example:
 * </p><pre>
 * 	public methodA() {
 * 		// TODO:
 * 		// Look up the object to be invoked.
 * 		// Use a Lookup Name of "ex31object"
 * 
 * 		//-
 * 		Object o = Naming.lookup("ex31object");
 * 		//+
 * 
 * 		// TODO #2
 * 		// Downcast the looked up object using the IIOP portability
 * 
 * 		//-
 * 		Ex31Object obj = (Ex31Object)PortableRemoteObject.narrow(
 * 			o, Ex31Object.class);
 * 		//+
 * 	}
 * </pre><p>
 * When run through GetMark in "exclude" mode, the above will produce:
 * </p><pre>
 *  public methodA() {
 *      // TODO:
 *      // Look up the object to be invoked.
 *      // Use a Lookup Name of "ex31object"
 * 
 * 
 *      // TODO #2
 *      // Downcast the looked up object using the IIOP portability
 *
 *  }
 * </pre><p>
 * You could use this in a script:
 * </p><pre>
 * for f in *.java
 * do
 *    echo $f
 *    java GetMark $f &gt; ../solutions/$f
 * done
 * </pre><p>
 * For an example of using GetMark for extraction
 * (GetMark first appeared in my 
 * <a href="http://javacook.darwinsys.com/">Java Cookbook</a>),
 * see the comments in the code for GetMark itself.
 * <p>
 * In this version, the mode (include or extract) and the strings for
 * the marks are hard-coded; ideally they would come
 * from a Properties or Preferences object and/or from the command line.
 *
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: GetMark.java,v 1.16 2004/02/08 23:57:29 ian Exp $
 */
public class GetMark {
	/** the default starting mark. */
	public final String startMark = "//+";
	/** the default ending mark. */
	public final String endMark = "//-";
	/** Set this to TRUE for running in "exclude" mode (e.g., for
	 * building exercises from solutions) and to FALSE for running
	 * in "extract" mode (e.g., writing a book and ommittin the
	 * imports and "public class" stuff).
	 */
	public final static boolean START = true;
	/** True if we are currently inside marks. */
	protected boolean printing = START;
	/** True if you want line numbers */
	protected final boolean number = false;
	//-
	/* This part should be excluded! */
	int foo = 42;
	//+

    /** Get Marked parts of one file, given an open LineNumberReader.
	 * This is the main operation of this class, and can be used
	 * inside other programs or from the main() wrapper.
	 */
    public void process(String fileName,
		LineNumberReader is,
		PrintStream out) {
		//+
		int nLines = 0;
		try {
			String inputLine;

			while ((inputLine = is.readLine()) != null) {
				if (inputLine.trim().equals(startMark)) {
					if (printing)
						// These go to stderr, so you can redirect the output
						System.err.println("ERROR: START INSIDE START, " +
							fileName + ':' + is.getLineNumber());
					printing = true;
				} else if (inputLine.trim().equals(endMark)) {
					if (!printing)
						System.err.println("ERROR: STOP WHILE STOPPED, " +
							fileName + ':' + is.getLineNumber());
					printing = false;
				} else if (printing) {
					if (number) {
						out.print(nLines);
						out.print(": ");
					}
					out.println(inputLine);
					++nLines;
				}
            }
            is.close();
			out.flush(); // Must not close - caller may still need it.
			if (nLines == 0)
				System.err.println("ERROR: No marks in " + fileName +
					"; no output generated!");
		//-
        } catch (IOException e) {
            System.out.println("IOException: " + e);
        }
    }

	/** This simple main program looks after filenames and
	 * opening files and such like for you, when GetMark is being
	 * used standalone.
	 * XXX TODO options parsing, allow include/exclude, number, etc.
	 * to be set from the command line.
	 */
    public static void main(String[] av) {
        GetMark o = new GetMark();
		PrintStream pw = new PrintStream(System.out);
        if (av.length == 0) {
            o.process("standard input", new LineNumberReader(
				new InputStreamReader(System.in)), pw);
		} else {
			for (int i=0; i<av.length; i++)
				try {
					o.process(av[i],
						new LineNumberReader(new FileReader(av[i])), pw);
				} catch (FileNotFoundException e) {
					System.err.println(e);
				}
        }
    }
}
//@@@@@@//
//io/GoodNewline.java
//@@@@@@//
import java.io.*;

/**
 * Multiple lines output from one method.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: GoodNewline.java,v 1.4 2004/02/08 23:57:29 ian Exp $
 */
public class GoodNewline {
	//+
	String myName;
	public static void main(String[] argv) {
		GoodNewline jack = new GoodNewline("Jack Adolphus Schmidt, III");
		jack.print(System.out);
	}

	protected void print(PrintStream out) {
		out.println(toString());	// classname and hashcode
		out.println(myName);		// print name  on next line
	}

	//-
	/* Constructor */
	public GoodNewline(String s) {
		myName = s;
	}
}
//@@@@@@//
//io/IndentContLineReader.java
//@@@@@@//
import java.io.*;

/** Subclass of ContLineReader for lines continued by indentation of
 * following line (like RFC822 mail, Usenet News, etc.).
 * Normally you would read header & body of the message(s) with code like:
 * <pre>
 * while ((headerLine = clr.readLine()) != null && headerLine.length() > 0) {
 *	processHeaderLine(headerLine);
 * }
 * clr.setContinuationMode(false);
 * while ((bodyLine = clr.readLine()) != null) {
 *	processBodyLine(bodyLine);
 * }
 * </pre>
 */
public class IndentContLineReader extends ContLineReader {
	/** Line number of first line in current (possibly continued) line */
	public int getLineNumber() {
		return firstLineNumber;
	}

	protected String prevLine;

	/** Read one (possibly continued) line, stripping out the '\'s that
	 * mark the end of all but the last.
	 */
	public String readLine() throws IOException {
		String s;

		// If we saved a previous line, start with it. Else,
		// read the first line of possible continuation. 
		// If non-null, put it into the StringBuffer and its line 
		// number in firstLineNumber.
		if (prevLine != null) {
			s = prevLine;
			prevLine = null;
		}
		else  {
			s = readPhysicalLine();
		}

		// save the line number of the first line.
		firstLineNumber = super.getLineNumber();

		// Now we have one line. If we are not in continuation
		// mode, or if a previous readPhysicalLine() returned null,
		// we are finished, so return it.
		if (!doContinue || s == null)
			return s;

		// Otherwise, start building a stringbuffer
		StringBuffer sb = new StringBuffer(s);

		// Read as many continued lines as there are, if any.
		while (true) {
			String nextPart = readPhysicalLine();
			if (nextPart == null) {
				// Egad! EOF within continued line.
				// Return what we have so far.
				return sb.toString();
			}
			// If the next line begins with space, it's continuation
			if (nextPart.length() > 0 &&
				Character.isWhitespace(nextPart.charAt(0))) {
				sb.append(nextPart);	// and add line.
			} else {
				// else we just read too far, so put in "pushback" holder
				prevLine = nextPart;
				break;
			}
		}

		return sb.toString();		// return what's left
	}

	/** Construct an IndentContLineReader with the default buffer size. */
	public IndentContLineReader(Reader in)  {
		super(in);
	}

	/** Construct an IndentContLineReader using the given buffer size. */
	public IndentContLineReader(Reader in, int sz)  {
		super(in, sz);
	}

}
//@@@@@@//
//io/IndentContLineReaderTest.java
//@@@@@@//
import java.io.IOException;
import java.io.StringReader;

import junit.framework.TestCase;

/**
 * @author ian
 */
public class IndentContLineReaderTest extends TestCase {
	public static void main(String[] args) {
		//junit.textui.TestRunner.run(IndentContLineReaderTest.suite());
	}
	protected static String sampleTxt = 
		"From: ian today now\n" +
		"Received: by foo.bar.com\n" +
		"	at 12:34:56 January 1, 2000\n" +
		"X-Silly-Headers: Too Many\n" +
		"This line should be line 5.\n" +
		"Test more indented line continues from line 6:\n" +
		"    space indented.\n" +
		"	tab indented;\n" +
		"\n" +
		"This is line 10\n" + 
		"the start of a hypothetical mail/news message, \n" +
		"that is, it follows a null line.\n" +
		"	Let us see how it fares if indented.\n" +
		" also space-indented.\n" +
		"\n" +
		"How about text ending without a newline?";

	public void testReading() throws IOException {
		IndentContLineReader is = new IndentContLineReader(
			new StringReader(sampleTxt));
		String aLine;
		// Print Mail/News Header
		System.out.println("----- Message Header -----");
		while ((aLine = is.readLine()) != null && aLine.length() > 0) {
			System.out.println(is.getLineNumber() + ": " + aLine);
		}
		// Make "is" behave like normal BufferedReader
		is.setContinuationMode(false);
		System.out.println();
		// Print Message Body
		System.out.println("----- Message Body -----");
		while ((aLine = is.readLine()) != null) {
			System.out.println(is.getLineNumber() + ": " + aLine);
		}
		is.close();
	}
}
//@@@@@@//
//io/JDOCreateDataStore.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.jdo.*;

/** Create a DataStore, initially empty.
 * Typically only needed if using the JDO RI.
 */
public class JDOCreateDataStore {
	public static void main(String[] args) throws IOException {
			Properties p = new Properties();
			p.load(new FileInputStream("jdo.properties"));
			p.setProperty("com.sun.jdori.option.ConnectionCreate", "true");            
			PersistenceManagerFactory pmf =
					JDOHelper.getPersistenceManagerFactory(p);
			PersistenceManager pm = pmf.getPersistenceManager();
			Transaction tx = pm.currentTransaction();
			tx.begin();
			tx.commit();
	}
}
//@@@@@@//
//io/MyData.java
//@@@@@@//
//package io;

import java.io.Serializable;

/** Simple data class used in Serialization demos. */
public class MyData implements Serializable {
	String userName;
	String passwordCypher;
	transient String passwordClear;

	/** This constructor is required for use by JDO */
	public MyData() {
		// Nothing to do
	}

	public MyData(String name, String clear) {
		setUserName(name);
		setPassword(clear);
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String s) {
		this.userName = s;
	}

	public String getPasswordCypher() {
		return passwordCypher;
	}

	/** Save the clear text p/w in the object, it won't get serialized
	 * So we must save the encryption! Encryption not shown here.
	 */
	public void setPassword(String s) {
		this.passwordClear = s;
		passwordCypher = encrypt(passwordClear);
	}

	public String toString() {
		return "MyData[" + userName + ",XXXXX]";
	}

	/** In real life this would use Java Cryptography */
	protected String encrypt(String s) {
		return "fjslkjlqj2TOP+SECRETkjlskl";
	}
}
//@@@@@@//
//io/OpenFileByName.java
//@@@@@@//
import java.io.*;
public class OpenFileByName {
	public static void main(String[] args) throws IOException {
		BufferedReader is = new BufferedReader(new FileReader("myFile.txt"));
		BufferedOutputStream bytesOut = new BufferedOutputStream(
			new FileOutputStream("bytes.dat"));

		// Code here to read from is, write to bytesOut

		bytesOut.close();
	}
}
//@@@@@@//
//io/PrintFile.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.*;

/**
 * PrintFile -- Print a file named on the command line
 */
public class PrintFile extends Frame {
	/** The number of pages to print */
	protected static final int NPAGES = 3;
	/** The actual number of pages */
	protected int nPages;
	/** The PrintJob object */
	PrintJob pjob = null;	// refers to whole print job

	/** main program: instantiate and show. */
	public static void main(String[] av) {
		PrintFile p = new PrintFile();
		p.setVisible(true);
		if (av.length==0)
			p.print(new InputStreamReader(System.in));
		else
			for (int i=0; i<av.length; i++)
				p.print(av[i]);
		p.setVisible(false);
		p.dispose();
		System.exit(0);
	}

	/** Construct a PrintFile object */
	PrintFile() {
		setLayout(new FlowLayout());
		Button b;
		add(b = new Button("Cancel"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (pjob != null)	// if quit while printing!
					pjob.end();
				System.exit(0);
			}
		});
		pack();
	}

	/** Print a file by name */
	public void print(String fn) {
		// open it, call the other guy 
		FileReader ifile = null;
		try {
			ifile = new FileReader(fn);
		} catch (FileNotFoundException fnf) {
			System.err.println("File not found!");
		}
		print(ifile);
	}

	/** Print a file by File */
	public void print(Reader ifile) {
		BufferedReader is = new BufferedReader(ifile);
		Graphics g = null;	// refers to current page
		System.out.println("Doing print");
		pjob = getToolkit().getPrintJob(this,
			"Printing Test", (Properties)null);
		if (pjob == null)          // User cancelled??
			return;
		Dimension pDim = pjob.getPageDimension();
		int pRes = pjob.getPageResolution();
		System.out.println("Page size " + pDim + "; Res " + pRes);
		g = pjob.getGraphics();
		g.setColor(Color.black);
		g.setFont(new Font("SansSerif", Font.PLAIN, 12));
		int y = 100;
		String line;
		try {
			while ((line = is.readLine()) != null) {
				g.drawString(line, 10, y+=18);
			}
		} catch (IOException e) {
			System.err.println(e);
		}
		// g.drawString("Page " + pgNum, 300, 300);
		g.dispose(); // flush page
		pjob.end();	// total end of print job.
		pjob = null;	// avoid redundant calls to pjob.end()
	}
}
//@@@@@@//
//io/PrintStandardOutput.java
//@@@@@@//
import java.io.*;

/** Print to the standard output */
public class PrintStandardOutput {

	public static void main(String[] args) {
		// Just a String to include in printouts.
		String myAnswer = "No, and that's final,";

		// Print to standard output
		System.out.println("Hello World of Java");
		// Print several things concatendated.
		System.out.println("The answer is " + myAnswer + " at this time."); 

		// Print to standard output using a Writer
		PrintWriter pw = new PrintWriter(System.out);
		pw.println("The answer is " + myAnswer + " at this time."); 

		// Caveat printing ints and chars together
		int i = 42;
		pw.println(i + '=' + " the answer.");	// WRONG
		pw.println("Note: " + i + '=' + " the answer.");	// OK

		// Some of the workarounds for the caveat above:
		pw.println(i + "=" + " the answer.");	// using quotes
		pw.println(i + ('=' + " the answer."));	// parenthesis

		pw.close();		// If you open it, you close it.
	}
}
//@@@@@@//
//io/ReadGZIP.java
//@@@@@@//
import java.io.*;
import java.util.zip.*;

/**
 * Read some data from a gzip file.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ReadGZIP.java,v 1.4 2004/03/06 20:54:38 ian Exp $
 */
public class ReadGZIP {
	public static void main(String[] argv) throws IOException {
		String FILENAME = "file.txt.gz";

		// Since there are 4 constructor calls here, I wrote them out in full.
		// In real life you would probably nest these constructor calls.
		FileInputStream fin = new FileInputStream(FILENAME);
		GZIPInputStream gzis = new GZIPInputStream(fin);
		InputStreamReader xover = new InputStreamReader(gzis);
		BufferedReader is = new BufferedReader(xover);

		String line;
		// Now read lines of text: the BufferedReader puts them in lines,
		// the InputStreamReader does Unicode conversion, and the
		// GZipInputStream "gunzip"s the data from the FileInputStream.
		while ((line = is.readLine()) != null)
			System.out.println("Read: " + line);
	}
}
//@@@@@@//
//io/ReadRandom.java
//@@@@@@//
import java.io.*;

/**
 * Read a file containing an offset, and a String at that offset.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ReadRandom.java,v 1.6 2004/03/07 17:30:35 ian Exp $
 */
public class RandomRead {
	final static String FILENAME = "random.dat";
	protected String fileName;
	protected RandomAccessFile seeker;

	public static void main(String[] argv) throws IOException {
		RandomRead r = new RandomRead(FILENAME);

		System.out.println("Offset is " + r.readOffset());
		System.out.println("Message is \"" + r.readMessage() + "\".");
	}

	/** Constructor: save filename, construct RandomAccessFile */
	public RandomRead(String fname) throws IOException {
		fileName = fname;
		seeker = new RandomAccessFile(fname, "r");
	}

	/** Read the Offset field, defined to be at location 0 in the file. */
	public int readOffset() throws IOException {
		seeker.seek(0);				// move to very beginning
		return seeker.readInt();	// and read the offset
	}

	/** Read the message at the given offset */
	public String readMessage() throws IOException {
		seeker.seek(readOffset());	// move to the offset
		return seeker.readLine();	// and read the String
	}
}
//@@@@@@//
//io/ReadStdin.java
//@@@@@@//
/**
 * Read from Standard Input
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @version 	$Id: ReadStdin.java,v 1.3 2004/02/08 23:57:29 ian Exp $
 */
public class ReadStdin {
	/** Simple test case */
	public static void main(String[] ap) {
		//+
		int b = 0;
		try {
			b = System.in.read();
		} catch (Exception e) {
			System.out.println("Caught " + e);
		}
		System.out.println("Read this data: " + (char)b);
		//-
	}
}
//@@@@@@//
//io/ReadStdinInt.java
//@@@@@@//
import java.io.*;
/**
 * Read an int from Standard Input
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @version 	$Id: ReadStdinInt.java,v 1.2 2004/02/08 23:57:29 ian Exp $
 */
public class ReadStdinInt {
	public static void main(String[] ap) {
		String line = null;
		int val = 0;
		try {
			BufferedReader is = new BufferedReader(
				new InputStreamReader(System.in));
			line = is.readLine();
			val = Integer.parseInt(line);
		} catch (NumberFormatException ex) {
			System.err.println("Not a valid number: " + line);
		} catch (IOException e) {
			System.err.println("Unexpected IO ERROR: " + e);
		}
		System.out.println("I read this number: " + val);
	}
}
//@@@@@@//
//io/ReadStdinInt15.java
//@@@@@@//
import java.util.Scanner;
/**
 * Read an int from Standard Input, using 1.5
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @version 	$Id: ReadStdinInt15.java,v 1.2 2004/03/07 16:31:58 ian Exp $
 */
public class ReadStdinInt15 {
	public static void main(String[] ap) {
		int val;
		try {
			Scanner sc = Scanner.create(System.in);      // Requires J2SE 1.5
			val = sc.nextInt();
		} catch (NumberFormatException ex) {
			System.err.println("Not a valid number: " + ex);
			return;
		}
		System.out.println("I read this number: " + val);
	}
}
//@@@@@@//
//io/Redirect.java
//@@@@@@//
import java.io.*;

/**
 * "Redirect" or reassign some standard descriptors.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Redirect.java,v 1.4 2004/03/06 20:57:56 ian Exp $
 */
public class Redirect {
	public static void main(String[] argv) throws IOException {
		//+
		String LOGFILENAME = "error.log";
		System.setErr(new PrintStream(new FileOutputStream(LOGFILENAME)));
		System.out.println("Please look for errors in " + LOGFILENAME);
		// Now assume this is somebody else's code; you'll see it writing to stderr...
		int[] a = new int[5];
		a[10] = 0;	// here comes an ArrayIndexOutOfBoundsException
		//-
	}
}
//@@@@@@//
//io/ScanStreamTok.java
//@@@@@@//
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StreamTokenizer;

/**
 * ScanStreamTok - show scanning a file with StringTokenizer.
 *
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version	$Id: ScanStreamTok.java,v 1.6 2004/02/17 00:17:54 ian Exp $
 */
public class ScanStreamTok {
	protected  StreamTokenizer tf;

	public static void main(String[] av) throws IOException {
		if (av.length == 0)
			new ScanStreamTok(
				new InputStreamReader(System.in)).process();
		else 
			for (int i=0; i<av.length; i++)
				new ScanStreamTok(av[i]).process();
	}

	/** Construct a file scanner by name */
	public ScanStreamTok(String fileName) throws IOException {
		tf = new StreamTokenizer(new FileReader(fileName));
	}

	/** Construct a file scanner by existing Reader */
	public ScanStreamTok(Reader rdr) throws IOException {
		tf = new StreamTokenizer(rdr);
	}

	protected void process() throws IOException {
		String s = null;
		int i;

		while ((i = tf.nextToken()) != StreamTokenizer.TT_EOF) {
			switch(i) {
			case StreamTokenizer.TT_EOF:
				System.out.println("End of file");
				break;
			case StreamTokenizer.TT_EOL:
				System.out.println("End of line");
				break;
			case StreamTokenizer.TT_NUMBER:
				System.out.println("Number " + tf.nval);
				break;
			case StreamTokenizer.TT_WORD:
				System.out.println("Word, length " + tf.sval.length() + "->" + tf.sval);
				break;
			default:
				System.out.println("What is it? i = " + i);
			}
		}
	}
}
//@@@@@@//
//io/ScanStringTok.java
//@@@@@@//
import java.io.*;
import java.util.*;

/**
 * ScanStringTok - show scanning a file with StringTokenizer.
 *
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version	$Id: ScanStringTok.java,v 1.4 2004/02/17 00:17:55 ian Exp $
 */
public class ScanStringTok {
	protected  LineNumberReader is;

	public static void main(String[] av) throws IOException {
		if (av.length == 0)
			new ScanStringTok(
				new InputStreamReader(System.in)).process();
		else 
			for (int i=0; i<av.length; i++)
				new ScanStringTok(av[i]).process();
	}

	/** Construct a file scanner by name */
	public ScanStringTok(String fileName) throws IOException {
		is = new LineNumberReader(new FileReader(fileName));
	}

	/** Construct a file scanner by existing Reader */
	public ScanStringTok(Reader rdr) throws IOException {
		// no point adding another level of buffering, if already
		// being buffered...
		if (rdr instanceof LineNumberReader)
			is = (LineNumberReader)rdr;
		else
			is = new LineNumberReader(rdr);
	}

	protected void process() {
		String s = null;
		try {
			while ((s = is.readLine()) != null) {
				StringTokenizer st = new StringTokenizer(s, "@", true);
				String user = (String)st.nextElement();
				st.nextElement();
				String host = (String)st.nextElement();
				System.out.println("User name: " + user +
					"; host part: " + host);

				// Presumably you would now do something 
				// with the user and host parts...  

			}

		} catch (NoSuchElementException ix) {
			System.err.println("Line " + is.getLineNumber() +
				": Invalid input " + s);
		} catch (IOException e) {
			System.err.println(e);
		}
	}
}
//@@@@@@//
//io/SerialDemoAbstractBase.java
//@@@@@@//
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

//import io.MyData;

/** Demonstrate use of Serialization. Typical Subclass main will be:
 *	public static void main(String[] s) throws Exception {
 *		new SerialDemoXXX().save();		// in parent class; calls write
 *		new SerialDemoXXX().dump();
 *	}
 */
public abstract class SerialDemoAbstractBase {

	/** The save method in an application */
	public void save() throws IOException {
		List l = new ArrayList();
		// Gather the data
		l.add(new MyData("Ian Darwin", "secret_java_cook"));
		l.add(new MyData("Abby Brant", "dujordian"));
		write(l);
	}

	/** Does the actual serialization */
	public abstract void write(Object theGraph) throws IOException;

	/** Reads the file and displays it. */
	public abstract void dump() throws IOException, ClassNotFoundException;
}
//@@@@@@//
//io/SerialDemoJDO.java
//@@@@@@//
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Collection;
import java.util.Properties;

import javax.jdo.JDOHelper;
import javax.jdo.PersistenceManager;
import javax.jdo.PersistenceManagerFactory;

/**
 * A demonstration of serialization using JDO.
 * JDO is normally used to access a database, but can also be used
 * to save locally, which is shown here.
 */
public class SerialDemoJDO extends SerialDemoAbstractBase {

	public static void main(String[] args) throws IOException {
		SerialDemoJDO jd = new SerialDemoJDO();
		jd.save();
		jd.dump();
	}

	public PersistenceManager getPM() {
		Properties p = new Properties();
		try {
			p.load(new FileInputStream("jdo.properties"));
			PersistenceManagerFactory pmf = 
				JDOHelper.getPersistenceManagerFactory(p);
			return pmf.getPersistenceManager();
		} catch (IOException ex) {
			throw new RuntimeException(ex.toString());
		}
	}

	public void write(Object o) {
		PersistenceManager pm = getPM();
		pm.currentTransaction().begin();
		if (o instanceof Collection) {
			pm.makePersistentAll((Collection)o);
		} else {
			pm.makePersistent(o);
		}
		pm.currentTransaction().commit();
		pm.close();
	}

	public void dump() {
		PersistenceManager pm = getPM();
		Object[] data = new Object[3];
		pm.retrieveAll(data);
		for (int i = 0; i < data.length; i++) {
			System.out.println(data[i]);
		}
		pm.close();
	}
}
//@@@@@@//
//io/SerialDemoObjectStream.java
//@@@@@@//
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

/** Demonstrate use of standard Object Serialization. */
public class SerialDemoObjectStream extends SerialDemoAbstractBase {
	protected static final String FILENAME = "serial.dat";

	public static void main(String[] s) throws Exception {
		new SerialDemoObjectStream().save();	// in parent class; calls write
		new SerialDemoObjectStream().dump();	// here
	}

	/** Does the actual serialization */
	public void write(Object theGraph) throws IOException {
		// Save the data to disk.
		ObjectOutputStream os = new ObjectOutputStream(
			new BufferedOutputStream(
				new FileOutputStream(FILENAME)));
		os.writeObject(theGraph);
		os.close();
	}

	public void dump() throws IOException, ClassNotFoundException {
		ObjectInputStream is = new ObjectInputStream(
			new FileInputStream(FILENAME));
		System.out.println(is.readObject());
		is.close();
	}
}

//@@@@@@//
//io/SerialDemoXML.java
//@@@@@@//
import java.beans.XMLDecoder;
import java.beans.XMLEncoder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/** Show the XML serialization added to "java.beans.*" in JDK1.4.
 * Subclass "SerialDemoAbstratBase" to get most of infrastructure
 */
public class SerialDemoXML extends SerialDemoAbstractBase {

	public static final String FILENAME = "serial.xml";

	public static void main(String[] args) throws IOException {
		new SerialDemoXML().save();
		new SerialDemoXML().dump();
	}

	/** Save the data to disk. */
	public void write(Object theGraph) throws IOException {
		XMLEncoder os = new XMLEncoder(		// NEEDS JDK 1.4
			new BufferedOutputStream(
				new FileOutputStream(FILENAME)));
		os.writeObject(theGraph);
		os.close();
	}

	/** Display the data */
	public void dump() throws IOException {
		XMLDecoder inp = new XMLDecoder(		// NEEDS JDK 1.4
			new BufferedInputStream(
				new FileInputStream(FILENAME)));
		System.out.println(inp.readObject());
		inp.close();
	}
}
//@@@@@@//
//io/SimpleCalcScanner.java
//@@@@@@//
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.util.Scanner;
import java.util.Stack;

/**
 * SimpleCalc -- simple calculator using 1.5 java.util.Scanner
 * @version	$Id: SimpleCalcScanner.java,v 1.3 2004/03/10 18:01:35 ian Exp $
 */
public class SimpleCalcScanner {
	/** The Scanner */
	protected  Scanner scan;

	/** The output */
	protected PrintWriter out = new PrintWriter(System.out);

	/** The variable name (not used in this version) */
	protected String variable;

	/** The operand stack */
	protected Stack s = new Stack();

	/* Driver - main program */
	public static void main(String[] av) throws IOException {
		if (av.length == 0)
			new SimpleCalcScanner(
				new InputStreamReader(System.in)).doCalc();
		else 
			for (int i=0; i<av.length; i++)
				new SimpleCalcScanner(av[i]).doCalc();
	}

	/** Construct a SimpleCalcScanner by name */
	public SimpleCalcScanner(String fileName) throws IOException {
		this(new FileReader(fileName));
	}

	/** Construct a SimpleCalcScanner from an open Reader */
	public SimpleCalcScanner(Reader rdr) throws IOException {
		scan = new Scanner(rdr);
		// Control the input character set:
		scan.slashSlashComments(true);	// treat "//" as comments
		scan.ordinaryChar('-');		// used for subtraction
		scan.ordinaryChar('/');	// used for division
	}

	/** Construct a SimpleCalcScanner from a Reader and a PrintWriter */
	public SimpleCalcScanner(Reader rdr, PrintWriter pw) throws IOException {
		this(rdr);
		setWriter(pw);
	}

	/** Change the output to go to a new PrintWriter */
	public void setWriter(PrintWriter pw) {
		out = pw;
	}

	protected void doCalc() throws IOException {
		int iType;
		double tmp;

		while (scan.hasNext()) {
			if (scan.hasNextDouble()) {
				push(scan.nextDouble());
			} else {
				String token = scan.next().toString();
				if (token.equals("+")) {
					// Found + operator, perform it immediately.
					push(pop() + pop());
				} else if (token.equals("-")) {
					// Found - operator, perform it (order matters).
					tmp = pop();
					push(pop() - tmp);
				} else if (token.equals("*")) {
					// Multiply is commutative
					push(pop() * pop());
				} else if (token.equals("/")) {
					// Handle division carefully: order matters!
					tmp = pop();
					push(pop() / tmp);
				} else if (token.equals("=")) {
					out.println(peek());
				} else {
					out.println("What's this? " + token);
				}
			}
		}
	}

	void push(double val) {
		s.push(new Double(val));
	}

	double pop() {
		return ((Double)s.pop()).doubleValue();
	}

	double peek() {
		return ((Double)s.peek()).doubleValue();
	}

	void clearStack() {
		s.removeAllElements();
	}
}
//@@@@@@//
//io/SimpleCalcStreamTok.java
//@@@@@@//
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.StreamTokenizer;
import java.util.Stack;

/**
 * SimpleCalc -- simple calculator to show StringTokenizer
 *
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version	$Id: SimpleCalcStreamTok.java,v 1.10 2004/03/10 18:22:26 ian Exp $
 */
public class SimpleCalcStreamTok {
	/** The StreamTokenizer Input */
	protected  StreamTokenizer tf;
	/** The Output File */
	protected PrintWriter out = new PrintWriter(System.out, true);
	/** The variable name (not used in this version) */
	protected String variable;
	/** The operand stack */
	protected Stack s;

	/* Driver - main program */
	public static void main(String[] av) throws IOException {
		if (av.length == 0)
			new SimpleCalcStreamTok(
				new InputStreamReader(System.in)).doCalc();
		else 
			for (int i=0; i<av.length; i++)
				new SimpleCalcStreamTok(av[i]).doCalc();
	}

	/** Construct by filename */
	public SimpleCalcStreamTok(String fileName) throws IOException {
		this(new FileReader(fileName));
	}

	/** Construct from an existing Reader */
	public SimpleCalcStreamTok(Reader rdr) throws IOException {
		tf = new StreamTokenizer(rdr);
		// Control the input character set:
		tf.slashSlashComments(true);	// treat "//" as comments
		tf.ordinaryChar('-');		// used for subtraction
		tf.ordinaryChar('/');	// used for division

		s = new Stack();
	}

	/** Construct from a Reader and a PrintWriter
	 */
	public SimpleCalcStreamTok(Reader in, PrintWriter out) throws IOException {
		this(in);
		setOutput(out);
	}
	
	/**
	 * Change the output destination.
	 */
	public void setOutput(PrintWriter out) {
		this.out = out;
	}

	protected void doCalc() throws IOException {
		int iType;
		double tmp;

		while ((iType = tf.nextToken()) != StreamTokenizer.TT_EOF) {
			switch(iType) {
			case StreamTokenizer.TT_NUMBER: // Found a number, push value to stack
				push(tf.nval);
				break;
			case StreamTokenizer.TT_WORD:
				// Found a variable, save its name. Not used here.
				variable = tf.sval;
				break;
			case '+':
				// + operator is commutative.
				push(pop() + pop());
				break;
			case '-':
				// - operator: order matters.
				tmp = pop();
				push(pop() - tmp);
				break;
			case '*':
				// Multiply is commutative
				push(pop() * pop());
				break;
			case '/':
				// Handle division carefully: order matters!
				tmp = pop();
				push(pop() / tmp);
				break;
			case '=':
				out.println(peek());
				break;
			default:
				out.println("What's this? iType = " + iType);
			}
		}
	}
	void push(double val) {
		s.push(new Double(val));
	}
	double pop() {
		return ((Double)s.pop()).doubleValue();
	}
	double peek() {
		return ((Double)s.peek()).doubleValue();
	}
	void clearStack() {
		s.removeAllElements();
	}
}
//@@@@@@//
//io/SimpleCalcTest.java
//@@@@@@//
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.StringWriter;

import junit.framework.TestCase;

public class SimpleCalcTest extends TestCase {

	final String TEST = "// This file is a test of the SimpleCalc class\n" +
		"2 4 + = 3 / =	// should print 6, 2\n" +
		"22 7 / =		// should print 3.141592857...\n";

	final String EXPECT = "6.0\n" +
		"2.0\n" +
		"3.142857142857143\n";

	public void testIt() throws Exception {
		BufferedReader is = new BufferedReader(
			new StringReader(TEST));
		StringWriter fluffy = new StringWriter();
		PrintWriter ps = new PrintWriter(fluffy);

		SimpleCalcStreamTok sc = new SimpleCalcStreamTok(is, ps);
		assertEquals(EXPECT, fluffy.getBuffer().toString());
	}
}
//@@@@@@//
//io/SpamRat.java
//@@@@@@//
import com.darwinsys.util.Debug;

import java.io.*;
import java.util.*;
import java.net.*;

/**
 * SpamRat: The Fury.
 * Read a SPAM mail message and generate an EMail compose window to the
 * SPAM-artist's ISP.
 * Of course, you must have saved the email message using a Mail User
 * Agent (MUA, or mail reader program) that preserves all header lines!
 *
 * TODO: 0) extract the ISP's name, do host lookup if numeric,
 *	do whois netblock lookup if that fails.
 *  1) Handle root spammers (use 2nd-last Received): need a heuristic
 *  to figure these out!
 *  2) Have a FileProperties containing known "abuse" type addresses
 *	(some are abuse, some are email-abuse, etc.). And name the
 *	template file.
 *  3) Construct and show a MailComposeBean (in a JFrame) with the
 *  template filled in as much as possible.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: SpamRat.java,v 1.8 2004/02/08 23:57:29 ian Exp $
 */
public class SpamRat {

    public static void main(String[] av) throws IOException {
		// For stdin or each file, build a IndentContLineReader
		// to treat the Received: lines as one.
        if (av.length == 0) {
            System.err.println("Usage: SpamRat spamfile [...]");
			return;
		}
		for (int i=0; i<av.length; i++)
			try {
				new SpamRat(av[i]).process();
			} catch (FileNotFoundException e) {
				System.err.println(e);
			}
    }

	/** Display an error message. */
	protected void error(String mesg, boolean terminate) {
		System.err.println(mesg);
		// if (myFrame != null) {
			// display it in a dialog.
		// }
		if (terminate) {
			System.exit(0);
		}
	}

	/** the name of the file we are reading */
	String spamFileName;
	/** the Reader for the file we are reading */
	LineNumberReader is;

	/** Constructor
	 * @param fileName - name of file containing a SPAM message.
	 */
	public SpamRat(String fileName) throws IOException {
		File f = new File(spamFileName = fileName);
		if (!f.isFile() || !f.canRead())
			System.err.println("Can't read file " + fileName);
		is = new IndentContLineReader(new FileReader(fileName));
	}

    /** process one file, given an open LineReader */
    public void process() {

		/* and the last shall be first, and the first shall be last */
		findReceived(is);
		for (int i=0; i<3; i++) {
			String line = (String)theStack.pop();
			System.out.println("Last-"+i+" receipt = " + line);

			// Get the IP out of it. Normal lines look like:
			// Received: from once.com (ip-08-14.teleport.com [206.163.123.238])
			//	by kim.teleport.com (8.8.5/8.7.3) with SMTP id MAA17284;
			//	Sat, 5 Jul 1997 12:48:00 -0700 (PDT)
			try {
				handle(line);
			} catch (EmptyStackException e) {
				return;
			} catch (Exception e) {
				System.out.println("** BOGUS ** " + e);
			}
		}
	}

	Stack theStack;
	protected Stack findReceived(LineNumberReader is) {
		theStack = new Stack();
        try {
            String line;

            while ((line = is.readLine()) != null &&
				line.length() > 0) {
				// If line begins with "Received:", add it to the stack.
				if (line.startsWith("Received:")) {
					Debug.println("match", "Adding " + line);
					theStack.push(line);
				}
            }
            is.close();
        } catch (IOException e) {
            System.out.println("IOException: " + e);
        }

		if (theStack.size() == 0) {
			System.err.println("No Received headers found");
			return null;
		}
		Debug.println("end", "Popping " + theStack.peek());
		return theStack;
    }

	/** Break out lines like this:
	 * Received: from once.com (ip-pdx08-14.teleport.com [206.163.123.238])
	 *	by kim.teleport.com (8.8.5/8.7.3) with SMTP id MAA17284;
	 *	Sat, 5 Jul 1997 12:48:00 -0700 (PDT)
	 * to find the IP name/address of the victim/villian ISP.
	 */
	void handle(String rl) {
		StringTokenizer w = new StringTokenizer(rl);
		if (!w.nextToken().equalsIgnoreCase("received:"))
			throw new IllegalArgumentException("invalid received line: " + rl);
		if (!w.nextToken().equalsIgnoreCase("from"))
			throw new IllegalArgumentException(
				"missing \"from\" in received line: " + rl);

		String fakeName = w.nextToken(); // possibly-fake name

		String realName  = w.nextToken();
		if (!realName.startsWith("("))
			throw new IllegalArgumentException(
				"bad \"(name\" in received line: " + rl);
		realName = realName.substring(1);

		try {
			InetAddress ia1 = InetAddress.getByName(realName);
		} catch (UnknownHostException e) {
			System.err.println("Warning: Host name " + 
				realName + " did not resolve");
		}

		String realIP    = w.nextToken();
		if (!realIP.startsWith("["))
			throw new IllegalArgumentException(
				"bad \"[IP]\" in received line: " + rl);
		realIP = realIP.substring(1, realIP.length()-1-1);

		try {
			InetAddress ia2 = InetAddress.getByName(realIP);
		} catch (UnknownHostException e) {
			System.err.println("Warning: IP " + realIP + " did not resolve");
		}

		sendFlame(realName, realIP, fakeName);
	}

	/** Display the response in a mail compose window. */
	protected void sendFlame(String host, String IP, String fakeName) {
		System.out.println("To: abuse@" + host);
		System.out.println("Subject: SPAM from your site!");
		System.out.println("Cc: postmaster");
		System.out.println();
		System.out.println("The attached unsolicited SPAM was injected");
		System.out.println("into the Internet, according to Received: lines,");
		System.out.println("by or through you, " + host + "(" + IP + ")");
		System.out.println("pretending to be " + fakeName);
		System.out.println("Please react accordingly.");
		System.out.println();

		// TODO IOutil.copy(spamFileName, ...);
	}
}
//@@@@@@//
//io/Stdout.java
//@@@@@@//
/**
 * All the examples for the Standard output recipe.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Stdout.java,v 1.4 2004/02/08 23:57:29 ian Exp $
 */
public class Stdout {
	public static void main(String[] argv) {
		//+
		Object anObject = new Object();
		String myAnswer = "no";
		int i = 42;
	
		System.out.println("Hello, World of Java");
		System.out.println("An object is " + anObject);
		System.out.println("The answer is " + myAnswer + " at this time.");
		System.out.println("The answer is " + i + '.');
		System.out.println("The answer is " + i + ".");
		System.out.println(i + '=' + " the answer.");
		System.out.println(new StringBuffer("The answer is ").append(i).append('.'));
		//-
	}
}
//@@@@@@//
//io/Strings.java
//@@@@@@//
import java.io.*;

/** Strings -- extract printable strings from binary file
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Strings.java,v 1.3 2004/02/08 23:57:29 ian Exp $
 */

public class Strings {

	protected int minLength = 4;

	/** Return true if the character is printable IN ASCII.
	 * Not using Character.isLetterOrDigit(); applies to all unicode ranges
	 */
	protected boolean isStringChar(char ch) {
		if (ch >= 'a' && ch <= 'z')
			return true;
		if (ch >= 'A' && ch <= 'Z')
			return true;
		if (ch >= '0' && ch <= '9')
			return true;
		switch(ch) {
			case '/': case '-': case ':':
			case '.': case ',': case '_':
			case '$': case '%': case '\'':
			case '(': case ')': case '[': case ']': case '<': case '>':
				return true;
		}
		return false;
	}

    /** Process one file */
    protected void process(String fileName, InputStream inStream) {
        try {
			int i;
            char ch;

			// This line alone cuts the runtime by about 66% on large files.
			BufferedInputStream is = new BufferedInputStream(inStream);

			StringBuffer sb = new StringBuffer();

			// Read a byte, cast it to char, check if part of printable string.
            while ((i = is.read()) != -1) {
				ch = (char)i;
				if (isStringChar(ch) || (sb.length()>0 && ch==' '))
					// If so, build up string.
					sb.append(ch);
				else {
					// if not, see if anything to output.
					if (sb.length() == 0)
						continue;
					if (sb.length() >= minLength) {
						report(fileName, sb);
					}
					sb.setLength(0);
				}
            }
            is.close();
        } catch (IOException e) {
            System.out.println("IOException: " + e);
        }
    }

	/** This simple main program looks after filenames and
	 * opening files and such like for you.
	 */
    public static void main(String[] av) {
        Strings o = new Strings();
        if (av.length == 0) {
            o.process("standard input", System.in);
		} else {
			for (int i=0; i<av.length; i++)
				try {
					o.process(av[i],
						new FileInputStream(av[i]));
				} catch (FileNotFoundException e) {
					System.err.println(e);
				}
        }
    }

	/** Output a match. Made a separate method for use by subclassers. */
	protected void report(String fName, StringBuffer theString) {
		System.out.println(fName + ": " + theString);
	}
}
//@@@@@@//
//io/TeePrintStream.java
//@@@@@@//
import java.io.*;

/** TeePrintStream tees all PrintStream operations into a file, rather
 * like the UNIX tee(1) command. It is a PrintStream subclass. The
 * expected usage would be something like the following:
 * <PRE>
 *	...
 *	TeePrintStream ts = new TeePrintStream(System.err, "err.log");
 *	System.setErr(ts);
 *	// ...lots of code that occasionally writes to System.err...
 *	ts.close();
 *	...
 * <PRE>
 * <P>I only override Constructors, the write(), check() and close() methods,
 * since any of the print() or println() methods must go through these.
 * Thanks to Svante Karlsson for help formulating this.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: TeePrintStream.java,v 1.5 2004/02/08 23:57:29 ian Exp $
 */
public class TeePrintStream extends PrintStream {
	protected PrintStream parent;
	protected String fileName;

	/** A simple test case. */
	public static void main(String[] args) throws IOException {
		TeePrintStream ts = new TeePrintStream(System.err, "err.log", true);
		System.setErr(ts);
		System.err.println("An imitation error message");
		ts.close();
	}

	/** Construct a TeePrintStream given an existing PrintStream,
	 * an opened OutputStream, and a boolean to control auto-flush.
	 * This is the main constructor, to which others delegate via "this".
	 */
	public TeePrintStream(PrintStream orig, OutputStream os, boolean flush)
	throws IOException {
		super(os, true);
		fileName = "(opened Stream)";
		parent = orig;
	}

	/** Construct a TeePrintStream given an existing PrintStream and
	 * an opened OutputStream.
	 */
	public TeePrintStream(PrintStream orig, OutputStream os)
	throws IOException {
		this(orig, os, true);
	}

	/* Construct a TeePrintStream given an existing Stream and a filename.
	 */
	public TeePrintStream(PrintStream os, String fn) throws IOException {
		this(os, fn, true);
	}

	/* Construct a TeePrintStream given an existing Stream, a filename,
	 * and a boolean to control the flush operation.
	 */
	public TeePrintStream(PrintStream orig, String fn, boolean flush)
	throws IOException {
		this(orig, new FileOutputStream(fn), flush);
	}

	/** Return true if either stream has an error. */
	public boolean checkError() {
		return parent.checkError() || super.checkError();
	}

	/** override write(). This is the actual "tee" operation. */
	public void write(int x) {
		parent.write(x);	// "write once;
		super.write(x);		// write somewhere else."
	}

	/** override write(). This is the actual "tee" operation. */
	public void write(byte[] x, int o, int l) {
		parent.write(x, o, l);	// "write once;
		super.write(x, o, l);	// write somewhere else."
	}

	/** Close both streams. */
	public void close() {
		parent.close();
		super.close();
	}

	/** Flush both streams. */
	public void flush() {
		parent.flush();
		super.flush();
	}
}
//@@@@@@//
//io/Undent.java
//@@@@@@//
import java.io.*;

/** Undent - remove leading spaces
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Undent.java,v 1.5 2004/02/08 23:57:09 ian Exp $
 */

public class Undent {
	//+
	/** the default number of spaces to remove. */
	int nSpaces = 2;
	//-

    public static void main(String[] av) {
        Undent c = new Undent();
        if (av.length == 0)
            c.process(new BufferedReader(
				new InputStreamReader(System.in)));
		else for (int i=0; i<av.length; i++) {
			try {
				c.process(new BufferedReader(new FileReader(av[i])));
			} catch (FileNotFoundException e) {
				System.err.println(e);
			}
        }
    }


    /** undent one file, given an open BufferedReader.
	 * Undent by removing UP TO "nSpaces" leading spaces.
	 */
    public void process(BufferedReader is) {
		//+
		// GRRR THIS DOES NOT QUITE WORK - FIX -- Ian
        try {
            String inputLine;

            while ((inputLine = is.readLine()) != null) {
				int i;
				for (i=0; i<nSpaces; i++) {
					if (!Character.isWhitespace(inputLine.charAt(i)))
						break;
				}
                System.out.println(inputLine.substring(i));
            }
            is.close();
		//-
        } catch (IOException e) {
            System.out.println("IOException: " + e);
        }
    }
	//-
}
//@@@@@@//
//io/UnZip.java
//@@@@@@//
import java.io.*;
import java.util.*;
import java.util.zip.*;

/**
 * UnZip -- print or unzip a JAR or PKZIP file using java.util.zip.
 * Command-line version: extracts files.
 * @author	Ian Darwin, Ian@DarwinSys.com
 * $Id: UnZip.java,v 1.7 2004/03/07 17:40:35 ian Exp $
 */
public class UnZip {
	/** Constants for mode listing or mode extracting. */
	public static final int LIST = 0, EXTRACT = 1;
	/** Whether we are extracting or just printing TOC */
	protected int mode = LIST;

	/** The ZipFile that is used to read an archive */
	protected ZipFile zippy;

	/** The buffer for reading/writing the ZipFile data */
	protected byte[] b;

	/** Simple main program, construct an UnZipper, process each
	 * .ZIP file from argv[] through that object.
	 */
	public static void main(String[] argv) {
		UnZip u = new UnZip();

		for (int i=0; i<argv.length; i++) {
			if ("-x".equals(argv[i])) {
				u.setMode(EXTRACT);
				continue;
			}
			String candidate = argv[i];
			// System.err.println("Trying path " + candidate);
			if (candidate.endsWith(".zip") ||
				candidate.endsWith(".jar"))
					u.unZip(candidate);
			else System.err.println("Not a zip file? " + candidate);
		}
		System.err.println("All done!");
	}

	/** Construct an UnZip object. Just allocate the buffer */
	UnZip() {
		b = new byte[8092];
	}

	/** Set the Mode (list, extract). */
	protected void setMode(int m) {
		if (m == LIST ||
		    m == EXTRACT)
			mode = m;
	}

	/** Cache of paths we've mkdir()ed. */
	protected SortedSet dirsMade;

	/** For a given Zip file, process each entry. */
	public void unZip(String fileName) {
		dirsMade = new TreeSet();
		try {
			zippy = new ZipFile(fileName);
			Enumeration all = zippy.entries();
			while (all.hasMoreElements()) {
				getFile((ZipEntry)all.nextElement());
			}
		} catch (IOException err) {
			System.err.println("IO Error: " + err);
			return;
		}
	}

	protected boolean warnedMkDir = false;

	/** Process one file from the zip, given its name.
	 * Either print the name, or create the file on disk.
	 */
	protected void getFile(ZipEntry e) throws IOException {
		String zipName = e.getName();
		switch (mode) {
		case EXTRACT:
			if (zipName.startsWith("/")) {
				if (!warnedMkDir)
					System.out.println("Ignoring absolute paths");
				warnedMkDir = true;
				zipName = zipName.substring(1);
			}
			// if a directory, just return. We mkdir for every file,
			// since some widely-used Zip creators don't put out
			// any directory entries, or put them in the wrong place.
			if (zipName.endsWith("/")) {
				return;
			}
			// Else must be a file; open the file for output
			// Get the directory part.
			int ix = zipName.lastIndexOf('/');
			if (ix > 0) {
				String dirName = zipName.substring(0, ix);
				if (!dirsMade.contains(dirName)) {
					File d = new File(dirName);
					// If it already exists as a dir, don't do anything
					if (!(d.exists() && d.isDirectory())) {
						// Try to create the directory, warn if it fails
						System.out.println("Creating Directory: " + dirName);
						if (!d.mkdirs()) {
							System.err.println(
							"Warning: unable to mkdir " + dirName);
						}
						dirsMade.add(dirName);
					}
				}
			}
			System.err.println("Creating " + zipName);
			FileOutputStream os = new FileOutputStream(zipName);
			InputStream  is = zippy.getInputStream(e);
			int n = 0;
			while ((n = is.read(b)) >0)
				os.write(b, 0, n);
			is.close();
			os.close();
			break;
		case LIST:
			// Not extracting, just list
			if (e.isDirectory()) {
				System.out.println("Directory " + zipName);
			} else {
				System.out.println("File " + zipName);
			}
			break;
		default:
			throw new IllegalStateException("mode value (" + mode + ") bad");
		}
	}
}
//@@@@@@//
//io/UseConverters.java
//@@@@@@//
import java.io.*;

/** Demonstrate creating readers and writers with a specific encoding.
 */
public class UseConverters {
	public static void main(String[] args) {
		try {
			BufferedReader fromKanji = new BufferedReader(
				new InputStreamReader(
					new FileInputStream("kanji.txt"), "EUC_JP"));
			PrintWriter toSwedish = new PrintWriter(
				new OutputStreamWriter(			// XXX check enco
					new FileOutputStream("sverige.txt"), "ISO8859_3"));

			// reading and writing here...
			String line = fromKanji.readLine();
			System.out.println("-->" + line + "<--");
			toSwedish.println(line);
			fromKanji.close();
			toSwedish.close();
		} catch (UnsupportedEncodingException exc) {
			System.err.println("Bad encoding" + exc);
			return;
		} catch (IOException err) {
			System.err.println("I/O Error: " + err);
			return;
		}
	}
}
//@@@@@@//
//io/Vis.java
//@@@@@@//
import java.io.*;

/**
 * Vis - make special characters visible.
 */
public class Vis {

    public static void main(String[] av) {
        Vis v = new Vis();
        if (av.length == 0)
            v.process(new BufferedReader(
				new InputStreamReader(System.in)));
		else for (int i=0; i<av.length; i++)
			try {
				v.process(new BufferedReader(new FileReader(av[i])));
			} catch (FileNotFoundException e) {
				System.err.println(e);
			}
    }

    /** print one file, given an open BufferedReader */
    public void process(BufferedReader is) {
        try {
            String inputLine;

            while ((inputLine = is.readLine()) != null) {
                for (int i=0; i<inputLine.length(); i++){
					char c = inputLine.charAt(i);
					switch(c) {
						case '\t': System.out.print("\\t"); break;
						case '\r': System.out.print("\\r"); break;
						case '\n': System.out.print("\\n"); break;
						default: System.out.print(c); break;
					}
				}
				System.out.println();
            }
            is.close();
        } catch (IOException e) {
            System.out.println("IOException: " + e);
        }
    }
}
//@@@@@@//
//io/WriteBinary.java
//@@@@@@//
import java.io.*;

/**
 * Write some data in binary.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: WriteBinary.java,v 1.3 2004/02/08 23:57:29 ian Exp $
 */
public class WriteBinary {
	public static void main(String[] argv) throws IOException {
		int i = 42;
		double d = Math.PI;
		String FILENAME = "binary.dat";
		DataOutputStream os = new DataOutputStream(
			new FileOutputStream(FILENAME));
		os.writeInt(i);
		os.writeDouble(d);
		os.close();
		System.out.println("Wrote " + i + ", " + d + " to file " + FILENAME);
	}
}
//@@@@@@//
//jabadot/JDConstants.java
//@@@@@@//
// package jabadot;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;

/** The main "properties"-like class for configuring JabaDot.
 * All of its properties starting with "jabadot.dir" are loaded from
 * Initialization Parameters.
 * <p>
 * This program has been configured as a "servlet" -
 * which it really is not -- just so it can get the value for
 * JABADOT_DIR from the servlet parameters. As a result, this
 * file should be listed as "preload" in the servlet engine configuration.
 *
 * @version $Id: JDConstants.java,v 1.18 2004/06/17 01:54:58 ian Exp $
 */
public class JDConstants extends HttpServlet {

	/** This must be a full path, since ya gotta start someplace. */
	protected static String JABADOT_DIR;

	protected static ServletContext ctx;

	/** This init servlet method loads the Properties. We know we'll
	 * get called once at the beginning of time, since we're set up
	 * that way in web.xml (as a pre-loaded servlet).
	 */
	public void init() throws ServletException {

		ctx = getServletConfig().getServletContext();

		// Get the JABADOT_DIR before all else!

		// Be careful of the difference between 
		// ServletContext.getInitParameter and Servlet.getInitParameter!
		// Be sure the installer puts in in jabadot/WEB-INF/web.xml,
		// NOT in tomcat/conf/web.xml - it will be ignored there!!

		JABADOT_DIR = ctx.getInitParameter("jabadot.dir");
		if (JABADOT_DIR == null) {
			System.out.println(
				"+------------- ERROR --------------------");
			System.out.println(
				"jabadot.dir not set as a context parameter.");
			System.out.println(
				"Please RTFM and try again"); // Time to WTFM!
			System.out.println(
				"+----------------------------------------");
		} else {
			System.out.println("JABADOT_DIR " + JABADOT_DIR);
		}

	}

	/** Get a property, but substitute $DIR with JABADOT_DIR */
	public static String getProperty(String key) {
		if (ctx==null)
			throw new IllegalStateException(
				"JDConstants.getProperty: not initialized!");
		return lookup(key);
	}

	private static String lookup(String key) {
		String val = ctx.getInitParameter(key);
		if (val == null)
			return null;
		return replace("$DIR", JABADOT_DIR, val);
	}

	/** Replace one string in another
	 * @return The modified string, or the original if no change made.
	 */
	public static String replace(String oldStr, String newStr, String inString) {
		int start = inString.indexOf(oldStr);
		if (start == -1) {
			return inString;
		}
		StringBuffer sb = new StringBuffer();
		sb.append(inString.substring(0, start));
		sb.append(newStr);
		sb.append(inString.substring(start+oldStr.length()));
		return sb.toString();
	}
}
//@@@@@@//
//jabadot/TextToJDBC.java
//@@@@@@//
// package jabadot;
import java.sql.*;
import java.io.*;
import java.util.*;
/**
 * Convert the database from text form to JDBC form.
 * 
 * @version $Id: TextToJDBC.java,v 1.1 2004/06/17 01:54:58 ian Exp $
 */
public class TextToJDBC {
	
	protected final static String TEXT_NAME = "userdb.txt";
	
	protected final static String DB_URL = "jdbc:idb:userdb.prp";
	
	public static void main(String[] fn) throws ClassNotFoundException,
			SQLException, IOException {
		
		BufferedReader is = new BufferedReader(new FileReader(TEXT_NAME));
		
		System.out.println("Setting UP JDBC Connection");
		// Load the database driver
		Class.forName("jdbc.idbDriver");

		Connection conn = DriverManager.getConnection(DB_URL, "ian", "secritt");

		Statement stmt = conn.createStatement();
		System.out.println("Creating table and index");
		stmt.executeUpdate("DROP TABLE userdb");
		stmt.executeUpdate("CREATE TABLE userdb (\n" +
			"name     char(12) PRIMARY KEY,\n" +
			"password char(20),\n" +
			"fullName char(30),\n" +
			"email    char(60),\n" +
			"city     char(20),\n" +
			"prov     char(20),\n" +
			"country  char(20),\n" +
			"privs    int\n" +
			")");
		stmt.executeUpdate("CREATE INDEX nickIndex ON userdb (name)");
		stmt.close();
		// put the data in the table
		PreparedStatement ps = conn
				.prepareStatement("INSERT INTO userdb VALUES (?,?,?,?,?,?,?,?)");
		String line;
		while ((line = is.readLine()) != null) {
			//name:password:fullname:City:Prov:Country:privs
			if (line.startsWith("#")) { // comment
				continue;
			}
			StringTokenizer st = new StringTokenizer(line, ":");
			String nick = st.nextToken();
			String pass = st.nextToken();
			String full = st.nextToken();
			String email = st.nextToken();
			String city = st.nextToken();
			String prov = st.nextToken();
			String ctry = st.nextToken();
			// User u = new User(nick, pass, full, email,
			// city, prov, ctry);
			String privs = st.nextToken();
			int iprivs = 0;
			if (privs.indexOf("A") != -1) {
				iprivs |= User.P_ADMIN;
			}
			if (privs.indexOf("E") != -1) {
				iprivs |= User.P_EDIT;
			}
			ps.setString(1, nick);
			ps.setString(2, pass);
			ps.setString(3, full);
			ps.setString(4, email);
			ps.setString(5, city);
			ps.setString(6, prov);
			ps.setString(7, ctry);
			ps.setInt(8, iprivs);
			ps.executeUpdate();
		}
		ps.close(); // All done with that statement
		conn.close(); // All done with that DB connection
		return; // All done with this program.
	}
}//@@@@@@//
//jabadot/User.java
//@@@@@@//
// package jabadot;

import java.util.Date;

/** Represents one logged in user 
 */
public class User implements java.io.Serializable {

	// #name:password:name:email:City:Prov:Country:privs
	/** The login name */
	protected String name;
	protected String password;
	protected String firstName;
	protected String lastName;
	protected String email;			// 5
	protected String address;
	protected String address2;
	protected String company;
	protected String city;
	protected String prov;			// 10
	protected String country;
	protected Date creationDate;
	protected Date lastLoginDate;
	protected String jobDescr;
	protected String os;			// 15
	protected String unixGUI;
	protected String proglang;
	/** user preference */
	protected String skin;

	//								// privs is 19

	protected boolean editPrivs = false;
	protected boolean adminPrivs = false;

	public static final int P_ADMIN = 01000;
	public static final int P_EDIT = 0100;

	/** Construct a user with no data -- must be a no-argument
	 * constructor for use in jsp:useBean.
	 */
	public User() {
		creationDate = new Date();
	}

	/** Construct a user with just the name */
	public User(String n) {
		this();			// set credt
		name = n;
	}

	/** Construct a user with all text fields. */
	public User(String nick, String pw, String fname, String lName,
		String emaddr,
		String comp,
		String addr1, String addr2,
		String cty, String pr, String cntry,
		String jd, String os, String gui, String lang,
		String skin) {
		this();			// set credt
		name = nick;
		password = pw;
		firstName = fname;
		lastName = lName;
		email = emaddr;
		address = addr1;
		address2 = addr2;
		company = comp;
		city = cty;
		prov = pr;
		country = cntry;
		this.skin = skin;
		jobDescr = jd;
		this.os = os;
		unixGUI = gui;
		proglang = lang;
	}

	/** Construct a user with common text fields. */
	public User(String nick, String pw, String fname, String lName,
		String emaddr, String prov, String cntry,
		Date credt, Date lastlog, String skin, boolean e, boolean a) {
		this();			// set credt
		name = nick;
		password = pw;
		firstName = fname;
		lastName = lName;
		email = emaddr;
		this.prov = prov;
		this.country = cntry;
		this.skin = skin;
		creationDate = credt;
		lastLoginDate = lastlog;
		adminPrivs = a;
		editPrivs = e;
	}

	/** Return the nickname. */
	public String getName() {
		return name;
	}

	/** The name should not be changeable, but we
	 * want to be able to say <jsp:setProperty property="*"/>
	 * and get it all...
	 */
	public void setName(String nick) {
		name = nick;
	}

	public String getPassword() {
		return password;
	}

	/** Validate a given password against the user's. */
	public boolean checkPassword(String userInput) {
		return password.equals(userInput);
	}

	/** Set password */
	public void setPassword(String password) {
		this.password = password;
	}

	/** Get email */
	public String getEmail() {
		return email;
	}

	/** Set email */
	public void setEmail(String email) {
		this.email = email;
	}

	/** Get fullName */
	public String getFullName() {
		return firstName + ' ' + lastName;
	}

	/** Set firstName */
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	/** Set lastName */
	public void setlastName(String lastName) {
		this.lastName = lastName;
	}

	/** Get city */
	public String getCity() {
		return city;
	}

	/** Set city */
	public void setCity(String city) {
		this.city = city;
	}

	/** Get prov */
	public String getProv() {
		return prov;
	}

	/** Set prov */
	public void setProv(String prov) {
		this.prov = prov;
	}

	/** Get country */
	public String getCountry() {
		return country;
	}

	/** Set country */
	public void setCountry(String country) {
		this.country = country;
	}

	/** Get adminPrivs */
	public boolean isAdminPrivileged() {
		return adminPrivs;
	}

	/** Set adminPrivs */
	public void setAdminPrivileged(boolean adminPrivs) {
		this.adminPrivs = adminPrivs;
	}

	/** Get EditPrivs */
	public boolean isEditPrivileged() {
		return editPrivs;
	}

	/** Set EditPrivs */
	public void setEditPrivileged(boolean editPrivs) {
		this.editPrivs = editPrivs;
	}

	/** Get all privs, as an int, for use in the database */
	public int getPrivs() {
		int i = 0;
		if (adminPrivs)
			i |= P_ADMIN;
		if (editPrivs)
			i |= P_EDIT;
		return i;
	}

	/** Get the Creation Date (read only field) */
	public Date getCreationDate() {
		return creationDate;
	}
	/** Set the Creation Date (read only field) */
	public void setCreationDate(Date date) {
		creationDate = date;
	}

	/** Get the LastLog Date (read only field) */
	public Date getLastLoginDate() {
		return lastLoginDate;
	}

	/** Get the LastLog Date (read only field) */
	public void setLastLoginDate(Date d) {
		lastLoginDate = d;
	}

	/** Return a String representation. */
	public String toString() {
		return new StringBuffer("User[").append(name).append(',').
			append(firstName).append(' ').append(lastName).
			append(']').toString();
	}

	/** Check if all required fields have been set */
	public boolean isComplete() {
		if (name == null || name.length()==0 ||
		    firstName == null || firstName.length()==0 ||
		    lastName == null || lastName.length()==0 ||
		    email == null || email.length()==0)
			return false;
		return true;
	}
}
//@@@@@@//
//jabadot/UserDB.java
//@@@@@@//
// package jabadot;

import java.io.IOException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/** A base for several "database" accessors for User objects.
 * We use a Singleton access method for efficiency and to enforce
 * single access on the database, which means we can keep an in-memory
 * copy (in an ArrayList) perfectly in synch with the database.
 *
 * Of course this really should be an EJB(!). But then JabaDot
 * would need a full EJB server to run, not just Tomcat and idb.
 */
public abstract class UserDB {

	/** The in-memory copy of the data */
	protected List users;

	/** The only instance of this class. */
	protected static UserDB singleton;

	/** Static initializer to initialize the Singleton.
	 * It is created as the non-abstract subclass formerly named
	 * in the context parameter "jabadot.jabadb.class"
	 * but now hardcoded as "jabadot.UserDBJDBC"
	 */
	static {
		// String dbClass = null;
		try {
			//dbClass = "jabadot.UserDBJDBC";
			//singleton = (UserDB)Class.forName(dbClass).newInstance();
			singleton = new UserDBJDBC();
		} catch (Exception ex) {
			System.err.println(
			"Unexpected exception: Unable to initialize UserDB singleton");
			ex.printStackTrace(System.err);
			throw new IllegalArgumentException(ex.toString());
		}
	}

	/** In some subclasses the constructor will probably load the database,
	 *  while in others it may defer this until getUserList().
	 */
	protected UserDB() throws IOException, SQLException {
		users = new ArrayList();
	}

	/** "factory" method to get an instance, which will always be
	 * the Singleton.
	 */
	public static UserDB getInstance() {
		if (singleton == null)
			throw new IllegalStateException(
				"UserDB initialization failed (singleton was null)");
		return singleton;
	}

	/** Get the list of users. */
	public List getUserList() {
		return users;
	}

	/** Get the User object for a given nickname */
	public User getUser(String nick) {
		Iterator it = users.iterator();
		while (it.hasNext()) {
			User u = (User)it.next();
			if (u.getName().equals(nick))
				return u;
		}
		return null;
	}

	public synchronized void addUser(User nu) throws IOException, SQLException {
		// Add it to the in-memory list
		users.add(nu);

		// Add it to the on-disk version
		// N.B. - must be done in subclass.
	}

	public abstract  void setPassword(String nick, String newPass) 
	throws SQLException;

	public abstract void deleteUser(String nick)
	throws SQLException;
}
//@@@@@@//
//jabadot/UserDBJDBC.java
//@@@@@@//
// package jabadot;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import javax.naming.NamingException;

/** A UserDB using JDBC and a relational DBMS..
 * We use the inherited getUser ("Find the User object for a given nickname")
 * since we keep everything in memory in this version.
 * <p>
 * ToDo: Consider whether this should be an Entity EJB.
 */
public class UserDBJDBC extends UserDB {

	protected PreparedStatement setPasswordStatement;
	protected PreparedStatement addUserStmt;
	protected PreparedStatement setLastLoginStmt;
	protected PreparedStatement deleteUserStmt;

	/** insert the dozen or so fields into the user database */
	final static String SQL_INSERT_USER =
		"insert into users " +
		" values (?,?,?,?,?,?,?,?,?,?,?,?,?)";

	/** Default constructor */
	protected UserDBJDBC() 
	throws NamingException, SQLException, IOException {
		super();

System.out.println("UserDBJDBC.<init> starting...");
/*
System.out.println("Getting InitialContext");
		Context ctx = new InitialContext();
System.out.println("Getting JNDI Context");
		Context env = (Context)ctx.lookup("java:comp/env");
System.out.println("Getting DataSource");
		DataSource ds = (DataSource)env.lookup("jdbc/jabadotDB");
System.out.println("Getting Connection");
		Connection conn = ds.getConnection();
System.out.println("Connection = " + conn);
*/
System.out.println("Loading Driver Class");
try {
	Class.forName("org.hsqldb.jdbcDriver");
} catch (ClassNotFoundException ex) {
	System.out.println("FAILED: " + ex.toString());
	throw new IllegalStateException(ex.toString());
}
System.out.println("Getting Connection");
	Connection conn = DriverManager.getConnection(
		"jdbc:hsqldb:/home/ian/src/jabadot/WEB-INF/jabadot",
		"jabadmin", "fredonia");

		Statement stmt = conn.createStatement();

		ResultSet rs = stmt.executeQuery("select * from users");

		while (rs.next()) {
			//name:password:fullname:City:Prov:Country:privs

			// Get the fields from the query.
			// Could be an Entity EJB with CMP: this is unnecessarily 
			// chummy with the SQL. See CreateUserDatabase.java for field#'s!
			int i = 1;
			String nick = rs.getString(i++).trim();
			String pass = rs.getString(i++).trim();
System.err.println(nick + " (" + pass + ")");
			String first = rs.getString(i++);
			String last = rs.getString(i++);
			String email = rs.getString(i++);
			String city = rs.getString(i++);
			String prov = rs.getString(i++);
			String ctry = rs.getString(i++);
			java.sql.Date credt = rs.getDate(i++);
			java.sql.Date lastlog = rs.getDate(i++);
			String skin = rs.getString(i++);
			boolean editPrivs = rs.getBoolean(i++);
			boolean adminPrivs = rs.getBoolean(i++);

			// Construct a user object from the fields
System.out.println("Constructing User object");
			User u = new User(nick, pass, first, last, email,
				prov, ctry, credt, lastlog,
				skin, editPrivs, adminPrivs);

System.out.println("Adding User object " + u + " to " + users);
			// Add it to the in-memory copy.
			users.add(u);
System.err.println("User " + nick + "; pass " + pass.charAt(0));
		}
		rs.close();		// All done with that resultset
		stmt.close();

		// Set up the PreparedStatements now so we don't have to
		// re-create them each time needed.
		addUserStmt = conn.prepareStatement(SQL_INSERT_USER);
		setPasswordStatement = conn.prepareStatement(
			"update users SET password = ? where name = ?");
		setLastLoginStmt = conn.prepareStatement(
			"update users SET lastLogin = ? where name = ?");
		deleteUserStmt = conn.prepareStatement(
			"delete from users where name = ?");
	}

	/** Add one user to the list, both in-memory and on disk. */
	public synchronized void addUser(User nu)
	throws IOException, SQLException {
		// Add it to the in-memory list
		super.addUser(nu);

		// Copy fields from user to DB
		// XXX WAY INCOMPLETE NOW
		int i = 1;
		addUserStmt.setString(i++, nu.name);
		addUserStmt.setString(i++, nu.password);
		addUserStmt.setString(i++, nu.firstName); 
		addUserStmt.setString(i++, nu.lastName);
		addUserStmt.setString(i++, nu.email);
		addUserStmt.setString(i++, nu.city);
		addUserStmt.setString(i++, nu.prov);
		addUserStmt.setString(i++, nu.country);
		java.sql.Date now = new java.sql.Date(System.currentTimeMillis());
		addUserStmt.setDate(i++, now);
		addUserStmt.setDate(i++, now);
		addUserStmt.setString(i++, nu.skin);
		addUserStmt.setBoolean(i++, false);
		addUserStmt.setBoolean(i++, false);
		--i;

		if (i != 13) {
			System.out.println("Warning: not enough fields set! i = " + i);
		}

		// Store in persistent DB
		addUserStmt.executeUpdate();
	}

	public void deleteUser(String nick) throws SQLException {
		// Find the user object
		User u = getUser(nick);
		if (u == null) {
			throw new SQLException("User " + nick + " not in in-memory DB");
		}
		deleteUserStmt.setString(1, nick);
		int n = deleteUserStmt.executeUpdate();
		if (n != 1) {	// not just one row??
			/*CANTHAPPEN */
			throw new SQLException("ERROR: deleted " + n + " rows!!");
		}

		// IFF we deleted it from the DB, also remove from the in-memory list
		users.remove(u);
	}

	public synchronized void setPassword(String nick, String newPass) 
	throws SQLException {

		// Find the user object
		User u = getUser(nick);

		// Change it in DB first; if this fails, the info in
		// the in-memory copy won't be changed either.
		setPasswordStatement.setString(1, newPass);
		setPasswordStatement.setString(2, nick);
		setPasswordStatement.executeUpdate();

		// Change it in-memory
		u.setPassword(newPass);
	}

	/** Update the Last Login Date field. */
	public synchronized void setLoginDate(String nick, java.util.Date date) 
	throws SQLException {
	
		// Find the user object
		User u = getUser(nick);

		// Change it in DB first; if this fails, the date in
		// the in-memory copy won't be changed either.
		// Have to convert from java.util.Date to java.sql.Date here.
		// Would be more efficient to use java.sql.Date everywhere.
		setLastLoginStmt.setDate(1, new java.sql.Date(date.getTime()));
		setLastLoginStmt.setString(2, nick);
		setLastLoginStmt.executeUpdate();

		// Change it in-memory
		u.setLastLoginDate(date);
	}
}
//@@@@@@//
//jabadot/UserDBTest.java
//@@@@@@//
// package jabadot;

import java.util.*;

/**
 * Standalone test program for UserDB.
 * @author Ian F. Darwin, ian@darwinsys.com
 * @version $Id: UserDBTest.java,v 1.6 2004/06/17 01:54:58 ian Exp $
 */
public class UserDBTest {
	public static void main(String argv[]) throws java.io.IOException {

		System.out.println("Testing Getting One...");
		User iadmin = UserDB.getInstance().getUser("iadmin");
		System.out.println(iadmin);

		System.out.println("Testing Getting All...");
		List al = UserDB.getInstance().getUserList();
		Iterator it = al.iterator();
		while (it.hasNext()) {
			System.out.println(it.next());
		}

		System.out.println("Testing privs");
		iadmin.setPassword("guten abend");
		if (iadmin.checkPassword("foo"))
			System.out.println("setPassword failed");
		if (!iadmin.checkPassword("guten abend"))
			System.out.println("checkPassword failed");
		System.out.println("All done");
		System.exit(0);
	}
}
//@@@@@@//
//jabadot/UserQuery.java
//@@@@@@//
// import jabadot.*;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

/** Look up one use from the relational database using JDBC.
 */
public class UserQuery {

	public static void main(String[] fn)
	throws ClassNotFoundException, SQLException, IOException {

		// Load the database driver
		Class.forName(JDConstants.getProperty("jabadot.jabadb.driver"));

		System.out.println("Getting Connection");
		Connection conn = DriverManager.getConnection(
			JDConstants.getProperty("jabadot.dburl"));

		Statement stmt = conn.createStatement();

		ResultSet rs = stmt.executeQuery(
			"SELECT * from jabadb where name='ian'");

		// Now retrieve (all) the rows that matched the query
		while (rs.next()) {

			// Field 1 is login name
			String name = rs.getString(1);

			// Password is field 2 - do not display.

			// Column 3 is fullname
			String fullName = rs.getString(3);

			System.out.println("User " + name + " is named " + fullName);
		}

		rs.close();			// All done with that resultset
		stmt.close();		// All done with that statement
		conn.close();		// All done with that DB connection
		System.exit(0);		// All done with this program.
	}
}
//@@@@@@//
//javacomm/CommPortDial.java
//@@@@@@//
import java.io.IOException;

import javax.comm.NoSuchPortException;
import javax.comm.PortInUseException;
import javax.comm.UnsupportedCommOperationException;

/**
 * Dial a phone using the Java Communications Package.
 *
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 */
public class CommPortDial extends CommPortModem {

	protected static String number = "000-0000";

	public static void main(String[] ap)
		throws IOException, NoSuchPortException,PortInUseException,
			UnsupportedCommOperationException {
		if (ap.length == 1)
			number = ap[0];
		new CommPortDial().converse();
		System.exit(0);
	}

	public CommPortDial() 
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {
		super(null);
	}

	protected void converse() throws IOException {

		String resp;		// the modem response.

		// Send the reset command
		send("ATZ");

		expect("OK");

		send("ATDT" + number);

		expect("OK");

		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			// nothing to do
		}
		is.close();
		os.close();
	}
}
//@@@@@@//
//javacomm/CommPortLister.java
//@@@@@@//
import javax.comm.*;
import java.util.*;

/**
 * List the ports.
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @version	$Id: CommPortLister.java,v 1.4 2004/02/09 03:33:51 ian Exp $
 */
public class CommPortLister {

	/** Simple test program. */
	public static void main(String[] ap) {
		new CommPortLister().list();
	}

	/** Ask the Java Communications API * what ports it thinks it has. */
	protected void list() {
		// get list of ports available on this particular computer,
		// by calling static method in CommPortIdentifier.
		Enumeration pList = CommPortIdentifier.getPortIdentifiers();

		// Process the list.
		while (pList.hasMoreElements()) {
			CommPortIdentifier cpi = (CommPortIdentifier)pList.nextElement();
			System.out.print("Port " + cpi.getName() + " ");
			if (cpi.getPortType() == CommPortIdentifier.PORT_SERIAL) {
				System.out.println("is a Serial Port: " + cpi);
			} else if (cpi.getPortType() == CommPortIdentifier.PORT_PARALLEL) {
				System.out.println("is a Parallel Port: " + cpi);
			} else {
				System.out.println("is an Unknown Port: " + cpi);
			}
		}
	}
}
//@@@@@@//
//javacomm/CommPortModem.java
//@@@@@@//
import java.io.IOException;

import javax.comm.NoSuchPortException;
import javax.comm.PortInUseException;
import javax.comm.UnsupportedCommOperationException;
import javax.swing.JFrame;

/**
 * Subclasses CommPortOpen and adds send/expect handling for dealing
 * with Hayes-type modems.
 *
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 */
public class CommPortModem extends CommPortOpen {

	/** The last line read from the serial port. */
	protected String response;

	/** A flag to control debugging output. */
	protected boolean debug = true;

	public CommPortModem(JFrame f)
		throws IOException, NoSuchPortException,PortInUseException,
			UnsupportedCommOperationException {
		super(f);
	}

	/** Send a line to a PC-style modem. Send \r\n, regardless of
	 * what platform we're on, instead of using println().
	 */
	protected void send(String s) throws IOException {
		if (debug) {
			System.out.print(">>> ");
			System.out.print(s);
			System.out.println();
		}
		os.print(s);
		os.print("\r\n");

		// Expect the modem to echo the command.
		if (!expect(s)) {
			System.err.println("WARNING: Modem did not echo command.");
		}

		// The modem sends an extra blank line by way of a prompt.
		// Here we read and discard it.
		String junk = is.readLine();
		if (junk.length() != 0) {
			System.err.print("Warning: unexpected response: ");
			System.err.println(junk);
		}
	}

	/** Read a line, saving it in "response". 
	 * @return true if the expected String is contained in the response, false if not.
	 */
	protected boolean expect(String exp) throws IOException {
		response = is.readLine();
		if (debug) {
			System.out.print("<<< ");
			System.out.print(response);
			System.out.println();
		}
		return response.indexOf(exp) >= 0;
	}
}
//@@@@@@//
//javacomm/CommPortOpen.java
//@@@@@@//
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

import javax.comm.CommPort;
import javax.comm.CommPortIdentifier;
import javax.comm.NoSuchPortException;
import javax.comm.ParallelPort;
import javax.comm.PortInUseException;
import javax.comm.SerialPort;
import javax.comm.UnsupportedCommOperationException;
import javax.swing.JFrame;

/**
 * Open a serial port using Java Communications.
 *
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 */
public class CommPortOpen {
	/** How long to wait for the open to finish up. */
	public static final int TIMEOUTSECONDS = 30;
	/** The baud rate to use. */
	public static final int BAUD = 19200;
	/** The parent JFrame, for the chooser. */
	protected JFrame parent;
	/** The input stream */
	protected BufferedReader is;
	/** The output stream */
	protected PrintStream os;
	/** The chosen Port Identifier */
	CommPortIdentifier thePortID;
	/** The chosen Port itself */
	CommPort thePort;

	public static void main(String[] argv)
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {

		new CommPortOpen(null).converse();

		System.exit(0);
	}

	/* Constructor */
	public CommPortOpen(JFrame f)
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {
		
		// Use the PortChooser from before. Pop up the JDialog.
		PortChooser chooser = new PortChooser(null);

		String portName = null;
		do {
			chooser.setVisible(true);
			
			// Dialog done. Get the port name.
			portName = chooser.getSelectedName();

			if (portName == null)
				System.out.println("No port selected. Try again.\n");
		} while (portName == null);

		// Get the CommPortIdentifier.
		thePortID = chooser.getSelectedIdentifier();

		// Now actually open the port.
		// This form of openPort takes an Application Name and a timeout.
		// 
		System.out.println("Trying to open " + thePortID.getName() + "...");

		switch (thePortID.getPortType()) {
		case CommPortIdentifier.PORT_SERIAL:
			thePort = thePortID.open("DarwinSys DataComm",
				TIMEOUTSECONDS * 1000);
			SerialPort myPort = (SerialPort) thePort;

			// set up the serial port
			myPort.setSerialPortParams(BAUD, SerialPort.DATABITS_8,
				SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);
			break;

		case CommPortIdentifier.PORT_PARALLEL:
			thePort = thePortID.open("DarwinSys Printing",
				TIMEOUTSECONDS * 1000);
			ParallelPort pPort = (ParallelPort)thePort;

			// Tell API to pick "best available mode" - can fail!
			// myPort.setMode(ParallelPort.LPT_MODE_ANY);

			// Print what the mode is
			int mode = pPort.getMode();
			switch (mode) {
				case ParallelPort.LPT_MODE_ECP:
					System.out.println("Mode is: ECP");
					break;
				case ParallelPort.LPT_MODE_EPP:
					System.out.println("Mode is: EPP");
					break;
				case ParallelPort.LPT_MODE_NIBBLE:
					System.out.println("Mode is: Nibble Mode.");
					break;
				case ParallelPort.LPT_MODE_PS2:
					System.out.println("Mode is: Byte mode.");
					break;
				case ParallelPort.LPT_MODE_SPP:
					System.out.println("Mode is: Compatibility mode.");
					break;
				// ParallelPort.LPT_MODE_ANY is a "set only" mode;
				// tells the API to pick "best mode"; will report the
				// actual mode it selected.
				default:
					throw new IllegalStateException("Parallel mode " + 
						mode + " invalid.");
			}
			break;
		default:	// Neither parallel nor serial??
			throw new IllegalStateException("Unknown port type " + thePortID);
		}

		// Get the input and output streams
		// Printers can be write-only
		try {
			is = new BufferedReader(new InputStreamReader(thePort.getInputStream()));
		} catch (IOException e) {
			System.err.println("Can't open input stream: write-only");
			is = null;
		}
		os = new PrintStream(thePort.getOutputStream(), true);
	}

	/** This method will be overridden by non-trivial subclasses
	 * to hold a conversation. 
	 */
	protected void converse() throws IOException {

		System.out.println("Ready to read and write port.");

		// Input/Output code not written -- must subclass.

		// Finally, clean up.
		if (is != null)
			is.close();
		os.close();
	}
}
//@@@@@@//
//javacomm/CommPortThreaded.java
//@@@@@@//
import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.InputStreamReader;

import javax.comm.NoSuchPortException;
import javax.comm.PortInUseException;
import javax.comm.UnsupportedCommOperationException;

/**
 * This program tries to do I/O in each direction using a separate Thread.
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 */
public class CommPortThreaded extends CommPortOpen {

	public static void main(String[] ap)
		throws IOException, NoSuchPortException,PortInUseException,
			UnsupportedCommOperationException {
		CommPortThreaded cp;
		try {
			cp = new CommPortThreaded();
			cp.converse();
		} catch(Exception e) {
			System.err.println("You lose!");
			System.err.println(e);
		}
	}

	public CommPortThreaded()
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {
		super(null);
	}

	/** This version of converse() just starts a Thread in each direction.
	 */
	protected void converse() throws IOException {

		String resp;		// the modem response.

		new DataThread(is, System.out).start();
		new DataThread(new DataInputStream(System.in), os).start();

	}

	/** This inner class handles one side of a conversation. */
	class DataThread extends Thread {
		BufferedReader inStream;
		PrintStream pStream;

		/** Construct this object */
		DataThread(InputStream is, PrintStream os) {
			inStream = new BufferedReader(new InputStreamReader(is));
			pStream = os;
		}
		DataThread(BufferedReader is, PrintStream os) {
			inStream = is;
			pStream = os;
		}

		/** A Thread's run method does the work. */
		public void run() {
			byte ch = 0;
			try {
				while ((ch = (byte)inStream.read()) != -1)
					pStream.print((char)ch);
			} catch (IOException e) {
				System.err.println("Input or output error: " + e);
				return;
			}
		}
	}
}
//@@@@@@//
//javacomm/JMModel.java
//@@@@@@//
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.Enumeration;
import java.util.HashMap;

import javax.comm.CommPortIdentifier;
import javax.comm.PortInUseException;
import javax.comm.SerialPort;
import javax.comm.UnsupportedCommOperationException;

/**
 * JMModel -- Communications I/O for JModem. No GUI stuff here.
 * @author	 Ian F. Darwin, http://www.darwinsys.com/
 * @version	 $Id: JMModel.java,v 1.4 2004/04/11 23:50:40 ian Exp $
 */
public class JMModel extends java.lang.Object {
	/** The View */
	JModem theGUI;

	/** The javax.com.CommPort object in use */
	private SerialPort thePort;

	/** The input and output streams */
	private InputStream serialInput;
	private OutputStream serialOutput;

	/** The size of the static read buffer. */
	protected static final int BUFSIZE = 1024;
	/** A buffer for the read listener; preallocated once. */
	static byte[] buf = new byte[BUFSIZE];
	/** A Thread for reading from the remote. */
	protected Thread serialReadThread;
	/** A file transfer program */
	protected TModem xferProg;
	/** The state for disconnected and connected */
	static int S_DISCONNECTED = 0, S_CONNECTED = 1;
	/** The state, either disconnected or connected */
	int state = S_DISCONNECTED;
	/** The substate settings */
	static int S_INTERACT = 0, S_XFER = 1;
	/** The online state, either interactive or in xfer. Used by the
	 * main reader thread to avoid reading data meant for the xfer program.
	 */
	int submode = S_INTERACT;

	// Constants to hide the Comm API from our GUI.
	public final static int PARITY_NONE = SerialPort.PARITY_NONE;
	public final static int PARITY_EVEN = SerialPort.PARITY_EVEN;
	public final static int PARITY_ODD	= SerialPort.PARITY_ODD;

	private int[] baudot = { 9600, 19200, 38400, 57600, 115200 };
	private String sysTypes[] = { "Unix", "DOS", "Other" };

	protected HashMap portsIDmap = new HashMap();

	/** Constructor */
	public JMModel(JModem gui) {
		theGUI = gui;
	}

	protected String DEFAULT_LOG_FILE = "jmodemlog.txt";;

	/** Use normal java.io to save the JTextArea's session log
	 * into a file.
	 */	
	public void saveLogFile() {
		String fileName = DEFAULT_LOG_FILE;
		try {
			Writer w = new FileWriter(fileName);
			theGUI.theTextArea.write(w);
			w.write('\r'); w.write('\n');	// in case last line is a prompt.
			w.close();
		} catch (IOException e) {
			theGUI.err("Error saving log file:\n" + e.toString());
			return;
		}
		theGUI.note("Session log saved to " + fileName);
	}

	/** Load the list of Serial Ports into the chooser.
	 * This code is far too chummy with the innards of class JModem.
	 */
	void populateComboBox() {
		// get list of ports available on this particular computer,
		// by calling static method in CommPortIdentifier.
		Enumeration pList = CommPortIdentifier.getPortIdentifiers();

		// Process the list of ports, putting serial ports into ComboBox
		while (pList.hasMoreElements()) {
			CommPortIdentifier cpi = (CommPortIdentifier)pList.nextElement();
			if (cpi.getPortType() == CommPortIdentifier.PORT_SERIAL) {
				theGUI.portsComboBox.addItem(cpi.getName());
				portsIDmap.put(cpi.getName(), cpi);
			}
		}
	}

	/** Connect to the chosen serial port, and set parameters. */
	void connect() {

		try {
			// Open the specified serial port
			CommPortIdentifier cpi = (CommPortIdentifier)portsIDmap.get(
			theGUI.portsComboBox.getSelectedItem());
			thePort = (SerialPort)cpi.open("JModem", 15*1000);

			// Set the serial port parameters.
			thePort.setSerialPortParams(
				baudot[theGUI.baudComboBox.getSelectedIndex()],		// baud
				theGUI.getDataBits() == 7 ?
				SerialPort.DATABITS_7 : SerialPort.DATABITS_8,
				SerialPort.STOPBITS_1,							// stop bits
				theGUI.getParity());							// parity

			thePort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN &
				SerialPort.FLOWCONTROL_RTSCTS_OUT);

		} catch (PortInUseException pue) {
			theGUI.err("Port in use: close other app, or use different port.");
			return;
		} catch (UnsupportedCommOperationException uoe) {
			theGUI.err("Unsupported options error: try different settings");
			return;
		}

		// Similar to "raw" mode: return when 1 or more chars available.
		try {
			thePort.enableReceiveThreshold(1);
			if (!thePort.isReceiveThresholdEnabled()) {
				theGUI.err("Could not set receive threshold");
				disconnect();
				return;
			}
			thePort.setInputBufferSize(buf.length);
		} catch (UnsupportedCommOperationException ev) {
			theGUI.err("Unable to set receive threshold in Comm API; port unusable.");
			disconnect();
			return;
		}

		// Get the streams
		try {
			serialInput = thePort.getInputStream();
		} catch (IOException e) {
			theGUI.err("Error getting input stream:\n" + e.toString());
			return;
		}
		try {
			serialOutput = thePort.getOutputStream();
		} catch (IOException e) {
			theGUI.err("Error getting output stream:\n" + e.toString());
			return;
		}

		// Now that we're all set, create a Thread to read data from the remote
		serialReadThread = new Thread(new Runnable() {
		int nbytes = buf.length;
			public void run() {
				do {
					try {
						// If the xfer program is running, stay out of its way.
							if (submode == S_XFER) {
								delay(1000);
							continue;
						}
						nbytes = serialInput.read(buf, 0, buf.length);
					} catch (IOException ev) {
					theGUI.err("Error reading from remote:\n" + ev.toString());
					return;
					}
					// XXX need an appendChar() method in MyTextArea
					String tmp = new String(buf, 0, nbytes);
					theGUI.theTextArea.append(tmp);
					theGUI.theTextArea.setCaretPosition(
					theGUI.theTextArea.getText().length());
				} while (serialInput != null);
			}
		});
		serialReadThread.start();

		// Finally, tell rest of program, and user, that we're online.
		state = S_CONNECTED;
		theGUI.connect();
	}

	/** Break our connection to the serial port. */
	void disconnect() {
		// Tell java.io we are done with the input and output
		try {
			serialReadThread.stop();	// IGNORE DEPRECATION WARNINGS; the Java
			// API still lacks a reliable termination method for Threads
			// that are blocked on e.g., local disk reads.
			serialInput.close();
			serialOutput.close();
			serialOutput = null;
		} catch (IOException e) {
			theGUI.err("IO Exception closing port:\n" + e.toString());
		}
		// Tell javax.comm we are done with the port.
		thePort.removeEventListener();
		thePort.close();
		// Discard TModem object, if present.
		xferProg = null;
		// Tell rest of program we are no longer online.
		state = S_DISCONNECTED;
		theGUI.disconnect();
	}

	/** Convenience routine, due to useless InterruptedException */
	public void delay(long milliseconds) {
		try {
			Thread.sleep(milliseconds);
		} catch (InterruptedException e) {
			// can't happen
		}
	}

	/** Send one character to the remote */
	void sendChar(char ch) {
		if (state != S_CONNECTED)
			return;
		// System.err.println("--> " + ch);
		try {
			serialOutput.write(ch);
		} catch (IOException e) {
			theGUI.err("Output error on remote:\n" + e.toString() +
				"\nClosing connection.");
			disconnect();
		}
	}

	/** Send a String of characters to the remote. */
	private void sendString(String s) {
		if (state != S_CONNECTED)
			return;
		try {
			serialOutput.write(s.getBytes());
		} catch (IOException e) {
			theGUI.err("Output error on remote:\n" + e.toString() +
				"\nClosing connection.");
			disconnect();
		}
	}

	/** Do one complete file transfer, using TModem */
	public void xfer() {

		if (state != S_CONNECTED) {
			theGUI.err("Must be connected to do file transfers");
			return;
		}
		if (xferProg == null) {
			xferProg = new TModem(serialInput, serialOutput, 
				new PrintWriter(System.out)); // xerProg discarded in disconnect()
		}
		String fileName = theGUI.getXferFileName();
		if (fileName.length() == 0) {
			theGUI.err("Filename must be given");
			return;
		}

		// Do the transfer!	If we are sending, send a "tmodem -r" to
		// the other side; if receiving, send "tmodem -s" to ask it
		// to send the file.
		try {
			if (theGUI.isSend()) {
				if (!new File(fileName).canRead()) {
						theGUI.err("Can't read file " + fileName + ".");
					return;
				}
				// Other end must "r"eceive what we send.
				sendString("tmodem -r " + fileName + "\r\n");
				delay(500);		// let command echo back to us
				submode = S_XFER;
				xferProg.send(fileName);
			} else {
				// Other end must send for us to receive.
				sendString("tmodem -s " + fileName + "\r\n");
				delay(500);		// let command echo back to us
				submode = S_XFER;
				xferProg.receive(fileName);
			}
		} catch (InterruptedException e) {
			theGUI.err("Timeout");
			return;
		} catch (IOException e) {
			theGUI.err("IO Exception in transfer:\n" + e);
			return;
		} catch (ProtocolBotchException ev) {
			theGUI.err("Protocol failure:\n" + ev);
			return;
		} finally {
			submode = S_INTERACT;
		}
		theGUI.note("File Transfer completed");
	}
}
//@@@@@@//
//javacomm/JModem.java
//@@@@@@//
import java.awt.BorderLayout;
import java.awt.Font;
import java.awt.event.KeyEvent;

import javax.swing.ButtonGroup;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;

/**
 * JModem - simple communications program.
 * WARNING this file was built with the NetBeans Developer IDE
 * and parts of it should not be modified with a text editor.
 * @author    Ian F. Darwin, http://www.darwinsys.com/
 * @version   $Id: JModem.java,v 1.18 2004/04/11 23:50:40 ian Exp $
 */
public class JModem extends javax.swing.JFrame {

  /** The Model. */
  JMModel theModel;

  /** The TextArea */
  JTextArea theTextArea;
  /** The courier font for the text areas and fields. */
  protected Font plainFont;
  /** The valid baud rates (actually BPS rates). */
  private int[] baudot = { 9600, 19200, 38400, 57600, 115200 };
  /** The types of remote systems. */
  private String sysTypes[] = { "Unix", "DOS", "Other" };

  private int M_RECEIVE = -1, M_SEND = +1;
  private int xferDirection = M_RECEIVE;

  /** Constructor */
  public JModem() {
    theModel = new JMModel(this);
    initComponents();
    finishConstructor();
    pack();
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the FormEditor.
   */
  private void initComponents () {//GEN-BEGIN:initComponents
    setTitle ("JModem");
    addWindowListener (new java.awt.event.WindowAdapter () {
        public void windowClosing (java.awt.event.WindowEvent evt) {
          exitForm (evt);
        }
      }
    );
    getContentPane ().setLayout (new java.awt.BorderLayout ());

    jMenuBar1 = new javax.swing.JMenuBar ();
      fileMenu = new javax.swing.JMenu ();
      fileMenu.setText ("File");
        saveLogFileMenuItem = new javax.swing.JMenuItem ();
        saveLogFileMenuItem.setText ("Save Log");
        saveLogFileMenuItem.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent evt) {
              saveLogFileMenuItemActionPerformed (evt);
            }
          }
        );
        fileMenu.add(saveLogFileMenuItem);

        fileMenu.addSeparator();

        exitMenuItem = new javax.swing.JMenuItem ();
        exitMenuItem.setText ("Exit");
        exitMenuItem.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent evt) {
              exitMenuItemActionPerformed (evt);
            }
          }
        );
        fileMenu.add(exitMenuItem);

      jMenuBar1.add(fileMenu);

      helpMenu = new javax.swing.JMenu ();
      helpMenu.setText ("Help");
        helpAboutMenuItem = new javax.swing.JMenuItem ();
        helpAboutMenuItem.setText ("Item");
        helpAboutMenuItem.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent evt) {
              helpAboutMenuItemActionPerformed (evt);
            }
          }
        );
        helpMenu.add(helpAboutMenuItem);

      jMenuBar1.add(helpMenu);


    setJMenuBar(jMenuBar1);
    connectPanel = new javax.swing.JPanel ();
    connectPanel.setLayout (new java.awt.FlowLayout ());

      connectPanelLabel = new javax.swing.JLabel ();
      connectPanelLabel.setText ("Connection");
      connectPanelLabel.setForeground (java.awt.Color.red);
      connectPanel.add (connectPanelLabel);

      portsLabel = new javax.swing.JLabel ();
      portsLabel.setText ("Port:");
      connectPanel.add (portsLabel);

      portsComboBox = new javax.swing.JComboBox ();
      portsComboBox.addActionListener (new java.awt.event.ActionListener () {
          public void actionPerformed (java.awt.event.ActionEvent evt) {
            portsComboBoxActionPerformed (evt);
          }
        }
      );
      connectPanel.add (portsComboBox);

      buadLabel = new javax.swing.JLabel ();
      buadLabel.setText ("Speed");
      connectPanel.add (buadLabel);

      baudComboBox = new javax.swing.JComboBox ();
      baudComboBox.addActionListener (new java.awt.event.ActionListener () {
          public void actionPerformed (java.awt.event.ActionEvent evt) {
            baudComboBoxActionPerformed (evt);
          }
        }
      );
      connectPanel.add (baudComboBox);

      databitsPanel = new javax.swing.JPanel ();
      databitsPanel.setPreferredSize (new java.awt.Dimension(50, 50));
      databitsPanel.setMinimumSize (new java.awt.Dimension(0, 0));
      databitsPanel.setLayout (new javax.swing.BoxLayout (databitsPanel, 1));

        d7RadioButton = new javax.swing.JRadioButton ();
        d7RadioButton.setText ("7");
        databitsPanel.add (d7RadioButton);

        d8RadioButton = new javax.swing.JRadioButton ();
        d8RadioButton.setSelected (true);
        d8RadioButton.setText ("8");
        databitsPanel.add (d8RadioButton);

      connectPanel.add (databitsPanel);

      parityPanel = new javax.swing.JPanel ();
      parityPanel.setPreferredSize (new java.awt.Dimension(50, 50));
      parityPanel.setLayout (new javax.swing.BoxLayout (parityPanel, 1));

        pNoneRadioButton = new javax.swing.JRadioButton ();
        pNoneRadioButton.setSelected (true);
        pNoneRadioButton.setText ("None");
        pNoneRadioButton.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent evt) {
              pNoneRadioButtonActionPerformed (evt);
            }
          }
        );
        parityPanel.add (pNoneRadioButton);

        pEvenRadioButton = new javax.swing.JRadioButton ();
        pEvenRadioButton.setText ("Even");
        pEvenRadioButton.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent evt) {
              evenRadioButtonActionPerformed (evt);
            }
          }
        );
        parityPanel.add (pEvenRadioButton);

        pOddRadioButton = new javax.swing.JRadioButton ();
        pOddRadioButton.setText ("Odd");
        pOddRadioButton.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent evt) {
              oddRadioButtonActionPerformed (evt);
            }
          }
        );
        parityPanel.add (pOddRadioButton);

      connectPanel.add (parityPanel);

      sysTypeLabel = new javax.swing.JLabel ();
      sysTypeLabel.setText ("Remote:");
      connectPanel.add (sysTypeLabel);

      sysTypeComboBox = new javax.swing.JComboBox ();
      sysTypeComboBox.addActionListener (new java.awt.event.ActionListener () {
          public void actionPerformed (java.awt.event.ActionEvent evt) {
            sysTypeComboBoxActionPerformed (evt);
          }
        }
      );
      connectPanel.add (sysTypeComboBox);

      connectButton = new javax.swing.JButton ();
      connectButton.setText ("Connect");
      connectButton.addActionListener (new java.awt.event.ActionListener () {
          public void actionPerformed (java.awt.event.ActionEvent evt) {
            connectButtonActionPerformed (evt);
          }
        }
      );
      connectPanel.add (connectButton);

    getContentPane().add(connectPanel, BorderLayout.NORTH);

    xferPanel = new javax.swing.JPanel ();
    xferPanel.setLayout (new java.awt.FlowLayout ());

      xferPanelLabel = new javax.swing.JLabel ();
      xferPanelLabel.setText ("File Transfer");
      xferPanelLabel.setForeground (java.awt.Color.red);
      xferPanel.add (xferPanelLabel);

      jPanel6 = new javax.swing.JPanel ();
      jPanel6.setLayout (new javax.swing.BoxLayout (jPanel6, 1));

        sendRadioButton = new javax.swing.JRadioButton ();
        sendRadioButton.setSelected (true);
        sendRadioButton.setText ("Send");
        sendRadioButton.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent evt) {
              sendRadioButtonActionPerformed (evt);
            }
          }
        );
        jPanel6.add (sendRadioButton);

        recvRadioButton = new javax.swing.JRadioButton ();
        recvRadioButton.setText ("Receive");
        recvRadioButton.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent evt) {
              recvRadioButtonActionPerformed (evt);
            }
          }
        );
        jPanel6.add (recvRadioButton);

      xferPanel.add (jPanel6);

      xferFilenameLabel = new javax.swing.JLabel ();
      xferFilenameLabel.setText ("Filename:");
      xferPanel.add (xferFilenameLabel);

      xferFileNameTF = new javax.swing.JTextField ();
      xferFileNameTF.setPreferredSize (new java.awt.Dimension(100, 20));
      xferPanel.add (xferFileNameTF);

      jPanel7 = new javax.swing.JPanel ();
      jPanel7.setLayout (new javax.swing.BoxLayout (jPanel7, 1));

        xferModeTextRadioButton = new javax.swing.JRadioButton ();
        xferModeTextRadioButton.setText ("Text");
        jPanel7.add (xferModeTextRadioButton);

        xferModeBinRadioButton = new javax.swing.JRadioButton ();
        xferModeBinRadioButton.setSelected (true);
        xferModeBinRadioButton.setText ("Binary");
        jPanel7.add (xferModeBinRadioButton);

      xferPanel.add (jPanel7);

      xferButton = new javax.swing.JButton ();
      xferButton.setText ("Transfer");
      xferButton.addActionListener (new java.awt.event.ActionListener () {
          public void actionPerformed (java.awt.event.ActionEvent evt) {
            xferButtonActionPerformed (evt);
          }
        }
      );
      xferPanel.add (xferButton);

    getContentPane ().add (xferPanel, BorderLayout.SOUTH);

  }//GEN-END:initComponents

  /** Save the session log to disk.
   */
  private void saveLogFileMenuItemActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveLogFileMenuItemActionPerformed
    theModel.saveLogFile();
  }//GEN-LAST:event_saveLogFileMenuItemActionPerformed

  private void helpAboutMenuItemActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_helpAboutMenuItemActionPerformed
    note("JModem 0.0 (c) 2000 Ian F. Darwin\nhttp://www.darwinsys.com/");
  }//GEN-LAST:event_helpAboutMenuItemActionPerformed

  private void baudComboBoxActionPerformed (java.awt.event.ActionEvent evt) {
    // Add your handling code here:
  }

  private void portsComboBoxActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_portsComboBoxActionPerformed
    // Add your handling code here:
  }//GEN-LAST:event_portsComboBoxActionPerformed

  /** A TextArea subclass with funky keypress forwarding: send to
   * remote, not to local. This IS a terminal emulator, after all.
   */
  class MyTextArea extends JTextArea {
    MyTextArea(int r, int c) {
      super(r, c);
    }

    /** Handle local KeyEvents: send KeyTyped to the remote. */
    protected void processComponentKeyEvent(java.awt.event.KeyEvent evt) {
      if (evt.getID() != KeyEvent.KEY_TYPED)
        return;

      // send keystrokes to remote, for processing.
      // do nothing locally, to avoid user keystrokes appearing twice!
      if (theModel.state != JMModel.S_CONNECTED) {
        getToolkit().beep();  // or just connect()?
        return;
      }
      char ch = evt.getKeyChar();
      if (ch == '\n') {    // XX if systemtype == dos
        // sendChar('\r');
        theModel.sendChar('\n');
        return;
      }
      theModel.sendChar(ch);
    }
  }

  /** Finish the initializations. */
  private void finishConstructor() {
    // Create the textarea with a JScrollpane wrapping it.
    // Install it in Centre of the TextArea.
    theTextArea = new MyTextArea(20, 80);
    getContentPane().add(new JScrollPane(theTextArea), BorderLayout.CENTER);
    plainFont = new Font("courier", Font.PLAIN, 13);
    theTextArea.setFont(plainFont);
    xferFileNameTF.setFont(plainFont);

    theModel.populateComboBox();
    portsComboBox.setSelectedIndex(0);

    // Load up the baud rate combo box
    for (int i=0; i<baudot.length; i++) {
      baudComboBox.addItem(Integer.toString(baudot[i]));
    }
    baudComboBox.setSelectedIndex(0);

    // Load up the System Type combo box
    for (int i=0; i<sysTypes.length; i++) {
      sysTypeComboBox.addItem(sysTypes[i]);
    }
    sysTypeComboBox.setSelectedIndex(0);

    // put radio buttons into groups to enforce single-selection
    ButtonGroup b1 = new ButtonGroup();
    b1.add(d7RadioButton);
    b1.add(d8RadioButton);

    ButtonGroup b2 = new ButtonGroup();
    b2.add(pNoneRadioButton);
    b2.add(pEvenRadioButton);
    b2.add(pOddRadioButton);

    ButtonGroup b3 = new ButtonGroup();
    b3.add(sendRadioButton);
    b3.add(recvRadioButton);

    ButtonGroup b4 = new ButtonGroup();
    b4.add(xferModeTextRadioButton);
    b4.add(xferModeBinRadioButton);
    xferModeBinRadioButton.setEnabled(true);
  }

  private void recvRadioButtonActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_recvRadioButtonActionPerformed
    xferDirection = M_RECEIVE;
  }//GEN-LAST:event_recvRadioButtonActionPerformed

  private void sendRadioButtonActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sendRadioButtonActionPerformed
    xferDirection = M_SEND;
  }//GEN-LAST:event_sendRadioButtonActionPerformed

  private void exitMenuItemActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitMenuItemActionPerformed
    System.exit(0);
  }//GEN-LAST:event_exitMenuItemActionPerformed

  private void sysTypeComboBoxActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sysTypeComboBoxActionPerformed
    // Add your handling code here:
  }//GEN-LAST:event_sysTypeComboBoxActionPerformed

  private void pNoneRadioButtonActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pNoneRadioButtonActionPerformed
    // Add your handling code here:
  }//GEN-LAST:event_pNoneRadioButtonActionPerformed

  private void oddRadioButtonActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_oddRadioButtonActionPerformed
    // Add your handling code here:
  }//GEN-LAST:event_oddRadioButtonActionPerformed

  private void evenRadioButtonActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_evenRadioButtonActionPerformed
    // Add your handling code here:
  }//GEN-LAST:event_evenRadioButtonActionPerformed



  /** This method basically toggles between Connected mode and
   * disconnected mode.
   */
  private void connectButtonActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_connectButtonActionPerformed
    if (theModel.state == JMModel.S_CONNECTED) {
      theModel.disconnect();  // calls our disconnect() if OK
    } else {
      theModel.connect();    // calls our connect() if OK
    }
  }//GEN-LAST:event_connectButtonActionPerformed

  /** Show that we have connected to the serial port. */
  void connect() {
      connectButton.setText("Disconnect");
      theTextArea.setEditable(true);
      theTextArea.requestFocus();
  }

  /** Show that we have connected to the serial port. */
  void disconnect() {
      connectButton.setText("Connect");
      theTextArea.setEditable(false);
  }

  private void xferButtonActionPerformed (java.awt.event.ActionEvent evt) {//GEN-FIRST:event_xferButtonActionPerformed

    // Do the transfer, using TModem class.
    theModel.xfer();

  }//GEN-LAST:event_xferButtonActionPerformed

  /** Exit the Application */
  private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
    System.exit (0);
  }//GEN-LAST:event_exitForm


// Some of these must be package-level visibility for JMModel,
// until we re-define the interface to that class a little...
// Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JPanel connectPanel;
  private javax.swing.JPanel xferPanel;
  private javax.swing.JLabel connectPanelLabel;
  private javax.swing.JLabel portsLabel;
  protected javax.swing.JComboBox portsComboBox;
  private javax.swing.JLabel buadLabel;
  protected javax.swing.JComboBox baudComboBox;
  private javax.swing.JPanel databitsPanel;
  private javax.swing.JPanel parityPanel;
  private javax.swing.JLabel sysTypeLabel;
  private javax.swing.JComboBox sysTypeComboBox;
  private javax.swing.JButton connectButton;
  private javax.swing.JRadioButton d7RadioButton;
  private javax.swing.JRadioButton d8RadioButton;
  private javax.swing.JRadioButton pNoneRadioButton;
  private javax.swing.JRadioButton pEvenRadioButton;
  private javax.swing.JRadioButton pOddRadioButton;
  private javax.swing.JLabel xferPanelLabel;
  private javax.swing.JPanel jPanel6;
  private javax.swing.JLabel xferFilenameLabel;
  private javax.swing.JTextField xferFileNameTF;
  private javax.swing.JPanel jPanel7;
  private javax.swing.JButton xferButton;
  private javax.swing.JRadioButton sendRadioButton;
  private javax.swing.JRadioButton recvRadioButton;
  private javax.swing.JRadioButton xferModeTextRadioButton;
  private javax.swing.JRadioButton xferModeBinRadioButton;
  private javax.swing.JMenuBar jMenuBar1;
  private javax.swing.JMenu fileMenu;
  private javax.swing.JMenu helpMenu;
  private javax.swing.JMenuItem saveLogFileMenuItem;
  private javax.swing.JMenuItem exitMenuItem;
  private javax.swing.JMenuItem helpAboutMenuItem;
// End of variables declaration//GEN-END:variables

  /** Tell if the user wants 7 or 8-bit words */
  public int getDataBits() {
    if (d7RadioButton.isSelected())
      return 7;
    if (d8RadioButton.isSelected())
      return 8;
    throw new IllegalStateException("No word size in radio button group");
  }

  /** Tell if the user wants even, odd, or no parity. */
  public int getParity() {
    if (pNoneRadioButton.isSelected()) return JMModel.PARITY_NONE;
    if (pEvenRadioButton.isSelected()) return JMModel.PARITY_EVEN;
    if (pOddRadioButton.isSelected())  return JMModel.PARITY_ODD;
    throw new IllegalStateException("No parity in radio button group");
  }

  /** Get the filename */
  public String getXferFileName() {
    return xferFileNameTF.getText();
  }

  /** "One if by send, two if receive" */
  public boolean isSend() {
    if (sendRadioButton.isSelected())
      return true;
    if (recvRadioButton.isSelected())
      return false;
    throw new IllegalStateException("No send/recv set in radio button group");
  }

  /** Convenience routine: Show a standard-form information dialog */
  void note(String message) {
    JOptionPane.showMessageDialog(this, message,
      "JModem Notice", JOptionPane.INFORMATION_MESSAGE);
    return;
  }

  /** Convenience routine: Show a standard-form error dialog */
  void err(String message) {
    JOptionPane.showMessageDialog(this, message,
      "JModem Error", JOptionPane.ERROR_MESSAGE);
    return;
  }

  /** Main: just create and show the application class. */
  public static void main(java.lang.String[] args) {
    new JModem().setVisible(true);
  }
}
//@@@@@@//
//javacomm/ParallelPrint.java
//@@@@@@//
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

import javax.comm.NoSuchPortException;
import javax.comm.PortInUseException;
import javax.comm.UnsupportedCommOperationException;
import javax.swing.JFrame;

/**
 * Print to a serial port using Java Communications.
 *
 * @author	Ian F. Darwin, http://www.darwinsys.com/
  */
public class ParallelPrint extends CommPortOpen {

	protected static String inputFileName;

	public static void main(String[] argv)
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {

		if (argv.length != 1) {
			System.err.println("Usage: ParallelPrint filename");
			System.exit(1);
		}
		inputFileName = argv[0];

		new ParallelPrint(null).converse();

		System.exit(0);
	}

	/* Constructor */
	public ParallelPrint(JFrame f)
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {
		
		super(f);
	}

	/** 
	 * Hold the (one-way) conversation. 
	 */
	protected void converse() throws IOException {

		// Make a reader for the input file.
		BufferedReader file = new BufferedReader(
			new FileReader(inputFileName));

		String line;
		while ((line = file.readLine()) != null)
			os.println(line);

		// Finally, clean up.
		file.close();
		os.close();
	}
}
//@@@@@@//
//javacomm/PortChooser.java
//@@@@@@//
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.util.Enumeration;
import java.util.HashMap;

import javax.comm.CommPortIdentifier;
import javax.comm.SerialPort;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

/**
 * Choose a port, any port!
 *
 * Java Communications is a "standard extention" and must be downloaded
 * and installed separately from the JDK before you can even compile this 
 * program.
 *
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @version	$Id: PortChooser.java,v 1.9 2004/04/11 23:50:40 ian Exp $
 */
public class PortChooser extends JDialog implements ItemListener {
	/** A mapping from names to CommPortIdentifiers. */
	protected HashMap map = new HashMap();
	/** The name of the choice the user made. */
	protected String selectedPortName;
	/** The CommPortIdentifier the user chose. */
	protected CommPortIdentifier selectedPortIdentifier;
	/** The JComboBox for serial ports */
	protected JComboBox serialPortsChoice;
	/** The JComboBox for parallel ports */
	protected JComboBox parallelPortsChoice;
	/** The JComboBox for anything else */
	protected JComboBox other;
	/** The SerialPort object */
	protected SerialPort ttya;
	/** To display the chosen */
	protected JLabel choice;
	/** Padding in the GUI */
	protected final int PAD = 5;

	/** This will be called from either of the JComboBoxen when the
	 * user selects any given item.
	 */
	public void itemStateChanged(ItemEvent e) {
		// Get the name
		selectedPortName = (String)((JComboBox)e.getSource()).getSelectedItem();
		// Get the given CommPortIdentifier
		selectedPortIdentifier = (CommPortIdentifier)map.get(selectedPortName);
		// Display the name.
		choice.setText(selectedPortName);
	}

	/* The public "getter" to retrieve the chosen port by name. */
	public String getSelectedName() {
		return selectedPortName;
	}

	/* The public "getter" to retrieve the selection by CommPortIdentifier. */
	public CommPortIdentifier getSelectedIdentifier() {
		return selectedPortIdentifier;
	}

	/** A test program to show up this chooser. */
	public static void main(String[] ap) {
		PortChooser c = new PortChooser(null);
		c.setVisible(true);	// blocking wait
		System.out.println("You chose " + c.getSelectedName() +
			" (known by " + c.getSelectedIdentifier() + ").");
		System.exit(0);
	}

	/** Construct a PortChooser --make the GUI and populate the ComboBoxes.
	 */
	public PortChooser(JFrame parent) {
		super(parent, "Port Chooser", true);

		makeGUI();
		populate();
		finishGUI();
	}

	/** Build the GUI. You can ignore this for now if you have not
	 * yet worked through the GUI chapter. Your mileage may vary.
	 */
	protected void makeGUI() {
		Container cp = getContentPane();

		JPanel centerPanel = new JPanel();
		cp.add(BorderLayout.CENTER, centerPanel);

		centerPanel.setLayout(new GridLayout(0,2, PAD, PAD));

		centerPanel.add(new JLabel("Serial Ports", JLabel.RIGHT));
		serialPortsChoice = new JComboBox();
		centerPanel.add(serialPortsChoice);
		serialPortsChoice.setEnabled(false);

		centerPanel.add(new JLabel("Parallel Ports", JLabel.RIGHT));
		parallelPortsChoice = new JComboBox();
		centerPanel.add(parallelPortsChoice);
		parallelPortsChoice.setEnabled(false);

		centerPanel.add(new JLabel("Unknown Ports", JLabel.RIGHT));
		other = new JComboBox();
		centerPanel.add(other);
		other.setEnabled(false);

		centerPanel.add(new JLabel("Your choice:", JLabel.RIGHT));
		centerPanel.add(choice = new JLabel());

		JButton okButton;
		cp.add(BorderLayout.SOUTH, okButton = new JButton("OK"));
		okButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				PortChooser.this.dispose();
			}
		});

	}

	/** Populate the ComboBoxes by asking the Java Communications API
	 * what ports it has.  Since the initial information comes from
	 * a Properties file, it may not exactly reflect your hardware.
	 */
	protected void populate() {
		// get list of ports available on this particular computer,
		// by calling static method in CommPortIdentifier.
		Enumeration pList = CommPortIdentifier.getPortIdentifiers();

		// Process the list, putting serial and parallel into ComboBoxes
		while (pList.hasMoreElements()) {
			CommPortIdentifier cpi = (CommPortIdentifier)pList.nextElement();
			// System.out.println("Port " + cpi.getName());
			map.put(cpi.getName(), cpi);
			if (cpi.getPortType() == CommPortIdentifier.PORT_SERIAL) {
				serialPortsChoice.setEnabled(true);
				serialPortsChoice.addItem(cpi.getName());
			} else if (cpi.getPortType() == CommPortIdentifier.PORT_PARALLEL) {
				parallelPortsChoice.setEnabled(true);
				parallelPortsChoice.addItem(cpi.getName());
			} else {
				other.setEnabled(true);
				other.addItem(cpi.getName());
			}
		}
		serialPortsChoice.setSelectedIndex(-1);
		parallelPortsChoice.setSelectedIndex(-1);
	}

	protected void finishGUI() {
		serialPortsChoice.addItemListener(this);
		parallelPortsChoice.addItemListener(this);
		other.addItemListener(this);
		pack();
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}
}
//@@@@@@//
//javacomm/PortOwner.java
//@@@@@@//
import javax.comm.*;
import java.io.*;
import javax.swing.*;

/** Demonstrate the port conflict resolution mechanism.
 * Run two copies of this program and choose the same port in each.
 * $Id: PortOwner.java,v 1.1 2000/02/27 03:45:34 ian Exp $
 */
public class PortOwner extends CommPortOpen {
	/** A name for showing which of several instances of this program */
	String myName;

	public PortOwner(String name)
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {

		super(null);
		myName = name;
		thePortID.addPortOwnershipListener(new MyResolver());
	}

	public void converse() {
		// lah de dah...
		// To simulate a long conversation on the port...
		
		try {
			Thread.sleep(1000 * 1000);
		} catch (InterruptedException cantHappen) {
			//
		}
	}

	/** An inner class that handles the ports conflict resolution. */
	class MyResolver implements CommPortOwnershipListener {
		protected boolean owned = false;
		public void ownershipChange(int whaHoppen) {
			switch (whaHoppen) {
			case PORT_OWNED:
				System.out.println("An open succeeded.");
				owned = true;
				break;
			case PORT_UNOWNED:
				System.out.println("A close succeeded.");
				owned = false;
				break;
			case PORT_OWNERSHIP_REQUESTED: 
				if (owned) {
					if (JOptionPane.showConfirmDialog(null,
						"I've been asked to give up the port, should I?",
						"Port Conflict (" + myName + ")",
						JOptionPane.OK_CANCEL_OPTION) == 0)
					thePort.close();
				} else {
					System.out.println("Somebody else has the port");
				}
			}
		}
	}

	public static void main(String[] argv)
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {

		if (argv.length != 1) {
			System.err.println("Usage: PortOwner aname");
			System.exit(1);
		}
			
		new PortOwner(argv[0]).converse();

		System.exit(0);
	}
}
//@@@@@@//
//javacomm/ProtocolBotchException.java
//@@@@@@//
/** An unchecked exception to indicate a protocol failure. */
public class ProtocolBotchException extends RuntimeException {
	ProtocolBotchException() {
		super();
	}
	ProtocolBotchException(String message) {
		super(message);
	}
}
//@@@@@@//
//javacomm/SerialLogger.java
//@@@@@@//
import java.io.*;
import javax.comm.*;
import java.util.*;

/**
 * Read from multiple Serial ports, notifying when data arrives on any.
 * @version $Id: SerialLogger.java,v 1.4 2004/03/11 04:09:14 ian Exp $
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 */
public class SerialLogger {

	public static void main(String[] argv)
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {

		new SerialLogger();
	}

	/* Constructor */
	public SerialLogger()
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {
		
		// get list of ports available on this particular computer,
		// by calling static method in CommPortIdentifier.
		Enumeration pList = CommPortIdentifier.getPortIdentifiers();

		// Process the list, processing only serial ports.
		while (pList.hasMoreElements()) {
			CommPortIdentifier cpi = (CommPortIdentifier)pList.nextElement();
			String name = cpi.getName();
			System.out.print("Port " + name + " ");
			if (cpi.getPortType() == CommPortIdentifier.PORT_SERIAL) {
				System.out.println("is a Serial Port: " + cpi);

				SerialPort thePort;
				try {
					thePort = (SerialPort)cpi.open("Logger", 1000);
				} catch (PortInUseException ev) {
					System.err.println("Port in use: " + name);
					continue;
				}

				// Tell the Comm API that we want serial events.
				thePort.notifyOnDataAvailable(true);
				try {
					thePort.addEventListener(new Logger(cpi.getName(), thePort));
				} catch (TooManyListenersException ev) {
					// "CantHappen" error
					System.err.println("Too many listeners(!) " + ev);
					System.exit(0);
				}
			}
		}
	}

	/** Handle one port. */
	public class Logger implements SerialPortEventListener { 
		String portName;
		SerialPort thePort;
		BufferedReader ifile;
		public Logger(String name, SerialPort port) throws IOException {
			portName = name;
			thePort = port;
			// Make a reader for the input file.
			ifile = new BufferedReader(
				new InputStreamReader(thePort.getInputStream()));
		}
		public void serialEvent(SerialPortEvent ev) {
			String line;
			try {
				line = ifile.readLine();
				if (line == null) {
					System.out.println("EOF on serial port.");
					System.exit(0);
				}
				System.out.println(portName + ": " + line);
			} catch (IOException ex) {
				System.err.println("IO Error " + ex);
			}
		}
	}
}
//@@@@@@//
//javacomm/SerialReadByEvents.java
//@@@@@@//
import java.io.IOException;
import java.util.TooManyListenersException;

import javax.comm.NoSuchPortException;
import javax.comm.PortInUseException;
import javax.comm.SerialPort;
import javax.comm.SerialPortEvent;
import javax.comm.SerialPortEventListener;
import javax.comm.UnsupportedCommOperationException;
import javax.swing.JFrame;

/**
 * Read from a Serial port, notifying when data arrives.
 * Simulation of part of an event-logging service.
 * @version $Id: SerialReadByEvents.java,v 1.4 2004/04/11 23:50:40 ian Exp $
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 */
public class SerialReadByEvents extends CommPortOpen 
	implements SerialPortEventListener {

	public static void main(String[] argv)
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {

		new SerialReadByEvents(null).converse();
	}

	/* Constructor */
	public SerialReadByEvents(JFrame f)
		throws IOException, NoSuchPortException, PortInUseException,
			UnsupportedCommOperationException {
		
		super(f);
	}

	/** 
	 * Hold the conversation. 
	 */
	protected void converse() throws IOException {

		if (!(thePort instanceof SerialPort)) {
			System.err.println("But I wanted a SERIAL port!");
			System.exit(1);
		}
		// Tell the Comm API that we want serial events.
		((SerialPort)thePort).notifyOnDataAvailable(true);
		try {
			((SerialPort)thePort).addEventListener(this);
		} catch (TooManyListenersException ev) {
			// "CantHappen" error
			System.err.println("Too many listeners(!) " + ev);
			System.exit(0);
		}
	
		
	}
	public void serialEvent(SerialPortEvent ev) {
		String line;
		try {
			line = is.readLine();
			if (line == null) {
				System.out.println("EOF on serial port.");
				System.exit(0);
			}
			os.println(line);
		} catch (IOException ex) {
			System.err.println("IO Error " + ex);
		}
	}
}
//@@@@@@//
//javacomm/TModem.java
//@@@@@@//
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;

/**
 * a tiny version of Ward Christensen's MODEM program for UNIX. 
 * Written ~ 1980 by Andrew Scott Beals. Last revised 1982.
 * A.D. 2000 - dragged from the archives for use in Java Cookbook.
 *
 * @author C version by Andrew Scott Beals, sjobrg.andy%mit-oz@mit-mc.arpa.
 * @author Java version by Ian F. Darwin, http://www.darwinsys.com/
 * $Id: TModem.java,v 1.10 2004/04/11 23:50:40 ian Exp $
 */
public class TModem {

	protected final byte CPMEOF = 26;		/* control/z */
	protected final int MAXERRORS = 10;		/* max times to retry one block */
	protected final int SECSIZE	= 128;		/* cpm sector, transmission block */
	protected final int SENTIMOUT = 30;		/* timeout time in send */
	protected final int	SLEEP	= 30;		/* timeout time in recv */

	/* Protocol characters used */

	protected final byte	SOH	= 1;	/* Start Of Header */
	protected final byte	EOT	= 4;	/* End Of Transmission */
	protected final byte	ACK	= 6;	/* ACKnowlege */
	protected final byte	NAK	= 0x15;	/* Negative AcKnowlege */

	protected InputStream inStream;
	protected OutputStream outStream;
	protected PrintWriter errStream;

	/** Construct a TModem */
	public TModem(InputStream is, OutputStream os, PrintWriter errs) {
		inStream = is;
		outStream = os;
		errStream = errs;
	}

	/** Construct a TModem with default files (stdin and stdout). */
	public TModem() {
		inStream = System.in;
		outStream = System.out;
		errStream = new PrintWriter(System.err);
	}

	/** A main program, for direct invocation. */
	public static void main(String[] argv) throws 
		IOException, InterruptedException {

		/* argc must == 2, i.e., `java TModem -s filename' */
		if (argv.length != 2) 
			usage();

		if (argv[0].charAt(0) != '-')
			usage();

		TModem tm = new TModem();
		tm.setStandalone(true);

		boolean OK = false;
		switch (argv[0].charAt(1)){
		case 'r': 
			OK = tm.receive(argv[1]); 
			break;
		case 's': 
			OK = tm.send(argv[1]); 
			break;
		default: 
			usage();
		}
		System.out.print(OK?"Done OK":"Failed");
		System.exit(0);
	}

	/* give user minimal usage message */
	protected static void usage()
	{
		System.err.println("usage: TModem -r/-s file");
		// not errStream, not die(), since this is static.
		System.exit(1);
	}

	/** If we're in a standalone app it is OK to System.exit() */
	protected boolean standalone = false;
	public void setStandalone(boolean is) {
		standalone = is;
	}
	public boolean isStandalone() {
		return standalone;
	}

	/** A flag used to communicate with inner class IOTimer */
	protected boolean gotChar;

	/** An inner class to provide a read timeout for alarms. */
	class IOTimer extends Thread {
		String message;
		long milliseconds;

		/** Construct an IO Timer */
		IOTimer(long sec, String mesg) {
			milliseconds = 1000 * sec;
			message = mesg;
		}
		
		public void run() {
	      try {
		    Thread.sleep(milliseconds);
		  } catch (InterruptedException e) {
		  	// can't happen
		  }
		  /** Implement the timer */
		  if (!gotChar)
			errStream.println("Timed out waiting for " + message);
			die(1);
		}
	}

	/*
	 * send a file to the remote
	 */
	public boolean send(String tfile) throws IOException, InterruptedException
	{
		char checksum, index, blocknumber, errorcount;
		byte character;
		byte[] sector = new byte[SECSIZE];
		int nbytes;
		DataInputStream foo;

		foo = new DataInputStream(new FileInputStream(tfile));
		errStream.println( "file open, ready to send");
		errorcount = 0;
		blocknumber = 1;

		// The C version uses "alarm()", a UNIX-only system call,
		// to detect if the read times out. Here we do detect it
		// by using a Thread, the IOTimer class defined above.
		gotChar = false;
		new IOTimer(SENTIMOUT, "NAK to start send").start();

		do {
			character = getchar();
			gotChar = true;
			if (character != NAK && errorcount < MAXERRORS)
				++errorcount;
		} while (character != NAK && errorcount < MAXERRORS);

		errStream.println( "transmission beginning");
		if (errorcount == MAXERRORS) {
			xerror();
		}

		while ((nbytes=inStream.read(sector))!=0) {
			if (nbytes<SECSIZE)
				sector[nbytes]=CPMEOF;
			errorcount = 0;
			while (errorcount < MAXERRORS) {
				errStream.println( "{" + blocknumber + "} ");
				putchar(SOH);	/* here is our header */
				putchar(blocknumber);	/* the block number */
				putchar(~blocknumber);	/* & its complement */
				checksum = 0;
				for (index = 0; index < SECSIZE; index++) {
					putchar(sector[index]);
					checksum += sector[index];
				}
				putchar(checksum);	/* tell our checksum */
				if (getchar() != ACK)
					++errorcount;
				else
					break;
			}
			if (errorcount == MAXERRORS)
				xerror();
			++blocknumber;
		}
		boolean isAck = false;
		while (!isAck) {
			putchar(EOT);
			isAck = getchar() == ACK;
		}
		errStream.println( "Transmission complete.");
		return true;
	}

	/*
	 * receive a file from the remote
	 */
	public boolean receive(String tfile) throws IOException, InterruptedException
	{
		char checksum, index, blocknumber, errorcount;
		byte character;
		byte[] sector = new byte[SECSIZE];
		DataOutputStream foo;

		foo = new DataOutputStream(new FileOutputStream(tfile));

		System.out.println("you have " + SLEEP + " seconds...");

		/* wait for the user or remote to get his act together */
		gotChar = false;
		new IOTimer(SLEEP, "receive from remote").start(); 

		errStream.println("Starting receive...");
		putchar(NAK);
		errorcount = 0;
		blocknumber = 1;
		rxLoop:
		do { 
			character = getchar();
			gotChar = true;
			if (character != EOT) {
				try {
					byte not_ch;
					if (character != SOH) {
						errStream.println( "Not SOH");
						if (++errorcount < MAXERRORS)
							continue rxLoop;
						else
							xerror();
					}
					character = getchar();
					not_ch = (byte)(~getchar());
					errStream.println( "[" +  character + "] ");
					if (character != not_ch) {
						errStream.println( "Blockcounts not ~");
						++errorcount;
						continue rxLoop;
					}
					if (character != blocknumber) {
						errStream.println( "Wrong blocknumber");
						++errorcount;
						continue rxLoop;
					}
					checksum = 0;
					for (index = 0; index < SECSIZE; index++) {
						sector[index] = getchar();
						checksum += sector[index];
					}
					if (checksum != getchar()) {
						errStream.println( "Bad checksum");
						errorcount++;
						continue rxLoop;
					}
					putchar(ACK);
					blocknumber++;
					try {
						foo.write(sector);
					} catch (IOException e) {
						errStream.println("write failed, blocknumber " + blocknumber);
					}
				} finally {
				if (errorcount != 0)
					putchar(NAK);
			}
		}
		} while (character != EOT);

		foo.close();

		putchar(ACK);	/* tell the other end we accepted his EOT 	*/
		putchar(ACK);
		putchar(ACK);

		errStream.println("Receive Completed.");
		return true;
	}

	protected byte getchar() throws IOException {
		return (byte)inStream.read();
	}

	protected void putchar(int c) throws IOException {
		outStream.write(c);
	}

	protected void xerror()
	{
		errStream.println("too many errors...aborting");
		die(1);
	}

	protected void die(int how)
	{
		if (standalone)
			System.exit(how);
		else throw new ProtocolBotchException("Error code " + how);
	}
}
//@@@@@@//
//JDBC/CachedRowSetDemo.java
//@@@@@@//
import javax.sql.rowset.CachedRowSet;

/** Demonstrate simple use of the CachedRowSet.
 * The RowSet family of interfaces is in JDK1.5, but the Implementation
 * classes are (as of Beta 1) still in the unsupported "com.sun" package.
 */
public class CachedRowSetDemo {
	public static final String ROWSET_IMPL_CLASS = "com.sun.rowset.CachedRowSetImpl";
	public static void main(String[] args) throws Exception {
		CachedRowSet rs;

		// Create the class with class.forName to avoid importing
		// from the unsupported com.sun packages.
		Class c = Class.forName(ROWSET_IMPL_CLASS);
		rs = (CachedRowSet)c.newInstance();

		rs.setUrl("jdbc:postgresql:tmclub");
		rs.setUsername("ian");
		rs.setPassword("secret");

		rs.setCommand("select * from members where name like ?");
		rs.setString(1, "I%");

		// This will cause the RowSet to connect, fetch its data, and
		// disconnect
		rs.execute();

		// Some time later, the client tries to do something.

		// Suppose we want to update data:
		while (rs.next()) {
			if (rs.getInt("id") == 42) {
				rs.setString(1, "Marvin");
				rs.updateRow();	// Normal JDBC

				// This additional call tells the CachedRowSet to connect
				// to its database and send the updated data back.
				rs.acceptChanges();
			}
		}
	
		// If we're all done...
		rs.close();
	}
}
//@@@@@@//
//JDBC/Connect.java
//@@@@@@//
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.SQLWarning;

/** Test of loading a driver and connecting to a database.
 * The URL assumes you have the M$ Example "Companies" database
 * configured as a System DSN (or user DSN for your user) in the
 * ODBC control panel.
 */
public class Connect {

	public static void main(String[] av) {
		String dbURL = "jdbc:odbc:Companies";
	    try {
			// Load the jdbc-odbc bridge driver
			Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");

			// Enable logging
			DriverManager.setLogWriter(new PrintWriter((System.err)));

			System.out.println("Getting Connection");
			Connection conn = 
				DriverManager.getConnection(dbURL, "ian", "");	// user, passwd

			// If a SQLWarning object is available, print its
			// warning(s).  There may be multiple warnings chained.

			SQLWarning warn = conn.getWarnings();
			while (warn != null) {
				System.out.println("SQLState: " + warn.getSQLState());
				System.out.println("Message:  " + warn.getMessage());
				System.out.println("Vendor:   " + warn.getErrorCode());
				System.out.println("");
				warn = warn.getNextWarning();
		    }

			// Do something with the connection here...

			conn.close();	// All done with that DB connection

	    } catch (ClassNotFoundException e) {
			System.out.println("Can't load driver " + e);
	    } catch (SQLException e) {
			System.out.println("Database access failed " + e);
	    }
	}
}
//@@@@@@//
//JDBC/datasource/DarwinsDataDelivery.java
//@@@@@@//
import java.sql.Connection;

import javax.naming.InitialContext;
import javax.sql.DataSource;

public class DarwinsDataDelivery {
	public static void main(String[] argv)  throws Exception {
		String driver = "oracle.jdbc.driver.OracleDriver";
		String dbURL = "jdbc:oracle:thin:@server:1521:db570";
		DataSource ds = new DarwinsDataSource(driver, dbURL);
		// Test it out...
		Connection conn = ds.getConnection("student", "student");
		// System.out.println("Connection = " + conn);
		// conn.close();

		// Bind it into JNDI
		System.getProperties().setProperty("java.naming.factory.initial",
			"com.sun.jndi.rmi.registry.RegistryContextFactory");
		System.getProperties().setProperty("java.naming.provider.url",
			"rmi://localhost/");
		new InitialContext().rebind("darwinsys/RainData", ds);
	}
}//@@@@@@//
//JDBC/datasource/DarwinsDataLookup.java
//@@@@@@//
// import com.darwinsys.sql.*;

import java.sql.*;
import javax.sql.*;
import javax.naming.*;

public class DarwinsDataLookup {
	public static void main(String[] argv)  throws Exception {

		// Find DataSource from JNDI
		System.getProperties().setProperty("java.naming.factory.initial",
			"com.sun.jndi.rmi.registry.RegistryContextFactory");
		System.getProperties().setProperty("java.naming.provider.url",
			"rmi://localhost/");
		DataSource ds =
			(DataSource)new InitialContext().lookup("darwinsys/RainData");

		// Test it out...
		Connection conn = ds.getConnection("student", "student");
		System.out.println("Connection = " + conn);
		conn.close();
	}
}//@@@@@@//
//JDBC/datasource/DarwinsDataSource.java
//@@@@@@//
// package com.darwinsys.sql;

import java.sql.*;
import javax.sql.*;
import java.io.*;
import java.rmi.*;

/** A simple DataSource wrapper for a JDBC connection.
 * Constructed using a drivername and dbURL
 * @version $Id: DarwinsDataSource.java,v 1.3 2003/06/22 23:19:09 ian Exp $
 */
public class DarwinsDataSource implements DataSource, Remote, Serializable {

	/** The SQL driver name. 
	  */
	protected String driverName;

	/** The Database URL */
	protected String dbURL;

	/** The LogWriter - not the same as DriverManager.getLogWriter */
	protected PrintWriter logWriter = new PrintWriter(System.out);

	public DarwinsDataSource(String driverName, String dbURL)
	 {
		this.driverName = driverName;
		this.dbURL = dbURL;
	}

	/** Attempt to establish a database connection using defaults. */
	public java.sql.Connection getConnection() throws java.sql.SQLException {
		return getConnection(null, null);
	}

	/** Attempt to establish a database connection using the given
	 * username and password as credentials.
	 */
	public java.sql.Connection getConnection(String userName, String passWord)
	throws java.sql.SQLException {

		try {
			Class.forName(driverName);
		} catch (ClassNotFoundException e) {
			System.err.println("Can't load driver; check CLASSPATH!");
			return null;
		} catch (Exception ex) {
			System.err.println("Can't load driver: " + ex);
			return null;
		}
	
		Connection c = DriverManager.getConnection(dbURL, userName, passWord);

		return c;
	}

	/** Set the log writer for this data source. */
	public void setLogWriter(PrintWriter out) {
		logWriter = out;
	}

	/** Get the log writer for this data source. */
	public PrintWriter getLogWriter() {
		return logWriter;
	}

	/** Sets the maximum time in seconds that this data source will wait
	 * while attempting to connect to a database.
	 */
	public void setLoginTimeout(int seconds) {
		DriverManager.setLoginTimeout(seconds);
	}

	/** Gets the maximum time in seconds that this data source can wait
	 * while attempting to connect to the database.
	 */
	public int getLoginTimeout() {
		return DriverManager.getLoginTimeout();
	}
}
//@@@@@@//
//JDBC/InsertRowBug.java
//@@@@@@//
import java.sql.*;

public class InsertRowBug {
    public static void main(String args[]) {

        String url;
        // url = "jdbc:odbc:SQL Anywhere 5.0 Sample";
        // url = "jdbc:oracle:thin:@server:1521:db570";
        url = "jdbc:odbc:RainForestDSN";

        String driver;
        //driver = "oracle.jdbc.driver.OracleDriver";
        driver = "sun.jdbc.odbc.JdbcOdbcDriver";

		String user, pass;
		user = "student";
		pass = "student";

        Connection con;
        Statement stmt;
		ResultSet uprs;

        try {
        		 Class.forName(driver);

        } catch(java.lang.ClassNotFoundException e) {
            System.err.println(e);
			return;
        }

        try {
            con = DriverManager.getConnection(url, user, pass);
			stmt = con.createStatement(
			ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
			uprs = stmt.executeQuery("SELECT * FROM Music_Recordings");

			// Check the column count 
			ResultSetMetaData md = uprs.getMetaData();
			System.out.println("Resultset has " +
				md.getColumnCount() + " cols.");

			int rowNum = uprs.getRow();
			System.out.println("row1 " + rowNum);
			uprs.absolute(1);
			rowNum = uprs.getRow();
			System.out.println("row2 " + rowNum);
			uprs.next();
			uprs.moveToInsertRow();
			uprs.updateInt(1, 150);
			uprs.updateString(2, "Madonna");
			uprs.updateString(3, "Dummy");
			uprs.updateString(4, "Jazz");
			uprs.updateString(5, "Image");
			uprs.updateInt(6, 5);
			uprs.updateDouble(7, 5);
			uprs.updateInt(8, 15);
			uprs.insertRow();
			uprs.close();
			stmt.close();
            con.close();
        } catch(SQLException ex) {
            System.err.println("SQLException: " + ex.getMessage());
        }
	}
}
//@@@@@@//
//JDBC/JDBCMeta.java
//@@@@@@//
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.SQLException;

import com.darwinsys.util.FileProperties;

/** A database MetaData query
 * @version $Id: JDBCMeta.java,v 1.7 2004/03/09 04:27:42 ian Exp $
 */
public class JDBCMeta {

	public static void main(String[] av) {
		int i;
		try {
			FileProperties fp = new FileProperties("JDBCMeta.properties");

			// Load the driver
			Class.forName(fp.getProperty("driver"));

			// Get the connection
			Connection conn = DriverManager.getConnection (
				fp.getProperty("dburl"),
				fp.getProperty("user"),
				fp.getProperty("password"));

			// Get a Database MetaData as a way of interrogating 
			// the names of the tables in this database.
			DatabaseMetaData meta = conn.getMetaData();

			System.out.println("We are using " + meta.getDatabaseProductName());
			System.out.println("Version is " + meta.getDatabaseProductVersion() );
        
			int txisolation = meta.getDefaultTransactionIsolation();
            System.out.println("Database default transaction isolation is " + 
				txisolation + " (" +
				transactionIsolationToString(txisolation) + ").");

			conn.close();

			System.out.println("All done!");

		} catch (java.io.IOException e) {
			System.out.println("Can't load PROPERTIES " + e);
		} catch (ClassNotFoundException e) {
			System.out.println("Can't load driver " + e);
		} catch (SQLException ex) {
			System.out.println("Database access failed:");
			System.out.println(ex);
		}
	}

	/** Convert a TransactionIsolation int (defined in java.sql.Connection)
	 * to the corresponding printable string.
	 */
	public static String transactionIsolationToString(int txisolation) {
		switch(txisolation) {
			case Connection.TRANSACTION_NONE: 
				// transactions not supported.
				return "TRANSACTION_NONE";
			case Connection.TRANSACTION_READ_UNCOMMITTED: 
				// All three phenomena can occur
				return "TRANSACTION_NONE";
			case Connection.TRANSACTION_READ_COMMITTED: 
			// Dirty reads are prevented; non-repeatable reads and 
			// phantom reads can occur.
				return "TRANSACTION_READ_COMMITTED";
			case Connection.TRANSACTION_REPEATABLE_READ: 
				// Dirty reads and non-repeatable reads are prevented;
				// phantom reads can occur.
				return "TRANSACTION_REPEATABLE_READ";
			case Connection.TRANSACTION_SERIALIZABLE:
				// All three phenomena prvented; slowest!
				return "TRANSACTION_SERIALIZABLE";
			default:
				throw new IllegalArgumentException(
					txisolation + " not a valid TX_ISOLATION");
		}
	}
}
//@@@@@@//
//JDBC/JDBCQuery.java
//@@@@@@//
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

/** A trivial example of a database query performed with JDBC. The database 
 * being queried only exists locally on Windows'95; it the MS Access 
 * "Video Database" sample database. Note that you must select this as 
 * "System DSN" under the name "Video.Collection" (On '95 you
 * do this from Settings->Control Panel->32Bit ODBC->System DSN)
 * for this particular configuration of the demo to work.
 * Other than this (see the URL below), the demo would work on
 * any platform (UNIX, MS, Mac, Novell, etc.).
 *
 * We simply get a JDBC connection to the local Database server via ODBC,
 * create a Statement from that, and a ResultSet with its Query set
 * to a selection of three items from a database table, and print the
 * results in a while loop as they come in from the database.
 */
public class JDBCQuery {

	public static void main(String[] av) {
	    try {
			System.out.println("Loading Driver (with Class.forName)");
			// Load the jdbc-odbc bridge driver
			Class.forName ("sun.jdbc.odbc.JdbcOdbcDriver");

			// Enable logging
			// DriverManager.setLogStream(System.err);

			System.out.println("Getting Connection");
			Connection conn = DriverManager.getConnection (
				"jdbc:odbc:Companies",
				"ian", "");	// user, passwd

			// Any warnings generated by the connect?
			checkForWarning(conn.getWarnings());

			System.out.println("Creating Statement");
			Statement stmt = conn.createStatement();

			System.out.println("Executing Query");
			ResultSet rs = stmt.executeQuery("SELECT * FROM Companies");

			System.out.println("Retrieving Results");
			int i = 0;
			while (rs.next()) {

				System.out.println("Retrieving Company ID");
				int x = rs.getInt("CustNO");
				System.out.println("Retrieving Name");
				String s = rs.getString("Company");

				System.out.println("ROW " + ++i + ": " +
					x + "; " + s + "; " + ".");

			}

			rs.close();		// All done with that resultset
			stmt.close();	// All done with that statement
			conn.close();	// All done with that DB connection

	    } catch (ClassNotFoundException e) {
			System.out.println("Can't load driver " + e);
	    } catch (SQLException e) {
			System.out.println("Database access failed " + e);
	    }
	}

	// Format and print any warnings from the connection
	private static void checkForWarning(SQLWarning warn) throws SQLException  {

	     // If a SQLWarning object was given, display the
	     // warning messages.  Note that there could be
	     // multiple warnings chained together

	     if (warn != null) {
		     System.out.println("*** Warning ***\n");
		     while (warn != null) {
			     System.out.println("SQLState: " +
				     warn.getSQLState());
			     System.out.println("Message:  " +
				     warn.getMessage());
			     System.out.println("Vendor:   " +
				     warn.getErrorCode());
			     System.out.println("");
			     warn = warn.getNextWarning();
		     }
	     }
     }
}
//@@@@@@//
//JDBC/ListTables.java
//@@@@@@//
/**
 * List the Tables in an SQL database
 */

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;

import com.darwinsys.sql.ConnectionUtil;

public class ListTables {
	public static void main(String[] args) throws SQLException {
		String config = args[0];
		Connection c = ConnectionUtil.getConnection(config);
		DatabaseMetaData md = c.getMetaData();
		ResultSet rs = md.getTables(null, null, "%", null);
		while (rs.next()) {
			System.out.println(rs.getString(3));
		}
	}
}
//@@@@@@//
//JDBC/LoadDriver.java
//@@@@@@//
/** 
 * Load some drivers.
 */
public class LoadDriver {
	public static void main(String[] av) {
		try {
			// Try to load the jdbc-odbc bridge driver
			// Should be present on Sun JDK implementations.
			Class c = Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
			System.out.println("Loaded " + c.getName());
			// Try to load an Oracle driver.
			Class d = Class.forName("oracle.jdbc.driver.OracleDriver");
			System.out.println("Loaded " + d.getName());
		} catch (ClassNotFoundException ex) {
			System.err.println(ex);
		}
	}
}
//@@@@@@//
//JDBC/RawSQLServlet.java
//@@@@@@//
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/** Process a raw SQL query; use ResultSetMetaData to format it.
 */
public class RawSQLServlet extends HttpServlet {

	/** The application-wide servlet context */
	protected ServletContext application;

	/** The DB connection object */
	protected Connection conn;

	/** The JDBC statement object */
	protected Statement stmt;

	/** Initialize the servlet. */
	public void init() throws ServletException {
		application = getServletConfig().getServletContext();
		String driver = null;
		try {

			driver = application.getInitParameter("db.driver");
			Class.forName(driver);

			// Get the connection
			log(getClass() + ": Getting Connection");
			Connection conn = DriverManager.getConnection (
				application.getInitParameter("db.url"),
				application.getInitParameter("db.user"),
				application.getInitParameter("db.password"));


			log(getClass() + ": Creating Statement");
			stmt = conn.createStatement();
		} catch (ClassNotFoundException ex) {
			log(getClass() + ": init: Could not load SQL driver " + driver);
		} catch (SQLException ex) {
			log(getClass() + ": init: SQL Error: " + ex);
		}
	}

	/** Do the SQL query */
	public void doPost(HttpServletRequest request,
		HttpServletResponse response) throws ServletException, IOException {

		String query = request.getParameter("sql");

		response.setContentType("text/html");
		PrintWriter out = response.getWriter();

		if (query == null) {
			out.println("<b>Error: malformed query, contact administrator</b>");
			return;
		}

		// NB MUST also check for admin privs before proceding!

		try {	// SQL
			out.println("<p>Your query: <b>" + query + "</b></p>");
			stmt.execute(query);
			ResultSet rs = stmt.getResultSet();
			if (rs == null) {
				// print updatecount
				out.println("<p>Result: updateCount = <b>" + 
					stmt.getUpdateCount() + "</p>");
			} else {
				// process resultset

				out.println("<br>Your response:");

				ResultSetMetaData md = rs.getMetaData();
				int count = md.getColumnCount();
				out.println("<table border=1>");
				out.print("<tr>");
				for (int i=1; i<=count; i++) {
					out.print("<th>");
					out.print(md.getColumnName(i));
				}
				out.println("</tr>");
				while (rs.next()) {
					out.print("<tr>");
					for (int i=1; i<=count; i++) {
						out.print("<td>");
					out.print(rs.getString(i));
				}
				out.println("</tr>");
				}
			}
			out.println("</table>");
			// rs.close();
		} catch (SQLException ex) {
			out.print("<B>" + getClass() + ": SQL Error:</B>\n" + ex);
			out.print("<pre>");
			ex.printStackTrace(out);
			out.print("</pre>");
		}
	}

	public void destroy() {
		try {
			conn.close();	// All done with that DB connection
		} catch (SQLException ex) {
			log(getClass() + ": destroy: " + ex);
		}
	}
}
//@@@@@@//
//JDBC/regress/ResultsDecoratorSQLTest.java
//@@@@@@//
package regress;
import javax.sql.rowset.WebRowSet;
import java.io.*;
import junit.framework.TestCase;

/**
 * ResultsDecoratorSQLTest
 * @version $Id: ResultsDecoratorSQLTest.java,v 1.1 2004/03/26 02:39:34 ian Exp $
 */
public class ResultsDecoratorSQLTest extends TestCase {
	protected static final String TEST_FILE = "rowdata.xml";
	
	protected WebRowSet testData;
	
	public static void main(String[] args) {
		//junit.textui.TestRunner.run(ResultsDecoratorSQLTest.suite());
	}

	/* (non-Javadoc)
	 * @see junit.framework.TestCase#setUp()
	 */
	protected void setUp() throws Exception {

		Reader r = new FileReader(TEST_FILE);
		testData.readXml(r);

	}
	/* (non-Javadoc)
	 * @see junit.framework.TestCase#tearDown()
	 */
	protected void tearDown() throws Exception {
		// TODO Auto-generated method stub
		super.tearDown();
	}
}
//@@@@@@//
//JDBC/ResultsDecorator.java
//@@@@@@//
import java.io.IOException;
import java.sql.ResultSet;
import java.sql.SQLException;

/** Base class for a series of ResultSet printers.
 * @version $Id: ResultsDecorator.java,v 1.2 2004/03/26 02:39:33 ian Exp $
 */
public abstract class ResultsDecorator {
	ResultsDecoratorPrinter parent;

	ResultsDecorator(ResultsDecoratorPrinter wr){
		this.parent = wr;
	}
	/** Print the name of this Decorator's output format */
	abstract String getName();
	
	/** Print the contents of a ResultSet */
	abstract void write(ResultSet rs) throws IOException, SQLException;
	
	/** Print the results of an operation as a Count */
	abstract void write(int rowCount) throws IOException;
	
	void println(String line) throws IOException {
		parent.println(line);
	}
	void println() throws IOException {
		parent.println();
	}
	void print(String lineSeg) throws IOException {
		parent.print(lineSeg);
	}
}//@@@@@@//
//JDBC/ResultsDecoratorHTML.java
//@@@@@@//
import java.io.IOException;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

/** Print ResultSet in HTML
 */
class ResultsDecoratorHTML extends ResultsDecorator {
	
	ResultsDecoratorHTML(ResultsDecoratorPrinter out) {
		super(out);
	}
	
	public void write(ResultSet rs) throws IOException, SQLException {

		ResultSetMetaData md = rs.getMetaData();
		int count = md.getColumnCount();
		println("<table border=1>");
		print("<tr>");
		for (int i=1; i<=count; i++) {
			print("<th>");
			print(md.getColumnLabel(i));
		}
		println("</tr>");
		while (rs.next()) {
			print("<tr>");
			for (int i=1; i<=count; i++) {
				print("<td>");
				print(rs.getString(i));
			}
			println("</tr>");
		}
		println("</table>");
	}

	/* (non-Javadoc)
	 * @see ResultSetDecorator#write(int)
	 */
	void write(int updateCount) throws IOException {
		println("<p>RowCount: updateCount = <b>" + 
					updateCount + "</p>");
	}

	/** Return a printable name for this decorator
	 * @see ResultsDecorator#getName()
	 */
	String getName() {
		return "HTML";
	}
}//@@@@@@//
//JDBC/ResultsDecoratorPrinter.java
//@@@@@@//
import java.io.IOException;
import java.io.PrintWriter;

/**
 * Callback so that ResultsDecorator can call invoker to handle redirections etc.
 * @version $Id: ResultsDecoratorPrinter.java,v 1.1 2004/03/26 02:39:33 ian Exp $
 */
public interface ResultsDecoratorPrinter {
	
	void print(String line) throws IOException;
	
	void println(String line) throws IOException;
	
	void println() throws IOException;
	
	PrintWriter getPrintWriter();
}
//@@@@@@//
//JDBC/ResultsDecoratorSQL.java
//@@@@@@//
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Types;
import java.io.*;
import java.sql.*;

/**
 * Print an SQL ResultSet in SQL-import format.
 * TODO: check all escaped characters needed! Test on PGSQL and DB2 at least...
 * @version $Id: ResultsDecoratorSQL.java,v 1.2 2004/03/26 02:39:33 ian Exp $
 */
public class ResultsDecoratorSQL extends ResultsDecorator {
	ResultsDecoratorSQL(ResultsDecoratorPrinter out) {
		super(out);
	}
	public void write(ResultSet rs) throws IOException, SQLException {
		ResultSetMetaData md = rs.getMetaData();
		// This assumes you're not using a Join!!
		String tableName = md.getTableName(1);
		int cols = md.getColumnCount();
		StringBuffer sb = new StringBuffer("insert into ").append(tableName).append("(");
		for (int i = 1; i <= cols; i++) {
			sb.append(md.getColumnName(i));
			if (i != cols) {
				sb.append(", ");
			}
		}
		sb.append(") values (");
		String insertCommand = sb.toString();
		while (rs.next()) {
			println(insertCommand);		
			for (int i = 1; i <= cols; i++) {
				String tmp = rs.getString(i);
				if (rs.wasNull()) {
					print("null");
				} else {
					int type = md.getColumnType(i);
					// Don't quote numeric types; quote all others for now.
					switch (type) {
						case Types.BIGINT:
						case Types.DECIMAL:
						case Types.DOUBLE:
						case Types.FLOAT:
						case Types.INTEGER:
							print(tmp);
							break;
						default:	
							tmp = tmp.replaceAll("'", "''");
							print("'" + tmp + "'");
					}
				}
				if (i != cols) {
					print( ", ");
				}
			}
			println(");");
		}
	}

	void write(int rowCount) throws IOException {
		println("RowCount: " + rowCount);
		
	}
	/* (non-Javadoc)
	 * @see ResultsDecorator#getName()
	 */
	String getName() {
		return "SQL";
	}
}//@@@@@@//
//JDBC/ResultsDecoratorText.java
//@@@@@@//
import java.io.IOException;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

/**
 * Print a ResultSet in plain text.
 * @version $Id: ResultsDecoratorText.java,v 1.3 2004/03/26 02:39:33 ian Exp $
 */
class ResultsDecoratorText extends ResultsDecorator {
	
	ResultsDecoratorText(ResultsDecoratorPrinter pt) {
		super(pt);
	}
	
	public void write(ResultSet rs) throws IOException,SQLException {
		ResultSetMetaData md = rs.getMetaData();
		int cols = md.getColumnCount();
		for (int i = 1; i <= cols; i++) {
			print(md.getColumnName(i) + "\t");
		}
		println();
		while (rs.next()) {
			for (int i = 1; i <= cols; i++) {
				print(rs.getString(i) + "\t");
			}
			println();
		}
	}

	void write(int rowCount) throws IOException {
		println("OK: " + rowCount);
	}

	/* (non-Javadoc)
	 * @see ResultsDecorator#getName()
	 */
	String getName() {
		return "Plain text";
	}
}//@@@@@@//
//JDBC/ResultsDecoratorXML.java
//@@@@@@//
import java.io.IOException;
import java.sql.ResultSet;
import java.sql.SQLException;

import javax.sql.rowset.WebRowSet;

/**
 * This guy's primary raison d'etre is to generate an XML output file
 * for use in JUnit testing of the ResultsDecoratorSQL!
 * @version $Id: ResultsDecoratorXML.java,v 1.1 2004/03/26 02:39:33 ian Exp $
 */
public class ResultsDecoratorXML extends ResultsDecorator {
	WebRowSet results;
	
	ResultsDecoratorXML(ResultsDecoratorPrinter out) {
		super(out);
		try {
			// The name is com.sun.rowset.WebRowSetImpl in rowset.jar,
			// but sun.rowset.jar in J2SDK1.5. Go figure.
			Class c = Class.forName("com.sun.rowset.WebRowSetImpl");
			results = (WebRowSet)c.newInstance();
			
		} catch (Exception ex){
			throw new IllegalArgumentException(
			"can't load WebRowSetImpl, check CLASSPATH");
		}
	}
	
	public void write(ResultSet rs) throws SQLException {
		results.writeXml(rs, parent.getPrintWriter());
	}

	void write(int rowCount) throws IOException {
		println("RowCount: " + rowCount);
		
	}

	/* (non-Javadoc)
	 * @see ResultsDecorator#getName()
	 */
	String getName() {
		return "XML";
	}
}//@@@@@@//
//JDBC/ResultSetUpdate.java
//@@@@@@//
import java.sql.*;

public class ResultSetUpdate {
    public static void main(String args[]) {

        String url;
        url = "jdbc:odbc:UserDB";

		String user, pass;
		user = "ian";
		pass = "stjklsq";

        Connection con;
        Statement stmt;
		ResultSet rs;

        try {
            con = DriverManager.getConnection(url, user, pass);
			stmt = con.createStatement(
			ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
			rs = stmt.executeQuery("SELECT * FROM Users where nick=\"ian\"");

			// Get the resultset ready, update the passwd field, commit
			rs.first();
			rs.updateString("password", "unguessable");
			rs.updateRow();

			rs.close();
			stmt.close();
            con.close();
        } catch(SQLException ex) {
            System.err.println("SQLException: " + ex.getMessage());
        }
	}
}
//@@@@@@//
//JDBC/ShowTable.java
//@@@@@@//
/**
 * List the Column names in an SQL database table.
 */

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;

import com.darwinsys.sql.ConnectionUtil;

public class ShowTable {
	public static void main(String[] args) throws SQLException {
		String config = args[0];
		String table = args[1];
		Connection c = ConnectionUtil.getConnection(config);
		DatabaseMetaData md = c.getMetaData();
		ResultSet rs = md.getColumns(null, null, table, "%");
		while (rs.next()) {
			System.out.println(rs.getString(4));
		}
	}
}
//@@@@@@//
//JDBC/SQLRunner.java
//@@@@@@//
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import com.darwinsys.database.DataBaseException;
import com.darwinsys.lang.GetOpt;
import com.darwinsys.sql.ConnectionUtil;

/** Class to run an SQL script, like psql(1), SQL*Plus, or similar programs.
 * Command line interface accepts options -c config [-f configFile] [scriptFile].
 * <p>Input language is: escape commands (begin with \ and MUST end with semi-colon), or
 * standard SQL statements which must also end with semi-colon);
 * <p>Escape sequences: 
 * <ul>
 * <li> \m (output-mode), takes character t for text,
 * h for html, s for sql, x for xml (not in this version)
 * (the SQL output is intended to be usable to re-insert the data into another identical table,
 * but this has not been extensively tested!).
 * <li> \o output-file, redirects output.
 * <li> \q quit the program
 * </ul>
 * TODO: Fix parsing so escapes don't need to end with SQL semi-colon.
 * <p>This class can also be used from within programs such as servlets, etc.
 * <p>TODO: knobs to set debug mode (interactively & from getopt!)
 * <p>For example, this command and input:</pre>
 * SQLrunner -c testdb
 * \ms;
 * select *from person where person_key=4;
 * </pre>might produce this output:<pre>
 * Executing : <<select * from person where person_key=4>>
 *  insert into PERSON(PERSON_KEY,  FIRST_NAME, INITIAL, LAST_NAME, ... ) 
 * values (4, 'Ian', 'F', 'Darwin', ...);
 * </pre>
 * @author	Ian Darwin, http://www.darwinsys.com/
 */
public class SQLRunner implements ResultsDecoratorPrinter {
	
	// TODO: This is an obvious candidate for a 1.5 "enum" (fixed in the 1.5 branch)
	
	/** The mode for textual output */
	public static final String MODE_TXT = "t";
	/** The mode for HTML output */
	public static final String MODE_HTML = "h";
	/** The mode for SQL output */
	public static final String MODE_SQL = "s";
	/** The mode for XML output */
	public static final String MODE_XML = "x";

	/** Database connection */
	protected Connection conn;

	/** SQL Statement */
	protected Statement stmt;
	
	/** Where the output is going */
	protected PrintWriter out;
	
	private ResultsDecorator currentDecorator;

	private ResultsDecorator textDecorator;

	private ResultsDecorator sqlDecorator;
	
	private ResultsDecorator htmlDecorator;
	
	private ResultsDecorator xmlDecorator;
	
	boolean debug = false;

	/** print help; called from several places in main */
	private static void doHelp(int i) {
		System.out.println(
		"Usage: SQLRunner [-f configFile] [-c config] [SQLscript[ ...]");
		System.exit(i);
	}

	/**
	 * main - parse arguments, construct SQLRunner object, open file(s), run scripts.
	 * @throws SQLException if anything goes wrong.
	 * @throws DatabaseException if anything goes wrong.
	 */
	public static void main(String[] args)  {
		String config = "default";
		String outputMode = MODE_TXT;
		String outputFile = null;
		boolean debug = false;
		GetOpt go = new GetOpt("df:c:m:o:");
		char c;
		while ((c = go.getopt(args)) != GetOpt.DONE) {
			switch(c) {
			case 'h':
				doHelp(0);
				break;
			case 'd':
				debug = true;
				break;
			case 'f':
				ConnectionUtil.setConfigFileName(go.optarg());
				break;
			case 'c':
				config = go.optarg();
				break;
			case 'm':
				outputMode = go.optarg();
				break;
			case 'o':
				outputFile = go.optarg();
				break;
			default:
				System.err.println("Unknown option character " + c);
				doHelp(1);
			}
		}

		try {

			Connection conn = ConnectionUtil.getConnection(config);

			SQLRunner prog = new SQLRunner(conn, outputFile, outputMode);
			prog.setDebug(debug);
			
			if (go.getOptInd() == args.length) {
				prog.runScript(new BufferedReader(
					new InputStreamReader(System.in)));
			} else for (int i = go.getOptInd()-1; i < args.length; i++) {
				prog.runScript(args[i]);
			}
			prog.close();
		} catch (SQLException ex) {
			throw new DataBaseException(ex.toString());
		} catch (IOException ex) {
			throw new DataBaseException(ex.toString());
		}
		System.exit(0);
	}

	/** Construct a SQLRunner object
	 * @param driver String for the JDBC driver
	 * @param dbUrl String for the JDBC URL
	 * @param user String for the username
	 * @param password String for the password, normally in cleartext
	 * @param outputMode One of the MODE_XXX constants.
	 * @throws ClassNotFoundException
	 * @throws SQLException
	 */
	public SQLRunner(String driver, String dbUrl, String user, String password,
			String outputFile, String outputMode)
			throws IOException, ClassNotFoundException, SQLException {
		conn = ConnectionUtil.createConnection(driver, dbUrl, user, password);
		finishSetup(outputFile, outputMode);
	}
	
	public SQLRunner(Connection c, String outputFile, String outputMode) throws IOException, SQLException {
		// set up the SQL input
		conn = c;
		finishSetup(outputFile, outputMode);
	}
	
	void finishSetup(String outputFileName, String outputMode) throws IOException, SQLException {
		DatabaseMetaData dbm = conn.getMetaData();
		String dbName = dbm.getDatabaseProductName();
		System.out.println("SQLRunner: Connected to " + dbName);
		stmt = conn.createStatement();
		
		if (outputFileName == null) {
			out = new PrintWriter(System.out);
		} else {
			out = new PrintWriter(new FileWriter(outputFileName));
		}
		
		setOutputMode(outputMode);
	}
	
	/** Set the output mode.
	 * @param outputMode Must be a value equal to one of the MODE_XXX values.
	 * @throws IllegalArgumentException if the mode is not valid.
	 */
	void setOutputMode(String outputMode) {
		if (outputMode.length() == 0) { throw new IllegalArgumentException(
			"invalid mode: " + outputMode + "; must be t, h or s"); }

		// Assign the correct ResultsDecorator, creating them on the fly
		// using the lazy evaluation pattern.
		ResultsDecorator newDecorator = null;
		switch (outputMode.charAt(0)) {
			case 't':
				if (textDecorator == null) {
					textDecorator = new ResultsDecoratorText(this);
				}
				newDecorator = textDecorator;
				break;
			case 'h':
				if (htmlDecorator == null) {
					htmlDecorator = new ResultsDecoratorHTML(this);
				}
				newDecorator = htmlDecorator;
				break;
			case 's':
				if (sqlDecorator == null) {
					sqlDecorator = new ResultsDecoratorSQL(this);
				}
				newDecorator = sqlDecorator;
				break;
			case 'x':
				if (xmlDecorator == null) {
					xmlDecorator = new ResultsDecoratorXML(this);
				}
				newDecorator = sqlDecorator;
				break;
			default:
				throw new IllegalArgumentException("invalid mode: "
								+ outputMode + "; must be t, h or s");
		}
		if (currentDecorator != newDecorator) {
			currentDecorator = newDecorator;
			System.out.println("Mode set to  "
					+ currentDecorator.getName());
		}

	}
	
	/** Run one script file, by name. Called from cmd line main
	 * or from user code.
	 */
	public void runScript(String scriptFile)
	throws IOException, SQLException {

		BufferedReader is;

		// Load the script file first, it's the most likely error
		is = new BufferedReader(new FileReader(scriptFile));

		runScript(is);
	}

	/** Run one script, by name, given a BufferedReader. */
	public void runScript(BufferedReader is)
	throws IOException, SQLException {

		String stmt;
		int i = 0;
		System.out.println("SQLRunner: ready.");
		while ((stmt = getStatement(is)) != null) {
			stmt = stmt.trim();
			if (stmt.startsWith("\\")) {
				doEscape(stmt);
			} else {
				runStatement(stmt);
			}
		}
	}

	/**
	 * Process an escape like \ms; for mode=sql.
	 */
	private void doEscape(String str) throws IOException, SQLException  {
		String rest = null;
		if (str.length() > 2) {
			rest = str.substring(2);
		}
		
		if (str.startsWith("\\d")) {	// Display
			if (rest == null){
				throw new IllegalArgumentException("\\d needs display arg");
			}
			display(rest);
		} else if (str.startsWith("\\m")) {	// MODE
			if (rest == null){
				throw new IllegalArgumentException("\\m needs output mode arg");
			}
			setOutputMode(rest);
		} else if (str.startsWith("\\o")){
			if (rest == null){
				throw new IllegalArgumentException("\\o needs output file arg");
			}
			setOutputFile(rest);
		} else if (str.startsWith("\\q")){
			System.exit(0);
		} else {
			throw new IllegalArgumentException("Unknown escape: " + str);
		}
		
	}

	/**
	 * Display - something
	 * @param rest - what to display
	 * XXX: Move formatting to ResultsDecorator: listTables(rs), listColumns(rs)
	 */
	private void display(String rest) throws SQLException {
		if (rest.equals("t")) {
			// Display list of tables
			DatabaseMetaData md = conn.getMetaData();
			ResultSet rs = md.getTables(null, null, "%", null);
			while (rs.next()) {
				System.out.println(rs.getString(3));
			}
		} else if (rest.startsWith("t")) {
			// Display one table
			String tableName = rest.substring(1).trim();
			System.out.println("# Display table " + tableName);
			DatabaseMetaData md = conn.getMetaData();
			ResultSet rs = md.getColumns(null, null, tableName, "%");
			while (rs.next()) {
				System.out.println(rs.getString(4));
			}
		} else
			throw new IllegalArgumentException("\\d"  + rest + " invalid");
	}

	/** Set the output to the given filename.
	 * @param fileName
	 */
	private void setOutputFile(String fileName) throws IOException{
		File file = new File(fileName);
		out = new PrintWriter(new FileWriter(file), true);
		System.out.println("Output set to " + file.getCanonicalPath());
	}
	 
	/** Set the output file back to System.out */
	private void setOutputFile() throws IOException{
		out = new PrintWriter(System.out, true);
	}

	/** Run one Statement, and format results as per Update or Query.
	 * Called from runScript or from user code.
	 */
	public void runStatement(String str) throws IOException, SQLException {
		
		System.out.println("Executing : <<" + str.trim() + ">>");
		System.out.flush();
		try {
			boolean hasResultSet = stmt.execute(str);
			if (!hasResultSet)
				currentDecorator.write(stmt.getUpdateCount());
			else {
				ResultSet rs = stmt.getResultSet();
				currentDecorator.write(rs);
			}
		} catch (SQLException ex) {
			if (debug){
				throw ex;
			} else {
				System.out.println("ERROR: " + ex.toString());
			}
		}
		System.out.println();
	}
	
	/** Extract one statement from the given Reader.
	 * Ignore comments and null lines.
	 * @return The SQL statement, up to but not including the ';' character.
	 * May be null if not statement found.
	 */
	public static String getStatement(BufferedReader is)
	throws IOException {
		String ret="";
		String line;
		boolean found = false;
		while ((line = is.readLine()) != null) {
			if (line == null || line.length() == 0) {
				continue;
			}
			if (!(line.startsWith("#") || line.startsWith("--"))) {
				ret += ' ' + line;
				found = true;
			}
			if (line.endsWith(";")) {
				// Kludge, kill off empty statements (";") by itself, continue scanning.
				if (line.length() == 1)
					line = "";
				ret = ret.substring(0, ret.length()-1);
				return ret;
			}
		}
		return null;
	}

	public void close() throws SQLException {
		stmt.close();
		conn.close();
		out.flush();
		out.close();
	}

	/* (non-Javadoc)
	 * @see DatabaseWriterImpl#println(java.lang.String)
	 */
	public void print(String line) throws IOException {
		out.print(line);
	}
	
	public void println(String line) throws IOException {
		out.println(line);
		out.flush();
	}

	/* (non-Javadoc)
	 * @see DatabaseWriterImpl#println()
	 */
	public void println() throws IOException {
		out.println();
		out.flush();
	}

	/* (non-Javadoc)
	 * @see ResultsDecoratorPrinter#getPrintWriter()
	 */
	public PrintWriter getPrintWriter() {
		return out;
	}
	/**
	 * @return Returns the debug.
	 */
	public boolean isDebug() {
		return debug;
	}
	/**
	 * @param debug True to enable debug, false to disable.
	 */
	public void setDebug(boolean debug) {
		this.debug = debug;
	}
}
//@@@@@@//
//JDBC/StoredProcedureDemo.java
//@@@@@@//
import java.sql.Connection;
import java.sql.CallableStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/** FRAGMENT ONLY showing syntax of prepared statement.
 */
public class CallableExample {
	public static void main(String[] args) throws SQLException {

		Connection conn = ConnectionUtil.getConnection("jabadot");

		CallableStatement cs = conn.prepareCall("{call ListDefunctUsers}");
		ResultSet rs = cs.executeQuery();

		while (rs.next()) {
			System.out.println("Defunct user: " + rs.getString("user"));
		}
	}
}
//@@@@@@//
//JDBC/testdatasource/TestDataSource.java
//@@@@@@//
import javax.naming.*;
import java.sql.*;
import javax.sql.*;

/** See if a DataSource exists and is usable.
 * @version $Id: TestDataSource.java,v 1.3 2004/03/20 03:09:44 ian Exp $
 */
public class TestDataSource {

	public static void main(String[] argv) 
		throws NamingException, SQLException {

		Context ctx = new InitialContext();

		String dsn = argv[0];
		System.out.println("Looking up " + dsn);
		Object o = ctx.lookup(dsn);
		DataSource d = (DataSource)o;

		System.out.println("Getting connection ");
		Connection con = d.getConnection();
		System.out.println("Got it!");
	}
}
//@@@@@@//
//JDBC/TXInfo.java
//@@@@@@//
import java.sql.*;

public class TXInfo {
	public static void main(String[] a) throws Exception {
	Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
	Connection con = DriverManager.getConnection(
		"jdbc:odbc:MusicVideo");
	int tx = con.getMetaData().getDefaultTransactionIsolation();
	String txtxt=null;
	switch(tx) {
		case Connection.TRANSACTION_NONE :
			txtxt = "TRANSACTION_NONE"; break;
		case Connection.TRANSACTION_READ_COMMITTED :
			txtxt = "TRANSACTION_READ_COMMITTED"; break;
		case Connection.TRANSACTION_READ_UNCOMMITTED :
			txtxt = "TRANSACTION_READ_UNCOMMITTED"; break;
		case Connection.TRANSACTION_REPEATABLE_READ :
			txtxt = "TRANSACTION_REPEATABLE_READ"; break;
        case Connection.TRANSACTION_SERIALIZABLE :
			txtxt = "TRANSACTION_SERIALIZABLE"; break;
		default:
			txtxt = "UNKNOWN!!";
	}
	System.out.println(txtxt);
	con.setTransactionIsolation(tx);
	System.out.println("Done");
	con.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
	System.out.println("TX is now " + con.getTransactionIsolation());
	}
}
//@@@@@@//
//JDBC/TypeMapDemo.java
//@@@@@@//
 import java.sql.*;
 import java.util.*;
 import java.io.*;

/*
 * Following up on the javadoc for java.sql.Connection,
 * make a TypeMap that maps a *structured* UDT into a
 * MusicRecording "automatically".
 * @author Ian Darwin
 */
public class TypeMapDemo {
	public static void main(String[] args)
	throws IOException, ClassNotFoundException, SQLException {

		Properties p = new Properties();
		p.load(new FileInputStream("db.properties"));
		Class c = Class.forName(p.getProperty("db.driver"));
		System.out.println("Loaded driverClass " + c.getName());

		Connection con = DriverManager.getConnection(
			p.getProperty("db.url"),
			"student", "student");
		System.out.println("Got Connection " + con);

		Statement s = con.createStatement();
		int ret;
		try {
			s.executeUpdate("drop table MR");
			s.executeUpdate("drop type MUSICRECORDING");
		} catch (SQLException andDoNothingWithIt) {
			// Should use "if defined" but not sure it works for UDTs...
		}
 		ret = s.executeUpdate(
			"create type MUSICRECORDING as object (" +
			"	id integer," +
			"	title varchar(20), " +
			"	artist varchar(20) " +
			")");
		System.out.println("Created TYPE! Ret=" + ret);

		ret = s.executeUpdate(
			"create table MR of MUSICRECORDING");
		System.out.println("Created TABLE! Ret=" + ret);

		int nRows = s.executeUpdate(
			"insert into MR values(123, 'Greatest Hits', 'Ian')");
		System.out.println("inserted " + nRows + " rows");


		// Put the data class into the connection's Type Map
		// If the data class were not an inner class,
		// this would likely be done with Class.forName(...);
		Map map = con.getTypeMap();
		map.put("MUSICRECORDING", MusicRecording.class);
		con.setTypeMap(map);

		ResultSet rs = s.executeQuery(
			"select * from MR where id = 123");
			//"select musicrecording(id,artist,title) from mr");
		rs.next();
		for (int i=1; i<=rs.getMetaData().getColumnCount(); i++) {
			Object o = rs.getObject(i);
			System.out.print(o + "(Type " +
				o.getClass().getName() + ")\t");
		}
		System.out.println();
	}

	/** 
	 * Simplified local copy of MusicRecording, so this pgm can stand alone.
	 * This is an inner class just for illustrative purposes;
	 * it would normally be an unrelated data class.
	 */
	public class MusicRecording {
		int id;
		String title;
		String artist;
		public String toString() {
			return "MusicRecording#"+id+"["+artist+"--"+title+"]";
		}
	}
}
//@@@@@@//
//jsp/Counter.java
//@@@@@@//
package darwin;

import java.io.*;

/** Simple "page counter" bean.
 * $Id: Counter.java,v 1.1 2001/11/13 19:17:06 ian Exp $
 */
public class Counter implements Serializable {
	private int counter;

	/** A public no-argument constructor is required of a javabean. */
	public Counter() {
		counter = 1;
	}

	public int getCount() {
		return counter;
	}
	public void setCount(int c) {
		counter = c;
	}

	/** This method increments the counter. Must be called (in a scriptlet)
	 * explicitly at present since there's not way to call
	 * methods other than set/get methods in the JSP standard.
	 */
	public void incr() {
		++counter;
	}
}
//@@@@@@//
//jsp/FiveInts.java
//@@@@@@//
import java.util.Random;

public class FiveInts {
	public static void main(String[] argv) {
		//+
		Random r = new Random();
		for (int i=0; i<5; i++)
			System.out.println(r.nextInt());
		//-
	}
}
//@@@@@@//
//jsp/FiveIntsServlet.java
//@@@@@@//
import java.util.Random;
import javax.servlet.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

public class FiveIntsServlet {
	public void service(HttpServletRequest req, HttpServletResponse resp) 
	throws IOException {
		PrintWriter out = resp.getWriter();
		out.println("<HTML>");
		out.println("<HEAD>");
		out.println("<TITLE>Your Personal Random Numbers</TITLE>");
		out.println("<H1>Your Personal Random Numbers</H1>");
		out.println("<P>Here are your personal random numbers,");
		out.println("carefully selected by a");
		out.println("<A HREF=\"http://java.sun.com\">Java</A> program.");
		out.println("<OL>");
		Random r = new Random();
		for (int i=0; i<5; i++) {
			out.print("<LI>");
			out.println(r.nextInt());
		}
		out.println("</OL>");
		out.println("<HR></HR>");
		out.println("<A HREF=\"index.html\">Back to main Page</A>");
	}
}
//@@@@@@//
//jsp/PasswordChecker.java
//@@@@@@//
package darwin;

/** Simple Password Checker Javabean.
 * Does not implement get methods, only set.
 * @version $Id: PasswordChecker.java,v 1.1 2001/11/13 19:17:06 ian Exp $
 */
public class PasswordChecker implements java.io.Serializable {
	protected String login, password;

	/** A public no-argument constructor is required of a javabean. */
	public PasswordChecker() {
	}

	/** Set the login name */
	public void setLogin(String s) {
		login = s;
	}

	/** Set the password */
	public void setPassword(String s) {
		password = s;
	}

	/** Return true if a valid name and password have been set.
	 * Obviously trivial: real version would look in a database. 
	 */
	public boolean isValidPassword() {
		return login!=null && password !=null &&
			login.equals("ian") &&
			password.equals("topSecret");
	}
}
//@@@@@@//
//lang/AbstractStatic.java
//@@@@@@//
/**
 * Can you call a static method of an abstract class?
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: AbstractStatic.java,v 1.4 2004/02/09 03:33:53 ian Exp $
 */
public abstract class AbstractStatic {

	public static void main(String[] argv) {
		//+
		System.out.println("Hello. The answer is yes.");
		// The following is redundant, since we got in here!
		AbstractStatic.foo();
		//-
	}

	public static void foo() {
		System.out.println("Hello from foo. The answer is still yes.");
	}

	/* And if you think about it, of course non-abstract static
	 * methods of an abstract class can be called. Isn't this
	 * how most "factory methods" work?
	 */
}
//@@@@@@//
//lang/AddException.java
//@@@@@@//
import java.io.*;

/** 
 * Demo to show what happens if you try to add an exception to a method
 * that its superclass method of the same signature did not have.
 *
 * @author	Ian Darwin
 *
 * @version	1.0
 */
public class AddException {
	/**
	 * Main program, test driver for ThreadsDemo1 class.
	 */
	public static void main(String[] argv) {
		new AddException();
	}

	public void run() {
	}
}

class AddException2 extends AddException {
	public void run() throws IOException {	// EXPECT COMPILE ERROR
	}
}

//@@@@@@//
//lang/ArgvNumber.java
//@@@@@@//
/** Show use of Argv to get an integer value from command line */
public class ArgvNumber {
	/** Main program */
	public static void main(String[] argv) {
		int number = 0;

		System.out.println("The number of words in argv is " + argv.length);

		if (argv.length == 0) {
			number = 1234;
		} else if (argv.length == 1) {
			try {
				number = Integer.parseInt(argv[0]);
			} catch(NumberFormatException e) {
				System.err.println("Number " + argv[0] + " invalid (" + e.getMessage() + ").");
				System.exit(1);
			}
		} else {
			System.err.println("usage: UseArgv number");
			System.exit(1);
		}

		System.out.println("OK, number is " + number);
	}
}
//@@@@@@//
//lang/Array2D.java
//@@@@@@//
public class Array2D {
	public static void main(String[] args) {
		int[][] data;
		data = new int[10][];
		data[0] = new int[5];
		data[1] = new int[20];
		System.out.println("data.length = " + data.length);
		System.out.println("data[0].length = " + data[0].length);
		System.out.println("data[1].length = " + data[1].length);
	}
}
//@@@@@@//
//lang/ArrayArgs.java
//@@@@@@//
public class ArrayArgs {
	ArrayArgs(int[] foo) {
		super();
	}
	public static void main(String[] argv) {
		// new ArrayArgs( { 1,2,3} );
		int myDate[] = {1,2,3};
		new ArrayArgs( myDate );
	}
}
//@@@@@@//
//lang/Bad.java
//@@@@@@//
public class Bad {
	public static void main(String[] u) {
		throw new IllegalStateException("Just testing");
	}
}
//@@@@@@//
//lang/BooleanAndOr.java
//@@@@@@//
/*
 * Test out combinations of Ands and Ors on Boolean values.
 * Some of these will probably throw a NullPointerException: which one(s)?
 * Pay attention to short-circuit evaluation; if the first subexpression
 * is known, do you need to evaluation the second??
 */
public class BooleanAndOr {
	public static void main(String[] a) {
		String s = null;

		// These use the conventional logical "and" (&&) and "or" (||).
		try {
			if ((s != null) && (s.length() > 0))
				System.out.println("At Point One");
			if ((s != null) || (s.length() > 0))
				System.out.println("At Point Two");
		} catch (Exception e) {
			System.out.print("Logical section threw ");
			e.printStackTrace();
		}

		// These use bitwise "and" (&) and "or" (|); is it valid? What results?
		try {
			if ((s == null) & (s.length() > 0))
				System.out.println("At Point Three");
			if ((s == null) | (s.length() > 0))
				System.out.println("At Point Four");
		} catch (Exception e) {
			System.out.print("Bitwise section threw ");
			e.printStackTrace();
		}
	}
}
//@@@@@@//
//lang/BuiltinTypes.java
//@@@@@@//
/**
 * Built in types
 */
public class BuiltinTypes {
	public static void main(String[] argv) {
		// An integer can be entered in several ways:
		int i = 123;
		System.out.println("i = " + i);
		i = 00123;
		System.out.println("i = " + i);
		i = 0x123;
		System.out.println("i = " + i);

		// A double can also be entered in several ways:
		float f = 123f;
		System.out.println("f = " + f);
		f = 123.0f;
		System.out.println("f = " + f);
		f = (float)1.23e2;		// 1.23 x (10 ^ 2)
		System.out.println("f = " + f);
	}
}
//@@@@@@//
//lang/ByteAdd.java
//@@@@@@//
/**
 * This shows something interesting about addition of "byte" variables
 * (which also applies to all integer types).
 */
public class ByteAdd {
	public static void main(String[] argv) {
		System.out.println("ByteAdd Program");
		// bytes are signed integer, so can range from -127 to +127
		byte b1 = 10, b2 = 127;	
		System.out.println("b1 + b2 = " + (b1+b2));
		b1 = 127;
		System.out.println("b1 + b2 = " + (b1+b2));
	}
}
//@@@@@@//
//lang/ByteAdd2.java
//@@@@@@//
/**
 * This shows something interesting about addition of "byte" variables
 * (which also applies to all integer types).
 */
public class ByteAdd2 {
	public static void main(String[] argv) {
		System.out.println("ByteAdd Program");
		// bytes are signed integer, so can range from -127 to +127
		byte b1 = 10;
		b1 += 1;		// This works, following does not:
		b1 = b1 + 1;	// EXPECT COMPILE ERROR
	}
}
//@@@@@@//
//lang/CastingDemo.java
//@@@@@@//
/** A simple casting demo. */
public class CastingDemo {
	public static void main(String[] argv) {
		int i, ans;
		double d = 2.75;
		i = d;			// EXPECT COMPILE ERROR
		i = (int)d;		// with cast; i gets 2
		System.out.println("i =" + i);
		ans = (int)d * 3;		// truncate d before multiplying
		System.out.println("ans =" + ans);
		ans = (int)(d * 3);	// multiplies before truncating
		System.out.println("ans =" + ans);
	}
}
//@@@@@@//
//lang/ChangeArrayLength.java
//@@@@@@//
/**
 * Can you change the .length of an array?
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ChangeArrayLength.java,v 1.5 2004/02/09 03:33:53 ian Exp $
 */
public class ChangeArrayLength {
	public static void main(String[] argv) {
		//+
		int[] a = new int[4];
		System.out.println(a.length);
		a.length = 5;	// EXPECT COMPILE ERROR
		//-
	}
}
//@@@@@@//
//lang/CharIsInt.java
//@@@@@@//
public class CharIsInt {
	public static void main(String[] argv) {
		char a = 'A';
		System.out.println("a is " + a);
		int i = a;
		System.out.println("i is " + i);
		char n = (char)-a;
		System.out.println("n is " + n);
		int z = n;
		System.out.println("z is " + z);
		// Now: is char signed or unsigned?
		// char neg = -1;		// WON'T COMPILE
		// System.out.println("neg is " + neg);
	}
}
//@@@@@@//
//lang/ClassCast.java
//@@@@@@//
/** Class Casting Demo. */
public class ClassCast {
	public static void main(String[] argv) {

		CCA anA = new CCA();
		CCB aB = new CCB(1);
		CCC aC = new CCC(2,3);

		System.out.println("A = " + anA);
		System.out.println("B = " + aB);
		System.out.println("C = " + aC);

		CCA aCast = aC;
		System.out.println("aCast = " + aCast);

		CCC anotherC = (CCC) aCast;
		System.out.println("anotherC = " + anotherC);
	}
}

class CCA {
}

class CCB extends CCA {
	int one;
	CCB(int i) {
		one = i;
	}
	public String toString() {
		return "In a B object: " + one;
	}
}
class CCC extends CCB {
	int two;
	CCC(int i, int j) {
		super(i);	// does "one = i" for us.
		two = j;
	}
	public String toString() {
		return "In a C object: " + one + "," + two;
	}
}
//@@@@@@//
//lang/CommentBug.java
//@@@@@@//
/** The documentation, and the Java Language Spec, claim that
 * slash-star comments do not nest. But they do in some compilers!
 */
public class CommentBug {
	/* This should be a /* compile-time */ error */	// EXPECT COMPILE ERROR
	public static void main(String[] a) {
		System.out.println("SHOULD NOT HAVE COMPILED!!");
	}
}
//@@@@@@//
//lang/CompileError.java
//@@@@@@//
/**
 * Program with a syntax error, to show compiler error messages
 */
public class CompileError {
	public static void main(String argv]) {	// EXPECT COMPILE ERROR
		System.out.println("You won't see this in Java");
		System.out.println(System.getProperties());
	}
}
//@@@@@@//
//lang/ConsRecurs.java
//@@@@@@//
/** What happens when two constructors call each other?
 * Can you get an infinite loop out of the process?
 */
public class ConsRecurs {

	public ConsRecurs(int i) {
		this(i*1.0);	// EXPECT COMPILE ERROR
	}

	public ConsRecurs(double d) {
		this((int)d);	// EXPECT COMPILE ERROR
	}

	public static void main(String[] a) {
		System.out.println("About to construct...");
		new ConsRecurs(Math.PI);
		System.out.println("Hey, I'm still alive!");
	}
}
//@@@@@@//
//lang/ConstrException.java
//@@@@@@//
// Just to show that constructors are allowed to throw exceptions

public class ConstrException {
	public ConstrException(int i) {
		if (i < 0)
			throw new IllegalArgumentException("value " + i +
				"invalid, must be non-negative");
	}
}
//@@@@@@//
//lang/Constructors.java
//@@@@@@//
/** Show Constructors conflicting */
public class Constructors {

	/** Constructor */
	public Constructors() {
		System.out.println("In the constructor");
	}
	/** Constructor that throws */
	public Constructors(int value) {
		if (value < 0)
			throw new IllegalArgumentException("Constructors: value < 0");
	}

	/** Not a Constructor, because of void */
	public void Constructors() {	// EXPECT COMPILE ERROR some compilers
		System.out.println("In void Constructor()");
	}
	void method1() {
		for (int i=0; i<5; i++)
			System.out.println(i);
	}
	public static void main(String[] a) {
		Constructors l = new Constructors();
		l.method1();
		l.Constructors();
		new Constructors(-1);		// expect Exception
	}
}
//@@@@@@//
//lang/DoWhile.java
//@@@@@@//
public class DoWhile {
	public static void main(String[] av) {

	int i = 5;
	do {
		System.out.println("i = " + i--);
	} while (i>=0);
	}
}
//@@@@@@//
//lang/EuroLanguage.java
//@@@@@@//
/* Make sure the compiler accepts European languages everywhere.
 * May require a locale to be set before it will compile!
 * But if you rename the class to, say, Espaol, many runtimes will be confused.
 */
public class EuroLanguage {
	public static int nmero;
	public static void main(String[] args) {
		System.out.println("Accin!");
		accin(123);
		System.out.println("Nmero = " + nmero);
	}
	public static void accin(int costa) {
		System.out.println("Su tarjeta cuesta los " + costa);
		nmero++;
	}
}

//@@@@@@//
//lang/ExceptionDemo.java
//@@@@@@//
/** Simple demo of exceptions */
public class ExceptionDemo {

	public static void main(String[] argv) {
		new ExceptionDemo().doTheWork();
	}

	/** This method demonstrates calling a method that might throw
	 * an exception, and catching the resulting exception.
	 */
	public void doTheWork() {
		Object o = null;

		for (int i=0; i<5; i++) {
			try {
				o = makeObj(i);
			} catch (IllegalArgumentException e) {
				System.err.println("Error: (" + e.getMessage() + ").");
				return;		// cut off println below if makeObj failed.
			}
			System.out.println(o);	// process the created object in some way
		}
	}

	/** Model of a method that creates and returns an object.
	 * This method is really here to show how you throw exceptions.
	 * @exception	IllegalArgumentException	if called with value 1.
	 */
	public Object makeObj(int type) throws IllegalArgumentException {
		if (type == 1)	// detects an error...
			throw new IllegalArgumentException("Don't like type " + type);
		return new Object();
	}
}
//@@@@@@//
//lang/ExceptionDemo2.java
//@@@@@@//
/** Simple demo of exceptions, with finally clause */
public class ExceptionDemo2 {

	public static void main(String[] argv) {
		new ExceptionDemo2().doTheWork();
	}

	/** This method demonstrates calling a method that might throw
	 * an exception, and catching the resulting exception.
	 */
	public void doTheWork() {
		Object o = null;

		for (int i=0; i<5; i++) {
			try {
				o = makeObj(i);
			} catch (IllegalArgumentException e) {
				System.err.println("Error: (" + e.getMessage() + ").");
				return;		// cut off println below if makeObj failed.
			} finally {
				System.err.println("All done");
				if (o==null)
					System.exit(0);
			}
			System.out.println(o);	// process the created object in some way
		}
	}

	/** Model of a method that creates and returns an object.
	 * This method is really here to show how you throw exceptions.
	 * @exception	IllegalArgumentException	if called with value 1.
	 */
	public Object makeObj(int type) throws IllegalArgumentException {
		if (type == 1)	// detects an error...
			throw new IllegalArgumentException("Don't like type " + type);
		return new Object();
	}
}
//@@@@@@//
//lang/FinalArgs.java
//@@@@@@//
import java.util.*;

/**
 * Experiment with "final" args to functions (new in 1.1)
 */
public class FinalArgs {
	public static void main(String argv[]) {
		new FinalArgs().run();
	}
	void run() {
		System.out.println("Hummm de dummm...");
		myFunc(Calendar.getInstance());
		System.out.println("Once upon a time...");
	}
	void myFunc(final Calendar d) {
		// d = null;	// this will not compile
		d.set(Calendar.YEAR, 1999); // this will compile, and changes the object
	}
}
//@@@@@@//
//lang/Finally.java
//@@@@@@//
/** Test case for "finally", to show its effect with
 * return or exit.
 */
public class Finally {
	/** Main method, does the work of the testing... */
	public static void main(String[] argv) {

		try {
			throw new Exception();
		} catch (Exception e) {
			System.out.println("Caught Exception");
			return;		// with return, Goodbye appears
			// System.exit(1);	// with exit, Goodbye does not appear
		} finally {
			System.out.println("Goodbye!");
		}
	}
}
//@@@@@@//
//lang/ForLoop.java
//@@@@@@//
/**
 * Check out "for" loop.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ForLoop.java,v 1.5 2004/02/09 03:33:53 ian Exp $
 */
public class ForLoop {
	public static void main(String[] argv) {
		System.out.println("Starting...");
		// So what REALLY happens if a for loop's test condition is
		// never satisfied.
		for (int i=0; i<0; i++)
			System.out.println("Should not get here ");
		System.out.println("All done.");
	}
}
//@@@@@@//
//lang/FtoD.java
//@@@@@@//
public class FtoD {
public static void main(String[] args) { 
	fmt(2.4f);
}

public static void fmt(double d) {
	System.out.println(d);
}
}
//@@@@@@//
//lang/GetSerVersUID.java
//@@@@@@//
import java.io.*;

/**
 * This program shows how to use getSerialVersionUID for a class that
 * isn't in a package and thus not findable to the normal "serialver" tool.
 *
 * @author Ian Darwin, http://www.darwinsys.com/
 */
public class GetSerVersUID {
	static final String ident = "$Id: GetSerVersUID.java,v 1.5 2004/02/09 03:33:53 ian Exp $";
	public static void main(String[] av) throws Exception {

		// First we construct a Class object for the given class
		Class cl = Class.forName("Candidate");

		// Then an ObjectStreamClass for the given class
		ObjectStreamClass ocl = ObjectStreamClass.lookup(cl);

		// And use the ObjectStreamClass to get the Class'
		// unique SerialVersionUID
		System.out.println("For class " + cl);
		System.out.println("static final long serialVersionUID = " +
			ocl.getSerialVersionUID() + "L;"); // must be long

		// And just for reference...
		System.out.println("(Must range from " + Long.MIN_VALUE +
			" to " + Long.MAX_VALUE + ".)");
	}
}
//@@@@@@//
//lang/HexNeg.java
//@@@@@@//
/**
 * Are all hex integers negative?
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: HexNeg.java,v 1.4 2004/02/09 03:33:53 ian Exp $
 */
public class HexNeg {
	public static void main(String[] argv) {
		//+
		long data[] = { 0, 0x01, 0xff, 0x100, 0xffff, 0xffffff, 
			0x7fffffff, 0xffffffff };
		for (int i=0; i<data.length; i++)
			System.out.println("data["+i+"] = " + data[i]);
		//-
	}
}
//@@@@@@//
//lang/ImportConflict.java
//@@@@@@//
/** Bring on the conflict! */

import java.util.*;	// includes Date
import java.sql.*;	// includes Date

public class ImportConflict {
	public static void main(String[] av) {
		System.out.println(new Date());	// EXPECT COMPILE ERROR
	}
}
//@@@@@@//
//lang/ImportNonPublic.java
//@@@@@@//
import java.util.VectorEnumerator;	// EXPECT COMPILE ERROR
public class ImportNonPublic {
	// Nothing here; this file is just to show what you can't do.
}
//@@@@@@//
//lang/InheritConstructor.java
//@@@@@@//
/** Show that if your class has no constructors, your superclass'
 * constructors still get called.
 */
public class InheritConstructor extends SomeOtherClass {
	public static void main(String[] c) {
		new InheritConstructor().run();
	}
	public void run() {
		System.out.println("In InheritConstructor::run");
	}
}

// This is the class that we extend.
class SomeOtherClass {
	SomeOtherClass() {
		System.out.println("In SomeOtherClass::<init>");
	}
}
//@@@@@@//
//lang/InheritStatics.java
//@@@@@@//
// Show that you do inherit static fields.

/** This is the class that we extend. */
class AnOtherClass {
	AnOtherClass() {
		System.out.println("In AnOtherClass::<init>");
	}
	static int foo = 24;
	static int bar() {
		return 42;
	}
}

/** This is the subclass */
public class InheritStatics extends AnOtherClass {
	public static void main(String[] c) {
		new InheritStatics().run();
	}
	public void run() {
		System.out.println("In InheritStatics::run");
		System.out.println("Foo is " + foo);
		System.out.println("Bar is " + bar());
	}
}
//@@@@@@//
//lang/InitializersDemo.java
//@@@@@@//
/* To show that certain things really must be initialized */

class InitializersDemo {
	public Object o;
	public int i;

	public static void main(String[] av) {
		Object mo;
		int mi;
		InitializersDemo t = new InitializersDemo();
		if (t.o == null)
			System.out.println("o is null");
		if (t.i == 0)
			System.out.println("i is zero");
		if (mo == null)		// EXPECT COMPILE ERROR
			System.out.println("mo is null");
		if (mi == 0)		// EXPECT COMPILE ERROR
			System.out.println("mi is zero");
	}
}
//@@@@@@//
//lang/InnerChild.java
//@@@@@@//
//+
/**
 * Demonstrate an Inner Child class
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: InnerChild.java,v 1.3 2004/02/09 03:33:53 ian Exp $
 */
public class InnerChild {
	public class InnerInnerChild extends InnerChild {
	}
	public static void main(String[] argv) {
		// System.out.println(new InnerChild.InnerInnerChild()); // NOT how!
		InnerChild x = new InnerChild();
		System.out.println(x.new InnerInnerChild());
	}
}
//-
//@@@@@@//
//lang/InnerClass1.java
//@@@@@@//
/** Demonstrate simple inner class. A named inner class
 * is used to show that it can access non-local variables
 * in the enclosing object.
 */
public class InnerClass1 {
	String msg = "Hello";

	void doWork() {
		Inner i = new Inner();
		i.doTheWork();
		msg = "Goodbye";
		i.doTheWork();
	}

	public static void main(String[] av) {
		InnerClass1 p = new InnerClass1();
		p.doWork();
	}

	class Inner {
		public void doTheWork() {
			// print member of enclosing class
			System.out.println(msg);
		}
	}
}
//@@@@@@//
//lang/InnerClass2.java
//@@@@@@//
import java.util.Date;

/** Demonstrate simple inner class which just extends an
 * existing class (Date) by overriding one method in it.
 */
public class InnerClass2 {

	void doWork() {
		Date d = new Date() {
			public String toString() {
				return "Today is " + super.toString();
			}
		};
		System.out.println("My Date: " + d);
		System.out.println("Std Date: " + new Date());
	}

	public static void main(String[] av) {
		InnerClass2 p = new InnerClass2();
		p.doWork();
	}
}
//@@@@@@//
//lang/InnerClass3.java
//@@@@@@//
/** Demonstrate inner-inner class. A named inner class
 * is used to show that it can access non-local variables
 * in the enclosing object.
 */
public class InnerClass3 {
	static String msg = "Hello";

	public static void main(String[] av) {
		class Inner {
			public void doTheWork() {
				// print member of enclosing class
				System.out.println(msg);
			}
		}
		Inner p = new Inner();
		p.doTheWork();
	}

}
//@@@@@@//
//lang/InnerMethods.java
//@@@@@@//
/** Just to show that there is no such thing as inner methods in Java */
public class InnerMethods {
	public static void main(String[] args) {
		new InnerMethods().work();
	}

	public void work() {	// EXPECT COMPILE ERROR
		void inner() {
			System.out.println("Hey, there is such a thing as Inner Methods");
			System.out.println("in Java. Better tell James Gosling and Sun!");
		}
		inner();
	}
}
//@@@@@@//
//lang/InstanceofNull.java
//@@@@@@//
/** Show that "null instanceof SomeClass" returns false, not a NPE */
public class InstanceofNull {
	public static void main(String[] args) {
		try {
			boolean match = null instanceof Object;
			System.out.println("null instanceof Object == " + match);
		} catch (Throwable t) {
			System.err.println(
			"OK, I admit I was wrong, null instanceof Object throws " + t);
		}
	}
}
//@@@@@@//
//lang/InterfaceInherit.java
//@@@@@@//
/** Find out whether interfaces are inherited.
 * Start with Thread which implements Runnable.
 */
public class InterfaceInherit extends Thread {
	public static void main(String[] a) {
		new InterfaceInherit().start();
	}
	public void run() {
		if (this instanceof InterfaceInherit)
		System.out.println("This is InterfaceInherit");
		if (this instanceof Thread)
		System.out.println("This is Thread");
		if (this instanceof Runnable)
		System.out.println("This is Thread -- Interfaces ARE inherited!");
	}
}
//@@@@@@//
//lang/InterfaceNoConstructor.java
//@@@@@@//
// Just to prove whether interfaces are allowed constructors or not

public interface InterfaceNoConstructor {

	public InterfaceNoConstructor() {	// EXPECT COMPILE ERROR
		// This would be a Constructor, would it not?
		// Same name as class, and no return type.
	}
}
//@@@@@@//
//lang/InterfaceWithoutAllThrows.java
//@@@@@@//
import java.io.*;

/** This shows that a class implementing an interface need not
 * declare all the Throws that are declared in the interface.
 */
public class InterfaceWithoutAllThrows {
	interface bar {
		public void foo() throws IOException;
	}
	class baz implements bar {
		public void foo() {
			System.out.println("This is foo-lish");
		}
	}
	public static void main(String[] argv) {
		new InterfaceWithoutAllThrows().new baz().foo();
	}
}

//@@@@@@//
//lang/InvokeMain.java
//@@@@@@//
//+
import java.lang.reflect.*;
//-

/**
 * Show loading a class and finding and calling its Main method.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: InvokeMain.java,v 1.3 2004/02/09 03:33:54 ian Exp $
 */
public class InvokeMain {
	public static void main(String[] argv) {
		//+
		try {
			// First, find the class.
			Class c = Class.forName("InvokeMain");	// RECURSION
			System.out.println(c);

			// Create the array of Argument Types
			Class[] argTypes = {
				argv.getClass(),	// array is Object!
			};

			// Now find the method
			Method m = c.getMethod("main", argTypes);
			System.out.println(m);

			// Create the actual argument array
			Object passedArgv[] = { argv };

			// Now invoke the method.
			m.invoke(null, passedArgv);

		} catch (Exception e) {
			System.err.println(e);
		}
		//-
	}
}
//@@@@@@//
//lang/LengthOf.java
//@@@@@@//
/**
 * LengthOf - show length of things
 */
public class LengthOf {
	public static void main(String[] argv) {
		int    ints[] = new int[3];
		Object objs[] = new Object[7];

		String stra = "Hello World";
		String strb = new String();

		// Length of any array - use its length attribute
		System.out.println("Length of argv is " + argv.length);
		System.out.println("Length of ints is " + ints.length);
		System.out.println("Length of objs is " + objs.length);

		// Length of any string - call its length() method.
		System.out.println("Length of stra is " + stra.length());
		System.out.println("Length of strb is " + strb.length());
	}
}
//@@@@@@//
//lang/Locals.java
//@@@@@@//
/** Show locals not conflicting */
public class Locals {
	final int i = 42;

	void method1(/*int i*/) {
		// int i = 12; 	// won't compile with this in
		for (int i=0; i<10; i++)
			System.out.println(i);
		System.out.println(i);
	}
	public static void main(String[] a) {
		new Locals().method1();
	}
}
//@@@@@@//
//lang/LoopLocal.java
//@@@@@@//

public class LoopLocal {
	public static void main(String[] args) {
		for (int j = 0; j < 5; j++) { 
			System.out.println(j);
		}
		// System.out.println(j);
	}
}
//@@@@@@//
//lang/loops/LoopFor.java
//@@@@@@//
/** Compile this program and dump the compiled bytecode
 * with "javap -c" or equivalent; you will be enlightened
 * as to the true nature of while loops compared to for loops.
  */
class LoopFor {

	 public static void main(String[] args) {
		 	for (int i=0; i<10; i++) {
		 				System.out.println(i);
			}

	}
}
//@@@@@@//
//lang/loops/LoopWhile.java
//@@@@@@//
/** Compile this program and dump the compiled bytecode
 * with "javap -c" or equivalent; you will be enlightened
 * as to the true nature of while loops compared to for loops.
  */
class Loops {	// EXPECT WARNING ABOUT NAME

	 public static void main(String[] args) {
	 		int i = 0;
	 		while (i<10) {
	 			System.out.println(i);
	 			i++;
	 		}
	}
}
//@@@@@@//
//lang/MainNotSpecial.java
//@@@@@@//
/** If main is not special to the compiler, you should be able to 
 * write it any way you like. And you can. But the <KBD>java</KBD>
 * command only knows to call one particular form, as you can see
 * by compiling and running this program.
 */
public class MainNotSpecial {
	public static void main() {
		System.out.println("In no-argument main");
	}
	public static void main(String[] argv) {
		System.out.println("In String[] main");
	}
	public static void main(int argc, String argv[]) {
		System.out.println("In int,String[] main");
	}
	public static void main(String argv) {
		System.out.println("In String main");
	}
}
//@@@@@@//
//lang/MethodAndField.java
//@@@@@@//
/** Show a class that has a method and a field with the same name (and type).
 */
public class MethodAndField {
	/** A method named "a" */
	int a() {
		return 42;
	}

	/** A field named a (whose value is computed by method a for good measure)
	 */
	int a = a();

	/** A main method to show that it all works. */
	public static void main(String[] args) {
		System.out.println(new MethodAndField().a);
	}
}
//@@@@@@//
//lang/MultInterfaces.java
//@@@@@@//
interface I1 {
	abstract void test(int i);
}
interface I2 {
	abstract void test(String s);
}

/**
 * To show what happens to the possible conflicts if you 
 * implement multiple interfaces: there are no conflicts.
 * If multiple interfaces have the exact same method, you
 * merely have to implement it.
 * If multiple interfaces have similar methods, you must
 * implement them all.
 * There's still no conflict.
 */
public class MultInterfaces implements I1, I2 {
	public void test(int i) {
		System.out.println("In MultInterfaces.I1.test");
	}
	public void test(String s) {
		System.out.println("In MultInterfaces.I2.test");
	}
	public static void main(String[] a) {
		MultInterfaces t = new MultInterfaces();
		t.test(42);
		t.test("Hello");
	}
}

//@@@@@@//
//lang/MultiSuperInterfaces.java
//@@@@@@//
public class MultiSuperInterfaces {
	public interface Marker 
		extends java.io.Serializable, java.rmi.Remote, java.lang.Runnable {
	}
	public class Marked implements Marker {
		public void run() {
			// needed for Runnable
		}
	}
	public static void main(String[] args) {
		new MultiSuperInterfaces().print();
	}

	void print() {
		Object o = new Marked();
		if (o instanceof java.io.Serializable) {
			System.out.println("Is Serializable");
		}
		if (o instanceof java.rmi.Remote) {
			System.out.println("Is Remote");
		}
		if (o instanceof java.lang.Runnable) {
			System.out.println("Is Runnable");
		}
	}
}
//@@@@@@//
//lang/NestedClasses.java
//@@@@@@//
/** Show various forms of nested classes.
 * Not all nested classes are "inner classes".
 */
class A extends Object {
	public class B {	// member class
		public class BB {
			public void print() {
				System.out.println("Hello from BB");
			}
		}
		public void print() {
			BB bb = new BB();
			bb.print();
		}
	}
	public void print() {
		class C {	// local class
		}
		Object d = new Object() {
			// anonymous inner class
		};
		System.out.println("Here are an A, a B, a C, and d.");
		System.out.println(this + " " + new B() + " " +
						new C() + " " + d);
		new B().print();
	}
	public static void main(String[] av) {
		new A().print();
	}
}
//@@@@@@//
//lang/NestedClassStatic.java
//@@@@@@//
public class NestedClassStatic {
	/** Just show that Nested Classes may be static */
	static class V {
	}
	public static void main(String[] args) {
		V v = new V();
		System.out.println(v);
		v = new V();
		System.out.println(v);
	}
}
//@@@@@@//
//lang/NoLocalStatics.java
//@@@@@@//
/**
 * Show that you can't have static variables in a method, unlike C/C++
 */
public class NoLocalStatics {
	public static void main(String[] argv) {
		NoLocalStatics t = new NoLocalStatics();
		t.process();
	}
	void process() {
		static int a = 42;			// EXPECT COMPILE ERROR
		System.out.println("Process: " + a);
	}
}
//@@@@@@//
//lang/NullStaticMethod.java
//@@@@@@//
/**
 * Test if you can use a null reference to find a static method.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: NullStaticMethod.java,v 1.3 2004/02/23 02:32:36 ian Exp $
 */
public class NullStaticMethod {
	public static void main(String[] argv) {
		System.out.println("XXX ");
		NullStaticMethod2 x = null;
		x.invoke();			// EXPECT COMPILE WARNING
	}
}
//@@@@@@//
//lang/NullStaticMethod2.java
//@@@@@@//
/**
 * Test if you can use a null reference to find a static method.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: NullStaticMethod2.java,v 1.2 2004/02/09 03:33:54 ian Exp $
 */
public class NullStaticMethod2 {
	public static void invoke() {
		System.out.println("Invoked even though null");
	}
}
//@@@@@@//
//lang/Overall.java
//@@@@@@//
// The Overall Structure of a Java Class

//package com.acme.stuff;

import java.util.Calendar;

public class Overall extends Object implements Fun, Action {

	int num;		// object-wide data
	float tmp;		// (each X object has own num, tmp)

	public Overall() {	// Constructor - same name as class
		// initializations...
	}

	public int abc() {		// ordinary method
		int i;					// local data
		int answer = 0;
		for (i=0; i<num; i++) {
			// compute answer
		}
		return answer;
	}

	Calendar xyz;				// other object-wide data

	public void def() {
		// more computation, presumably using xyz
	}
}

// Stuff below here is just to get this to compile.

interface Fun {
}
interface Action {
}
//@@@@@@//
//lang/OverLoad.java
//@@@@@@//
/**
 * OverLoad demonstrates method overloading
 */
public class OverLoad {
	static void myfunc(int x, int y) {
		System.out.println("x = "+x+", y = "+y);
	}
	static void myfunc(int x) {
		myfunc(x, 100);		// same as "OverLoad.myfunc(x, 100);"
	}
	public static void main(String[] argv) {
		myfunc(24,24);
		myfunc(24);
	}
}
//@@@@@@//
//lang/OverLoadReturn.java
//@@@@@@//
/** Can you overload a method to have two different return types?
 */
public class OverLoadReturn {
	public static void main(String[] a) {
		System.out.println("Hello. Why did you call me up?");
		OverLoadReturn r = new OverLoadReturn();
		int i = method();
		String s = method();	// EXPECT COMPILE ERROR
	}

	static int method() {
		System.out.println("In int method");
		return 0;
	}

	static String method(String input) {	// THIS WORKS
		System.out.println("In String method(String)");
		return input;
	}

	static String method() {				// EXPECT COMPILE ERROR
		System.out.println("In String method");
		return null;
	}
}
//@@@@@@//
//lang/OverRide.java
//@@@@@@//
/** Demonstration of overriding, from Chapter 7. */
public class OverRide {
	public static void main(String[] av) {
		System.out.println("Calling an A's version of xyz");
		new AAA().xyz();
		System.out.println("Calling a B's version of xyz");
		new BBB().xyz();
	}
}

class AAA {
	void xyz() {
		System.out.println("In AAA.xyz");
	}
}

class BBB extends AAA {
	void xyz() {
		System.out.println("In BBB.xyz");
		super.xyz();
	}
}
//@@@@@@//
//lang/OverrideField.java
//@@@@@@//
/** Demonstration of overriding fields. */
public class OverrideField {
	public static void main(String[] av) {
		System.out.println("OA's version of getAttr returns: " +
			new OA().getAttr());
		System.out.println("OB's version of getAttr returns: " +
			new OB().getAttr());
		// Declared as OA, instantiated as OB, so gets OB's version of things.
		OA c = new OB();
		System.out.println("C's version of getAttr returns: " +
			c.getAttr());
	}
}

class OA {
	final int attr = 1;
	int getAttr() {
		System.out.println("In OA.getAttr");
		return attr;
	}
}

class OB extends OA {
	final int attr = 2;
	int getAttr() {
		System.out.println("In OB.getAttr");
		super.getAttr(); // Just to show flow of control
		return attr;
	}
}
//@@@@@@//
//lang/PartialImplements.java
//@@@@@@//
// Can we implement part of an interface?

interface X {
	public void a();
	public void b();
}

abstract class AA implements X {
	public void a() {}
}

class BB extends AA {
	public void b()  {}
}
//@@@@@@//
//lang/PrivProt.java
//@@@@@@//
/** Member modifier "private protected" is now gone from the language!
 * This class proves it: modern Java compilers must reject this file.
 */
class PrivProt0 {
	private protected int a;	// EXPECT COMPILE ERROR
	public int b;

	PrivProt0(int ia, int ib) {
		a = ia; b = ib;
	}
}

public class PrivProt {
	public static void main(String[] s) {
		PrivProt0 a = new PrivProt0(2,4);
		int x = a.a;			// EXPECT COMPILE ERROR
		int y = a.b;
		System.out.println("Here they are: "+x+','+y);
	}
}
//@@@@@@//
//lang/Protected.java
//@@@@@@//
// package x;

/**
 * Check what "protected" really means: can we see into a proteced
 * attribute of another class in the same package as us?
 */
public class Protected {
	public static void main(String[] argv) {
		System.out.println("Protected values demo");
		Protected p = new Protected();
		p.process();
	}
	void process() {
		Protected2 p2 = new Protected2();	// can we spy into this?
		System.out.println("Process: " + p2.dat);
		p2.foo();
	}
}
//@@@@@@//
//lang/Protected2.java
//@@@@@@//
// package x;

/** This class is in the same package as Protected above.
 * If this compiles, it means that "protected" DOES allow access to
 * other classes in the same package (and it does, on JDK1.1.x).
 * Note that JDK1.0 had "private protected" for this purpose, but
 * JDK1.1 does not.
 */
class Protected2 {
	/** A protected datum: can we see it from Protected1? */
	protected int dat = 42;	
	/** A protected method: can we call it from Protected1? */
	protected void foo() {
		System.out.println("In a Protected2 object's foo() method.");
	}
}
//@@@@@@//
//lang/ProtectedClass.java
//@@@@@@//
/** Can you have such a thing as a protected class?
 */
package foo;

import java.util.Date;

protected class ProtectedClass {		// EXPECT COMPILE ERROR
	public static void main(String[] a) {
		System.out.println("It seems you CAN have a protected class");
	}
}
//@@@@@@//
//lang/RefValues.java
//@@@@@@//
import java.util.*;

/** 
 * RefValues - program to show Reference values vs scalars.
 */
public class RefValues {

	public static void main(String[] argv) {
		RefValues ref = new RefValues();
	}

	public RefValues() {
		long longValue = 420;
		GregorianCalendar d1 = new GregorianCalendar(1971,04,24);

		System.out.println("Before demoMethod, long = " + longValue + 
			" Year = " + d1.get(Calendar.YEAR));

		demoMethod(longValue, d1);

		System.out.println("After  demoMethod, long = " + longValue + 
			" Year = " + d1.get(Calendar.YEAR));
		if (d1 == null) {	/* "can't happen" */
			System.err.println("demoMethod changed my date obj!");
			return;
		}
	}

	public void demoMethod(long myLong, GregorianCalendar myCal) {
		myLong = 24;		// does not affect main.longValue
		myCal.set(Calendar.YEAR, 1999);  // DOES affect main's d1
		myCal = null;		// no affect on main's d1
	}

}
//@@@@@@//
//lang/ReturnType.java
//@@@@@@//
/**
 * Simple Hello World demo program.
 */
public class ReturnType {

	int idemo() {
		return 4;
	}
	String demo() {
		return "Goodbye world";
	}

	void doTheWork() {
		String d = demo();	// assigns "Goodbye cruel world" to d
		// int e = demo();		// EXPECT COMPILE ERROR
		int e = idemo();		// Get it right
		System.out.println("d="+d);
		System.out.println("e="+e);
	}

	public static void main(String[] a) {
		new ReturnType().doTheWork();
	}
}
//@@@@@@//
//lang/Shifting.java
//@@@@@@//
/**
 //+
 * Show some effects of shifting on ints and longs
 //-
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Shifting.java,v 1.3 2004/02/09 03:33:54 ian Exp $
 */
public class Shifting {
	public static void main(String[] argv) {
		//+
		System.out.println(" 2<<4 = " + (2<<4));
		System.out.println(" 2<<8 = " + (2<<8));
		System.out.println("2<<16 = " + (2<<16));
		System.out.println("2<<24 = " + (2<<24));
		System.out.println("2<<31 = " + (2<<31));
		System.out.println("2<<32 = " + (2<<32));

		// Now try those last two as longs
		System.out.println("2<<31 = " + ((long)2<<31));
		System.out.println("2<<32 = " + ((long)2<<32));
		//-
	}
}
//@@@@@@//
//lang/ShortsVsInts.java
//@@@@@@//
public class ShortsVsInts {
	public static void main(String[] unused) {
		short i,j;
		i = 30;
		j = ++i;	// works
		j += 1;		// works
		j += 32768;	// compiles; truncates at run time!
		System.out.println(j);
		System.out.println(Short.MAX_VALUE);
		//j = j + 1;	// won't compile
	}
}
//@@@@@@//
//lang/ShowInitializers.java
//@@@@@@//
/** Just show use of initializers, and which ones need to be initialized. */
public class ShowInitializers {
		int quantity;		// defaults to zero
		int value = 0;		// better style?
		void setValue() {
			int rate;		// un-initialized by default
			doSomethingWith(rate);	// EXPECT COMPILE ERROR
		}

		/** This method is not shown in the course notes.
		 * It doesn't do anything with its input. 
		 */
		public void doSomethingWith(int r) {
		}
}
//@@@@@@//
//lang/ShowToString.java
//@@@@@@//
import java.util.*;
import java.awt.Button;

/**
 * ShowToString -- demo program to show default toString methods.
 * Some classes provide a toString() method, while others inherit
 * the default toString() from Object. In all cases, you can print
 * an object by calling its toString(), which is very useful in debugging!
 */
public class ShowToString {

	/** main method */
	public static void main(String[] argv) {

		System.out.println("An Object\t" + new Object());
		System.out.println("A Date  \t" + new Date());
		System.out.println("A GregorianCalendar\t" + new GregorianCalendar());
		System.out.println("An Exception\t" + new Exception("Hi!"));
		Button b = new Button("Push ME!");	// An AWT pushbutton
		b.setBounds(40, 50, 120, 60);	// explained in the AWT chapter!
		System.out.println("A Button\t" + b);
		System.out.println("A ShowToString object!\t" + new ShowToString());
	}
}
//@@@@@@//
//lang/StackTrace.java
//@@@@@@//
/**
 * Every "Exception" (or subclass) object contains a "stackTrace", or
 * traceback, meant to indicate where the error occurred.
 *
 * Let's find out where a stackTrace comes from, and how to use it, when
 * exceptions are created and thrown. Some textbooks claim that it is
 * the operation of constructing the exception that anchors its trace,
 * others the throwing. Let us see for ourselves.
 */
public class StackTrace {

	IllegalArgumentException ex;

	public static void main(String[] argv) {
		StackTrace st = new StackTrace();
		st.makeit();
		System.out.println("CONSTRUCTED BUT NOT THROWN");
		st.ex.printStackTrace();	
		st.throwit();
		// MAY BE NOTREACHED - THINK ABOUT IT!
		System.out.println("CONSTRUCTED BUT NOT THROWN");
		st.ex.printStackTrace();
	}

	public void makeit() {
		ex = new IllegalArgumentException("Don't like the weather today");
	}
	public void throwit() throws IllegalArgumentException {
		throw ex;
	}
}
//@@@@@@//
//lang/StaticIniDemo.java
//@@@@@@//
/**
 * Show static initializers. These are run when the class is loaded.
 * If you run the main program here, you will see the static
 * initializer before the "About to load class", since the class
 * is loaded before main gets run. If you copy the guts of main into
 * another class, the messages will come out in the "expected" order.
 *
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: StaticIniDemo.java,v 1.5 2004/02/09 03:33:54 ian Exp $
 */
public class StaticIniDemo {

	/** A static initializer - called when class is loaded. */
	static {
		System.out.println("In static initializer");
	}

	/** A constructor -- called when object is instantiated. */
	public StaticIniDemo() {
		System.out.println("In Constructor");
	}

	public static void main(String[] a) {
		try {
			System.err.println("About to load class");
			Class c = Class.forName("StaticIniDemo");
			System.err.println("About to construct instance");
			Object sd = c.newInstance();
			System.err.println("Object is " + sd);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
//@@@@@@//
//lang/Switch.java
//@@@@@@//
public class Switch {
	static short s;
	static int   i;
	static long  L;
	public static void main(String[] args) { 
		switch(s) {
			case 0: System.out.println(s);
		}
		switch(i) {
			case 0: System.out.println(i);
		}
		switch(L) {		// EXPECT COMPILER ERROR
			case 0: System.out.println(L);
		}
	}
}
//@@@@@@//
//lang/SwitchByte.java
//@@@@@@//
public class SwitchByte {
	void voo() {
		byte x = bar();
		switch(x) {
			case 1000: 	// EXPECT COMPILE ERROR
				System.exit(1000); break;
			default: System.exit(0); break;
		}
	}

	byte bar() {
		return 1000;	// EXPECT COMPILE ERROR
	}
}
//@@@@@@//
//lang/ThrowsUnchecked.java
//@@@@@@//
/** What happens if a method declares an unchecked exception?
 * Some people seem to think that declaring a method in a throws
 * clause is what makes it "checked". As we see here, this is not
 * the case; checked-ness has only to do with an exception's place
 * in Java's class inheritance hierarchy.
 */
public class ThrowsUnchecked {

	public static void main(String[] argv) {
		new ThrowsUnchecked().doTheWork();
	}

	/** This method demonstrates calling a method that might throw
	 * an exception, and catching the resulting exception.
	 */
	public void doTheWork() {
		String s = " 42";
		int i = testit(s);	// Note: compiles with no try/catch.
		System.out.println("parseit(" + s + ") returned " + i);
	}

	/** Model of a method that might throw an unchecked exception.
	 * @exception	NumberFormatException	if called with value 1.
	 */
	public int testit(String input) throws NumberFormatException {
		return Integer.parseInt(input);
	}
}
//@@@@@@//
//lang/ToString.java
//@@@@@@//
/**
 * ToString -- demo program to show a toString method.
 */
public class ToString {
	int value;

	ToString() {
		value = 0;
	}
	ToString(int it) {
		value = it;
	}
	public String toString() {
		return "-->" + value + "<--";
	}

	public static void main(String[] argv) {
		ToString s = new ToString(123);

		System.out.println("Hello, World of Java");
		System.out.println("My object is" + s);
	}
}
//@@@@@@//
//lang/TryStealingInnerClass.java
//@@@@@@//
import java.awt.event.*;

// This file is to show what happens if you try to access an inner class
// created in another class. Here we try to steal ButtonDemo2.java's
// inner class named MyActionListener. You will find that you can't,
// since it has no visible constructor!

class ButtonDemo2 {
	// Create an inner class which may be named ButtonDemo2$1
	Object o = new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
			}
	};
}

public class TryStealingInnerClass {
	public static void main(String[] a) {
		new TryStealingInnerClass().doIt();
	}
	public void doIt() {
		Object o = new ButtonDemo2$1$();	// EXPECT COMPILE ERROR
		System.out.println(o.toString());
	}
}
//@@@@@@//
//lang/TwoStrings.java
//@@@@@@//
/**
 * See if Strings are shared in Java.
 * The thing is, it depends on whether you say 
 * "string" or new String("mystring");
 */
public class TwoStrings {
	public static void main(String[] argv) {
		String one = "A String";
		String two = "A String";
		String three = new String(one);
		compare(one, two);
		compare(two, three);
	}
	public static void compare(String one, String two) {
		System.out.println("Comparing...");
		if (one == two) {
			System.out.println("Strings are shared: " +
				one.hashCode() + ", " + two.hashCode());
		} else if (one.equals(two)) {
			System.out.println("At least the strings are equal: " +
				one.hashCode() + ", " + two.hashCode());
			System.out.println((Object)one);
			System.out.println(two);
		} else System.out.println("This is rather distressing, sir.");
		System.out.println();
	}
}
//@@@@@@//
//lang/Unnamed.java
//@@@@@@//
/** Can a class in a package access a class in the unnamed package? 
 * Answer: depends on the JDK. 1.3: yes. 1.4: no.
 * See http://java.sun.com/j2se/1.4/compatibility.html, item 8.
 */

package x;

import Unnamed1;	// EXPECT COMPILE ERROR (1.4 or later)

public class Unnamed {
	public static void main(String[] args) {
		System.out.println(new Unnamed1());
	}
}
//@@@@@@//
//lang/Unnamed1.java
//@@@@@@//
/**
 * Can a class in a package access a class in the unnamed package?
 */

public class Unnamed1 {
	public String toString() {
		return "This is from a class in the unnamed package";
	}
}
//@@@@@@//
//lang/UsePackage.java
//@@@@@@//
import com.darwinsys.ianstuff.*;

/** Demo program using classes from a package. */
public class UsePackage {
	public static void main(String[] argv) {
		UPX x = new UPX();
		UPY y = new UPY();
		System.out.println("We have constructed two objects:");
		System.out.println(x);
		System.out.println(y);
	}
}
//@@@@@@//
//lang/UseThis.java
//@@@@@@//
// This shows off the uses of "this". It is a non-public class
// just so the file name UseThis doesn't have to be the class name
// (some students found "This" in the class name confusing in this example).
class MyClass {
	final static int MAXX=640, MAXY=480;	// low-res (VGA)
	int x, y;				// current location
	/** Construct a MyClass with x and y values */
	MyClass(int x, int y) {
		this.x = x;
		this.y = y;
        }
	/** Construct a MyClass with default values */
	MyClass() {
		this(MAXX/2, MAXY/2);   // Use the constructor above
        }

	public String toString() {
		return "[" + x + "," + y + "]";
	}

	/** Test main program */
	public static void main(String[] av) {
		System.out.println(new MyClass(300,100));
		System.out.println(new MyClass());
	}
}
//@@@@@@//
//lang/VarArgsDemo.java
//@@@@@@//
import java.io.PrintStream;
import java.util.Date;

/**
 * VarArgsDemo - show 1.5 variable arguments
 * @author ian
 * @version $Id: VarArgsDemo.java,v 1.1 2004/03/07 16:35:13 ian Exp $
 */
public class VarArgsDemo {

	public static void main(String[] args) {
		process(System.out, "Hello", "Goodbye");
		process(System.out, 42, 1066, 1776);
		process(System.out, "Foo", new Date(), new Object());
	}
	static void process(PrintStream out, Object ... args) {
		line();
		for (int i = 0; i < args.length; i++){
			out.println("Argument " + i + " is " + args[i]);
		}
	}
	static void process(PrintStream out, int ... args) {
		for (int i = 0; i < args.length; i++){
			out.println("Argument " + i + " is " + args[i]);
		}
	}
	private static void line() {
		System.out.println("--------------------------");
	}
}
//@@@@@@//
//lang/Visibility.java
//@@@@@@//
public class Visibility {
	final int i = 42;
	void method1() {
		// int i = 13;				// would conflict with line below
		for (int i=0; i<10; i++)	// does not corrupt object's i
			// for (int i=0; i<3; i++) // not allowed, use j
				System.out.println("i = " + i);	// prints 0, 1, ...
		System.out.println("i = " + i);		// prints 42
	}
}
//@@@@@@//
//native1.1/HelloWorld.java
//@@@@@@//
/**
 * A trivial class to show Java Native Interface 1.1 usage from Java.
  */
public class HelloWorld {
  int myNumber = 42; // used to show argument passing

  // declare native class
  public native void displayHelloWorld();

  // Application main, call its display method
  public static void main(String[] args) {
    System.out.println("HelloWorld starting; args.length="+
                       args.length+"...");
    for (int i=0; i<args.length; i++)
                       System.out.println("args["+i+"]="+args[i]);
    HelloWorld hw = new HelloWorld();
    hw.displayHelloWorld();// call the native function
    System.out.println("Back in Java, \"myNumber\" now " + hw.myNumber);
  }

  // Static code blocks are executed once, when class file is loaded
  static {
    System.loadLibrary("hello");
  }
}
//@@@@@@//
//native1.1/Test.java
//@@@@@@//
public class Test {
	public static void main(String[] args) {
		int[] x = null;
		x[42]++;
	}
}
	
//@@@@@@//
//NETWatch/NetFrame.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;
import java.util.*;

/** Main GUI component for the NetWatch program.
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @version	$Id: NetFrame.java,v 1.5 2004/02/09 03:33:41 ian Exp $
 * Copyright (c) 2000, Ian F. Darwin. See LEGAL.NOTICE for licensing.
 */
public class NetFrame extends JFrame {
	Properties props;
	Container cp;
	JDialog propsDialog;

	/** Constructor */
	public NetFrame(String title, Properties p) {
		super(title);

		props = p;
		cp = getContentPane();

		JMenuBar jb = new JMenuBar();
		JMenu jm;
		JMenuItem mi;

		// FILE MENU
		jb.add(jm = new JMenu("File"));
		jm.add(mi = new JMenuItem("Exit"));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.exit(0);
			}
		});

		// VIEW MENU
		jb.add(jm = new JMenu("Edit"));
		jm.add(mi = new JMenuItem("Properties..."));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (propsDialog == null) {
					propsDialog = new ProtoDialog(NetFrame.this, "Properties");
				}
				propsDialog.setVisible(true);
				// TODO fetch protocol

			}
		});

		// HELP MENU
		jb.add(jm = new JMenu("Help"));
		jm.add(mi = new JMenuItem("About"));
		mi.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				JOptionPane.showMessageDialog(NetFrame.this,
					"NetWatch Application -- $Version$\n" +
					"Copyright (c) 2000 Ian F. Darwin\n" +
					"See LEGAL.NOTICE for licensing.",
					"RMIWatch",
					JOptionPane.INFORMATION_MESSAGE);
			}
		});
		this.setJMenuBar(jb);

		cp.setLayout(new GridLayout(0,1));
	}

	/** CONSTRUCT PANELS, ONE FOR EACH HOST. */
	protected void addHost(String hostName, Properties props) {
		cp.add(new RMIPanel(hostName, props));

		// If asked for ncolumns, make it so.
		// Else If it got too tall, make it multi columns.
		String nc = props.getProperty("netwatch.gui.columns");
		if (nc != null) {
			int n = Integer.parseInt(nc);
			cp.setLayout(new GridLayout(0, n));
		} else if (cp.getComponents().length > 12)
			cp.setLayout(new GridLayout(0,3));
		else if (cp.getComponents().length > 6)
			cp.setLayout(new GridLayout(0,2));
	}
}
//@@@@@@//
//NETWatch/NetPanel.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import java.net.*;
import java.rmi.*;
import java.util.*;

/** Displays one machines status.
 * Part of the NetWatch program: watch the network
 * on a bunch of machines (i.e., in a classroom or lab).
 * <P>Each non-abstract subclass just needs to implement run(),
 * which must, in a while (!done) loop:
 * <UL><LI>Try to contact the host
 * <LI>call setState(); (argument below)
 * <LI>call ta.setText();
 * <LI>Thread.sleep(sleepTime * MSEC);
 * </UL>
 * <P>The argument to setState() must be one of:
 * <UL>
 * <LI>FINE == Server has "expect"ed name registered.
 * <LI>DUBIOUS == Server does not have expected name registered.
 * <LI>EMPTY == Server has nothing registered.
 * <LI>NOREG == host is up but not running RMI
 * <LI>DOWN == host unreachable, not responding, ECONN, etc.
 * </UL>
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * Copyright (c) 2000, Ian F. Darwin. See LEGAL.NOTICE for licensing.
 * @version	$Id: NetPanel.java,v 1.4 2004/03/14 00:17:03 ian Exp $
 */
public abstract class NetPanel extends JPanel implements Runnable {
	/** The name of this host */
	protected String hostName;
	/** The text area to display a list of stuff */
	protected JTextArea ta;
	/** Properties, passed in to constructor */
	protected Properties props;
	/** Default sleep time, in seconds. */
	protected static int DEFAULT_SLEEP = 30;
	/** Sleep time, in seconds. */
	protected int sleepTime = DEFAULT_SLEEP;
	/** Conversion */
	protected int MSEC = 1000;
	/** The constant-width font, shared by all instances. */
	protected static Font cwFont;
	/** The states */
	/** The state for: has "expect"ed name registered. */
	protected final static int FINE = 1; 
	/** The state for: does not have expected name registered. */
	protected final static int DUBIOUS = 2;
	/** The state for: Server has nothing registered. */
	protected final static int EMPTY = 3;
	/** The state for: host is up but not running RMI */
	protected final static int NOREG = 4;
	/** The state for: host unreachable, not responding, ECONN, etc. */
	protected final static int DOWN = 5;
	/** The color for when a machine is FINE */
	protected static final Color COLOR_FINE = Color.green;
	/** The color for when a machine is DUBIOUS */
	protected static final Color COLOR_DUBIOUS = Color.yellow;
	/** The color for when a machine is EMPTY */
	protected static final Color COLOR_EMPTY = Color.white;
	/** The color for when a machine has NOREG */
	protected static final Color COLOR_NOREG = Color.red;
	/** The color for when a machine is NOREG */
	protected static final Color COLOR_DOWN = Color.black;

	/** State of the monitored hosts RMI registry, up or down.
	 * Initially set 0, which isnt one of the named states, to
	 * force the background color to be set on the first transition.
	 */
	protected int state = 0;
	
	public NetPanel(String host, Properties p) {
		hostName = host;
		props = p;
		String s = props.getProperty("rmiwatch.sleep");
		if (s != null)
			sleepTime = Integer.parseInt(s);
		// System.out.println("Sleep time now " + sleepTime);

		// Maybe get font name and size from props?
		if (cwFont == null)
			cwFont = new Font("lucidasansTypewriter", Font.PLAIN, 10);

		// Gooey gooey stuff.
		ta = new JTextArea(2, 26);
		ta.setEditable(false);
		ta.setFont(cwFont);
		add(BorderLayout.CENTER, ta);
		setBorder(BorderFactory.createTitledBorder(hostName));

		// Sparks. Ignition!
		new Thread(this).start();
	}

	boolean done = false;
	/** Stop this Thread */
	public void stop() {
		done = true;
	}

	/** Record the new state of the current machine.
	 * If this machine has changed state, set its color
	 * @param newState - one of the five valid states in the introduction.
	 */
	protected void setState(int newState) {
		if (state /*already*/ == newState)
			return;		// nothing to do.
		switch(newState) {
			case FINE:		// Server has "expect"ed name registered.
				ta.setBackground(COLOR_FINE);
				ta.setForeground(Color.black);
				break;
			case DUBIOUS:	// Server does not have expected name registered.
				ta.setBackground(COLOR_DUBIOUS);
				ta.setForeground(Color.black);
				break;
			case EMPTY:		// Server has nothing registered.
				ta.setBackground(COLOR_EMPTY);
				ta.setForeground(Color.black);
				break;
			case NOREG:		// host is up but not running RMI
				ta.setBackground(COLOR_NOREG);
				ta.setForeground(Color.white);
				break;
			case DOWN:		// host unreachable, not responding, ECONN, etc.
				ta.setBackground(COLOR_DOWN);
				ta.setForeground(Color.white);
				break;
			default:
				throw new IllegalStateException("setState("+state+") invalid");
			}
		state = newState;
	}
}
//@@@@@@//
//NETWatch/NetWatch.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;
import java.util.*;

/** Main program for the NetWatch program: watch the network status
 * on a bunch of machines (i.e., in a classroom or lab). Currently only
 * for RMI, but can be extended for TCP socket, CORBA ORB, etc.
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @version	$Id: NetWatch.java,v 1.7 2004/02/09 03:33:41 ian Exp $
 * Copyright (c) 2000, Ian F. Darwin. See LEGAL.NOTICE for licensing.
 */
public class NetWatch {
	public static void main(String[] argv) {

		Properties p = null;

		NetFrame f = new NetFrame("Network Watcher", p);

		try {
			FileInputStream is = new FileInputStream("NetWatch.properties");
			p = new Properties();
			p.load(is);
			is.close();
		} catch (IOException e) {
			JOptionPane.showMessageDialog(f,
				e.toString(), "Properties error",
				JOptionPane.ERROR_MESSAGE);
		}

		// NOW CONSTRUCT PANELS, ONE FOR EACH HOST.

		// If arguments, use them as hostnames.
		if (argv.length!=0) {
			for (int i=0; i<argv.length; i++) {
				f.addHost(argv[i], p);
			}
		// No arguments. Can we use properties?
		} else if (p != null && p.size() > 0) {
			String net = p.getProperty("netwatch.net");
			int start = Integer.parseInt(p.getProperty("netwatch.start"));
			int end = Integer.parseInt(p.getProperty("netwatch.end"));
			for (int i=start; i<=end; i++) {
				f.addHost(net + "." + i, p);
			}
			for (int i=0; ; i++) {
				String nextHost = p.getProperty("nethost" + i);
				if (nextHost == null)
					break;
				f.addHost(nextHost, p);
			}
		}
		// None of the above. Fall back to localhost
		else {
			f.addHost("localhost", p);
		}

		// All done. Pack the Frame and show it.
		f.pack();
		// UtilGUI.centre(f);
		f.setVisible(true);
		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				System.exit(0);
			}
		});
	}
}
//@@@@@@//
//NETWatch/ProtoDialog.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

public class ProtoDialog extends JDialog {

	JComboBox protoBox, portBox;

	public ProtoDialog(Frame f, String t) {
		super(f, t, true);

		Container cp = getContentPane();
		cp.setLayout(new GridLayout(2,2));
		cp.add(new JLabel("Protocol:", JLabel.RIGHT));
		cp.add(protoBox = new JComboBox());
		protoBox.addItem("Ping");
		protoBox.addItem("RMI");
		protoBox.addItem("CORBA");
		protoBox.addItem("WWW");
		protoBox.setEditable(true);
		cp.add(new JLabel("Port:", JLabel.RIGHT));
		cp.add(portBox = new JComboBox());
		portBox.addItem("0");
		portBox.addItem("1099");
		portBox.addItem("28735");
		portBox.setEditable(true);
		pack();
	}

	public String getProto() {
		return protoBox.getSelectedItem().toString();
	}
	public String getPort() {
		return portBox.getSelectedItem().toString();
	}
	public static void main(String[] args) {
		new ProtoDialog(new Frame("ProtoDialog dummy parent"),
			"ProtoDialog Test").setVisible(true);
	}
}
//@@@@@@//
//NETWatch/RMIPanel.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import java.net.*;
import java.rmi.*;
import java.util.*;

/** Displays one machines status, for RMI..
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * Copyright (c) 2000, Ian F. Darwin. See LEGAL.NOTICE for licensing.
 * @version	$Id: RMIPanel.java,v 1.4 2004/02/09 03:33:41 ian Exp $
 */
public class RMIPanel extends NetPanel implements Runnable {
	
	public RMIPanel(String host, Properties p) {
		super(host, p);
	}

	/** Keep the screen updated forever, unless stop()ped. */
	public void run() {
		String thePort = props.getProperty("rmiwatch.port", "");
		String theURL = "rmi://" + hostName + ":" + thePort;
		while (!done) {
			try {
				String[] names = Naming.list(theURL);
				ta.setText("");
				for (int i=0; i<names.length; i++) {
					ta.append(i + ": " + names[i] + "\n");
				}
				// If we didnt get an exception, host is up.
				String expect = props.getProperty("rmiwatch.expect");
				String fullText = ta.getText();
				if (fullText.length() == 0) {
					ta.setText("(nothing registered!)");
					setState(EMPTY);
				} else if (expect != null && fullText.indexOf(expect)==-1) {
					setState(DUBIOUS);
				} else setState(FINE);
			} catch (java.rmi.ConnectIOException e) {
				setState(DOWN);
				ta.setText("Net error: " + e.detail.getClass());
			} catch (java.rmi.ConnectException e) {
				setState(NOREG);
				ta.setText("RMI error: " + e.getClass().getName() + "\n" +
					"  " + e.detail.getClass());
				// System.err.println(hostName + ":" + e);
			} catch (RemoteException e) {
				setState(NOREG);
				ta.setText("RMI error: " + e.getClass().getName() + "\n" +
					"  " + e.detail.getClass());
			} catch (MalformedURLException e) {
				setState(DOWN);
				ta.setText("Invalid host: " + e.toString());
			} finally {
				// sleep() in "finally" so common "down" states dont bypass.
				// Randomize time so we dont make net load bursty.
				try {
					Thread.sleep((int)(sleepTime * MSEC * 2 * Math.random()));
				} catch (InterruptedException e) {
					/*CANTHAPPEN*/
				}
			}
		}
	}
}
//@@@@@@//
//netweb/ApiSearch.java
//@@@@@@//
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

/*
 * ApiSearch.java -- look up an API name in the api database
 * 
 * @author  Ian Darwin, http://www.darwinsys.com/
 * @version $Id: ApiSearch.java,v 1.2 2004/02/09 03:33:54 ian Exp $
 */
public class ApiSearch extends HttpServlet
{
	/** Set up the Servlet */
	public void init() {
		// Get a database connection?
	}

	/** Called in response to a GET request (data encoded in the URL) */
	public void doGet(HttpServletRequest req, HttpServletResponse resp)
		throws ServletException, IOException {

		resp.setContentType("text/html");
		PrintWriter out = resp.getWriter(); 

		// logic code and main HTML goes here.

		// Forward to "apisearchresults.jsp"
	}

	/** Called in response to a POST request (data unencoded on the socket) */
	public void doPost(HttpServletRequest req, HttpServletResponse resp)
		throws ServletException, IOException {

		doGet(req, resp);
	}
}
//@@@@@@//
//netweb/Browser0.java
//@@@@@@//
import java.net.*;
import java.io.*;

/**
 * Browser0 - Get the contents of a URL, write to stdout
 */
public class Browser0 {
	public static void main(String[] av) {
		new Browser0(av);
	}

	Browser0(String av[]) {
		String loc = null;
		String data = null;
		switch(av.length) {
			case 0: loc = "http://localhost/"; break;
			case 1: loc = av[0]; break;
			default:
				System.err.println("Usage: getFromURL [url]");
				System.exit(1);
		}
		try {
			URL Web = new URL(loc);
			BufferedReader is = new BufferedReader(
				new InputStreamReader(
				Web.openStream()));
			String line;
			while ((line = is.readLine()) != null)
				System.out.println(line);
			is.close();
		} catch (MalformedURLException e) {
			System.out.println("MalformedURLException: " + e);
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		if (data != null)
			System.out.println("Data " + data);
	}
}
//@@@@@@//
//netweb/Browser1.java
//@@@@@@//
import java.awt.*;
import java.net.*;
import java.io.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.text.html.*;

/**
 * Browser1 - Get the contents of a URL, write to stdout
 */
public class Browser1 {
	public static void main(String[] av) {
		new Browser1(av);
	}

	JEditorPane p;

	Browser1(String av[]) {
		String loc = null;
		String data = null;
		switch(av.length) {
			case 0: loc = "http://localhost/"; break;
			case 1: loc = av[0]; break;
			default:
				System.err.println("Usage: getFromURL [url]");
				System.exit(1);
		}
		try {
			URL Web = new URL(loc);
			p = new JEditorPane(Web);
			JFrame jf = new JFrame("HTML");
			p.setContentType("text/html");
			p.addHyperlinkListener(new Hyperactive());
			p.setEditable(false);
			Container cp = jf.getContentPane();
			cp.add(BorderLayout.NORTH, p);
			jf.pack();
			jf.setVisible(true);
		} catch (MalformedURLException e) {
			System.out.println("MalformedURLException: " + e);
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
		if (data != null)
			System.out.println("Data " + data);
	}
	class Hyperactive implements HyperlinkListener {

		public void hyperlinkUpdate(HyperlinkEvent e) {
			if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
				JEditorPane pane = (JEditorPane) e.getSource();
				if (e instanceof HTMLFrameHyperlinkEvent) {
					HTMLFrameHyperlinkEvent  evt = (HTMLFrameHyperlinkEvent)e;
					HTMLDocument doc = (HTMLDocument)pane.getDocument();
					doc.processHTMLFrameHyperlinkEvent(evt);
				} else {
					try {
						pane.setPage(e.getURL());
					} catch (Throwable t) {
						t.printStackTrace();
					}
				}
			}
		}
	}
}
//@@@@@@//
//netweb/FileToURL.java
//@@@@@@//
import java.io.File;

/** Convert a filename to a URL using the Java 2 java.io.File.toURL()
 */
public class FileToURL
{
	public static void main(String[] argv)
	throws java.net.MalformedURLException {
		java.net.URL u = new File("GetResource.java").toURL();
		System.out.println(u);
	}
}
//@@@@@@//
//netweb/GetResource.java
//@@@@@@//
public class GetResource {
	public static void main(String[] argv) {
		Class c = GetResource.class;
		java.net.URL u = c.getResource("GetResource.java");
		System.out.println(u);
	}
}
//@@@@@@//
//netweb/GetURLs.java
//@@@@@@//
import java.io.*;
import java.net.*;
import java.util.*;

public class GetURLs {
	/** The tag reader */
	ReadTag reader;

	public GetURLs(URL theURL) throws IOException {
		reader = new ReadTag(theURL);
	}

	public GetURLs(String theURL) throws MalformedURLException, IOException {
		reader = new ReadTag(theURL);
	}

	/* The tags we want to look at */
	public final static String[] wantTags = {
		"<a ", "<A ",
		"<applet ", "<APPLET ",
		"<img ", "<IMG ",
		"<frame ", "<FRAME ",
	};

	public ArrayList getURLs() throws IOException {
		ArrayList al = new ArrayList();
		String tag;
		while ((tag = reader.nextTag()) != null) {
			for (int i=0; i<wantTags.length; i++) {
				if (tag.startsWith(wantTags[i])) {
					al.add(tag);
					continue;		// optimization
				}
			}
		}
		return al;
	}

	public void close() throws IOException {
		if (reader != null) 
			reader.close();
	}
	public static void main(String[] argv) throws 
			MalformedURLException, IOException {
		String theURL = argv.length == 0 ?
			"http://localhost/" : argv[0];
		GetURLs gu = new GetURLs(theURL);
		ArrayList urls = gu.getURLs();
		Iterator urlIterator = urls.iterator();
		while (urlIterator.hasNext()) {
			System.out.println(urlIterator.next());
		}
	}
}
//@@@@@@//
//netweb/ImageIndex.java
//@@@@@@//
import java.io.*;
import java.util.*;

import com.darwinsys.util.FileProperties;

/** ImageIndex -- make an index.html for an image directory
 * based on some images and a "captions.txt" file.
 * <pre>
 * For each image x, assume there is the following:
 *		a file x+THUMB_SUFFIX which is the thumbnail
 * 		a file x+IMAGE_SUFFIX which is the large image
 *		an entry in the "captions.txt" file, of the form
 *			x	Group shot in front of statue
 * <pre>
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @Version $Id: ImageIndex.java,v 1.5 2004/02/09 03:33:55 ian Exp $
 */
public class ImageIndex {
	protected String image_suffix;
	protected String thumb_suffix;
	/** The captions file (created by hand) */
	public static final String CAPTIONS_FILE = "captions.txt";
	/** A reader for the captions file */
	protected BufferedReader cap;
	/** The map from filename to caption */
	protected HashMap map = new HashMap();
	/** Vector for listing names for sorting */
	Vector names = new Vector();
	/** The output file that we create */
	public static final String OUTPUTFILE = "index.html";
	/** The main output stream */
	PrintWriter out;
	/** Properties */
	Properties pprops;
	/** Properties file */
	String PROPS_FILE = "ImageIndex.properties";

	/** The background color for the page */
	public String bgcolor;
	/** The title of this show */
	String title;

	/** Make an index */
	public static void main(String[] av) {
		ImageIndex mi = new ImageIndex();
		try {
			mi.open(CAPTIONS_FILE, OUTPUTFILE);		// open files
			mi.read();		// read caption file
			mi.BEGIN();		// print HTML header
			mi.process();		// do bulk of work
			mi.END();		// print trailer.
			mi.close();		// close files
		} catch (IOException e) {
			System.err.println(e);
		}
	}

	/** Open the files */
	void open(String captions, String outFile) throws IOException {
		cap = new BufferedReader(new FileReader(captions));
		out = new PrintWriter(new FileWriter(outFile));
		pprops = new FileProperties(PROPS_FILE);
		title = pprops.getProperty("title");
		thumb_suffix = pprops.getProperty("thumb_suffix");
		image_suffix = pprops.getProperty("image_suffix");
	}

	/** read the captions file */
	void read() throws IOException {

		String line;
		while ((line = cap.readLine()) != null) {
			StringTokenizer st = new StringTokenizer(line, "\t");
			String name = st.nextToken();
			String desc = st.nextToken();
			names.addElement(name);
			map.put(name, desc);
		}
		cap.close();
	}

	/** Write the HTML headers */
	void BEGIN() {
		println("<HTML>");
		println("<HEAD>");
		println("    <META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">");
		println("    <META NAME=\"GENERATOR\" CONTENT=\"Java ImageIndex\">");
		println("    <TITLE>" + title + "</TITLE>");
		println("</HEAD>");
		println("<BODY BGCOLOR=\"" + pprops.get("bgcolor") + "\">");
		println("<H1>" + title + "</H1>");
		println("<P>All files are Copyright &copy;: All rights reserved.");
		println("</P>");
		println("<HR>");
	}

	/** Do the bulk of the work */
	void process() {

		System.out.println("Generating HTML...");
		println("<table>");

		String fn;
		for (int i=0; i<names.size(); i++) {
			fn = (String)names.elementAt(i);
			mkLink(fn, (String)map.get(fn));
		}
		println("</table>");
		System.out.println("*** process - done ***");
	}

	void mkLink(String href, String descrip) {
		// System.out.println(href + "==>" + descrip);
		String thumbnail = href + thumb_suffix;
		String image = href + image_suffix;
		print("<tr><td>");
		print("<a href=\"" + image + "\">");
		print("<img src=\"" + thumbnail + "\"></a>");
		print("</td><td>");
		print("<a href=\"" + image + "\">");
		print(descrip + "</a>");
		print("</td></tr>");
		println();
	}

	/** Write the trailers and a signature */
	void END() {
		System.out.println("Finishing the HTML");
		println("</UL>");
		println("<P>This file generated by the Java program ");
		print("<A HREF=\"ImageIndex.java\">ImageIndex</A> at ");
		println(new Date().toString());
		println("</P>");
		println("</BODY>");
		println("</HTML>");
	}

	/** Close open files */
	void close() {
		System.out.println("Closing output files...");
		if (out != null)
			out.close();
	}

	/** Convenience routine for out.print */
	void print(String s) {
		out.print(s);
	}

	/** Convenience routine for out.println */
	void println(String s) {
		out.println(s);
	}

	void println() {
		out.println();
	}

}
//@@@@@@//
//netweb/JScript.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import netscape.javascript.*; 

/* An Applet to perform JavaScript directly.
 * The import of netscape.javascript.* requires a JAR file.
 * EXPECT COMPILE ERROR unless you have the Netscape JAR file.
 * This may be e.g., $NETSCAPEHOME/java/classes/java40.jar.
 * The use of JavaScript requires <applet ... mayscript="true">
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @author Roger Goudarzi -- provided background information.
 * @version $Id: JScript.java,v 1.6 2004/02/16 02:44:14 ian Exp $
 */
public class JScript extends java.applet.Applet {
	JSObject jsObject;

	public void init() {
		jsObject = JSObject.getWindow(this);
		Button b = new Button("CLOSE BROWSER");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				jsObject.eval("window.close()");
			}
		});
		add(b);
	}
}
//@@@@@@//
//netweb/LinkButton.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.util.*;

/** Synthetic button, not using Native toolkit. This is slightly fancier
 * than the XButton* classes, but still does not do everything you
 * might want in a button. It does both support actionListeners AND
 * have a TARGET URL that it jumps to (after notifying the actionListeners).
 *
 * @author	Copyright 1995, 1997 Ian F. Darwin,
 * <A HREF="mailto:http://www.darwinsys.com/">http://www.darwinsys.com/</A>,
 * <A HREF="http:www.darwinsys.com/">http://www.darwinsys.com</A>.
 * @version	$Id: LinkButton.java,v 1.2 2004/02/09 03:33:55 ian Exp $
 */
public class LinkButton extends Applet implements MouseListener {
	/** The label that is to appear in the button */
	protected String label = null;
	/** The name of the image */
	protected String imName = null;
	/** The Image to display in the button */
	protected Image im;
	/** The width and height, based on the Image */
	protected int width, height;
	/** The list of ActionListeners. Usually short, so a Vector is fine.
	 * TODO use new AwtMulticastBroadcaster */
	protected Vector l;
	/** Padding around the text for getMinimumSize() */
	protected final int MIN_PAD = 5;
	/** Padding around the text for getPreferredSize() */
	protected final int PREF_PAD = 10;
	/** State: at first CALM; AWAKE when the mouse enters, ARMED if 
	 * the mouse has been clicked but not yet released
	 * in our window; FIRED if activated,
	 */
	protected int state;
	public final static int CALM=0, AWAKE=1, ARMED=2, FIRED=3;
	/** The string form of the URL to jump to */
	String target;
	/** The URL to jump to when the button is pushed. */
	URL targetURL;

	/** Called from the browser to set up. We want to throw various
	 * kinds of exceptions but the API predefines that we don't, so we
	 * limit ourselves to the ubiquitous IllegalArgumentException.
	 */
	public void init() {
		String s;

		System.out.println("In LinkButton::init");
		try {
			if ((target = getParameter("target")) == null)
				throw new IllegalArgumentException("TARGET parameter REQUIRED");
			targetURL = new URL(target);
			if ((imName = getParameter("image")) != null)
				setImage(getImage(new URL(imName)));
		} catch (MalformedURLException rsi) {
			throw new IllegalArgumentException("MalformedURLException " +
				rsi.getMessage());
		}
		label = getParameter("label");

		// last-minute checking: must be an Image or text
		if (imName == null && label == null)
				throw new IllegalArgumentException("LABEL or IMAGE is REQUIRED");
		// Now handle font stuff.
		fontName = getParameter("fontname");
		if ((s = getParameter("fontsize")) != null)
			fontSize = Integer.parseInt(s);
		if (fontName != null || fontSize != 0) {
			System.out.println("Name " + fontName + ", size " + fontSize);
			textFont = new Font(fontName, Font.BOLD, fontSize);
		}
		
		// Applets don't do this; application components may:
		// setSize(getPreferredSize());

		// N.B. Must say we want to handle *mouse* events!
		addMouseListener(this);

		// set up the list of action handlers
		l = new Vector();
	}
	
	public void start() {
		System.out.println("In LinkButton::start");
	}

	/** Give Parameter info the the AppletViewer, just for those
	 * writing HTML without hardcopy documentation :-)
	 */
	public String[][] getParameterInfo() {
		String info[][] = {
			{ "label",		"string",	"Text to display" },
			{ "fontname",	"name",		"Font to display it in" },
			{ "fontsize",	"10-30?",	"Size to display it at" },
			{ "image",		"img file", "Alternate image" },
			{ "target",		"URL",		"Where do you want to go tomorrow?" },
		};
		return info;
	}

	// Font Stuff
	/** The font name */
	protected String fontName = null;
	/** The font size */
	protected int fontSize = 0;
	/** The font itself */
	protected Font textFont;

	/** Set the Image to appear. You must have done the appropriate
	 * (applet or applicatoin) form of getImage before this call.
	 */
	public void setImage(Image i) {
		im = i;
		MediaTracker mt = new MediaTracker(this);
		mt.addImage(im, 0);
		try {
			mt.waitForID(0);
		} catch(InterruptedException e) {
			System.err.println("Wonkey! INTR in waitForID!");
			return;
		}
		if (mt.isErrorID(0)) {
			throw new IllegalArgumentException("Couldn't load image");
		}
		width = im.getWidth(this);
		height = im.getHeight(this);
		setSize(width, height);
	}

	/** Compute the size of a String */
	protected Dimension getStrSize(String l) {
		if (textFont == null) 
			throw new IllegalArgumentException("No Font!");
		FontMetrics fm = getFontMetrics(textFont);
		return new Dimension(fm.stringWidth(l), fm.getAscent());
	}


	/** Paint -- draw the text */
	public void paint(Graphics g) {
		Dimension bd = getSize();
		// System.out.println("In paint, im=" + im + "; label=" + label);

		if (im != null) {
			g.drawImage(im, 0, 0, bd.width, bd.height, this);
			g.draw3DRect(0, 0, bd.width-2, bd.height-2, true);
			return;
		}

		switch(state) {
		case CALM:
			g.setColor(Color.black);
			break;
		case AWAKE:
			g.setColor(Color.blue);
			break;
		case ARMED:
			g.setColor(Color.red);
			break;
		case FIRED:
			g.setColor(Color.green);
			break;
		default:
			showStatus("LinkButton BUG: state=" + state);
		}

		// draw the box
		g.draw3DRect(0, 0, bd.width-2, bd.height-2, true);

		if (label == null)
			return;

		// Compute where to draw the text.
		g.setFont(textFont);
		Dimension td = getStrSize(label);
		int x = (bd.width-td.width)/2;
		if (x<0)	// what if text is too wide? Cram at left margin.
			x=0;
		int y = ((bd.height-td.height)/2)+td.height;
		// System.out.println("drawString("+label+", "+x+", "+y+");");

		// Now draw it.
		g.drawString(label, x, y);
		return;
	}

	/** Add an ActionListener to our list of listeners. */
	public void addActionListener(ActionListener listener) {
		l.addElement(listener);
	}

	/** Remove an ActionListener; we'll no longer bother it. */
	public void removeActionListener(ActionListener listener) {
		l.removeElement(listener);
	}

	/** The mouse was clicked, so notify all our ActionListeners. */
	protected void fireButton() {
		repaint();
		for (int i=0; i<l.size(); i++)
			((ActionListener)(l.elementAt(i))).actionPerformed(
				new ActionEvent(this,
					ActionEvent.ACTION_PERFORMED,
					label == null? "A LinkButton" : label));
		try {
			Thread.sleep(100);
		} catch (InterruptedException e) {
			// nothing to do!
		}
		if (targetURL != null) {
			showStatus("Going to " + target);
			getAppletContext().showDocument(targetURL);
		}
	}

	public void mousePressed(MouseEvent e) {
		state = ARMED;
		repaint();
	}

	/** The mouse was released in our window. If also pressed there,
	 * consider it a "click", and fire the event. */
	public void mouseReleased(MouseEvent e) {
		// System.out.println("MouseUp");

		if (state==ARMED) {
			state = FIRED;
			fireButton();
		}
		state = CALM;
		repaint();
	}

	/** Called by AWT when the mouse walks into our den. */
	public void mouseEntered(MouseEvent e) {
		// System.out.println("mouseEntered");
		state = AWAKE;
		repaint();
		showStatus(target);
	}

	/** Called by AWT when the mouse escapes from our den. */
	public void mouseExited(MouseEvent e) {
		// System.out.println("mouseExited");
		state = CALM;
		repaint();
		showStatus("");
	}

	/** mouseClicked is defined by MouseListener, but not used here */
	public void mouseClicked(MouseEvent e) {
	}
}
//@@@@@@//
//netweb/LinkChecker.java
//@@@@@@//
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.io.*;
import java.util.*;

import com.darwinsys.io.FileIO;
import com.darwinsys.swingui.UtilGUI; 
import com.darwinsys.util.Debug;

/** A simple HTML Link Checker. 
 * Need a Properties file to set depth, URLs to check. etc.
 * Responses not adequate; need to check at least for 404-type errors!
 * When all that is (said and) done, display in a Tree instead of a TextArea.
 * Then use Color coding to indicate errors.
 * <p>
 * Further, it needs to use Swing and Threads properly (see
 * Java Swing, section on "MultiThreading Issues with Swing".
 * As it stands, the GUI thread is locked up until the complete
 * checking is completed, which could take a long time.
 * <p>
 * TODO: parse using an XML parser, though this would fail for most web
 * sites today (and how much longer do you think we must maintain
 * so much ad-hoc code for parsing the almost-regular kludge known as HTML?)
 *
 * @author Ian Darwin, Darwin Open Systems, www.darwinsys.com.
 * @version $Id: LinkChecker.java,v 1.21 2004/06/21 01:36:53 ian Exp $
 */
public class LinkChecker extends JFrame {
	/** The "global" activation flag: set true to halt. */
	protected boolean done = false;

	/** The textfield for the starting URL.
	 * Should have a Properties file and a JComboBox instead.
	 */
	protected JTextField textFldURL;
	protected JButton checkButton;
	protected JButton saveButton;
	protected JButton killButton;
	protected JTextArea textWindow;
	protected int indent = 0;
	protected Map hash = new HashMap();
  
	public static void main(String[] args) {
		LinkChecker lc = new LinkChecker();
		if (args.length >= 1)
			lc.textFldURL.setText(args[0]);
		lc.setVisible(true);
	}
	
	void setGUIStartable(boolean startable ) {
		checkButton.setEnabled(startable);
		killButton.setEnabled(!startable);
	}
  
	/** Construct a LinkChecker */
	public LinkChecker() {
		super("LinkChecker");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Container cp = getContentPane();
		cp.setLayout(new BorderLayout());
		JPanel p = new JPanel();
		p.setLayout(new FlowLayout());
		p.add(new JLabel("URL"));
		p.add(textFldURL = new JTextField(30));
		p.add(checkButton = new JButton("Check URL"));

		// Make a single action listener for both the text field (when
		// you hit return) and the explicit "Check URL" button.
		ActionListener starter = new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				done = false;
				setGUIStartable(true);
				Thread t = new Thread() {
					public void run() {
						textWindow.setText("Checking...");
						setGUIStartable(false);
						checkOut(textFldURL.getText());
						textWindow.append("-- All done --");
						setGUIStartable(true);
					}
				};
				t.start();
			}
		};
		textFldURL.addActionListener(starter);
		checkButton.addActionListener(starter);
		p.add(killButton = new JButton("Stop"));
		killButton.setEnabled(false);	// until startChecking is called.
		killButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				done = true;
			}
		});
		p.add(saveButton = new JButton("Save Log"));
		saveButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
			try {
				String log = textWindow.getText();
				String fileName = "linkchecker.log";
				FileIO.stringToFile(log, fileName);
				JOptionPane.showMessageDialog(LinkChecker.this,
					"File saved as " + fileName, "Done",
					JOptionPane.INFORMATION_MESSAGE);
			} catch (IOException ex) {
				JOptionPane.showMessageDialog(LinkChecker.this,
					"IOError",
					ex.toString(),
					JOptionPane.ERROR_MESSAGE);
				}
			}
		});
		// Now lay out the main GUI - URL & buttons on top, text larger
		cp.add(p, BorderLayout.NORTH);
		textWindow = new JTextArea(80, 40);
		cp.add(new JScrollPane(textWindow), BorderLayout.CENTER);
		UtilGUI.maximize(this);
	}

  
	/** Start checking, given a URL by name.
	 * Calls checkLink to check each link.
	 */
	public void checkOut(String rootURLString) {
		URL rootURL = null;
		GetURLs urlGetter = null;

		if (done)
			return;
		if (rootURLString == null) {
			textWindow.append("checkOut(null) isn't very useful");
			return;
		}
		if (hash.get(rootURLString) != null) {
			return;	// already visited
		}
		hash.put(rootURLString, Boolean.TRUE);

		// Open the root URL for reading. May be a filename or a real URL.
		try {
			try {
				rootURL = new URL(rootURLString);
			} catch (MalformedURLException e) {
				// Neat Trick: if not a valid URL, try again as a file.
				rootURL = new File(rootURLString).toURL();
			}
			// Either way, now try to open it.
			urlGetter = new GetURLs(rootURL);
		} catch (FileNotFoundException e) {
			textWindow.append("Can't open file " + rootURLString + "\n");
			return;
		} catch (IOException e) {
			textWindow.append("openStream " + rootURLString + " " + e + "\n");
			return;
		}

		// If we're still here, the root URL given is OK.
		// Next we make up a "directory" URL from it.
		String rootURLdirString;
		if (rootURLString.endsWith("/") ||
			rootURLString.endsWith("\\"))
				rootURLdirString = rootURLString;
		else {
			rootURLdirString = rootURLString.substring(0, 
				rootURLString.lastIndexOf('/'));	// XXX or \
		}

		try {
			ArrayList urlTags = urlGetter.getURLs();
			Iterator urlIterator = urlTags.iterator();
			while (urlIterator.hasNext()) {
				if (done)
					return;
				String tag = (String)urlIterator.next();
				Debug.println("TAG", tag);
						
				String href = extractHREF(tag);

				for (int j=0; j<indent; j++)
					textWindow.append("\t");
				textWindow.append(href + " -- ");

				// Can't really validate these!
				if (href == null) {
					textWindow.append(" null? !!\n");
					continue;
				}
				if (href.startsWith("mailto:")) {
					textWindow.append(href + " -- not checking\n");
					continue;
				}

				if (href.startsWith("..") || href.startsWith("#")) {
					textWindow.append(href + " -- not checking\n");
					// nothing doing!
					continue; 
				}

				URL hrefURL = new URL(rootURL, href);

				// TRY THE URL.
				// (don't combine previous textWindow.append with this one,
				// since this one can throw an exception)
				textWindow.append(checkLink(hrefURL));

				// There should be an option to control whether to
				// "try the url" first and then see if off-site, or
				// vice versa, for the case when checking a site you're
				// working on on your notebook on a train in the Rockies
				// with no web access available.

				// Now see if the URL is off-site.
				if (!hrefURL.getHost().equals(rootURL.getHost())) {
					textWindow.append("-- OFFSITE -- not following\n");
					continue;
				}
				textWindow.append("\n");

				// If HTML, check it recursively. No point checking
				// PHP, CGI, JSP, etc., since these usually need forms input.
				// If a directory, assume HTML or something under it will work.
				if (href.endsWith(".htm") ||
					href.endsWith(".html") ||
					href.endsWith("/")) {
						++indent;
						if (href.indexOf(':') != -1)
							checkOut(href);			// RECURSE
						else {
							String newRef = 
								 rootURLdirString + '/' + href;
							checkOut(newRef);		// RECURSE
						}
						--indent;
				}
			}
			urlGetter.close();
		} catch (IOException e) {
			System.err.println("Error: (" + e +")");
		}
	}

	/** Check one link, given its DocumentBase and the tag */
	public String checkLink(URL linkURL) {

		try { 
			// Open it; if the open fails we'll likely throw an exception
			URLConnection luf = linkURL.openConnection();
			if (linkURL.getProtocol().equals("http")) {
				HttpURLConnection huf = (HttpURLConnection)luf;
				String s = huf.getResponseCode() + " " + huf.getResponseMessage();
				if (huf.getResponseCode() == -1)
					return "Server error: bad HTTP response";
				return s;
			} else if (linkURL.getProtocol().equals("file")) {
				InputStream is = luf.getInputStream();
				is.close();
				// If that didn't throw an exception, the file is probably OK
				return "(File)";
			} else
				return "(non-HTTP)";
		}
		catch (SocketException e) {
			return "DEAD: " + e.toString();
		}
		catch (IOException e) {
			return "DEAD";
		}
    }
 
	/** Extract the URL from <sometag attrs HREF="http://foo/bar" attrs ...> 
	 * We presume that the HREF is correctly quoted!!!!!
	 * TODO: Handle Applets.
	 */
	public String extractHREF(String tag) throws MalformedURLException {
		String caseTag = tag.toLowerCase(), attrib;
		int p1, p2, p3, p4;

		if (caseTag.startsWith("<a") && 
			Character.isWhitespace(caseTag.charAt(2))) {
			attrib = "href";		// A
		} else if (caseTag.startsWith("<applet ")){
			attrib = "code";
		} else
			attrib = "src";			// image, frame
		// XXX refactor to use 1.5 enum here
		if (attrib.equals("href") && caseTag.indexOf("name") != -1) {
			return null;		// silently ignore <a name=...>
		}
		p1 = caseTag.indexOf(attrib);
		if (p1 < 0) {
			throw new MalformedURLException("Can't find " + attrib + " in " + tag);
		}
		p2 = tag.indexOf ("=", p1);

		// This fails to handle unquoted href, which some dinosaurs insist
		// on using, saying the parser can sort it out. Phhhhhhhht!!!!
		// XXX should handle single-quoted hrefs here
		p3 = tag.indexOf("\"", p2);
		p4 = tag.indexOf("\"", p3+1);
		if (p3 < 0 || p4 < 0) {
			throw new MalformedURLException("Invalid " + attrib + " in " + tag);
		}
		String href = tag.substring(p3+1, p4);
		return href;
	}
}
//@@@@@@//
//netweb/MakeHTML.java
//@@@@@@//
import java.awt.*;
import java.applet.*;
import java.net.*;

/*
 * Inspired by this USENET posting:
 * From: pierreba@zorglub.cae.ca (Pierre Baillargeon)
 * Newsgroups: comp.lang.java,comp.lang.java.programmer,comp.lang.java.api
 * Subject: Re: HTML class for Java (applets)?
 * Date: 2 Aug 1996 12:33:31 GMT
 * Organization: CAE Electronics, Montreal
 * Message-ID: <4tssir$a0g@web.cae.ca>                 
 * ...
 * If you want to build your own HTML, I don't think there is a method that
 * will work with all browsers, but this works under Netscape (and maybe under
 * other supporting Javascript): build a javascript URL containing the HTML!
 */

public class MakeHTML extends Applet {
	protected Button goButton;

	public void init() {
		add(goButton = new Button("Go for it!"));
	}

	public boolean action(Event evt, Object o) {
		try {
			URL myNewURL = new URL("JavaScript", "", 0,
				"'<HTML><HEAD><TITLE>Testing!</TITLE></HEAD>" +
				"<BODY><P>Go to" +
				"<A HREF=\"http://www.darwinsys.com\"> " +
				"My Web Page</A>.</BODY></HTML>'" );

			// debug...
			System.out.println("URL = " + myNewURL);

			// "And then a miracle occurs..."
			getAppletContext().showDocument(myNewURL);

		} catch (Exception err) {
			System.err.println("Error!\n" + err);
			showStatus("Error, look in Java Console for details!");
		}
		return true;	// NOTREACHED
	}
}
//@@@@@@//
//netweb/MkIndex.java
//@@@@@@//
import java.io.*;
import java.util.*;
import com.darwinsys.io.FileIO;

/** MkIndex -- make a static index.html for a Java Source directory
 * <p>
 * Started life as an awk script that used "ls" to get
 * the list of files, grep out .class and javadoc output files, |sort.
 * Now it's all in Java (including the ls-ing and the sorting).
 *
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @Version $Id: MkIndex.java,v 1.44 2004/06/21 01:16:36 ian Exp $
 */
public class MkIndex {

	private boolean verbose = false;

	class NameMap implements Comparable {
		String name, nameLC;
		String path;
		public NameMap(String nm, String p) {
			name = nm;
			nameLC = name.toLowerCase();
			path = p;
		}
		public int compareTo(Object other) {
			return nameLC.compareTo(((NameMap)other).nameLC);
		}
	}

	/** The output file that we create */
	public static final String OUTPUTFILE = "index-byname.html";
	/** The string for TITLE and H1 */
	public static final String TITLE =
		"Ian Darwin's Java Cookbook: Source Code: By Name";
	/** The main output stream */
	PrintWriter out;
	/** The background color for the page */
	public static final String BGCOLOR="#33ee33";

	/** Make an index */
	public static void main(String[] args) throws IOException {
		MkIndex mi = new MkIndex();
		mi.setWriter(new PrintWriter(new FileWriter(OUTPUTFILE)));
		mi.begin();		// print HTML header
		System.out.println("** Start Pass One **");
		if (args.length > 0) {
			for (int i=0; i<args.length; i++)
				mi.process(new File(args[i]));	// "We do ALL the work..."
		} else {
			mi.process(new File("."));
		}
		mi.writeNav();	// Write navigator
		mi.writeList();	// Write huge list of files
		mi.end();		// print trailer.
		mi.close();		// close files
	}

	void setWriter(PrintWriter aWriter) {
		out = aWriter;
	}

	/** Write the HTML headers */
	void begin() throws IOException {
		println("<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN'");
		println("	'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'");
		println(">");
		println();
		println("<html>");

		println("<head>");
		println("	<meta http-equiv='Content-Type' content='text/html; charset=iso-8859-1'/>");
		println("	<meta name='Generator' content='Java MkIndex'/>");
		println("	<link rel='stylesheet' type='text/css' href='/stylesheet.css' title='style'/>");
		println("	<title>" + TITLE + "</title>");
		println("</head>");
		println();
		println("<body bgcolor=\"" + BGCOLOR + "\">");
		println("<h1>" + TITLE + "</h1>");
		if (new File("about.html").exists()) {
			FileIO.copyFile("about.html", out, false);
		} else {
			println("<p>The following files are online.");
			println("Some of these files are still experimental!</p>");
			println("<p>Most of these files are Java source code.");
			println("If you load an HTML file from here, the applets will not run!");
			println("The HTML files must be saved to disk and the applets compiled,");
			println("before you can run them!</p>");
		}
		println("<p>All files are Copyright (c): All rights reserved.");
		println("See the accompanying <a href=\"legal-notice.txt\">Legal Notice</a> for conditions of use.");
		println("May be used by readers of my Java Cookbook for educational purposes, and for commercial use if certain conditions are met.");
		println("</p>");
		println("<hr />");
	}

	/** Array of letters that exist. Should
	 * fold case here so don't get f and F as distinct entries!
	 * This only works for ASCII characters (8-bit chars).
	 */
	boolean[] exists = new boolean[255];

	/** List for temporary storage, and sorting */
	ArrayList list = new ArrayList();

	/** Return true if a filename should be ignored. */
	boolean ignorable(String name) {
		if (name.startsWith("index") ||
			name.endsWith(".class") ||
			name.endsWith(".jar") ||
			name.endsWith(".bak")) {
			if (verbose) {
				System.err.println("Ignoring " + name);
			}
			return true;
		} else if (name.equals("CVS")) {		// Ignore CVS subdirectories
			return true;						// don't mention it
		} else if (name.charAt(0) == '.' && name.length() > 1) {// UNIX dot-file
			return true;
		}
		return false;
	}

	/** Do the bulk of the work */
	void process(File file) throws IOException {

		String name = file.getName();
		if (ignorable(name)) {
			return;
		}

		if (file.isDirectory()) {
			System.out.println("Indexing directory " + name);
			File[] files = file.listFiles();
			for (int i=0; i<files.length; i++) {
				String fn = files[i].getName();
				process(new File(file, fn));
			}
		} else {
			// file to be processed.
			list.add(new NameMap(name, file.getPath()));
			exists[name.charAt(0)] = true;
		}
	}

	void writeNav() throws IOException {

		System.out.println("Writing the Alphabet Navigator...");
		for (char c = 'A'; c<='Z'; c++)
			if (exists[c])
				print("<a href=\"#" + c + "\">" + c + "</a> ");
	}

	void writeList() throws IOException {

		// ... the beginning of the HTML Unordered List...
		println("<ul>");

		System.out.println("Sorting the list...");
		Collections.sort(list);

		System.out.println("Start PASS TWO -- from List to " +
			OUTPUTFILE + "...");
		Iterator it = list.iterator();
		while (it.hasNext()) {
			NameMap map = (NameMap)it.next();
			String fn = map.name;
			String path = map.path;
			// Need to make a link into this directory.
			// IF there is a descr.txt file, use it for the text
			// of the link, otherwise, use the directory name.
			// But, if there is an index.html (or index.htm) file,
			// make the link to that file, else to the directory itself.
			if (fn.endsWith("/")) {	// directory
				String descr = null;
				if (new File(fn + "descr.txt").exists()) {
					descr = FileIO.readLine(fn + "descr.txt");
				};
				if (new File(fn + "index.html").exists())
					mkDirLink(fn+"index.html", descr!=null?descr:fn);
				else if (new File(fn + "index.htm").exists())
						mkDirLink(fn+"index.htm", descr!=null?descr:fn);
				else
					mkLink(fn, descr!=null?descr:fn + " -- Directory");
			} else // file
				mkLink(fn, path);
		}
		System.out.println("*** process - ALL DONE***");
	}

	/** Keep track of each letter for #links */
	boolean done[] = new boolean[255];

	void mkLink(String name, String path) {
		print("<li>");
		char c = name.charAt(0);
		if (!done[c]) {
			print("<a name=\"" + c + "\"/>");
			done[c] = true;
		}
		println("<a href=\"" + path + "\">" + name + "</a>");
	}

	void mkDirLink(String index, String dir) {
		// XXX Open the index and look for TITLE lines!
		println("<a href='" + index + "'>" + dir + "</a>");
	}

	/** Write the trailers and a signature */
	void end() {
		System.out.println("Finishing the HTML");
		println("</ul>");
		flush();
		println("<p>This file generated by ");
		print("<a href=\"MkIndex.java\">MkIndex</a>, a Java program, at ");
		println(Calendar.getInstance().getTime().toString());
		println("</p>");
		println("</body>");
		println("</html>");
	}

	/** Close open files */
	void close() {
		System.out.println("Closing output files...");
		if (out != null)
			out.close();
	}

	/** Convenience routine for out.print */
	void print(String s) {
		out.print(s);
	}

	/** Convenience routine for out.println */
	void println(String s) {
		out.println(s);
	}

	/** Convenience routine for out.println */
	void println() {
		out.println();
	}

	/** Convenience for out.flush(); */
	void flush() {
		out.flush();
	}
}
//@@@@@@//
//netweb/PostQuery.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
import java.io.*;
import java.net.*;

/**
 * Simple demonstration of posting to a query form cgi on a Web server.
 * @author 		Ian Darwin, http://www.darwinsys.com/
 * @copyright 	1997, Ian Darwin, Ontario, Canada
 * @see			http://www.learningtree.com/us/courses/471.htm
 */
public class PostQuery extends Applet implements ActionListener{
	protected Button goButton;
	protected URLConnection conn;
	protected PrintWriter ps;
	protected BufferedReader is;

	public PostQuery() {
		add(goButton = new Button("Go for it!"));
		goButton.addActionListener(this);
	}

	public void actionPerformed(ActionEvent evt) {
		try {
			URL myNewURL;
			String serverURL = getParameter("serverURL");
			if (serverURL == null)
				serverURL = "http://server/cgi-bin/test-cgi.pl";
			showStatus("Building URL " + serverURL);
			myNewURL = new URL(serverURL);

			showStatus("Connecting to " + myNewURL);

			// Try to open the connection...
			conn = myNewURL.openConnection();
			showStatus("Connected! to " + myNewURL);
			conn.setDoOutput(true);
			conn.setUseCaches(false);	// ensure response always from server

			ps = new PrintWriter(
				new OutputStreamWriter(conn.getOutputStream()));

			showStatus("Sending...");

			ps.println(URLEncoder.encode("key") + "=" +
					URLEncoder.encode("some value"));
			ps.println(URLEncoder.encode("key 2") + "=" +
					URLEncoder.encode("another value"));
			ps.close();

			conn.setDoInput(true);
			is = new BufferedReader(
				new InputStreamReader(conn.getInputStream()));

			showStatus("Receiving...");
			String newReq;
			while ((newReq = is.readLine()) != null) {
				System.out.println("Response = " + newReq);
			}
			showStatus("Look for results in the console window");
			is.close();

		} catch (Exception err) {
			showStatus("Error, look in Java Console for details!");
			System.err.println("Error!\n" + err);
		}
	}
}
//@@@@@@//
//netweb/ReadTag.java
//@@@@@@//
import java.io.*;
import java.net.*;

/** A simple but reusable HTML tag extractor.
 * @author Ian Darwin, Darwin Open Systems, www.darwinsys.com.
 * @version $Id: ReadTag.java,v 1.4 2000/05/05 14:05:23 ian Exp $
 */
public class ReadTag {
	/** The URL that this ReadTag object is reading */
	protected URL myURL = null;
	/** The Reader for this object */
	protected BufferedReader inrdr = null;
  
	/* Simple main showing one way of using the ReadTag class. */
	public static void main(String[] args) throws MalformedURLException, IOException {
		if (args.length == 0) {
			System.err.println("Usage: ReadTag URL [...]");
			return;
		}

		for (int i=0; i<args.length; i++) {
			ReadTag rt = new ReadTag(args[0]);
			String tag;
			while ((tag = rt.nextTag()) != null) {
				System.out.println(tag);
			}
			rt.close();
		}
	}
  
	/** Construct a ReadTag given a URL String */
	public ReadTag(String theURLString) throws 
			IOException, MalformedURLException {

		this(new URL(theURLString));
	}

	/** Construct a ReadTag given a URL */
	public ReadTag(URL theURL) throws IOException {
		myURL = theURL;
		// Open the URL for reading
		inrdr = new BufferedReader(new InputStreamReader(myURL.openStream()));
	}

	/** Read the next tag.  */
	public String nextTag() throws IOException {
		int i;
		while ((i = inrdr.read()) != -1) {
			char thisChar = (char)i;
			if (thisChar == '<') {
				String tag = readTag();
				return tag;
			}
		}
		return null;
	}

	public void close() throws IOException {
		inrdr.close();
	}

	/** Read one tag. Adapted from code by Elliotte Rusty Harold */
	protected String readTag() throws IOException {
		StringBuffer theTag = new StringBuffer("<");
		int i = '<';
	  
		while (i != '>' && (i = inrdr.read()) != -1) {
				theTag.append((char)i);
		}     
		return theTag.toString();
	}

	/* Return a String representation of this object */
	public String toString() {
		return "ReadTag[" + myURL.toString() + "]";
	}
}
//@@@@@@//
//netweb/TestDirForMkIndex/Foo.java
//@@@@@@//
//@@@@@@//
//netweb/TextBrowser.java
//@@@@@@//
import java.net.*;
import java.io.*;

/**
 * TextBrowser - URL/text mode getter.
 * Display the contents of a text-only URL
 * @author	Ian Darwin, http://www.darwinsys.com/
 */
public class TextBrowser {

	public static void main(String[] av) {
		TextBrowser tb = new TextBrowser();
		if (av.length == 0) {
			System.err.println("Usage: TextBrowser URL [...]");
			System.exit(1);
		}
		else for (int i=0; i<av.length; i++) {
			tb.showDocument(av[i]);
		}
	}

	/** Show one document, by filename */
	protected void showDocument(String loc) {
		URL webURL = null;
		try {
			System.err.println("*** Loading " + loc + "... ***");
			webURL = new URL(loc);
			BufferedReader is = new BufferedReader(
				new InputStreamReader(webURL.openStream()));
			String line;
			while ((line = is.readLine()) != null) {
				System.out.println(line);
			}
			is.close();
		} catch (MalformedURLException e) {
			System.err.println("Load failed: " + e);
		} catch (IOException e) {
			System.err.println("IOException: " + e);
		}
	}
}
//@@@@@@//
//netweb/URIDemo.java
//@@@@@@//
import java.net.URI;
import java.net.URL;
import java.net.URISyntaxException;
import java.net.MalformedURLException;

public class URIDemo {
	public static void main(String[] args)
	throws URISyntaxException, MalformedURLException {

		URI u = new URI("http://www.darwinsys.com/java/../openbsd/../index.jsp");
		System.out.println("Raw: " + u);
		URI normalized = u.normalize();
		System.out.println("Normalized: " + normalized);
		final URI BASE = new URI("http://www.darwinsys.com");
		System.out.println("Relativized to " + BASE + ": " + BASE.relativize(u));

		// A URL is a type of URI
		URL url = new URL(normalized.toString());
		System.out.println("URL: " + url);
	}
}
//@@@@@@//
//netweb/Weather.java
//@@@@@@//
import java.io.*;
import java.net.*;

import com.darwinsys.io.FileIO;

/** Connect to a METCAST station and print the results
 */
public class Weather {

	public static final String request = 
	"(ReqID (bounding-box 90. -180. -90. 180.)\n" +
    "  (st_constraint (block_id \"716240\"))\n" +
	// "  (products (METAR (mime-type \"text/plain\")))\n" +
    "  (products (TAF (mime-type \"text/plain\"))))\n";
	public static final String SERVER =
		"http://zowie.metnet.navy.mil/cgi-bin/oleg/server";

	class OMFHandler extends ContentHandler {
		public Object getContent(URLConnection uc) {
			String response = "";
			try {
				BufferedReader is = new BufferedReader(
					new InputStreamReader(uc.getInputStream()));
				String line;
				while ((line = is.readLine()) != null) {
					response += line;
				}
				is.close();
			} catch (IOException ex) {
				return ex.toString() + " partial response: " + response;
			}
			return response;
		}
	}

	public static void main(String[] args) throws Exception {
		Weather wx = new Weather();
		wx.process();
	}

	protected void process() throws Exception {

		System.out.println("Setting up URLConnection");

		URL u = new URL(SERVER);

		URLConnection cx = u.openConnection();
		cx.setContentHandlerFactory(new ContentHandlerFactory() {
			public ContentHandler createContentHandler(String type) {
				if (type.startsWith("text/x-omf"))
					return new OMFHandler();
				return null;
			}
		});

		cx.setDoInput(true);
		cx.setDoOutput(true);
		cx.setAllowUserInteraction(false);

		DataOutputStream os =
			new DataOutputStream(cx.getOutputStream());

		System.out.println("Connecting the URLConnection");
		cx.connect();

		System.out.println("Request is:");
		System.out.println(request);

		System.out.println("Sending Request");
		os.writeBytes("mbl-stmt=" + URLEncoder.encode(request));
		os.flush();

		System.out.println("Getting the Response");
		
		Object response = cx.getContent();
		if (response instanceof InputStream)
			response = FileIO.inputStreamToString((InputStream)response);
		System.out.println(response);
	}
}

//@@@@@@//
//network/chat/Chat.java
//@@@@@@//
package chat;

/** Constants and Class Methods for Java Chat Clients and Server.
 *
 * The protocol:
 *	--> Lusername
 *  --> Btext_to_broadcast
 *	--> Musername\Message
 *	--> Q
 *  <-- any text to be displayed.
 *
 * @author Ian Darwin
 * @version $Id: Chat.java,v 1.3 2004/02/16 02:44:43 ian Exp $
 */
public class Chat {

	// These are the first character of messages from client to server

	public static final int PORTNUM = 9999;
	public static final int MAX_LOGIN_LENGTH = 20;
	public static final char SEPARATOR = '\\';
	public static final char COMMAND = '\\';
	public static final char CMD_LOGIN = 'L';
	public static final char CMD_QUIT  = 'Q';
	public static final char CMD_MESG  = 'M';
	public static final char CMD_BCAST = 'B';

	// These are the first character of messages from server to client

	public static final char RESP_PUBLIC = 'P';
	public static final char RESP_PRIVATE = 'M';
	public static final char RESP_SYSTEM = 'S';

	// TODO in main loop:
	// if (text.charAt(0) == '/')
	//		send(text);
	// else send("B"+text);

	public static boolean isValidLoginName(String login) {
		// check length
		if (login.length() > MAX_LOGIN_LENGTH)
			return false;

		// check for bad chars
		// if (contains bad chars)
		//	return false

		// Passed above tests, is OK
		return true;
	}
}
//@@@@@@//
//network/chat/ChatRoom.java
//@@@@@@//
package chat;

import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;

/** 
 * <p>
 * Simple Chat Room Applet.
 * Writing a Chat Room seems to be one of many obligatory rites (or wrongs)
 * of passage for Java experts these days.</p>
 * <p>
 * This one is a toy because it doesn't have much of a protocol, which
 * means we can't query the server as to * who's logged in,
 * or anything fancy like that. However, it works OK for small groups.</p>
 * <p>
 * Uses client socket w/ two Threads (main and one constructed),
 * one for reading and one for writing.</p>
 * <p>
 * Server multiplexes messages back to all clients.</p>
 * @author Ian Darwin
 * @version $Id: ChatRoom.java,v 1.8 2004/03/09 03:59:37 ian Exp $
 */
public class ChatRoom extends Applet {
	/** Whether we are being run as an Applet or an Application */
	protected boolean inAnApplet = true;
	/** The state of logged-in-ness */
	protected boolean loggedIn;
	/* The Frame, for a pop-up, durable Chat Room. */
	protected Frame cp;
	/** The default port number */
	protected static int PORTNUM = Chat.PORTNUM;
	/** The actual port number */
	protected int port;
	/** The network socket */
	protected Socket sock;
	/** BufferedReader for reading from socket */
	protected BufferedReader is;
	/** PrintWriter for sending lines on socket */
	protected PrintWriter pw;
	/** TextField for input */
	protected TextField tf;
	/** TextArea to display conversations */
	protected TextArea ta;
	/** The Login button */
	protected Button lib;
	/** The LogOUT button */
	protected Button lob;
	/** The TitleBar title */
	final static String TITLE = "Chat: Ian Darwin's Toy Chat Room Client";
	/** The message that we paint */
	protected String paintMessage;

	/** init, overriding the version inherited from Applet */
	public void init() {
		paintMessage = "Creating Window for Chat";
		repaint();
		cp = new Frame(TITLE);
		cp.setLayout(new BorderLayout());
		String portNum = null;
		if (inAnApplet)
			portNum = getParameter("port");
		port = PORTNUM;
		if (portNum != null)
			port = Integer.parseInt(portNum);

		// The GUI
		ta = new TextArea(14, 80);
		ta.setEditable(false);		// readonly
		ta.setFont(new Font("Monospaced", Font.PLAIN, 11));
		cp.add(BorderLayout.NORTH, ta);

		Panel p = new Panel();
		Button b;

		// The login button
		p.add(lib = new Button("Login"));
		lib.setEnabled(true);
		lib.requestFocus();
		lib.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				login();
				lib.setEnabled(false);
				lob.setEnabled(true);
				tf.requestFocus();	// set keyboard focus in right place!
			}
		});

		// The logout button
		p.add(lob = new Button("Logout"));
		lob.setEnabled(false);
		lob.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				logout();
				lib.setEnabled(true);
				lob.setEnabled(false);
				lib.requestFocus();
			}
		});

		p.add(new Label("Message here:"));
		tf = new TextField(40);
		tf.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (loggedIn) {
					pw.println(Chat.CMD_BCAST+tf.getText());
					tf.setText(""); 
				}
			}
		});
		p.add(tf);

		cp.add(BorderLayout.SOUTH, p);

        cp.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				// If we do setVisible and dispose, then the Close completes
				ChatRoom.this.cp.setVisible(false);
				ChatRoom.this.cp.dispose();
				logout();
			}
		});
		cp.pack();
		// After packing the Frame, centre it on the screen.
		Dimension us = cp.getSize(), 
			them = Toolkit.getDefaultToolkit().getScreenSize();
		int newX = (them.width - us.width) / 2;
		int newY = (them.height- us.height)/ 2;
		cp.setLocation(newX, newY);
		cp.setVisible(true);
		paintMessage = "Window should now be visible";
		repaint();
	}

	protected String serverHost = "localhost";

	/** LOG ME IN TO THE CHAT */
	public void login() {
		showStatus("In login!");
		if (loggedIn)
			return;
		if (inAnApplet)
			serverHost = getCodeBase().getHost();
		try {
			sock = new Socket(serverHost, port);
			is = new BufferedReader(new InputStreamReader(sock.getInputStream()));
			pw = new PrintWriter(sock.getOutputStream(), true);
		} catch(IOException e) {
			showStatus("Can't get socket to " + 
				serverHost + "/" + port + ": " + e);
			cp.add(new Label("Can't get socket: " + e));
			return;
		}
		showStatus("Got socket");

		// Construct and start the reader: from server to textarea.
		// Make a Thread to avoid lockups.
		new Thread(new Runnable() {
			public void run() {
				String line;
				try {
					while (loggedIn && ((line = is.readLine()) != null))
						ta.append(line + "\n");
				} catch(IOException e) {
					showStatus("GAA! LOST THE LINK!!");
					return;
				}
			}
		}).start();

		// FAKE LOGIN FOR NOW
		pw.println(Chat.CMD_LOGIN + "AppletUser");
		loggedIn = true;
	}

	/** Log me out, Scotty, there's no intelligent life here! */
	public void logout() {
		if (!loggedIn)
			return;
		loggedIn = false;
		try {
			if (sock != null)
				sock.close();
		} catch (IOException ign) {
			// so what?
		}
	}

	// It is deliberate that there is no STOP method - we want to keep
	// going even if the user moves the browser to another page.
	// Anti-social? Maybe, but you can use the CLOSE button to kill 
	// the Frame, or you can exit the Browser.

	/** Paint paints the small window that appears in the HTML,
	 * telling the user to look elsewhere!
	 */
	public void paint(Graphics g) {
		Dimension d = getSize();
		int h = d.height;
		int w = d.width;
		g.fillRect(0, 0, w, 0);
		g.setColor(Color.black);
		g.drawString(paintMessage, 10, (h/2)-5);
	}


	/** a showStatus that works for Applets or non-Applets alike */
	public void showStatus(String mesg) {
		if (inAnApplet)
			super.showStatus(mesg);
		System.out.println(mesg);
	}

	/** A main method to allow the client to be run as an Application */
	public static void main(String[] args) {
		ChatRoom room101 = new ChatRoom();
		room101.inAnApplet = false;
		room101.init();
		room101.start();
	}
}
//@@@@@@//
//network/chat/ChatServer.java
//@@@@@@//
package chat;

import java.io.*;
import java.net.*;
import java.util.*;

/** Trivial Chat Server to go with our Trivial Chat Client.
 *
 * WARNING -- this code is believed thread-safe but has NOT been 100% vetted 
 * by a team of world-class experts for Thread-safeness.
 * DO NOT BUILD ANYTHING CRITICAL BASED ON THIS until you have done so.
 * See the various books on Threaded Java for design issues.
 *
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ChatServer.java,v 1.10 2004/03/13 21:56:32 ian Exp $
 */
public class ChatServer {
	/** What I call myself in system messages */
	protected final static String CHATMASTER_ID = "ChatMaster";
	/** What goes between any handle and the message */
	protected final static String SEP = ": ";
	/** The Server Socket */
	protected ServerSocket servSock;
	/** The list of my current clients */
	protected ArrayList clients;
	/** Debugging state */
	private static boolean DEBUG = false;

	/** Main just constructs a ChatServer, which should never return */
	public static void main(String[] argv) {
		System.out.println("DarwinSys Chat Server 0.1 starting...");
		if (argv.length == 1 && argv[0].equals("-debug"))
			DEBUG = true;
		ChatServer w = new ChatServer();
		w.runServer();			// should never return.
		System.out.println("**ERROR* Chat Server 0.1 quitting");
	}

	/** Construct (and run!) a Chat Service */
	ChatServer() {
		clients = new ArrayList();
		try {
			servSock = new ServerSocket(Chat.PORTNUM);
			System.out.println("DarwinSys Chat Server Listening on port " +
				Chat.PORTNUM);
		} catch(IOException e) {
			log("IO Exception in ChatServer.<init>" + e);
			System.exit(0);
		}
	}

	public void runServer() {
		try {
			while (true) {
				Socket us = servSock.accept();
				String hostName = us.getInetAddress().getHostName();
				System.out.println("Accepted from " + hostName);
				ChatHandler cl = new ChatHandler(us, hostName);
				synchronized (clients) {
					clients.add(cl);
					cl.start();
					if (clients.size() == 1)
						cl.send(CHATMASTER_ID, "Welcome! you're the first one here");
					else {
						cl.send(CHATMASTER_ID, "Welcome! you're the latest of " +
							clients.size() + " users.");
					}
				}
			}
		} catch(IOException e) {
			log("IO Exception in runServer: " + e);
			System.exit(0);
		}
	}

	protected void log(String s) {
		System.out.println(s);
	}

	/** Inner class to handle one conversation */
	protected class ChatHandler extends Thread {
		/** The client socket */
		protected Socket clientSock;
		/** BufferedReader for reading from socket */
		protected BufferedReader is;
		/** PrintWriter for sending lines on socket */
		protected PrintWriter pw;
		/** The client's host */
		protected String clientIP;
		/** String form of user's handle (name) */
		protected String login;

		/* Construct a Chat Handler */
		public ChatHandler(Socket sock, String clnt) throws IOException {
			clientSock = sock;
			clientIP = clnt;
			is = new BufferedReader(
				new InputStreamReader(sock.getInputStream()));
			pw = new PrintWriter(sock.getOutputStream(), true);
		}

		/** Each ChatHandler is a Thread, so here's the run() method,
		 * which handles this conversation.
		 */
		public void run() {
			String line;
			try {
				while ((line = is.readLine()) != null) {
					char c = line.charAt(0);
					line = line.substring(1);
					switch (c) {
					case Chat.CMD_LOGIN:
						if (!Chat.isValidLoginName(line)) {
							send(CHATMASTER_ID, "LOGIN " + line + " invalid");
							log("LOGIN INVALID from " + clientIP);
							continue;
						}
						login = line;
						broadcast(CHATMASTER_ID, login + 
							" joins us, for a total of " + 
							clients.size() + " users");
						break;
					case Chat.CMD_MESG:
						if (login == null) {
							send(CHATMASTER_ID, "please login first");
							continue;
						}
						int where = line.indexOf(Chat.SEPARATOR);
						String recip = line.substring(0, where);
						String mesg = line.substring(where+1);
						log("MESG: " + login + "-->" + recip + ": "+ mesg);
						ChatHandler cl = lookup(recip);
						if (cl == null)
							psend(CHATMASTER_ID, recip + " not logged in.");
						else
							cl.psend(login, mesg);
						break;
					case Chat.CMD_QUIT:
						broadcast(CHATMASTER_ID,
							"Goodbye to " + login + "@" + clientIP);
						close();
						return;		// The end of this ChatHandler
						
					case Chat.CMD_BCAST:
						if (login != null)
							broadcast(login, line);
						else
							log("B<L FROM " + clientIP);
						break;
					default:
						log("Unknown cmd " + c + " from " + login + "@" + clientIP);
					}
				}
			} catch (IOException e) {
				log("IO Exception: " + e);
			} finally {
				// the sock ended, so we're done, bye now
				System.out.println(login + SEP + "All Done");
				synchronized(clients) {
					clients.remove(this);
					if (clients.size() == 0) {
						System.out.println(CHATMASTER_ID + SEP +
							"I'm so lonely I could cry...");
					} else if (clients.size() == 1) {
						ChatHandler last = (ChatHandler)clients.get(0);
						last.send(CHATMASTER_ID,
							"Hey, you're talking to yourself again");
					} else {
						broadcast(CHATMASTER_ID,
							"There are now " + clients.size() + " users");
					}
				}
			}
		}

		protected void close() {
			if (clientSock == null) {
				log("close when not open");
				return;
			}
			try {
				clientSock.close();
				clientSock = null;
			} catch (IOException e) {
				log("Failure during close to " + clientIP);
			}
		}

		/** Send one message to this user */
		public void send(String sender, String mesg) {
			pw.println(sender + SEP + mesg);
		}

		/** Send a private message */
		protected void psend(String sender, String msg) {
			send("<*" + sender + "*>", msg);
		}
		
		/** Send one message to all users */
		public void broadcast(String sender, String mesg) {
			System.out.println("Broadcasting " + sender + SEP + mesg);
			for (int i=0; i<clients.size(); i++) {
				ChatHandler sib = (ChatHandler)clients.get(i);
				if (DEBUG)
					System.out.println("Sending to " + sib);
				sib.send(sender, mesg);
			}
			if (DEBUG) System.out.println("Done broadcast");
		}

		protected ChatHandler lookup(String nick) {
			synchronized(clients) {
				for (int i=0; i<clients.size(); i++) {
					ChatHandler cl = (ChatHandler)clients.get(i);
					if (cl.login.equals(nick))
						return cl;
				}
			}
			return null;
		}

		/** Present this ChatHandler as a String */
		public String toString() {
			return "ChatHandler[" + login + "]";
		}
	}
}
//@@@@@@//
//network/chat/ConsChat.java
//@@@@@@//
package chat;

import java.io.*;
import java.net.*;

/** Simple console-mode (command-line) chat client.
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: ConsChat.java,v 1.6 2004/02/16 02:44:43 ian Exp $
 */
public class ConsChat {
	public static void main(String[] args) throws IOException {
		new ConsChat().chat();
	}

	protected Socket sock;
	protected BufferedReader is;
	protected PrintWriter pw;
	protected BufferedReader cons;

	protected ConsChat() throws IOException {
		sock = new Socket("localhost", Chat.PORTNUM);
		is   = new BufferedReader(new InputStreamReader(sock.getInputStream()));
		pw   = new PrintWriter(sock.getOutputStream(), true);
		cons = new BufferedReader(new InputStreamReader(System.in));

		// Construct and start the reader: from server to stdout.
		// Make a Thread to avoid lockups.
		new Thread() {
			public void run() {
				setName("socket reader thread");
				System.out.println("Starting " + getName());
				System.out.flush();
				String line;
				try {
					// reader thread blocks here
					while ((line = is.readLine()) != null) {
						System.out.println(line);
						System.out.flush();
					}
				} catch (IOException ex) {
					System.err.println("Read error on socket: " + ex);
					return;
				}
			}
		}.start();
	}

	protected void chat() throws IOException {
		String text;

		System.out.print("Login name: "); System.out.flush();
		text = cons.readLine();
		send(Chat.CMD_LOGIN + text);

		// Main thread blocks here
		while ((text = cons.readLine()) != null) {
			if (text.length() == 0 || text.charAt(0) == '#')
				continue;			// ignore null lines and comments
			if (text.charAt(0) == '/')
				send(text.substring(1));
			else send("B"+text);
		}
	}

	protected void send(String s) {
		pw.println(s);
		pw.flush();
	}

}
//@@@@@@//
//network/Connect.java
//@@@@@@//
import java.net.*;

/*
 * A simple demonstration of setting up a Java network client.
 * @version $Id: Connect.java,v 1.3 2001/03/13 20:32:38 ian Exp $
 */ 
public class Connect {
	public static void main(String[] argv) {
		String server_name = "localhost";

		try {
			Socket sock = new Socket(server_name, 80);

			/* Finally, we can read and write on the socket. */
			System.out.println(" *** Connected to " + server_name  + " ***");
			/* ... */

			sock.close();

		} catch (java.io.IOException e) {
			System.err.println("error connecting to " + 
				server_name + ": " + e);
			return;
		}

	}
}
//@@@@@@//
//network/ConnectFriendly.java
//@@@@@@//
import java.net.ConnectException;
import java.net.NoRouteToHostException;
import java.net.Socket;
import java.net.UnknownHostException;

/* Client with error handling */
public class ConnectFriendly {
	public static void main(String[] argv) {
		String server_name = argv.length == 1 ? argv[0] : "localhost";
		int tcp_port = 80;
		try {
			Socket sock = new Socket(server_name, tcp_port);

			/* Finally, we can read and write on the socket. */
			System.out.println(" *** Connected to " + server_name  + " ***");
			/* ... */

			sock.close();

		} catch (UnknownHostException e) {
			System.err.println(server_name + " Unknown host");
			return;
		} catch (NoRouteToHostException e) {
			System.err.println(server_name + " Unreachable" );
			return;
		} catch (ConnectException e) {
			System.err.println(server_name + " connect refused");
			return;
		} catch (java.io.IOException e) {
			System.err.println(server_name + ' ' + e.getMessage());
			return;
		}
	}
}
//@@@@@@//
//network/DaytimeBinary.java
//@@@@@@//
import java.io.*;
import java.net.*;
import java.util.*;

/**
 * DaytimeBinary - connect to the standard Time (binary) service.
 * @author Ian F. Darwin
 * @version $Id: DaytimeBinary.java,v 1.7 2004/02/16 02:44:43 ian Exp $
 */
public class DaytimeBinary {
	/** The TCP port for the binary time service. */
	public static final short TIME_PORT = 37;
	/** Seconds between 1970, the time base for Date(long) and Time.
	 * Factors in leap years (up to 2100), hours, minutes, and seconds.
	 * Subtract 1 day for 1900, add in 1/2 day for 1969/1970.
	 */
	protected static final long BASE_DAYS = 
		(long)((1970-1900)*365 + (1970-1900-1)/4);
	/* Seconds since 1970 */
	public static final long BASE_DIFF = (BASE_DAYS * 24 * 60 * 60);
	/** Convert from seconds to milliseconds */
	public static final int MSEC = 1000;

	public static void main(String[] argv) {
		String hostName;
		if (argv.length == 0)
			hostName = "localhost";
		else
			hostName = argv[0];

		try {
			Socket sock = new Socket(hostName, TIME_PORT);
			DataInputStream is = new DataInputStream(new 
				BufferedInputStream(sock.getInputStream()));
			// Need to read 4 bytes from the network, unsigned.
			// Do it yourself; there is no readUnsignedInt().
			// Long is 8 bytes on Java, but we are using the
			// existing time protocol, which uses 4-byte ints.
			long remoteTime = (
				((long)(is.readUnsignedByte()) << 24) |
				((long)(is.readUnsignedByte()) << 16) |
				((long)(is.readUnsignedByte()) <<  8) |
				((long)(is.readUnsignedByte()) <<  0));
			System.out.println("Remote time is " + remoteTime);
			System.out.println("BASE_DIFF is " + BASE_DIFF);
			System.out.println("Time diff == " + (remoteTime - BASE_DIFF));
			Date d = new Date((remoteTime - BASE_DIFF) * MSEC);
			System.out.println("Time on " + hostName + " is " + d.toString());
		} catch (IOException e) {
			System.err.println(e);
		}
	}
}
//@@@@@@//
//network/DaytimeObject.java
//@@@@@@//
import java.io.*;
import java.net.*;
import java.util.*;

/**
 * DaytimeObject - connect to the non-standard Time (object) service.
 * @author Ian F. Darwin
 * @version $Id: DaytimeObject.java,v 1.4 2002/10/26 13:53:50 ian Exp $
 */
public class DaytimeObject {
	/** The TCP port for the object time service. */
	public static final short TIME_PORT = 1951;

	public static void main(String[] argv) {
		String hostName;
		if (argv.length == 0)
			hostName = "localhost";
		else
			hostName = argv[0];

		try {
			Socket sock = new Socket(hostName, TIME_PORT);
			ObjectInputStream is = new ObjectInputStream(new 
				BufferedInputStream(sock.getInputStream()));

			// Read and validate the Object
			Object o = is.readObject();
			if (o == null) {
				System.err.println("Read null from server!");
			} else if ((o instanceof Date)) {

				// Valid, so cast to Date, and print
				Date d = (Date) o;
				System.out.println("Server host is " + hostName);
				System.out.println("Time there is " + d.toString());

			} else {
				throw new IllegalArgumentException("Wanted Date, got " + o);
			}
		} catch (ClassNotFoundException e) {
			System.err.println("Wanted date, got INVALID CLASS (" + e + ")");
		} catch (IOException e) {
			System.err.println(e);
		}
	}
}
//@@@@@@//
//network/DaytimeObjectServer.java
//@@@@@@//
import java.io.*;
import java.net.*;
import java.util.*;

/**
 * DaytimeObjectServer - server for the non-standard Time (object) service.
 * @author Ian F. Darwin
 * @version $Id: DaytimeObjectServer.java,v 1.3 2002/10/26 13:53:50 ian Exp $
 */
public class DaytimeObjectServer {
	/** The TCP port for the object time service. */
	public static final short TIME_PORT = 1951;

	public static void main(String[] argv) {
		ServerSocket sock;
		Socket  clientSock;
		try {
			sock = new ServerSocket(TIME_PORT);
			while ((clientSock = sock.accept()) != null) {
				System.out.println("Accept from " + 
					clientSock.getInetAddress());
				ObjectOutputStream os = new ObjectOutputStream(
					clientSock.getOutputStream());

				// Construct and write the Object
				os.writeObject(new Date());

				os.close();
			}

		} catch (IOException e) {
			System.err.println(e);
		}
	}
}
//@@@@@@//
//network/DaytimeServer.java
//@@@@@@//
import java.io.*;
import java.net.*;

/**
 * DaytimeServer - server for the standard binary time service.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: DaytimeServer.java,v 1.4 2004/02/09 03:33:55 ian Exp $
 */
public class DaytimeServer {
	/** Our server-side rendezvous socket */
	ServerSocket sock;
	/** The port number to use by default */
	public final static int PORT = 37;

	/** main: construct and run */
	public static void main(String[] argv) {
		new DaytimeServer(PORT).runService();
	}

	/** Construct a DaytimeServer on the given port number */
	public DaytimeServer(int port) {
		try {
			sock = new ServerSocket(port);
		} catch (IOException e) {
			System.err.println("I/O error in setup\n" + e);
			System.exit(1);
		}
	}

	/** This handles the connections */
	protected void runService() {
		Socket ios = null;
		DataOutputStream os = null;
		while (true) {
			try {
				System.out.println("Waiting for connection on port " + PORT);
				ios = sock.accept();
				System.err.println("Accepted from " +
					ios.getInetAddress().getHostName());
				os = new DataOutputStream(ios.getOutputStream());
				long time = System.currentTimeMillis();

				time /= DaytimeBinary.MSEC;	// Daytime Protocol is in seconds

				// Convert to Java time base.
				time += DaytimeBinary.BASE_DIFF;

				// Write it, truncating cast to int since it is using
				// the Internet Daytime protocol which uses 4 bytes.
				// This will fail in the year 2038, along with all
				// 32-bit timekeeping systems based from 1970.
				// Remember, you read about the Y2038 crisis here first!
				os.writeInt((int)time);
				os.close();
			} catch (IOException e) {
				System.err.println(e);
			}
		}
	}
}
//@@@@@@//
//network/DaytimeText.java
//@@@@@@//
import java.io.*;
import java.net.*;

/**
 * DaytimeText - connect to the standard Daytime (ascii) service.
 * @author Ian F. Darwin
 * @version $Id: DaytimeText.java,v 1.4 2002/10/26 13:53:50 ian Exp $
 */
public class DaytimeText {
	public static final short TIME_PORT = 13;

	public static void main(String[] argv) {
		String hostName;
		if (argv.length == 0)
			hostName = "localhost";
		else
			hostName = argv[0];

		try {
			Socket sock = new Socket(hostName, TIME_PORT);
			BufferedReader is = new BufferedReader(new 
				InputStreamReader(sock.getInputStream()));
			String remoteTime = is.readLine();
			System.out.println("Time on " + hostName + " is " + remoteTime);
		} catch (IOException e) {
			System.err.println(e);
		}
	}
}
//@@@@@@//
//network/DaytimeUDP.java
//@@@@@@//
import java.io.*;
import java.net.*;

import com.darwinsys.util.Debug;

/**
 * Simple UDP client - contact the standard ascii time service
 * @author Ian Darwin, http://www.darwinsys.com/.
 */
public class DaytimeUDP {
	/** The UDP port number */
	public final static int DAYTIME_PORT = 13;

	/** A buffer plenty big enough for the date string */
	protected final static int PACKET_SIZE = 100;

	/** The main program that drives this network client.
	 * @param argv[0] hostname, running daytime/udp server
	 */
	public static void main(String[] argv) throws IOException {
		if (argv.length < 1) {
			System.err.println("usage: java DayTimeUDP host");
			System.exit(1);
		}
		String host = argv[0];
		InetAddress servAddr = InetAddress.getByName(host);
		DatagramSocket sock = new DatagramSocket();
		//sock.connect(servAddr, DAYTIME_PORT);
		byte[] buffer = new byte[PACKET_SIZE];

		// The udp packet we will send and receive
		DatagramPacket packet = new DatagramPacket(
			buffer, PACKET_SIZE, servAddr, DAYTIME_PORT);

		/* Send empty max-length (-1 for null byte) packet to server */
		packet.setLength(PACKET_SIZE-1);
		sock.send(packet);
		Debug.println("net", "Sent request");

		// Receive a packet and print it.
		sock.receive(packet);
		Debug.println("net", "Got packet of size " + packet.getLength());
		System.out.print("Date on " + host + " is " + 
			new String(buffer, 0, packet.getLength()));
	}
}
//@@@@@@//
//network/EchoClient.java
//@@@@@@//
import java.io.*;
import java.net.*;

/** EchoClient - simple line-mode echo client. Reads from stdin,
 * writes to console.
 * Talks to a UNIX "echo" server or a surrogate for it (EchoServer.java).
 * @author	Ian Darwin, Learning Tree, Course 471/478 author.
 * @version Copyright (C) 1995, 1996 Ian F. Darwin
 */
public class EchoClient {
	/** Main program: construct an EchoClient object and use
	 * its "converse" method to call the Echo server.
	 */
	public static void main(String[] argv) {
		EchoClient c = new EchoClient();
		c.converse(argv.length==1?argv[0]:"localhost");
	}

	/** Hold one conversation with the named hosts echo server */
	protected void converse(String hostname) {
		Socket sock = null;
		try {
			int i;
			sock = new Socket(hostname, 7);	// echo server.
			BufferedReader stdin = new BufferedReader(
				new InputStreamReader(System.in));
			BufferedReader is = new BufferedReader(
				new InputStreamReader(sock.getInputStream(), "8859_1"));
			PrintWriter os = new PrintWriter(
				new OutputStreamWriter(
					sock.getOutputStream(), "8859_1"), true);

			String line;
			do {
				System.out.print(">> ");
				if ((line = stdin.readLine()) == null)
					break;
				// Do the CRLF ourself since println appends only a \r on
				// platforms where that is the native line ending.
				os.print(line + "\r\n");
				os.flush();
				String reply = is.readLine();
				System.out.print("<< ");
				System.out.println(reply);
			} while (line != null);
		} catch (IOException e) {	// handles all input/output errors
			System.err.println(e);
		} finally {					// cleanup
			try {
				if (sock != null)
					sock.close();
			} catch (IOException ignoreMe) {
				// nothing
			}
		}
	}
}
//@@@@@@//
//network/EchoClientOneLine.java
//@@@@@@//
import java.io.*;
import java.net.*;
/**
 * EchoClientOneLine - create client socket, send one line,
 * read it back. See also EchoClient.java, slightly fancier.
 */
public class EchoClientOneLine {
	/** What we send across the net */
	String mesg = "Hello across the net";

	public static void main(String[] argv) {
		if (argv.length == 0)
			new EchoClientOneLine().converse("localhost");
		else
			new EchoClientOneLine().converse(argv[0]);
	}

	/** Hold one conversation across the net */
	protected void converse(String hostName) {
		try {
			Socket sock = new Socket(hostName, 7); // echo server.
			BufferedReader is = new BufferedReader(new 
				InputStreamReader(sock.getInputStream()));
			PrintWriter os = new PrintWriter(sock.getOutputStream(), true);
			// Do the CRLF ourself since println appends only a \r on
			// platforms where that is the native line ending.
			os.print(mesg + "\r\n"); os.flush();
			String reply = is.readLine();
			System.out.println("Sent \"" + mesg  + "\"");
			System.out.println("Got  \"" + reply + "\"");
		} catch (IOException e) {
			System.err.println(e);
		}
	}
}
//@@@@@@//
//network/EchoGui.java
//@@@@@@//
import java.awt.*;
import java.io.*;
import java.net.*;

/**
 * EchoGui - create client socket, do I-O on it.
 *
 * @author	Ian Darwin, Learning Tree, Course 471/478
 */
public class EchoGui {
	String hostname = null;
	Socket sock;
	BufferedReader is;
	PrintWriter os;
	TextArea ta;

	public static void main(String[] argv) {
		if (argv.length == 0)
			new EchoGui().converse();
		else
			new EchoGui(argv[0]).converse();
	}

	EchoGui(String host) {
		Frame f = new Frame("EchoGui");
		f.add("Center", ta = new TextArea(24, 80));
		f.pack();
		f.setVisible(true);
		hostname = host;
	}
	EchoGui() {
		this("localhost");
	}
	protected void converse() {
		try {
			String mesg = "Hello \u08b7 across the net\u2603";
			sock = new Socket(hostname, 7);	// echo server.
			is = new BufferedReader(new InputStreamReader(sock.getInputStream()));
			os = new PrintWriter(sock.getOutputStream(), true);

			os.write(mesg); os.print("\r\n");
			ta.append("Sent \"" + mesg  + "\"");

			String reply = is.readLine();
			ta.append("Got  \"" + reply + "\"");
		} catch (IOException e) {
			System.err.println(e);
		}
	}
}
//@@@@@@//
//network/EchoServer.java
//@@@@@@//
import java.io.*;
import java.net.*;

/**
 * EchoServer - create server socket, do I-O on it.
 *
 * @author  Ian Darwin
 * @version Copyright (c) 1995, 1996, 1997, 2000 Ian F. Darwin
 */
public class EchoServer {
	/** Our server-side rendezvous socket */
	protected ServerSocket sock;
	/** The port number to use by default */
	public final static int ECHOPORT = 7;
	/** Flag to control debugging */
	protected boolean debug = true;

	/** main: construct and run */
	public static void main(String[] argv) {
		new EchoServer(ECHOPORT).handle();
	}

	/** Construct an EchoServer on the given port number */
	public EchoServer(int port) {
		try {
			sock = new ServerSocket(port);
		} catch (IOException e) {
			System.err.println("I/O error in setup");
			System.err.println(e);
			System.exit(1);
		}
	}

	/** This handles the connections */
	protected void handle() {
		Socket ios = null;
		BufferedReader is = null;
		PrintWriter os = null;
		while (true) {
			try {
				System.out.println("Waiting for client...");
				ios = sock.accept();
				System.err.println("Accepted from " +
					ios.getInetAddress().getHostName());
				is = new BufferedReader(
					new InputStreamReader(ios.getInputStream(), "8859_1"));
				os = new PrintWriter(
						new OutputStreamWriter(
							ios.getOutputStream(), "8859_1"), true);
				String echoLine;
				while ((echoLine = is.readLine()) != null) {
					System.err.println("Read " + echoLine);
					os.print(echoLine + "\r\n");
					os.flush();
					System.err.println("Wrote " + echoLine);
				}
				System.err.println("All done!");
			} catch (IOException e) {
				System.err.println(e);
			} finally {
				try {
					if (is != null)
						is.close();
					if (os != null)
						os.close();
					if (ios != null)
						ios.close();
				} catch (IOException e) {
					// These are unlikely, but might indicate that
					// the other end shut down early, a disk filled up
					// but wasn't detected until close, etc.
					System.err.println("IO Error in close");
				}
			}
		}
		/*NOTREACHED*/
	}
}
//@@@@@@//
//network/EchoServerThreaded.java
//@@@@@@//
import java.net.*;
import java.io.*;

/**
 * Threaded Echo Server, sequential allocation scheme.
 * @author Ian F. Darwin.
 */
public class EchoServerThreaded {

	public static final int ECHOPORT = 7;

	public static void main(String[] av)
	{
		new EchoServerThreaded().runServer();
	}

	public void runServer()
	{
		ServerSocket sock;
		Socket clientSocket;

		try {
			sock = new ServerSocket(ECHOPORT);
		
			System.out.println("EchoServerThreaded ready for connections.");

			/* Wait for a connection */
			while(true){
				clientSocket = sock.accept();
				/* Create a thread to do the communication, and start it */
				new Handler(clientSocket).start();
			}
		} catch(IOException e) {
			/* Crash the server if IO fails. Something bad has happened */
			System.err.println("Could not accept " + e);
			System.exit(1);
		}
	}

	/** A Thread subclass to handle one client conversation. */
	class Handler extends Thread {
		Socket sock;

		Handler(Socket s) {
			sock = s;
		}

		public void run() {
			System.out.println("Socket starting: " + sock);
			try {
				BufferedReader is =
					new BufferedReader(
						new InputStreamReader(sock.getInputStream()));
				PrintStream os = new PrintStream(sock.getOutputStream(), true);
				String line;
				while ((line = is.readLine()) != null) {
					os.print(line + "\r\n");
					os.flush();
				}
				sock.close();
			} catch (IOException e) {
				System.out.println("IO Error on socket " + e);
				return;
			}
			System.out.println("Socket ENDED: " + sock);
		}
	}
}
//@@@@@@//
//network/EchoServerThreaded2.java
//@@@@@@//
import java.net.*;
import java.io.*; 

/**
 * Threaded Echo Server, pre-allocation scheme.
 * Each Thread waits in its accept() call for a connection; this synchronizes
 * on the serversocket when calling its accept() method.
 * @author Ian F. Darwin.
 */
public class EchoServerThreaded2 {

	public static final int ECHOPORT = 7;

	public static final int NUM_THREADS = 4;

	/** Main method, to start the servers. */
	public static void main(String[] av)
	{
		new EchoServerThreaded2(ECHOPORT, NUM_THREADS);
	}

	/** Constructor */
	public EchoServerThreaded2(int port, int numThreads)
	{
		ServerSocket servSock;
		Socket clientSocket;

		try {
			servSock = new ServerSocket(ECHOPORT);
		
		} catch(IOException e) {
			/* Crash the server if IO fails. Something bad has happened */
			throw new RuntimeException("Could not create ServerSocket " + e);
		}

		// Create a series of threads and start them.
		for (int i=0; i<numThreads; i++) {
			new Handler(servSock, i).start();
		}
	}

	/** A Thread subclass to handle one client conversation. */
	class Handler extends Thread {
		ServerSocket servSock;
		int threadNumber;

		/** Construct a Handler. */
		Handler(ServerSocket s, int i) {
			super();
			servSock = s;
			threadNumber = i;
			setName("Thread " + threadNumber);
		}

		public void run() 
		{
			/* Wait for a connection. Synchronized on the ServerSocket
			 * while calling its accept() method.
			 */
			while (true) {
				try {
					System.out.println( getName() + " waiting");

					Socket clientSocket;
					// Wait here for the next connection.
					synchronized(servSock) {
						clientSocket = servSock.accept();
					}
					System.out.println(getName() + " starting, IP=" + 
						clientSocket.getInetAddress());
					BufferedReader is = new BufferedReader(
						new InputStreamReader(clientSocket.getInputStream()));
					PrintStream os = new PrintStream(
						clientSocket.getOutputStream(), true);
					String line;
					while ((line = is.readLine()) != null) {
						os.print(line + "\r\n");
						os.flush();
					}
					System.out.println(getName() + " ENDED ");
					clientSocket.close();
				} catch (IOException ex) {
					System.out.println(getName() + ": IO Error on socket " + ex);
					return;
				}
			}
		}
	}
}
//@@@@@@//
//network/ErrorReporting.java
//@@@@@@//
import java.net.*;

/* Client with error handling */
public class ErrorReporting {
	public static void main(String[] argv) {
		int tcp_port = 80;
		String server_name = argv.length == 0 ? "localhost" : argv[0];
		try {
			Socket sock = new Socket(server_name, tcp_port);

			/* Finally, we can read and write on the socket. */
			System.out.println(" *** Connected to " + server_name  + " ***");
			/* ... */

			sock.close();

		} catch (UnknownHostException e) {
			System.err.println(server_name + " Unknown host");
			return;
		} catch (NoRouteToHostException e) {
			System.err.println(server_name + " Unreachable" );
			return;
		} catch (ConnectException e) {
			System.err.println(server_name + " connect refused");
			return;
		} catch (java.io.IOException e) {
			System.err.println(server_name + ' ' + e.getMessage());
			return;
		}
	}
}
//@@@@@@//
//network/Finger.java
//@@@@@@//
import java.io.*;
import java.net.*;
import java.util.StringTokenizer;

/**
 * Finger -- access remote finger client.
 *
 * @author	Ian Darwin, Learning Tree, Course 471/478
 */
public class Finger {
	static String mesg;
	static Socket sock;
	static BufferedReader is;
	static PrintStream os;

	public static void main(String[] av) {
		if (av.length == 0)
			System.out.println("Just you");
		else for (int i=0; i<av.length; i++)
			new Finger().finger(av[i]);
	}

	void finger(String s) {
		StringTokenizer st = new StringTokenizer(s, "@", true);
		String user = (String)st.nextElement();
		st.nextElement();
		String host = (String)st.nextElement();
		//if (st.countTokens() != 2) {
		//	System.out.println("Count = " + st.countTokens());
		//	System.err.println("User " + s + " invalid, must be user@host");
		//	return;
		//}
		System.out.println("[" + user + "@" + host + "]");
		try {
			sock = new Socket(host, 7);
			is =
				new BufferedReader(
					new InputStreamReader(sock.getInputStream()));
			os = new PrintStream(sock.getOutputStream());

			if (true) // long flag
				os.print("/W "); // wide mode

			// Write request, with \n so readLine() doesn't hang!
			os.print("\r\n");
			os.flush();

			// Whatever we get back, we print.
			// No timeout policy -- if it hangs, user can INTR.
			String reply;
			while ((reply = is.readLine()) != null)
				System.out.println(reply);

		} catch (IOException e) {
			System.err.println(e);
		}
	}
}
//@@@@@@//
//network/Inet6Demo.java
//@@@@@@//
import java.net.*;
import java.io.*;

public class Inet6Demo {
	/** A well-known port that often listens on IPV4 and IPV6 */
	public final static int DAYTIME_PORT = 13;

	/** The server host */
	private final static String HOST = "darian6";

	public static void main(String[] args) throws IOException {

		Inet6Address server = (Inet6Address) Inet6Address.getByName(HOST);
		System.out.println("Lookup: " + server);

		Socket clientSocket;
		// clientSocket = new Socket(server, DAYTIME_PORT);
		clientSocket = new Socket("fe80::203:93ff:fe07:3ef6", DAYTIME_PORT);
		System.out.println(clientSocket);

		BufferedReader is = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
		String dateString = is.readLine();
		System.out.println(dateString);
		is.close();
		clientSocket.close();
	}
}
//@@@@@@//
//network/InetAddrDemo.java
//@@@@@@//
import java.io.*;
import java.net.*;

public class InetAddrDemo {
	public static void main(String[] args)
	throws IOException {
		String ipNumber = "123.45.67.89";
		String hostName = "www.darwinsys.com";

		// Look up a host by name
		System.out.println(hostName + "'s address is " +
			InetAddress.getByName(hostName).getHostAddress());

		// Look up a host by address
		System.out.println(ipNumber + "'s name is " +
			InetAddress.getByName(ipNumber).getHostName());

		Socket theSocket = new Socket("server", 80);
		int myPortNumber = 12345;

		// Connect to different portnum on same host as an open Socket
		InetAddress remote = theSocket.getInetAddress();
		Socket anotherSocket = new Socket(remote, myPortNumber);
	}
}
//@@@@@@//
//network/JSSEWebServer0.java
//@@@@@@//
import java.net.ServerSocket;
import javax.net.ssl.SSLServerSocketFactory;

/**
 * JSSEWebServer - subclass trivial WebServer0 to make it use SSL.
 * @version $Id: JSSEWebServer0.java,v 1.1 2004/03/09 03:59:36 ian Exp $
 */
public class JSSEWebServer0 extends WebServer0 {

	public static final int HTTPS = 8443;
	
	public static void main(String[] args) throws Exception {
		System.out.println("DarwinSys JSSE Server 0.0 starting...");
		JSSEWebServer0 w = new JSSEWebServer0();
		w.runServer(HTTPS);		// never returns!!
	}
	
	/** Get an HTTPS ServerSocket using JSSE.
	 * @see WebServer0#getServerSocket(int)
	 * @throws ClassNotFoundException if the SecurityProvider cannot be instantiated.
	 */
	protected ServerSocket getServerSocket(int port) throws Exception {
		
		SSLServerSocketFactory ssf = (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();
		
		return ssf.createServerSocket(port);
	}

}
//@@@@@@//
//network/Listen.java
//@@@@@@//
import java.io.*;
import java.net.*;

/**
 * Listen -- make a ServerSocket and wait for connections.
 * @author Ian F. Darwin
 * @version $Id: Listen.java,v 1.2 2001/01/13 23:09:58 ian Exp $
 */
public class Listen {
	/** The TCP port for the service. */
	public static final short PORT = 9999;

	public static void main(String[] argv) throws IOException {
		ServerSocket sock;
		Socket  clientSock;
		try {
			sock = new ServerSocket(PORT);
			while ((clientSock = sock.accept()) != null) {

				// Process it.
				process(clientSock);
			}

		} catch (IOException e) {
			System.err.println(e);
		}
	}

	/** This would do something with one client. */
	static void process(Socket s) throws IOException {
		System.out.println("Accept from client " + s.getInetAddress());
		// The conversation would be here.
		s.close();
	}
}
//@@@@@@//
//network/ListenInside.java
//@@@@@@//
import java.io.*;
import java.net.*;

/**
 * ListenInside -- make a server socket that listens only on
 * a particular interface, in this case, one named by INSIDE_HOST.
 * @author Ian F. Darwin
 * @version $Id: ListenInside.java,v 1.2 2004/02/16 02:44:43 ian Exp $
 */
public class ListenInside {
	/** The TCP port for the service. */
	public static final short PORT = 9999;
	/** The name of the network interface. */
	public static final String INSIDE_HOST = "acmewidgets-inside";
	/** The number of clients allowed to queue */
	public static final int BACKLOG = 10;

	public static void main(String[] argv) throws IOException {
		ServerSocket sock;
		Socket  clientSock;
		try {
			sock = new ServerSocket(PORT, BACKLOG, 
				InetAddress.getByName(INSIDE_HOST));
			while ((clientSock = sock.accept()) != null) {

				// Process it.
				process(clientSock);
			}

		} catch (IOException e) {
			System.err.println(e);
		}
	}

	/** Hold server's conversation with one client. */
	static void process(Socket s) throws IOException {
		System.out.println("Connected from  " + INSIDE_HOST + 
			": " + s.getInetAddress(  ));
		// The conversation would be here.
		s.close();
	}
}
//@@@@@@//
//network/Log14Demo.java
//@@@@@@//
import java.util.logging.Logger;

public class Log14Demo {
	public static void main(String[] args) {

		Logger myLogger = Logger.getLogger("com.darwinsys");

		Object o = new Object();
		myLogger.info("I created an object: " + o);
	}
}
//@@@@@@//
//network/Log14Demo2.java
//@@@@@@//
import java.util.logging.Logger;
import java.util.logging.LogRecord;
import java.util.logging.Level;

public class Log14Demo2 {
	public static void main(String[] args) {

		Logger myLogger = Logger.getLogger("com.darwinsys");

		try {
			Object o = new Object();
			if (o != null) {	// bogus, just to show logging
				throw new IllegalArgumentException("Just testing");
			}
			myLogger.info("I created an object: " + o);
		} catch (Throwable t) {
			LogRecord msg = new LogRecord(Level.SEVERE,
				"Caught exception ");
			msg.setThrown(t);
			myLogger.log(msg);
		}
	}
}
//@@@@@@//
//network/Log4JDemo.java
//@@@@@@//
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;

public class Log4JDemo {
	public static void main(String[] args) {

		Logger myLogger = Logger.getLogger("com.darwinsys");

		// PropertyConfigurator.configure("log4j.properties");
		
		Object o = new Object();
		myLogger.info("I created an object: " + o);

	}
}
//@@@@@@//
//network/Log4JDemo2.java
//@@@@@@//
import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;

public class Log4JDemo2 {
	public static void main(String[] args) {

		Logger myLogger = Logger.getLogger("com.darwinsys");

		try {
			Object o = new Object();
			if (o != null) {	// bogus, just to show logging
				throw new IllegalArgumentException("Just testing");
			}
			myLogger.info("I created an object: " + o);
		} catch (Exception ex) {
			// XXX
			myLogger.error("Caught Exception: " + ex);
		}
	}
}
//@@@@@@//
//network/NetLog.java
//@@@@@@//
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.Socket;

/** NetLog - NetLog client API.
 * @see		NetLogSimple -- demonstration example usage.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version Copyright (C) 1995, 1996 Ian Darwin
 */
public class NetLog {
	protected final static int NETLOG_PORT = NetLogServer.PORT;
	protected int port = NETLOG_PORT;
	protected Socket sock = null;
	protected PrintWriter os;

	public NetLog() throws IOException {
		this(NETLOG_PORT);
	}

	public NetLog(int prtNum) throws IOException {
		this(InetAddress.getLocalHost(), prtNum);
	}

	public NetLog(String host, int prtNum) throws IOException {
		this(InetAddress.getByName(host), prtNum);
	}

	public NetLog(InetAddress host, int prtNum) throws IOException {
		port = prtNum;
		sock = new Socket(host, prtNum);
		os = new PrintWriter(
			new OutputStreamWriter(
				sock.getOutputStream(), "8859_1"), true);
	}

	/** Send one String to the log */
	public void log(String mesg) throws IOException {
		if (os == null)
			return;

		// System.out.print(">> ");
		os.print(mesg);
		// Do the CRLF ourself since println appends only a \r on
		// platforms where that is the native line ending.
		os.print("\r\n");
		os.flush();
	}

	/** Send one Object to the log */
	public void log(Object obj) throws IOException {
		if (os == null)
			return;
		if (obj == null) {
			// throw IllegalStateException??
			return;
		}
		log(obj.toString());
	}

	/** Close the log. */
	public void close() {
		os.close();
		os = null;
	}
}
//@@@@@@//
//network/NetLogServer.java
//@@@@@@//
import javax.swing.*;
import java.awt.event.*;
import java.net.*;
import java.io.*;

/**
 * Threaded NetLog Server, pre-allocation schema.
 * @author Ian F. Darwin.
 */
public class NetLogServer {

	public static final int PORT = 65432;

	public static final int NUM_THREADS = 8;

	JFrame theFrame;
	JTextArea theTextArea;

	/** Main method, to start the servers. */
	public static void main(String[] av)
	{
		new NetLogServer(PORT, NUM_THREADS);
	}

	/** Constructor */
	public NetLogServer(int port, int numThreads)
	{
		ServerSocket servSock;
		Socket clientSocket;

		try {
			servSock = new ServerSocket(PORT);

		} catch(IOException e) {
			/* Crash the server if IO fails. Something bad has happened */
			System.err.println("Could not create ServerSocket " + e);
			System.exit(1);
			return;	/*NOTREACHED*/
		}

		// Build the GUI - must be before Handler constructors!
		theFrame  = new JFrame("NetLog Server");
		theTextArea = new JTextArea(24, 80);
		theTextArea.setEditable(false);
		theTextArea.setBorder(BorderFactory.createTitledBorder("NetLogServer"));
		theFrame.getContentPane().add(new JScrollPane(theTextArea));

		// Now start the Threads
		for (int i=0; i<numThreads; i++) {
			new Handler(servSock, i).start();
		}

		theFrame.pack();
		theFrame.setVisible(true);
		theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	}

	public synchronized void log(int tid, String s) {
		StringBuffer sb = new StringBuffer();
		sb.append(tid);
		sb.append(": ");

		if (s == null) {
			sb.append("(null)");
		}
		else if (s.length() == 0) {
			sb.append("(null string)");
		}
		else
			sb.append(s);

		sb.append('\n');
		theTextArea.append(sb.toString());
		theTextArea.setCaretPosition(theTextArea.getText().length());
		theFrame.toFront();
	}

	/** A Thread subclass to handle one client conversation. */
	class Handler extends Thread {
		ServerSocket servSock;
		int tid;

		/** Construct a Handler. */
		Handler(ServerSocket s, int i) {
			super();
			servSock = s;
			tid = i;
			setName("Thread " + tid);
		}

		public void run()
		{
			/* Wait for a connection */
			while (true){
				try {
					// log(tid, getName() + " waiting");
					Socket clientSocket = servSock.accept();
					log(tid,getName() + " START, IP=" +
						clientSocket.getInetAddress());
					BufferedReader is = new BufferedReader(
						new InputStreamReader(clientSocket.getInputStream()));
					String line;
					while ((line = is.readLine()) != null) {
						// System.out.println(">> " + line);
						log(tid,line);
					}
					log(tid,getName() + " ENDED ");
					clientSocket.close();
				} catch (IOException ex) {
					log(tid, getName() + ": IO Error on socket " + ex);
					return;
				}
			}
		}
	}
}
//@@@@@@//
//network/NetLogSimple.java
//@@@@@@//
import java.io.IOException;

/* A simple example of using the NetLog program.
 * Unrealistic in that it's standalone; this API is
 * intended for use inside another program, possibly
 * a servlet or EJB.
 */
public class NetLogSimple {

	public static void main(String[] args) throws IOException {

		System.out.println("NetLogSimple: Starting...");

		// Get the connection to the NetLog
		NetLog nl = new NetLog();

		// Show sending a String
		nl.log("Hello Java");

		// Show sending Objects
		nl.log(new java.util.Date());
		nl.log(nl);

		// Show sending null and "" (normally an accident...)
		nl.log(null);
		nl.log("");

		// All done, close the log
		nl.close();

		System.out.println("NetLogSimple: Done...");
	}
}
//@@@@@@//
//network/NetworkInterfaceDemo.java
//@@@@@@//
import java.io.IOException;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.util.Enumeration;

/**
 * Show some uses of the new-in-1.4 NetworkInterface class.
 */
public class NetworkInterfaceDemo {
	public static void main(String[] a) throws IOException {
		Enumeration list = NetworkInterface.getNetworkInterfaces();
		while (list.hasMoreElements()) {
			// Get one NetworkInterface
			NetworkInterface iface = (NetworkInterface) list.nextElement();
			// Print its name
			System.out.println(iface.getDisplayName());
			Enumeration addrs = iface.getInetAddresses();
			// And its address(es)
			while (addrs.hasMoreElements()) {
				InetAddress addr = (InetAddress) addrs.nextElement();
				System.out.println(addr);
			}

		}
		// Try to get the Interface for a given local (this machine's) address
		InetAddress destAddr = InetAddress.getByName("daroad");
		try {
			NetworkInterface dest = NetworkInterface.getByInetAddress(destAddr);
			System.out.println("Address for " + destAddr + " is " + dest);
		} catch (SocketException ex) {
			System.err.println("Couldn't get address for " + destAddr);
		}
	}
}
//@@@@@@//
//network/Probe.java
//@@@@@@//
import java.net.*;
/**
 * Probe a network address for useful information.
 */
public class Probe {
	public static void main(String[] argv) {
		if (argv.length == 0) {
			System.err.println("lusage: Probe hostname [...]");
			return;
		}
		Probe p = new Probe();
		for (int i=0; i<argv.length; i++)
			p.probe(argv[i]);
	}
	/** Do all the probing for one hostname */
	void probe(String hn) {
		System.out.println("Java NetProbe 0.0: probing " + hn);
		try {
			InetAddress all[] = InetAddress.getAllByName(hn);
			System.out.println(hn + " has " + all.length + " addresses.");
			for (int i=0; i<all.length; i++)
				System.out.println("Address " + all[i]);
		} catch (UnknownHostException ue) {
			System.out.println("Unknown host " + hn);
		}
	}
}
//@@@@@@//
//network/RemCat.java
//@@@@@@//
import java.io.*;
import java.net.*;

/**
 * <p>
 * RemCat - remotely cat (DOS type) a file, using the TFTP protocol.
 * Inspired by the "rcat" exercise in Learning Tree Course 363, 
 * <I>UNIX Network Programming</I>, by Dr. Chris Brown.</p>
 * <[>
 * Note that the TFTP server is NOT "internationalized"; the name and
 * mode *in the protocol* are defined in terms of ASCII, not UniCode.</p>
 *
 * @author	Chris R. Brown, original C version
 * @author	Java version by Ian Darwin, http://www.darwinsys.com/.
 */
public class RemCat {
	/** The UDP port number */
	public final static int TFTP_PORT = 69;
	/** The mode we will use - octet for everything. */
	protected final String MODE = "octet";

	/** The offset for the code/response as a byte */
	protected final int OFFSET_REQUEST = 1;
	/** The offset for the packet number as a byte */
	protected final int OFFSET_PACKETNUM = 3;

	/** Debugging flag */
	protected static boolean debug = false;

	/** TFTP op-code for a read request */
	public final int OP_RRQ = 1;
	/** TFTP op-code for a read request */
	public final int OP_WRQ = 2;
	/** TFTP op-code for a read request */
	public final int OP_DATA = 3;
	/** TFTP op-code for a read request */
	public final int OP_ACK	= 4;
	/** TFTP op-code for a read request */
	public final int OP_ERROR = 5;

	protected final static int PACKET_SIZE = 516;	// == 2 + 2 + 512
	protected String host;
	protected InetAddress servAddr;
	protected DatagramSocket sock;
	protected byte buffer[];
	protected DatagramPacket inp, outp;

	/** The main program that drives this network client.
	 * @param argv[0] hostname, running TFTP server
	 * @param argv[1..n] filename(s), must be at least one
	 */
	public static void main(String[] argv) throws IOException {
		if (argv.length < 2) {
			System.err.println("usage: rcat host filename[...]");
			System.exit(1);
		}
		if (debug)
			System.err.println("Java RemCat starting");
		RemCat rc = new RemCat(argv[0]);
		for (int i = 1; i<argv.length; i++) {
			if (debug)
				System.err.println("-- Starting file " + 
					argv[0] + ":" + argv[i] + "---");
			rc.readFile(argv[i]);
		}
	}

	RemCat(String host) throws IOException {
		super();
		this.host = host;
		servAddr = InetAddress.getByName(host);
		sock = new DatagramSocket();
		buffer = new byte[PACKET_SIZE];
		outp = new DatagramPacket(buffer, PACKET_SIZE, servAddr, TFTP_PORT);
		inp = new DatagramPacket(buffer, PACKET_SIZE);
	}

	/* Build a TFTP Read Request packet. This is messy because the
	 * fields have variable length. Numbers must be in
	 * network order, too; fortunately Java just seems 
	 * naturally smart enough :-) to use network byte order.
	 */
	void readFile(String path) throws IOException {
		buffer[0] = 0;
		buffer[OFFSET_REQUEST] = OP_RRQ;		// read request
		int p = 2;			// number of chars into buffer

		// Convert filename String to bytes in buffer , using "p" as an
		// offset indicator to get all the bits of this request
		// in exactly the right spot.
		byte[] bTemp = path.getBytes();	// i.e., ASCII
		System.arraycopy(bTemp, 0, buffer, p, path.length());
		p += path.length();
		buffer[p++] = 0;		// null byte terminates string

		// Similarly, convert MODE ("stream" or "octet") to bytes in buffer
		bTemp = MODE.getBytes();	// i.e., ASCII
		System.arraycopy(bTemp, 0, buffer, p, MODE.length());
		p += MODE.length();
		buffer[p++] = 0;		// null terminate

		/* Send Read Request to tftp server */
		outp.setLength(p);
		sock.send(outp);

		/* Loop reading data packets from the server until a short
		 * packet arrives; this indicates the end of the file.
		 */
		int len = 0;
		do {
			sock.receive(inp);
			if (debug)
				System.err.println(
					"Packet # " + Byte.toString(buffer[OFFSET_PACKETNUM])+
					"RESPONSE CODE " + Byte.toString(buffer[OFFSET_REQUEST]));
			if (buffer[OFFSET_REQUEST] == OP_ERROR) {
				System.err.println("rcat ERROR: " +
					new String(buffer, 4, inp.getLength()-4));
				return;
			}
			if (debug)
				System.err.println("Got packet of size " +
					inp.getLength());

			/* Print the data from the packet */
			System.out.write(buffer, 4, inp.getLength()-4);

			/* Ack the packet. The block number we 
			 * want to ack is already in buffer so 
			 * we just change the opcode. The ACK is 
			 * sent to the port number which the server 
			 * just sent the data from, NOT to port 
			 * TFTP_PORT.
			 */
			buffer[OFFSET_REQUEST] = OP_ACK;
			outp.setLength(4);
			outp.setPort(inp.getPort());
			sock.send(outp);
		} while (inp.getLength() == PACKET_SIZE);

		if (debug)
			System.err.println("** ALL DONE** Leaving loop, last size " +
				inp.getLength());
	}
}
//@@@@@@//
//network/Telnet.java
//@@@@@@//
import java.net.*;
import java.io.*;

/**
 * Telnet - connect to a given host and service
 * This does not hold a candle to a real Telnet client, but
 * shows some ideas on how to implement such a thing.
 * @version $Id: Telnet.java,v 1.11 2004/02/16 02:44:43 ian Exp $
 */
public class Telnet {
	String host;
	int portNum;
	public static void main(String[] argv) {
		new Telnet().talkTo(argv);
	}
	private void talkTo(String av[]) {
		if (av.length >= 1)
			host = av[0];
		else
			host = "localhost";
		if (av.length >= 2)
			portNum = Integer.parseInt(av[1]);
		else portNum = 23;
		System.out.println("Host " + host + "; port " + portNum);
		try {
			Socket s = new Socket(host, portNum);

			// Connect the remote to our stdout
			new Pipe(s.getInputStream(), System.out).start();

			// Connect our stdin to the remote
			new Pipe(System.in, s.getOutputStream()).start();

		} catch(IOException e) {
			System.out.println(e);
			return;
		}
		System.out.println("Connected OK");
	}

	/* This class handles one half of a full-duplex connection.
	 * Line-at-a-time mode.
	 */
	class Pipe extends Thread {
		BufferedReader is;
		PrintStream os;

		/** Construct a Pipe to read from is and write to os */
		Pipe(InputStream is, OutputStream os) {
			this.is = new BufferedReader(new InputStreamReader(is));
			this.os = new PrintStream(os);
		}

		/** Do the reading and writing. */
		public void run() {
			String line;
			try {
				while ((line = is.readLine()) != null) {
					os.print(line);
					os.print("\r\n");
					os.flush();
				}
			} catch(IOException e) {
				throw new RuntimeException(e.getMessage());
			}
		}
	}
}
//@@@@@@//
//network/WebRedirector.java
//@@@@@@//
import java.io.*;
import java.util.*;
import java.net.Socket;


/**
 * Web Redirector - yet another useful? subclass of WebServer0, this one to redirect 
 * any and all incoming requests to a new URL and/or PORT (like 8080).
 * @version $Id: WebRedirector.java,v 1.1 2004/04/03 18:43:01 ian Exp $
 */
public class WebRedirector extends WebServer0 {
	public static final String GOTO = "http://localhost:8080/";
	
	private static String goto = GOTO;
	public static void main(String[] args) throws Exception {
		if (args.length == 1) {
			goto = args[0];
		}
		System.out.println("DarwinSys Web Redirector 0.0 starting...");
		WebRedirector w = new WebRedirector();
		w.runServer(HTTP);		// never returns!!
	}
	
	/** Generate one redirection request
	 * @see WebServer0#Handler(java.net.Socket)
	 */
	public void Handler(Socket s) {
		BufferedReader is;	// inputStream, from Viewer
		PrintWriter os;		// outputStream, to Viewer
		String request;		// what Viewer sends us.
		try {
			String from = s.getInetAddress().toString();
			System.out.println("Accepted connection from " + from);
			os = new PrintWriter(s.getOutputStream(), true);
			is = new BufferedReader(new InputStreamReader(s.getInputStream()));
			request = is.readLine();
			StringTokenizer st = new StringTokenizer(request);
			if (st.countTokens() < 3) {
				os.println("HTTP/1.0 400 invalid request");
				os.println();
				os.flush();
				s.close();
			}
			String requestMethod = st.nextToken();
			String requestURI = st.nextToken();
			String requestVersion = st.nextToken();
			System.out.println("Request: " + requestMethod + " for " + requestURI + " via " + requestVersion);
			String nullLine = is.readLine();
			
			os.println("HTTP/1.1 302 Moved Temporarily");
			os.println("Location: " + GOTO + requestURI);
			os.println("Content-Type: text/plain");
			os.println("Server-name: DarwinSys NULL Java WebRedirector 0");
			os.flush();
			s.close();
		} catch (IOException ex){
			System.err.println("Error: " + ex);
		}
	}
}
//@@@@@@//
//network/WebServer0.java
//@@@@@@//
   . 
 : Q	 R S T
 U V W
  Q
  X Y
  Z
  [	  \
  ]
  ^ _	 R `
 U a
 R b
 c d
 e f g
  Q h
  i
  f j k
 c l
  m
  n
  o p
  q r s
 c t
 " u v
 " V w x y z { | } ~    
  
   
 " 
 c  
    HTTP I ConstantValue   P s Ljava/net/ServerSocket; <init> ()V Code LineNumberTable main ([Ljava/lang/String;)V 
Exceptions  getServerSocket (I)Ljava/net/ServerSocket; 	runServer (I)V Handler (Ljava/net/Socket;)V 
SourceFile WebServer0.java A B    (DarwinSys JavaWeb Server 0.0 starting...    
WebServer0 K L java/net/ServerSocket A L I J ? @   M N java/io/IOException      L       java/lang/StringBuffer Accepted connection from    java/io/BufferedReader java/io/InputStreamReader   A  A    java/util/StringTokenizer A  	Request:  java/io/PrintWriter   A  HTTP/1.0 200 Here is your data Content-type: text/html ,Server-name: DarwinSys NULL Java WebServer 0 D<html><head><title>Wrong System Reached</title></head>
<h1>Welcome,  , but...</h1>
 &<p>You have reached a desktop machine  &that does not run a real Web service.
 #<p>Please pick another system!</p>
 ?<p>Or view <A HREF="http://www.darwinsys.com/java/server.html"> 9the WebServer0 source (at the Authors Web Site)</A>.</p>
 )<hr/><em>Java-based WebServer0</em><hr/>
 </html>
 Content-length:          B  B IOException    java/lang/Object java/lang/Exception java/lang/System out Ljava/io/PrintStream; java/io/PrintStream println (Ljava/lang/String;)V accept ()Ljava/net/Socket; err (Ljava/lang/Object;)V exit java/net/Socket getInetAddress ()Ljava/net/InetAddress; java/net/InetAddress toString ()Ljava/lang/String; append ,(Ljava/lang/String;)Ljava/lang/StringBuffer; getInputStream ()Ljava/io/InputStream; (Ljava/io/InputStream;)V (Ljava/io/Reader;)V readLine getOutputStream ()Ljava/io/OutputStream; (Ljava/io/OutputStream;Z)V java/lang/String length ()I (I)Ljava/lang/StringBuffer; flush close ,(Ljava/lang/Object;)Ljava/lang/StringBuffer; !  :     ; <  =    >   ? @     A B  C        *     D        	 E F  C   ;        Y L+P     D               G     H  I J  C   !     	 Y 	    D       ' G     H  K L  C   b     &** 
 *  M*, M ,    	     D   "    , 	 /  0  5  1  2 ! 3 % 4 G     H  M N  C    	  +  :  Y      Y Y+   M, : Y  :  Y !    , : "Y+ # $N-% &-' &-( & Y )  * + , - . / 0 1  :- Y 2  3 4  &-5 &- &- 6+ 7 :  Y 8  9          D   V    B 	 C # D 6 E < F G G a H g I t J z K  L  M  W  X  Y  Z  [  ^  \  ] _  O    P//@@@@@@//
//numbers/AllTests.java
//@@@@@@//
import junit.framework.Test;
import junit.framework.TestSuite;

/**
 * JUnit test suite for all numbers tests.
 * @author ian
 */
public class AllTests {
	public static void main(String[] args) {
	}
	public static Test suite() {
		TestSuite suite = new TestSuite("Tests for 'numbers' directory");
		//$JUnit-BEGIN$
		suite.addTestSuite(BigNumCalcTest.class);
		suite.addTestSuite(ComplexTest.class);
		// ScaledNumberFormat is not supported; need to sync with
		// latest OpenBSD C version
		// suite.addTestSuite(ScaledNumberFormatTest.class);
		//$JUnit-END$
		return suite;
	}
}
//@@@@@@//
//numbers/BigNumCalc.java
//@@@@@@//
import java.math.BigDecimal;
import java.util.Stack;

/** A trivial reverse-polish stack-based calculator for big numbers */
public class BigNumCalc {

	/** an array of Objects, simulating user input */
	public static Object[] testInput = {
		new BigDecimal("3419229223372036854775807.23343"),
		new BigDecimal("2.0"),
		"*",
	};

	public static void main(String[] args) {
		BigNumCalc calc = new BigNumCalc();
		System.out.println(calc.calculate(testInput));
	}

	Stack s = new Stack();

	public BigDecimal calculate(Object[] input) {
		BigDecimal tmp;
		for (int i = 0; i < input.length; i++) {
			Object o = input[i];
			if (o instanceof BigDecimal) {
				s.push(o);
			} else if (o instanceof String) {
				switch (((String)o).charAt(0)) {
				// + and * are commutative, order doesn't matter
				case '+':
					s.push(((BigDecimal)s.pop()).add((BigDecimal)s.pop()));
					break;
				case '*':
					s.push(((BigDecimal)s.pop()).multiply((BigDecimal)s.pop()));
					break;
				// - and /, order *does* matter
				case '-':
					tmp = (BigDecimal)s.pop();
					s.push(((BigDecimal)s.pop()).subtract(tmp));
					break;
				case '/':
					tmp = (BigDecimal)s.pop();
					s.push(((BigDecimal)s.pop()).divide(tmp,
						BigDecimal.ROUND_UP));
					break;
				default:
					throw new IllegalStateException("Unknown OPERATOR popped");
				}
			} else {
				throw new IllegalArgumentException("Syntax error in input");
			}
		}
		return (BigDecimal)s.pop();
	}
}
//@@@@@@//
//numbers/BigNumCalcTest.java
//@@@@@@//
import java.math.BigDecimal;

import junit.framework.TestCase;

public class BigNumCalcTest extends TestCase {
	BigNumCalc calc;

	public void setUp() {
		calc = new BigNumCalc();
	}

	public void testAdd() {
		Object[] testData = new Object[] {
			new BigDecimal(22),
			new BigDecimal(11),
			"+"
		};
		assertEquals(new BigDecimal(33),
			calc.calculate(testData));
	}

	public void testSubtract() {
		Object[] testData = new Object[] {
			new BigDecimal(22),
			new BigDecimal(11),
			"-"
		};
		assertEquals(new BigDecimal(11),
			calc.calculate(testData));
	}

	public void testMultipy() {
		Object[] testData = new Object[] {
			new BigDecimal(22),
			new BigDecimal(11),
			"*"
		};
		assertEquals(new BigDecimal(242),
			calc.calculate(testData));
	}

	public void testDivide() {
		Object[] testData = new Object[] {
			new BigDecimal(22),
			new BigDecimal(11),
			"/"
		};
		assertEquals(new BigDecimal(2),
			calc.calculate(testData));
	}
}
//@@@@@@//
//numbers/BigNums.java
//@@@@@@//
import java.math.*;

/**
 * Demonstrate large numbers.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: BigNums.java,v 1.4 2004/02/09 03:33:56 ian Exp $
 */
public class BigNums {
	public static void main(String[] argv) {
		//+
		System.out.println("Here's Long.MAX_VALUE: " + Long.MAX_VALUE);
		BigInteger bInt = new BigInteger("3419229223372036854775807");
		System.out.println("Here's a bigger number: " + bInt);
		System.out.println("Here it is as a double: " + bInt.doubleValue());
		//-
	}
}
//@@@@@@//
//numbers/BinaryDigits.java
//@@@@@@//
/**
 * Template for standalone, line-mode main program.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: BinaryDigits.java,v 1.3 2004/02/09 03:33:56 ian Exp $
 */
public class BinaryDigits {
	public static void main(String[] argv) {
		//+
		String bin = "101010";
		System.out.println(bin + " as an integer is " + Integer.valueOf(bin, 2));
		int i = 42;
		System.out.println(i + " as binary digits (bits) is " + 
			Integer.toBinaryString(i));
		//-
	}
}
//@@@@@@//
//numbers/CastNeeded.java
//@@@@@@//
/** Casting Demo. */
public class CastNeeded {
	//+
	public static void main(String[] argv) {
		int i;
		double j = 2.75;
		i = j;			// EXPECT COMPILE ERROR
		i = (int)j;		// with cast; i gets 2
		System.out.println("i =" + i);
		byte b;
		b = i;			// EXPECT COMPILE ERROR
		b = (byte)i;	// with cast, i gets 2
		System.out.println("b =" + b);
	}
	//-
}
//@@@@@@//
//numbers/Complex.java
//@@@@@@//
/** A class to represent Complex Numbers. A Complex object is
 * immutable once created; the add, subtract and multiply routines
 * return newly-created Complex objects containing the results.
 *
 * @author Ian F. Darwin, inspired by David Flanagan.
 * @version $Id: Complex.java,v 1.3 2004/05/13 22:28:59 ian Exp $
 */
public class Complex {
	/** The real part */
	private double r;
	/** The imaginary part */
	private double i;

	/** Construct a Complex */
	Complex(double rr, double ii) {
		r = rr;
		i = ii;
	}

	/** Display the current Complex as a String, for use in
	 * println() and elsewhere.
	 */
	public String toString() {
		StringBuffer sb = new StringBuffer().append(r);
		if (i>0)
			sb.append('+');	// else append(i) appends - sign
		return sb.append(i).append('i').toString();
	}

	/** Return just the Real part */
	public double getReal() {
		return r;
	}
	/** Return just the Real part */
	public double getImaginary() {
		return i;
	}
	/** Return the magnitude of a complex number */
	public double magnitude() {
		return Math.sqrt(r*r + i*i);
	}

	/** Add another Complex to this one
	 */
	public Complex add(Complex other) {
		return add(this, other);
	}

	/** Add two Complexes
	 */
	public static Complex add(Complex c1, Complex c2) {
		return new Complex(c1.r+c2.r, c1.i+c2.i);
	}

	/** Subtract another Complex from this one
	 */
	public Complex subtract(Complex other) {
		return subtract(this, other);
	}

	/** Subtract two Complexes
	 */
	public static Complex subtract(Complex c1, Complex c2) {
		return new Complex(c1.r-c2.r, c1.i-c2.i);
	}

	/** Multiply this Complex times another one
	 */
	public Complex multiply(Complex other) {
		return multiply(this, other);
	}

	/** Multiply two Complexes
	 */
	public static Complex multiply(Complex c1, Complex c2) {
		return new Complex(c1.r*c2.r - c1.i*c2.i, c1.r*c2.i + c1.i*c2.r);
	}

	/** Divide c1 by c2.
	 * @author Gisbert Selke.
	 */
	public static Complex divide(Complex c1, Complex c2) {
		return new Complex(
			(c1.r*c2.r+c1.i*c2.i)/(c2.r*c2.r+c2.i*c2.i),
			(c1.i*c2.r-c1.r*c2.i)/(c2.r*c2.r+c2.i*c2.i));
	}
	
	/* Compare this Complex number with another
	 */
	public boolean equals(Object o) {
		if (!(o instanceof Complex))
			throw new IllegalArgumentException(
					"Complex.equals argument must be a Complex");
		Complex other = (Complex)o;
		return r == other.r && i == other.i;
	}
	
	/* Generate a hashCode; not sure how well distributed these are.
	 */
	public int hashCode() {
		return (int)( r) |  (int)i;
	}
}
//@@@@@@//
//numbers/ComplexDemo.java
//@@@@@@//
/** A class to test Complex Numbers. 
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ComplexDemo.java,v 1.6 2004/05/13 22:28:59 ian Exp $
 */
public class ComplexDemo {
	/** The program */
	public static void main(String[] args) {
		Complex c = new Complex(3,  5);
		Complex d = new Complex(2, -2);
		System.out.println(c);
		System.out.println(c + ".getReal() = " + c.getReal());
		System.out.println(c + " + " + d + " = " + c.add(d));
		System.out.println(c + " + " + d + " = " + Complex.add(c, d));
		System.out.println(c + " * " + d + " = " + c.multiply(d));
		System.out.println(Complex.divide(c, d));
	}
}
//@@@@@@//
//numbers/ComplexTest.java
//@@@@@@//
import junit.framework.TestCase;

/**
 * Test cases for Complex
 * @author ian
 */
public class ComplexTest extends TestCase {
	public void testEquals() {
		Complex c = new Complex(Math.PI, -Math.PI);
		assertEquals("equality test", c, c);
	}
	
	public void testAdd() {
		Complex a = new Complex(3,-1);
		Complex b = new Complex(1, 5);
		Complex sum = Complex.add(a, b);
		assertEquals("add test", new Complex(4, 4), sum);
	}
	
	public void testMultiply() {
		Complex c = new Complex(3,  5);
		Complex d = new Complex(2, -2);
		Complex m = new Complex(16.0, 4.0);
	}
	
	// TODO: test divide
	
	public void testToString() {
		assertEquals("toString Test", "3.4-5.6i", 
				new Complex(3.4, -5.6).toString());
	}
}
//@@@@@@//
//numbers/FloatCmp.java
//@@@@@@//
/**
 * Floating-point comparisons.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: FloatCmp.java,v 1.11 2004/02/09 03:33:56 ian Exp $
 */
public class FloatCmp {
	final static double EPSILON = 0.0000001;
	public static void main(String[] argv) {
		double da = 3 * .3333333333;
		double db = 0.99999992857;

		// Compare two numbers that are expected to be close.
		if (da == db) {
			System.out.println("Java considers " + da + "==" + db);
		// else compare with our own equals method
		} else if (equals(da, db, 0.0000001)) {
			System.out.println("True within epsilon " + EPSILON);
		} else {
			System.out.println(da + " != " + db);
		}

		// Show that comparing two NaNs is not a good idea:
		double d1 = Double.NaN;
		double d2 = Double.NaN;
		if (d1 == d2)
			System.err.println("Comparing two NaNs incorrectly returns true.");
		if (!new Double(d1).equals(new Double(d2)))
			System.err.println("Double(NaN).equal(NaN) incorrectly returns false.");
	}

	/** Compare two doubles within a given epsilon */
	public static boolean equals(double a, double b, double eps) {
		if (a==b) return true;
		// If the difference is less than epsilon, treat as equal.
		return Math.abs(a - b) < eps;
	}

	/** Compare two doubles, using default epsilon */
	public static boolean equals(double a, double b) {
		if (a==b) return true;
		// If the difference is less than epsilon, treat as equal.
		return Math.abs(a - b) < EPSILON * Math.max(Math.abs(a), Math.abs(b));
	}
}
//@@@@@@//
//numbers/FloatDoubleTime.java
//@@@@@@//
public class FloatDoubleTime {
	/** How many times to do the loop */
	protected static final int HOW_MANY = 10000000;

	public static void main(String[] args) {
		long t0 = System.currentTimeMillis();
		float f = 0;
		for (int i=0; i<HOW_MANY; i++)
			f *= i;
		long t1 = System.currentTimeMillis();

		double d = 0;
		for (int i=0; i<HOW_MANY; i++)
			d *= i;
		long t2 = System.currentTimeMillis();

		System.out.println("Float:  " + (t1 - t0) + " " + f);

		System.out.println("Double: " + (t2 - t1) + " " + d);
	}
} 
//@@@@@@//
//numbers/FormatPlurals.java
//@@@@@@//
/**
 * Format a plural correctly, by hand.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: FormatPlurals.java,v 1.6 2004/02/09 03:33:56 ian Exp $
 */
public class FormatPlurals {
	public static void main(String[] argv) {
		report(0);
		report(1);
		report(2);
	}

	/** report -- using conditional operator */
	public static void report(int n) {
		System.out.println("We used " + n + " item" + (n==1?"":"s"));
	}
}
//@@@@@@//
//numbers/FormatPluralsChoice.java
//@@@@@@//
import java.text.*;

/**
 * Format a plural correctly, using a ChoiceFormat.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: FormatPluralsChoice.java,v 1.5 2004/03/06 22:52:32 ian Exp $
 */
public class FormatPluralsChoice extends FormatPlurals {
	static double[] limits = { 0, 1, 2 };
	static String[] formats = { "items", "item", "items"};
	static ChoiceFormat myFormat = new ChoiceFormat(limits, formats);

	/** report -- using conditional operator */
	public static void report(int n) {
		System.out.println("We used " + n + " " + myFormat.format(n));
	}

	public static void main(String[] argv) {
		report(0);
		report(1);
		report(2);
	}
}
//@@@@@@//
//numbers/FractMult.java
//@@@@@@//
/** Compute the value of 2/3 of 5 */
public class FractMult {
	public static void main(String[] u) {

		double d1 = 0.666 * 5;	// fast but obscure and inaccurate: convert
		System.out.println(d1); // 2/3 to 0.666 in programmer's head

		double d2 = 2/3 * 5;	// wrong answer - 2/3 == 0, 0*5 = 0
		System.out.println(d2);

		double d3 = 2d/3d * 5;	// "normal"
		System.out.println(d3);

		double d4 = (2*5)/3d;	// one step done as integers, almost same answer
		System.out.println(d4);

		int i5 = 2*5/3;			// fast, approximate integer answer
		System.out.println(i5);
	}
}
//@@@@@@//
//numbers/GetNumber.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;

/**
 * GetNumber - program to determine if a number is float or int.
 *
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: GetNumber.java,v 1.6 2004/03/06 21:59:33 ian Exp $
 */
public class GetNumber extends Frame {

	/** The input textField */
	private TextField textField;
	/** The results area */
	private TextField statusLabel;

	/** Constructor: set up the GUI */
	public GetNumber() {
		Panel p = new Panel();
		p.add(new Label("Number:"));
		p.add(textField = new TextField(10));
		add(BorderLayout.NORTH, p);
		textField.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ev) {
				String s = textField.getText();
				statusLabel.setText(process(s).toString());
			}
		});
		add(BorderLayout.SOUTH, statusLabel = new TextField(10));
		pack();
	}

	private static Number NAN = new Double(Double.NaN);

	/* Process one String, returning it as a Number subclass
	 * Does not require the GUI.
	 */
	public Number process(String s) {
		if (s.matches(".*[.dDeEfF]")) {
			try {
				double dValue = Double.parseDouble(s);
				System.out.println("It's a double: " + dValue);
				return new Double(dValue);
			} catch (NumberFormatException e) {
				System.out.println("Invalid a double: " + s);
				return NAN;
			}
		} else // did not contain . d e or f, so try as int.
			try {
				int iValue = Integer.parseInt(s);
				System.out.println("It's an int: " + iValue);
				return new Integer(iValue);
			} catch (NumberFormatException e2) {
				System.out.println("Not a number:" + s);
				return NAN;
			}
	}

	public static void main(String[] ap) {
		new GetNumber().setVisible(true);
	}
}
//@@@@@@//
//numbers/Heron.java
//@@@@@@//
/** Compute the area of a triangle using Heron's Formula.
 * Code and values from Prof W. Kahan and Joseph D. Darcy.
 * See http://www.cs.berkeley.edu/~wkahan/JAVAhurt.pdf.
 * Derived from listing in Rick Grehan's Java Pro article (October 1999).
 * Simplified and reformatted by Ian Darwin.
 */
public class Heron {
	public static void main(String[] args) {
		// Sides for triangle in float
		float af, bf, cf;
		float sf, areaf;

		// Ditto in double
		double ad, bd, cd;
		double sd, aread;

		// Area of triangle in float
		af = 12345679.0f;
		bf = 12345678.0f;
		cf = 1.01233995f;

		sf = (af+bf+cf)/2.0f;
		areaf = (float)Math.sqrt(sf * (sf - af) * (sf - bf) * (sf - cf));
		System.out.println("Single precision: " + areaf);

		// Area of triangle in double
		ad = 12345679.0;
		bd = 12345678.0;
		cd = 1.01233995;

		sd = (ad+bd+cd)/2.0d;
		aread =        Math.sqrt(sd * (sd - ad) * (sd - bd) * (sd - cd));
		System.out.println("Double precision: " + aread);
	}
}
//@@@@@@//
//numbers/InfNaN.java
//@@@@@@//
/**
 * Show INFINITY and NaN
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: InfNaN.java,v 1.4 2004/02/09 03:33:57 ian Exp $
 */
public class InfNaN {
	//+
	public static void main(String[] argv) {
		double d = 123;
		double e = 0;
		if (d/e == Double.POSITIVE_INFINITY)
			System.out.println("Check for POSITIVE_INFINITY works");
		double s = Math.sqrt(-1);
		if (s == Double.NaN)
			System.out.println("Comparison with NaN incorrectly returns true");
		if (Double.isNaN(s))
			System.out.println("Double.isNaN() correctly returns true");
	}
	//-
}
//@@@@@@//
//numbers/IntFract.java
//@@@@@@//
/**
 * Multiply a decimal fraction, not using floating point
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: IntFract.java,v 1.5 2004/02/09 03:33:57 ian Exp $
 */
public class IntFract {
	public static void main(String[] argv) {
		//+
		int a = 100;
		int b = a*5/7;
		System.out.println("5/7 of " + a + " is " + b);
		// Just for fun, do it again in floating point.
		final double FRACT = 0.7142857132857;
		int c = (int)(a*FRACT);
		System.out.println(FRACT + " of " + a + " is " + c);
		//-
	}
}
//@@@@@@//
//numbers/IntOverflow.java
//@@@@@@//
public class IntOverflow {
	public static void main(String[] unused) {
		do_shorts();
		do_ints();
	}
	protected static void do_shorts() {
		short i = Short.MAX_VALUE;
		System.out.println("i=" + i++);
		System.out.println("i=" + i++);
		System.out.println("i=" + i++);
	}
	protected static void do_ints() {
		int i = Integer.MAX_VALUE;
		System.out.println("i=" + i++);
		System.out.println("i=" + i++);
		System.out.println("i=" + i++);
	}
}
//@@@@@@//
//numbers/Logarithm.java
//@@@@@@//
/**
 * Show the logarithm to base e of a number
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Logarithm.java,v 1.3 2004/02/09 03:33:57 ian Exp $
 */
public class Logarithm {
	public static void main(String[] argv) {
		//+
		double someValue;
		// compute someValue...
		//-
		someValue = 0;
		//+
		double log_e = Math.log(someValue);
		//-
	}
}
//@@@@@@//
//numbers/LogBase.java
//@@@@@@//
/**
 * Log to arbitrary base
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: LogBase.java,v 1.3 2004/02/09 03:33:57 ian Exp $
 */
public class LogBase {
	//+
	public static double log_base(double base, double value) {
		return Math.log(value) / Math.log(base);
	}
	//-
}
//@@@@@@//
//numbers/LogBaseUse.java
//@@@@@@//
/**
 * Log to arbitrary base
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: LogBaseUse.java,v 1.3 2004/02/09 03:33:57 ian Exp $
 */
public class LogBaseUse {
	//+
	public static void main(String[] argv) {
		double d = LogBase.log_base(10, 10000);
		System.out.println("log10(10000) = " + d);
	}
	//-
}
//@@@@@@//
//numbers/Math1.java
//@@@@@@//
/** Show some things from java.lang.Math */
public class Math1 {
	public static void main(String[] argv) {
	System.out.println("A random number is " + Math.random());
	System.out.println("The square root of 2 is " + Math.sqrt(2.0));
	}
}
//@@@@@@//
//numbers/Matrix.java
//@@@@@@//
/**
 * Multiply two matrices.
 * Only defined for int: TODO: rewrite using 1.5 Generics to add 
 * support for long, float, and double.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Matrix.java,v 1.4 2004/03/07 02:53:53 ian Exp $
 */
public class Matrix {

	/* Matrix-multiply two arrays together.
	 * The arrays MUST be rectangular.
	 * @author Tom Christiansen & Nathan Torkington, Perl Cookbook version.
	 */
	public static int[][] multiply(int[][] m1, int[][] m2) {
		int m1rows = m1.length;
		int m1cols = m1[0].length;
		int m2rows = m2.length;
		int m2cols = m2[0].length;
		if (m1cols != m2rows)
			throw new IllegalArgumentException("matrices don't match: " + m1cols + " != " + m2rows);
		int[][] result = new int[m1rows][m2cols];

		// multiply
		for (int i=0; i<m1rows; i++)
			for (int j=0; j<m2cols; j++)
				for (int k=0; k<m1cols; k++)
				result[i][j] += m1[i][k] * m2[k][j];

		return result;
	}

	/** Matrix print.
	 */
	public static void mprint(int[][] a) {
		int rows = a.length;
		int cols = a[0].length;
		System.out.println("array["+rows+"]["+cols+"] = {");
		for (int i=0; i<rows; i++) {
			System.out.print("{");
			for (int j=0; j<cols; j++)
				System.out.print(" " + a[i][j] + ",");
			System.out.println("},");
		}
		System.out.println(":;");
	}
}
//@@@@@@//
//numbers/MatrixUse.java
//@@@@@@//
/**
 * Multiply two matrices.
 * Only defined for int: clone the code (or wait for Templates)
 * for long, float, and double.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: MatrixUse.java,v 1.3 2004/02/09 03:33:57 ian Exp $
 */
public class MatrixUse {
	public static void main(String[] argv) {
		//+
		int x[][] = {
			{ 3, 2, 3 },
			{ 5, 9, 8 },
		};
		int y[][] = {
			{ 4, 7 },
			{ 9, 3 },
			{ 8, 1 },
		};
		int z[][] = Matrix.multiply(x, y);
		Matrix.mprint(x);
		Matrix.mprint(y);
		Matrix.mprint(z);
		//-
	}
}

//@@@@@@//
//numbers/NumFormat.java
//@@@@@@//
import java.text.*;
import java.util.*;

/** JDK1.1 introduced a series of Formatting classes that
 * format various items in locale-appropriate ways
 * (10000 becomes 10,000 or 10.000 or whatever, as needed
 * in various locales.
 *
 * This program shows some simple ways of using it; for more,
 * see JavaDoc on java.util.Locale and java.text.NumberFormat.
 */
public class NumFormat {
	public static void main(String[] av) {
		int data[] = { 100, 1000, 10000, 1000000 };
		NumberFormat nf = NumberFormat.getInstance(Locale.US);
		for (int i = 0; i < data.length; ++i) {
			System.out.println(data[i] + "\t" + nf.format(data[i]));
		}
	}
}
      
//@@@@@@//
//numbers/NumFormat2.java
//@@@@@@//
import java.text.NumberFormat;

/*
 * Format a number our way and the default way.
 */
public class NumFormat2 {
	/** A number to format */
	public static final double data[] = {
		0, 1, 22d/7, 100.2345678
	};

	/** The main (and only) method in this class. */
	public static void main(String[] av) { 
		// Get a format instance
		NumberFormat form = NumberFormat.getInstance();

		// Set it to look like 999.99[99]
		form.setMinimumIntegerDigits(3);
		form.setMinimumFractionDigits(2);
		form.setMaximumFractionDigits(4);

		// Now print using it.
		for (int i=0; i<data.length; i++)
			System.out.println(data[i] + "\tformats as " +
				form.format(data[i]));
	}
}
//@@@@@@//
//numbers/NumFormatParse.java
//@@@@@@//
import java.text.NumberFormat;
import java.text.ParseException;

/*
 * Parse a number using a NumberFormat.
 */
public class NumFormatParse {
	//+
	/** A number to parse */
	public static final String input = "4096.251";
	//-

	/** The main (and only) method in this class. */
	public static void main(String[] av) { 

		//+
		NumberFormat defForm = NumberFormat.getInstance();

		try {
			Number d = defForm.parse(input);
			System.out.println(input + 
				" parses as " + d +
				" and formats as " + defForm.format(d));
		} catch (ParseException pe) {
			System.err.println(input + "not parseable!");
		}
		//-
	}
}
//@@@@@@//
//numbers/NumFormatTest.java
//@@@@@@//
import java.text.DecimalFormat;
import java.text.NumberFormat;

/*
 * Format a number our way and the default way.
 */
public class NumFormatTest {
	//+
	/** A number to format */
	public static final double intlNumber = 1024.25;
	/** Another number to format */
	public static final double ourNumber = 100.2345678;
	//-

	/** The main (and only) method in this class. */
	public static void main(String[] av) { 

		//+
		NumberFormat defForm = NumberFormat.getInstance();
		NumberFormat ourForm = new DecimalFormat("##0.##");
		// toPattern() will reveal the combination of #0., etc
		// that this particular Locale uses to format with!
		System.out.println("defForm's pattern is " +
			((DecimalFormat)defForm).toPattern());
		System.out.println(intlNumber + " formats as " +
			defForm.format(intlNumber));
		System.out.println(ourNumber + " formats as " +
			ourForm.format(ourNumber));
		System.out.println(ourNumber + " formats as " +
			defForm.format(ourNumber) + " using the default format");
		//-
	}
}
//@@@@@@//
//numbers/NumSeries.java
//@@@@@@//
import java.util.BitSet;

/** Operations on series of numbers */
public class NumSeries {
	public static void main(String[] args) {

		// When you want an ordinal list of numbers, use a for loop
		// starting at 1.
		for (int i = 1; i <= months.length; i++)
			System.out.println("Month # " + i);
	
		// When you want a set of array indices, use a for loop
		// starting at 0.
		for (int i = 0; i < months.length; i++)
			System.out.println("Month " + months[i]);

		// For a discontiguous set of integers, try a BitSet

		// Create a BitSet and turn on a couple of bits.
		BitSet b = new BitSet();
		b.set(0);	// January
		b.set(3);	// April

		// Presumably this would be somewhere else in the code.
		for (int i = 0; i<months.length; i++) {
			if (b.get(i))
				System.out.println("Month " + months[i] + " requested");
		}
	}
	/** The names of the months. See Dates/Times chapter for a better way */
	protected static String months[] = {
		"January", "February", "March", "April",
		"May", "June", "July", "August",
		"September", "October", "November", "December"
	};
}
//@@@@@@//
//numbers/Palindrome.java
//@@@@@@//
/** Compute the Palindrome of a number by adding the number composed of
 * its digits in reverse order, until a Palindrome occurs.
 * e.g., 42->66 (42+24); 1951->5995 (1951+1591=3542; 3542+2453=5995).
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: Palindrome.java,v 1.10 2004/03/07 02:53:21 ian Exp $.
 */
public class Palindrome {

	public static boolean verbose = true;

	public static void main(String[] argv) {
		for (int i=0; i<argv.length; i++)
			try {
				long l = Long.parseLong(argv[i]);
				if (l < 0) {
					System.err.println(argv[i] + " -> TOO SMALL");
					continue;
				}
				System.out.println(argv[i] + "->" + findPalindrome(l));
			} catch (NumberFormatException e) {
				System.err.println(argv[i] + "-> INVALID");
			} catch (IllegalStateException e) {
				System.err.println(argv[i] + "-> " + e);
			} 
	}

	/** find a palindromic number given a starting point, by
	 * calling ourself until we get a number that is palindromic.
	 */
	static long findPalindrome(long num) {
		if (num < 0)
			throw new IllegalStateException("negative");
		if (isPalindrome(num))
			return num;
		if (verbose)
 			System.out.println("Trying " + num);
		return findPalindrome(num + reverseNumber(num));
	}

	/** The number of digits in Long.MAX_VALUE */
	protected static final int MAX_DIGITS = 19;

	// digits array is shared by isPalindrome and reverseNumber,
	// which cannot both be running at the same time.

	/* Statically allocated array to avoid new-ing each time. */
	static long[] digits = new long[MAX_DIGITS];

	/** Check if a number is palindromic. */
	static boolean isPalindrome(long num) {
		// Consider any single digit to be as palindromic as can be
		if (num >= 0 && num <= 9)
			return true;

		int nDigits = 0;
		while (num > 0) {
			digits[nDigits++] = num % 10;
			num /= 10;
		}
		for (int i=0; i<nDigits/2; i++)
			if (digits[i] != digits[nDigits - i - 1])
				return false;
		return true;
	}

	static long reverseNumber(long num) {
		int nDigits = 0;
		while (num > 0) {
			digits[nDigits++] = num % 10;
			num /= 10;
		}
		long ret = 0;
		for (int i=0; i<nDigits; i++) {
			ret *= 10;
			ret += digits[i];
		}
		return ret;
	}
}
//@@@@@@//
//numbers/PalindromeBig.java
//@@@@@@//
import java.math.BigInteger;

/** Compute the Palindrome of a number by adding the number composed of
 * its digits in reverse order, until a Palindrome occurs.
 * e.g., 42->66 (42+24); 1951->5995 (1951+1591=3542; 3542+2453=5995).
 * <P>TODO: Do we need to handle negative numbers?
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: PalindromeBig.java,v 1.3 2004/02/09 03:33:57 ian Exp $.
 */
public class PalindromeBig {

	public static boolean verbose = true;

	public static void main(String[] argv) {
		for (int i=0; i<argv.length; i++)
			try {
				BigInteger l = new BigInteger(argv[i]);
				if (l.compareTo(BigInteger.ZERO) < 0) {
					System.err.println(argv[i] + " -> TOO SMALL");
					continue;
				}
				System.out.println(argv[i] + "->" + findPalindrome(l));
			} catch (NumberFormatException e) {
				System.err.println(argv[i] + "-> INVALID");
			} catch (IllegalStateException e) {
				System.err.println(argv[i] + "-> " + e);
			} 
	}

	/** find a palindromic number given a starting point, by
	 * calling ourself until we get a number that is palindromic.
	 */
	public static BigInteger findPalindrome(BigInteger num) {
		if (num.compareTo(BigInteger.ZERO) < 0)
			throw new IllegalStateException("negative");
		if (isPalindrome(num))
			return num;
		if (verbose)
			System.out.println("Trying " + num);
		return findPalindrome(num.add(reverseNumber(num)));
	}

	/** A ridiculously large number  */
	protected static final int MAX_DIGITS = 255;

	/** Check if a number is palindromic. */
	public static boolean isPalindrome(BigInteger num) {
		String digits = num.toString();
		int numDigits = digits.length();
		if (numDigits >= MAX_DIGITS) {
			throw new IllegalStateException("too big");
		}
		// Consider any single digit to be as palindromic as can be
		if (numDigits == 1)
			return true;
		for (int i=0; i<numDigits/2; i++) {
			// System.out.println(
			// 	digits.charAt(i) + " ? " + digits.charAt(numDigits - i - 1));
			if (digits.charAt(i) != digits.charAt(numDigits - i - 1))
				return false;
		}
		return true;
	}

	static BigInteger reverseNumber(BigInteger num) {
		String digits = num.toString();
			int numDigits = digits.length();
		char[] sb = new char[numDigits];
		for (int i=0; i<digits.length(); i++) {
			sb[i] = digits.charAt(numDigits - i - 1);
		}
		// Debug.println("rev",
		// 	"reverseNumber(" + digits + ") -> " + "\"" + sb + "\"");
		return new BigInteger(new String(sb));
	}
}
//@@@@@@//
//numbers/PalindromeFirst.java
//@@@@@@//
/**
 * Find the first integer number that cannot be Palindromified.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: PalindromeFirst.java,v 1.2 2004/02/09 03:33:57 ian Exp $
 */
public class PalindromeFirst {
	public static void main(String[] argv) {
		int numErrors = 0;
		Palindrome.verbose = false;
		for (int i=0; i<Long.MAX_VALUE; i++) {
			try {
				Palindrome.findPalindrome(i);
			} catch (RuntimeException ex) {
				System.out.println("Caught exception on " + i + ": " + ex);
				numErrors = numErrors + 1;
				if (numErrors > 200)
					return;
			}
		}
	}
}
//@@@@@@//
//numbers/Primes.java
//@@@@@@//
/* Compute prime numbers, after Knuth, Vol 1, Sec 1.3.2, Alg. "P".
 * Unlike Knuth, I don't build table formatting into
 * computational programs; output is one per line.
 * <p>
 * Note that there may be more efficient algorithms for finding primes.
 * Consult a good book on numerical algorithms.
 * @author Ian Darwin
 */
public class Primes {
	/** The default stopping point for primes */
	public static final long DEFAULT_STOP = 4294967295L;
	/** The first prime number */
	public static final int FP = 2;

	static int MAX = 10000;

	public static void main(String[] args) {
		long[] prime = new long[MAX];

		long stop = DEFAULT_STOP;
		if (args.length == 1) {
			stop = Long.parseLong(args[0]);
		}

		prime[1] = FP; 			// P1 (ignore prime[0])
		long n = FP+1; 			// odd candidates
		int j = 1;				// numberFound

		boolean isPrime = true;	// for 3

		do {

			if (isPrime) {
				if (j == MAX-1) {
					// Grow array dynamically if needed
					long[] np = new long[MAX * 2];
					System.arraycopy(prime, 0, np, 0, MAX);
					MAX *= 2;
					prime = np;
				}
				prime[++j] = n;	// P2
				isPrime = false;
			}
			n += 2;				// P4

			for (int k = 2; k <= j && k < MAX; k++) {	// P5, P6, P8
				long q = n / prime[k];
				long r = n % prime[k];
				if (r == 0) {			
					break;
				}
				if (q <= prime[k]) {		// P7
					isPrime = true;
					break;
				}
			}
			
		} while (n < stop);				// P3

		for (int i=1; i<=j; i++)
			System.out.println(prime[i]);
	}
}
//@@@@@@//
//numbers/Random1.java
//@@@@@@//

/** Demonstrate the easy way of getting random numbers,
 * using java.lang.Math.Random().
 */
public class Random1 {
	public static void main(String[] argv) {
		//+
		// java.lang.Math.random() is static, don't need to construct Math
		System.out.println("A random from java.lang.Math is " + Math.random());
		//-
	}
}
//@@@@@@//
//numbers/Random2.java
//@@@@@@//
import java.util.*;

/** Demonstrate the better way of getting random numbers,
 * using java.util.Random.next*().
 */
public class Random2 {
	public static void main(String[] argv) {
		//+
		// java.util.Random methods are non-static, so need to construct
		Random r = new Random();
		for (int i=0; i<10; i++)
		System.out.println("A double from java.util.Random is " + r.nextDouble());
		for (int i=0; i<10; i++)
		System.out.println("An integer from java.util.Random is " + r.nextInt());
		//-
	}
}
//@@@@@@//
//numbers/Random3.java
//@@@@@@//
import java.util.*;

/** Demonstrate the better way of getting random numbers,
 * using java.util.Random.next*().
 */
public class Random3 {
	public static void main(String[] argv) {
		// java.util.Random methods are non-static, do need to construct Math
		//+
		Random r = new Random();
		for (int i=0; i<10; i++)
		System.out.println("A gaussian random double is " + r.nextGaussian());
		//-
	}
}
//@@@@@@//
//numbers/Random4.java
//@@@@@@//
import java.util.*;
import java.io.*;

/** Print "n" calls to nextDouble() and nextGaussian() in raw form
 * using java.util.Random.next*(); results can be plotted.
 */
public class Random4 {
	public static void main(String[] argv) throws IOException {
		// java.util.Random methods are non-static, do need to construct Math
		Random r = new Random();
		PrintWriter file1 = new PrintWriter(new FileWriter("file1"));
		PrintWriter file2 = new PrintWriter(new FileWriter("file2"));
		for (int i=0; i<10000; i++) {
			file1.println(r.nextDouble());
			file2.println(r.nextGaussian());
		}
		file1.close();
		file2.close();
	}
}
//@@@@@@//
//numbers/RandomInt.java
//@@@@@@//
import java.util.*;

/** Generate random ints by asking Random() for
 * a series of random integers from 1 to 10, inclusive.
 *
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: RandomInt.java,v 1.4 2004/03/07 02:51:50 ian Exp $
 */
public class RandomInt {
	public static void main(String[] a) {
		Random r = new Random();
		for (int i=0; i<1000; i++)
			// nextInt(10) goes from 0-9; add 1 for 1-10;
			System.out.println(1+Math.round(r.nextInt(10)));
	}
}
//@@@@@@//
//numbers/RangedInt.java
//@@@@@@//
/** A RangedInt is similar to Integer but enforces upper and lower bounds
 * that are set at construction time.
 * Originally for Learning Tree International Course 471.
 *
 */
public class RangedInt {
        /** Current value */
        protected int currentValue;

        /** Maximum value allowed */
        protected int maxValue;

        /** Minimum value allowed */
        protected int minValue;

        /**
         * Constructor: Stores the maximum and minimum
         * values and sets the current value to 0 or
         * the minimum value whichever is greater.
         */
        public RangedInt( int min, int max) {
            // store the supplied limits
            minValue = min;
            maxValue = max;

            // set the initial value of this object
            if (min > 0)
                currentValue = min;
            else
                currentValue = 0;
        }

        /**
         * Default Constructor: Sets the maximum and minimum
         * values to MAX_VALUE and MIN_VALUE.
         */
        public RangedInt() {
            // call the (int, int) constructor
            // with the max and min values
            this(Integer.MIN_VALUE, Integer.MAX_VALUE);
        }

        /**
         * Set the current value of the object. If new
         * value is outside bounds then throw an
         * IllegalArgumentException
         */
        public void setValue ( int newValue) throws IllegalArgumentException {

            // check the new value
            if (newValue < minValue || newValue > maxValue)
                throw new IllegalArgumentException("From RangedInt");
			currentValue = newValue;
        }

        /**
         * Return the current value of the object
         */
        public int getValue() {
            // return the current value
            return currentValue;
        }
}
//@@@@@@//
//numbers/RealValues.java
//@@@@@@//
/**
 * Show real values.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: RealValues.java,v 1.7 2004/02/09 03:33:57 ian Exp $
 */
public class RealValues {
	public static void main(String[] argv) {
		System.out.println("The real 0.3 is " + 0.3);
		System.out.println("The real 0.3 times 3 is " + 0.3 * 3);
	}
}
//@@@@@@//
//numbers/RomanNumberDemo.java
//@@@@@@//
public class RomanNumberDemo {
	/** Simple test case */
	public static void main(String[] argv) {
		//+
		RomanNumberFormat nf = new RomanNumberFormat();
		System.out.println("Test of " + nf);
		try {
			System.out.println("0->" + nf.format(0));
			System.out.println("Failed to object to zero");
		} catch (NumberFormatException ex) {
			System.out.println("Correctly rejected zero");
		}
		System.out.println("42->" + nf.format(42));
		System.out.println("678->" + nf.format(678));
		System.out.println("1999->" + nf.format(1999));
		System.out.println("2000->" + nf.format(2000));	// Y2K anyone?
		System.out.println("2001->" + nf.format(2001));	// Y2K anyone?
		System.out.println("3999->" + nf.format(3999));
		System.out.println("4000->" + nf.format(4000));	// expect Exception
		//-
		// parsing not implemented.
		System.out.println("XIV->" + nf.parseObject("XIV", null));
	}
}
//@@@@@@//
//numbers/RomanNumberFormat.java
//@@@@@@//
import java.text.FieldPosition;
import java.text.Format;
import java.text.NumberFormat;
import java.text.ParsePosition;

/**
 * Roman Number class. Not localized, since "Latin's a Dead Dead Language..."
 * and we don't display Roman Numbers differently in different Locales.
 * Filled with quick-n-dirty algorithms.
 *
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: RomanNumberFormat.java,v 1.10 2004/05/13 22:28:59 ian Exp $
 */
public class RomanNumberFormat extends Format {

	/** Characters used in "Arabic to Roman", that is, format() methods. */
	static char A2R[][] = {
			{ 0, 'M' },
			{ 0, 'C', 'D', 'M' },
			{ 0, 'X', 'L', 'C' },
			{ 0, 'I', 'V', 'X' },
	};

	/** Format a given double as a Roman Numeral; just truncate to a
	 * long, and call format(long).
	 */
	public String format(double n) {
		return format((long)n);
	}

	/** Format a given long as a Roman Numeral. Just call the
	 * three-argument form.
	 */
	public String format(long n) {
		if (n <= 0 || n >= 4000)
			throw new NumberFormatException(n + " must be > 0 && < 4000");
		StringBuffer sb = new StringBuffer();
		format(new Integer((int)n), sb, new FieldPosition(NumberFormat.INTEGER_FIELD));
		return sb.toString();
	}

	/* Format the given Number as a Roman Numeral, returning the
	 * Stringbuffer (updated), and updating the FieldPosition.
	 * This method is the REAL FORMATTING ENGINE.
	 * Method signature is overkill, but required as a subclass of Format.
	 */
	public StringBuffer format(Object on, StringBuffer sb, FieldPosition fp) {
		if (!(on instanceof Number))
			throw new IllegalArgumentException(on + " must be a Number object");
		if (fp.getField() != NumberFormat.INTEGER_FIELD)
			throw new IllegalArgumentException(fp + " must be FieldPosition(NumberFormat.INTEGER_FIELD");
		int n = ((Number)on).intValue();	// TODO: check in range.

		// First, put the digits on a tiny stack. Must be 4 digits.
		for (int i=0; i<4; i++) {
			int d=n%10;
			push(d);
			// System.out.println("Pushed " + d);
			n=n/10;
		}

		// Now pop and convert.
		for (int i=0; i<4; i++) {
			int ch = pop();
			// System.out.println("Popped " + ch);
			if (ch==0)
				continue;
			else if (ch <= 3) {
				for(int k=1; k<=ch; k++)
					sb.append(A2R[i][1]); // I
			}
			else if (ch == 4) {
				sb.append(A2R[i][1]);	// I
				sb.append(A2R[i][2]);	// V
			}
			else if (ch == 5) {
				sb.append(A2R[i][2]);	// V
			}
			else if (ch <= 8) {
				sb.append(A2R[i][2]);	// V
				for (int k=6; k<=ch; k++)
					sb.append(A2R[i][1]);	// I
			}
			else { // 9
				sb.append(A2R[i][1]);
				sb.append(A2R[i][3]);
			}
		}
		// fp.setBeginIndex(0);
		// fp.setEndIndex(3);
		return sb;
	}

	/** Parse a generic object, returning an Object */
	public Object parseObject(String what, ParsePosition where) {
		throw new IllegalArgumentException("Parsing not implemented");
		// TODO PARSING HERE
		// return new Long(0);
	}

	/* Implement a toy stack */
	protected int stack[] = new int[10];
	protected int depth = 0;

	/* Implement a toy stack */
	protected void push(int n) {
		stack[depth++] = n;
	}
	/* Implement a toy stack */
	protected int pop() {
		return stack[--depth];
	}
}
//@@@@@@//
//numbers/RomanNumberSimple.java
//@@@@@@//
import java.util.Calendar;

public class RomanNumberSimple {
	public static void main(String[] args) {
		RomanNumberFormat nf = new RomanNumberFormat();
		int year = Calendar.getInstance().get(Calendar.YEAR);
		System.out.println(year + " -> " + nf.format(year));
	}
}
//@@@@@@//
//numbers/RomanYear.java
//@@@@@@//
import java.util.*;

/** Print the current year in Roman Numerals */
public class RomanYear {

	public static void main(String[] argv) {

		RomanNumberFormat rf = new RomanNumberFormat();
		Calendar cal = Calendar.getInstance();
		int year = cal.get(Calendar.YEAR);

		// If no arguments, just print the year.
		if (argv.length == 0) {
			System.out.println(rf.format(year));
			return;
		}
		
		// Else a micro-formatter: replace "-" arg with year, else print.
		for (int i=0; i<argv.length; i++) {
			if (argv[i].equals("-"))
				System.out.print(rf.format(year));
			else
				System.out.print(argv[i]);	// e.g., "Copyright"
			System.out.print(' ');
		}
		System.out.println();
	}
}
//@@@@@@//
//numbers/Round.java
//@@@@@@//
/**
 * Demonstrate our own version round().
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Round.java,v 1.4 2004/03/06 22:17:32 ian Exp $
 */
public class Round {
	/** We round a number up if its fraction exceeds this threshold. */
	public static final double THRESHOLD = 0.54;
	/* 
	 * Round floating values to integers.
	 * @Return the closest int to the argument.
	 * @param d A non-negative values to be rounded.
	 */
	static int round(double d) {
		if (d < 0) {
			throw new IllegalArgumentException("Value must be non-negative");
		}
		int di = (int)Math.floor(d);	// integral value below (or ==) d
		if ((d - di) > THRESHOLD) {
			return di + 1;
		} else {
			return di;
		}
	}
	
	public static void main(String[] argv) {
		for (double d = 0.1; d<=1.0; d+=0.01) {
			System.out.println("My way:  " + d + "-> " + round(d));
			System.out.println("Math way:" + d + "-> " + Math.round(d));
		}
	}
}
//@@@@@@//
//numbers/ScaledNumberFormatSimple.java
//@@@@@@//
import com.darwinsys.util.ScaledNumberFormat;

/** A simple example of ScaleNumberFormat, from com.darwinsys.util
  */
public class ScaledNumberFormatSimple {
	public static void main(String[] args) {
		String cinput = "1.5K";
		long ninput = 10483892;
		long result;
		ScaledNumberFormat nf = new ScaledNumberFormat();

		result = ((Long)nf.parseObject(cinput, null)).longValue();
		System.out.println(cinput + " -> " + result);

		System.out.println(ninput + " -> " + nf.format(ninput));
	}
}
//@@@@@@//
//numbers/SmallIntMult.java
//@@@@@@//
public class SmallIntMult {
    public static void main(String[] argv) {
        byte b = 1;
        short s = 1;
        // You may be surprised by the next line.
        short result = b * s;		// EXPECT COMPILE ERROR
    }
}
//@@@@@@//
//numbers/StrictFP.java
//@@@@@@//
/**
 * Show real values.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: StrictFP.java,v 1.3 2004/02/09 03:33:58 ian Exp $
 */
public class StrictFP {
	public static strictfp void main(String[] argv) {
		double alpha = 8e+307;
		System.out.println(mulNotStrict(alpha));
		System.out.println(mulStrictFP(alpha));
		System.out.println(2 * alpha);
	}

	static double mulNotStrict(double a) {
		return a * 4 * 0.5;
	}
	static strictfp double mulStrictFP(double a) {
		return a * 4 * 0.5;
	}
}
//@@@@@@//
//numbers/StringToDouble.java
//@@@@@@//

public class StringToDouble {

	//+
	public static void main(String[] argv) {
		String aNumber = argv[0];	// not argv[1]
		double result;
		try {
			result = Double.parseDouble(aNumber); 
		} catch(NumberFormatException exc) {
			System.out.println("Invalid number " + aNumber);
			return;
		}
		System.out.println("Number is " + result);
	}
	//-
}
//@@@@@@//
//numbers/TempConverter.java
//@@@@@@//

/* Print a table of Fahrenheit and Celsius temperatures 
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: TempConverter.java,v 1.10 2004/03/16 01:43:31 ian Exp $
 */
public class TempConverter {

	public static void main(String[] args) {
		TempConverter t = new TempConverter();
		t.start();
		t.data();
		t.end();
	}

	protected void start() {
	}

	protected void data() {
		for (int i=-40; i<=120; i+=10) {
			float c = (i-32)*(5f/9);
			print(i, c);
		}
	}

	protected void print(float f, float c) {
		System.out.println(f + " " + c);
	}

	protected void end() {
	}
}
//@@@@@@//
//numbers/TempConverter2.java
//@@@@@@//
import java.text.*;

/* Print a table of fahrenheit and celsius temperatures, a bit more neatly.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: TempConverter2.java,v 1.6 2004/03/07 02:50:49 ian Exp $
 */
public class TempConverter2 extends TempConverter {
	protected DecimalFormat df;

	public static void main(String[] args) {
		TempConverter t = new TempConverter2();
		t.start();
		t.data();
		t.end();
	}

	// Constructor
	public TempConverter2() {
		df = new DecimalFormat("#0.00");
	}

	protected void print(float f, float c) {
		System.out.println(df.format(f) + " " + df.format(c));
	}

	protected void start() {
		System.out.println("Fahr    Centigrade.");
	}

	protected void end() {
		System.out.println("-------------------");
	}
}
//@@@@@@//
//numbers/TempConverter3.java
//@@@@@@//
import java.text.*;

/* Print a table of Fahrenheit and Celsius temperatures, with decimal
 * points lined up.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: TempConverter3.java,v 1.4 2004/03/07 02:50:49 ian Exp $
 */
public class TempConverter3 extends TempConverter2 {
	protected FieldPosition fp;
	protected DecimalFormat dff;

	public static void main(String[] args) {
		TempConverter t = new TempConverter3();
		t.start();
		t.data();
		t.end();
	}

	// Constructor
	public TempConverter3() {
		super();
		dff = new DecimalFormat("#0.0");
		fp = new FieldPosition(NumberFormat.INTEGER_FIELD);
	}

	protected void print(float f, float c) {
		String fs = dff.format(f, new StringBuffer(), fp).toString();
		fs = prependSpaces(4 - fp.getEndIndex(), fs);

		String cs = df.format(c, new StringBuffer(), fp).toString();
		cs = prependSpaces(4 - fp.getEndIndex(), cs);

		System.out.println(fs + "  " + cs);
	}

	protected String prependSpaces(int n, String s) {
		String[] res = {
			"", " ", "  ", "   ", "    ", "     "
		};
		if (n<res.length)
			return res[n] + s;
		throw new IllegalStateException("Rebuild with bigger \"res\" array.");
	}
}
//@@@@@@//
//numbers/Trig.java
//@@@@@@//
/**
 * Demonstrate a few of the Math functions for Trigonometry.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Trig.java,v 1.5 2004/02/09 03:33:58 ian Exp $
 */
public class Trig {
	public static void main(String[] argv) {
		//+
		System.out.println("Java's PI is " + Math.PI);
		System.out.println("Java's e is " + Math.E);
		System.out.println("The cosine of 1.1418 is " + Math.cos(1.1418));
		//-
	}
}
//@@@@@@//
//oo/AllClasses.java
//@@@@@@//
import java.awt.Component;
import java.awt.event.*;
import javax.swing.*;

public class AllClasses {
	/** Inner class can be used anywhere in class AllClasses */
	public class Data {
		int x;
		int y;
	}
	public void getResults() {
		JButton b = new JButton("Press me");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				Data loc = new Data();
				loc.x = ((Component)evt.getSource()).getX();
				loc.x = ((Component)evt.getSource()).getY();
				System.out.println("Thanks for pressing me");
			}
		});
	}
}

/** Class contained in same file as AllClasses, but can be used
 * (with a warning) in other contexts.
 */
class AnotherClass {
	// methods and fields here...
	AnotherClass() {
		// Inner class from above can not be used here, of course
		// Data d = new Data();	// EXPECT COMPILE ERROR
	}
}
//@@@@@@//
//oo/ChessMoveException.java
//@@@@@@//
/** A ChessMoveException is thrown  when the user makes an illegal move. */
public class ChessMoveException extends Exception {
	public ChessMoveException () {
		super();
	}
	public ChessMoveException (String msg) {
		super(msg);
	}
}
//@@@@@@//
//oo/Clone0.java
//@@@@@@//
public class Clone0 {
	public static void main(String[] args) { 
		Object o = new Object();
		Object o2 = o.clone();	// EXPECT COMPILE ERROR
	}
}
//@@@@@@//
//oo/Clone1.java
//@@@@@@//
/** Demonstration of cloning. */
public class Clone1 implements Cloneable {

	/** Clone this object. Call super.clone() to do the work */
	public Object clone() {
		try {
			return super.clone();
		} catch (CloneNotSupportedException ex) {
			System.out.println("Now that's a surprise!!");
			throw new InternalError(ex.toString());
		}
	}

	int x;
	transient int y;	// will be cloned, but not serialized

	/** Display the current object as a string */
	public String toString() {
		return "Clone1[" + x + "," + y + "]";
	}
}
//@@@@@@//
//oo/Clone1Test.java
//@@@@@@//
import junit.framework.*;

public class Clone1Test extends TestCase {

	Clone1 c;

	public void setUp() { 
		c = new Clone1();
		c.x = 100;
		c.y = 200;
	}

	Clone1 d;

	/** Test that clone() method returns OK. */
	public void testClone() {
		d = (Clone1)c.clone();
		// If we get here it didn't throw an exception.
		System.out.println("c=" + c);
		System.out.println("d=" + d);
		/* Test that data gets cloned correctly */
		assertEquals(c.x, d.x);
		assertEquals(c.y, d.y);
	}

	/** Constructor needed by junit */
	public Clone1Test(String name) { super(name); }
}
//@@@@@@//
//oo/CloneSub.java
//@@@@@@//
class One extends java.lang.Object {
	int x;
}

class Two extends One /*implements Cloneable*/ {
	int y;
	public void foo() {
		try {
			Object o = this.clone();
		} catch (CloneNotSupportedException ex) {
			System.err.println(ex);
		}
	}

	public Object clone() throws CloneNotSupportedException {
		return super.clone();
	}
}

public class CloneSub {
	public static void main(String[] args) throws CloneNotSupportedException {
		Two t1 = new Two();
		t1.x = 100;
		t1.y = 200;
		Two t2 = (Two)t1.clone();
		System.out.println(t2);
		System.out.println(t2.y);
	}
}
//@@@@@@//
//oo/ColorTest.java
//@@@@@@//
import java.awt.Color;

public class ColorTest {
	public static void main(String[] args) {
		Color c = new Color(130, 130, 130, 130);
		System.out.println(c + "; " + c.hashCode());
	}
}
//@@@@@@//
//oo/EqualsDemo.java
//@@@@@@//
public class EqualsDemo {
	private int int1;
	private SomeClass obj1;

	/** Constructor */
	public EqualsDemo(int i, SomeClass o) {
		int1 = i;
		if (o == null) {
			throw new IllegalArgumentException("Object may not be null");
		}
		obj1 = o;
	}

	/** Default Constructor */
	public EqualsDemo() {
		this(0, new SomeClass());
	}

	/** Demonstration "equals" method */
	public boolean equals(Object o) {
		if (o == this)		// optimization
			return true;

		// Castable to this class? (false if == null)
		if (!(o instanceof EqualsDemo))
			return false;

		EqualsDemo other = (EqualsDemo)o;	// OK, cast to this class

		// compare field-by-field
		if (int1 != other.int1)			// compare primitives directly
			return false;
		if (!obj1.equals(other.obj1))	// compare objects using their equals
			return false;
		return true;
	}
}
//@@@@@@//
//oo/EqualsDemoTest.java
//@@@@@@//
import junit.framework.*;

/** Some JUnit test cases for EqualsDemo.
 * Writing a full set is left as "an exercise for the reader".
 * Run as: $ java junit.textui.TestRunner EqualsDemoTest
 * @version $Id: EqualsDemoTest.java,v 1.3 2003/06/04 01:44:10 ian Exp $
 */
public class EqualsDemoTest extends TestCase {

	/** an object being tested */
	EqualsDemo d1;
	/** another object being tested */
	EqualsDemo d2;

	/** init() method */
	public void setUp() {
		d1 = new EqualsDemo();
		d2 = new EqualsDemo();
	}

	/** constructor plumbing for junit */
	public EqualsDemoTest(String name) {
		super(name);
	}

	public void testSymmetry() { 
		assertTrue(d1.equals(d1));
	}

	public void testSymmetric() {
		assertTrue(d1.equals(d2) && d2.equals(d1));
	}

	public void testCaution() {
		assertTrue(!d1.equals(null));
	}
}
//@@@@@@//
//oo/inherit/Customer.java
//@@@@@@//
public class Customer extends Person {
	private int customerNumber;

	public Customer(String firstName, String lastName, int number) {
		super(firstName, lastName);
		setCustomerNumber(number);
	}

	public void setCustomerNumber(int n) {
		if (n < 1)
			throw new IllegalArgumentException("Invalid customer number " + n);
		customerNumber = n;
	}
}
//@@@@@@//
//oo/inherit/Employee.java
//@@@@@@//
public class Employee extends Person {
	private short deptCode;
	private int staffNumber;

	public Employee(String firstName, String lastName, short dept, int number) {
		super(firstName, lastName);
		setDeptCode(dept);
		setStaffID(number);
	}

	public void setDeptCode(short dept) {
		deptCode = dept;
	}

	public void setStaffID(int number) {
		if (number < 1)
			throw new IllegalArgumentException("Invalid staff number " +
				number);
		staffNumber = number;
	}
}
//@@@@@@//
//oo/inherit/Person.java
//@@@@@@//
public class Person {
	String firstName;
	String lastName;
	Person(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
}
//@@@@@@//
//oo/interface/Asset.java
//@@@@@@//
/** Asset is the top level of every Asset */
public abstract class Asset extends Object {
	// No fields or methods; it's just the base of everything.
}

//@@@@@@//
//oo/interface/BuildingAsset.java
//@@@@@@//
/** The top level of everything that is permanently part of the building */
public abstract class BuildingAsset extends Asset {
	protected int room;

	public BuildingAsset(int room) {
		this.room = room;
	}
}
//@@@@@@//
//oo/interface/BuildingLight.java
//@@@@@@//
public abstract class BuildingLight extends BuildingAsset {
	// generic info on lighting: flourescent/incandescent, ...
	BuildingLight(int roomNumber) {
		super(roomNumber);
	}
}
//@@@@@@//
//oo/interface/BuildingManagement.java
//@@@@@@//
/**
 * BuildingManagement - control an energy-saving building.
 * This class shows how we might control the objects in an office
 * that can safely be powered off at nighttime to save energy - lots of
 * it, when applied to a large office!
 */
public class BuildingManagement {

	Asset things[] = new Asset[24];	
	int numItems = 0;

	/** goodNight is called from a timer Thread at 2200, or when we
	 * get the "shutdown" command from the security guard.
	 */
	public void goodNight() {
		for (int i=0; i<things.length; i++)
			if (things[i] instanceof PowerSwitchable)
				((PowerSwitchable)things[i]).powerDown();
	}

	// goodMorning() would be the same, but call each one's powerUp().

	/** Add a Asset to this building */
	public void add(Asset thing) {	
		System.out.println("Adding " + thing);
		things[numItems++] = thing;
	}

	/** The main program */
	public static void main(String[] av) {
		BuildingManagement b1 = new BuildingManagement();
		b1.add(new RoomLights(101));	// control lights in room 101
		b1.add(new EmergencyLight(101));	// and emerg. lights.
		// add the computer on desk#4 in room 101
		b1.add(new ComputerCPU(10104));
		// and its monitor
		b1.add(new ComputerMonitor(10104));

		// time passes, and the sun sets...
		b1.goodNight();
	}
}
//@@@@@@//
//oo/interface/ComputerAsset.java
//@@@@@@//
public abstract class ComputerAsset extends Asset {
	// generic computer component stuff here: location, owner, 
	// warranty expiration date :-), etc.
	int deskNumber;
	ComputerAsset(int deskNumber) {
		this.deskNumber = deskNumber;
	}
}
//@@@@@@//
//oo/interface/ComputerCPU.java
//@@@@@@//
public class ComputerCPU extends ComputerAsset {
	// information about CPU (P5, P6, ...), RAM, etc.
	ComputerCPU(int deskNumber) {
		super(deskNumber);
	}
}
//@@@@@@//
//oo/interface/ComputerMonitor.java
//@@@@@@//
public class ComputerMonitor extends ComputerAsset implements PowerSwitchable {
	ComputerMonitor(int roomNumber) {
		super(roomNumber);
	}
	public void powerDown() {
		System.out.println("Dousing monitor at desk " + deskNumber);
		// send the code to the Monitor's X10 box to shut it off
	}
	public void powerUp() {
		System.out.println("Warming up monitor at desk " + deskNumber);
		// send the code to the Monitor's X10 box to turn it on
	}
}
//@@@@@@//
//oo/interface/EmergencyLight.java
//@@@@@@//
public class EmergencyLight extends BuildingLight {	// NEVER SWITCH OFF
	EmergencyLight(int roomNumber) {
		super(roomNumber);
	}
}
//@@@@@@//
//oo/interface/PowerSwitchable.java
//@@@@@@//
/**
 * PowerSwitchable is an Interface that will be implemented by things
 * that can safely be turned off at night. Could use X10(tm) or BlueTooth
 * or 802.11 or any similar network technology to turn things on or off.
 *
 * @author	Ian F. Darwin
 */
public interface PowerSwitchable {

	/** The technique for turning this unit off */
	public void powerDown();

	/** The technique for turning this unit on */
	public void powerUp();
}
//@@@@@@//
//oo/interface/RoomLights.java
//@@@@@@//
public class RoomLights extends BuildingLight implements PowerSwitchable {
	RoomLights(int roomNumber) {
		super(roomNumber);
	}
	public void powerDown() {
		System.out.println("Dousing lights in room " + room);
	}
	public void powerUp() {
		System.out.println("Lighting lights in room " + room);
	}
}
//@@@@@@//
//oo/metrolib/Cmd.java
//@@@@@@//
package metrolib;

public class Cmd {
	public final static int HELP = 'h';
	public final static int NORTH = 'n';
	public final static int EAST = 'e';
	public final static int SOUTH = 's';
	public final static int WEST = 'w';
	public final static int QUIT = 'q';
	public final static int UNKNOWN = '?';

	public static int parseCmd(String line) {
		if (line == null || line.equals("q") ||
			line.equalsIgnoreCase("quit"))
			return QUIT;
		if (line.equals("n") || line.equalsIgnoreCase("north"))
			return NORTH;
		if (line.equals("e") || line.equalsIgnoreCase("east"))
			return EAST;
		if (line.equals("s") || line.equalsIgnoreCase("south"))
			return SOUTH;
		if (line.equals("w") || line.equalsIgnoreCase("west"))
			return WEST;

		if (line.equals("h") || line.equals("?") ||
			line.equalsIgnoreCase("help"))
			return HELP;

		// more later...

		return UNKNOWN;
	}
}
//@@@@@@//
//oo/metrolib/MetroLib.java
//@@@@@@//
package metrolib;

import java.io.*;

public class MetroLib {
	private Room room;

	MetroLib() {
		room = Rooms.getFirstRoom();
	}

	/** Main program, get the game going and run it. */
	public static void main(String[] args) throws IOException {
		println("This is a trivial game demonstrating OO structures.");
		BufferedReader is = new BufferedReader(
			new InputStreamReader(System.in));
		MetroLib game = new MetroLib();
		println("You can in general move north south east or west");
		println("");
		// Manually print out first room's message.
		println(game.room.entryMessage);

		// Main loop: run the game.
		int cmd;
		while ((cmd = game.parseCmd(is)) != Cmd.QUIT) {
			game.play(cmd);
		}
	}

	/** Read a line and delegate it to the parser */
	int parseCmd(BufferedReader is) throws IOException {
		String line = is.readLine();
		return Cmd.parseCmd(line);
	}

	void play(int cmd) {
		Room newRoom = null;
		boolean noWay = false;
		switch(cmd) {
		case Cmd.UNKNOWN:
			println("Unknown command!");
			break;
		case Cmd.NORTH:
			if (room.north != null) {
				newRoom = room.north;
			} else
				noWay = true;
			break;
		case Cmd.EAST:
			if (room.east != null) {
				newRoom = room.east;
			} else
				noWay = true;
			break;
		case Cmd.SOUTH:
			if (room.south != null) {
				newRoom = room.south;
			} else
				noWay = true;
			break;
		case Cmd.WEST:
			if (room.west != null) {
				newRoom = room.west;
			} else
				noWay = true;
			break;
		case Cmd.HELP:
			println("Sorry, help not written yet. I cannot help it");
			break;
		default:
			println("LOGIC ERROR: Unhandled case " + (char)cmd);
			break;
		}
		if (noWay) {
			println("I see no way to go in that direction");
			return;
		}
		if (newRoom != null) {
			if (room.exitMessage != null) {
				println(room.exitMessage);
			}
			// The magic happens: we change rooms.
			room = newRoom;
			println(room.entryMessage);
		}
	}

	static void println(String s) {
		System.out.println(s);
	}
}
//@@@@@@//
//oo/metrolib/Room.java
//@@@@@@//
package metrolib;

/** A Room is one location in the game.
 */
class Room {
	/** The exits from this Room */
	Room north, east, south, west;
	/** The message to display when entering this room */
	String entryMessage = "You are now in a room";
	/** The message (if any) to display when leaving */
	String exitMessage;

	public void setAll(Room n, Room e, Room s, Room w,
		String inMsg, String outMsg) {
		north = n; east = e; south = s; west = w;
		entryMessage = inMsg;
		exitMessage = outMsg;
	}
}
//@@@@@@//
//oo/metrolib/Rooms.java
//@@@@@@//
package metrolib;

/** This is the rooms data structure.
 * In a real game this would be generated from a database!
 */
public class Rooms {
	static Room lobby;
	static Room mainHall;
	static Room hallOfKings;

	static {
		System.out.println("Building rooms...");

		// MUST init these all before setting them up.
		lobby = new Room();
		mainHall = new Room();
		hallOfKings = new Room();

		lobby.setAll(null, mainHall, null, null,
			"You are standing in the lobby. There is a door to the east", 
			"Come visit this generic lobby again soon");
		mainHall.setAll(null, hallOfKings, null, lobby,
			"You are in the Great Hall. There are doors to the east and west",
			null);
		hallOfKings.setAll(null, null, null, mainHall,
			"You are in the Hall of The Mountain Kings. There is a door to the west", null);
	}

	public static Room getFirstRoom() {
		return lobby;
	}
}

//@@@@@@//
//oo/PrintHashCodes.java
//@@@@@@//
/** Display hashCodes from some objects */
public class PrintHashCodes {

	/** Some objects to hashCode() on */
	protected static Object[] data = {
		new PrintHashCodes(),
		new java.awt.Color(0x44, 0x88, 0xcc),
		new SomeClass()
	};

	public static void main(String[] args) {
		System.out.println("About to hashCode " + data.length + " objects.");
		for (int i=0; i<data.length; i++) {
			System.out.println(data[i].toString() + " --> " + 
				data[i].hashCode());
		}
		System.out.println("All done.");
	}
}
//@@@@@@//
//oo/SerializableUser.java
//@@@@@@//
/** Demo of a data class that will be used as a JavaBean or as a data
 * class in a Servlet container; making it Serializable allows
 * it to be saved ("serialized") to disk or over a network connection.
 */
public class SerializableUser implements java.io.Serializable {
	public String name;
	public String address;
	public String country;
	public String phoneNum;

	// other fields, and methods, here...
    static final long serialVersionUID = -7978489268769667877L;
}
//@@@@@@//
//oo/shapes/Circle.java
//@@@@@@//
public class Circle extends Shape {
	double radius;
	public double computeArea() {
		return Math.PI * radius * radius;
	}
}
//@@@@@@//
//oo/shapes/Main.java
//@@@@@@//
import java.util.*;

/** Part of a main program using Shape objects */
public class Main {

	Collection allShapes;	// created in a Constructor, not shown

	/** Iterate over all the Shapes, getting their areas */
	public double totalAreas() {
		Iterator it = allShapes.iterator();
		double total = 0.0;
		while (it.hasNext()) {
			Shape s = (Shape)it.next();
			total += s.computeArea();
		}
		return total;
	}
}
//@@@@@@//
//oo/shapes/Rectangle.java
//@@@@@@//
public class Rectangle extends Shape {
	double width, height;
	public double computeArea() {
		return width * height;
	}
}
//@@@@@@//
//oo/shapes/Shape.java
//@@@@@@//
public abstract class Shape {
	protected int x, y;
	public abstract double computeArea();
}
//@@@@@@//
//oo/ShutdownDemo.java
//@@@@@@//
/** Demonstrate how finalize() methods and shutdownHooks interact
 *  with calls to System.exit().
 */
public class ShutdownDemo {
	public static void main(String[] args) throws Exception {

		// Create an Object with a finalize() method.
		Object f = new Object() {
			public void finalize() {
				System.out.println( "Running finalize()");
			}
		};

		// Add a shutdownHook to the JVM
		Runtime.getRuntime().addShutdownHook(new Thread() {
			public void run() {
				System.out.println("Running Shutdown Hook");
			}
		});

		// Unless the user puts -f (for "free") on the command line,
		// call System.exit while holding a reference to 
		// Object f, which can therefore not be finalized().

		if (args.length == 1 && args[0].equals("-f")) {
			f = null;
			System.gc();
		}

		System.out.println("Calling System.exit()");
		System.exit(0);
	}
}
//@@@@@@//
//oo/SideEffects.java
//@@@@@@//
import java.util.*;

/**
 * Simple demo of avoiding side-effects by using Object.clone()
 * to duplicate an object before passing it to your enemy's methods.
 * Cloneable is a "marker" interface: it has no methods, but is tested
 * for by Object.clone. If you implement it, you tell Object.clone that
 * your data is stable enough that field-by-field copy is OK.
 */
class Enemy {
	public void munge(SideEffects md) {
		System.out.println("Object is " + md);
		md.year = 0;
		md.td.setYear(71);	  // Ignore deprecation warnings
	}
}

public class SideEffects implements Cloneable {
	/** When we clone a "SideEffects", this REFERENCE gets cloned */
	public Date td;	
	/** When we clone a "SideEffects", this integer does NOT get cloned */
	volatile int year;

	public static void main(String[] argv) throws CloneNotSupportedException {
		new SideEffects().process();
	}

	SideEffects() {
		td = new Date();	// today
		year = td.getYear();
	}

	public void process() throws CloneNotSupportedException {
		Enemy r = new Enemy();
		System.out.println("We have seen the enemy, and he is " + r);
		System.out.println("Today is " + td + "; nice weather, isn't it?");
		System.out.println("And the year is " + year);
		r.munge((SideEffects)this.clone());
		System.out.println("Why, I believe it is now " + td);
		if (year == 0)		// should not happen!!
			System.out.println("** PANIC IN YEAR ZERO **");
		System.out.println("But wait, the year is still " + year);
		r.munge(this);
		System.out.println("Now I'm certain that it's " + td);
		System.out.println("Now the year is  " + year);
	}
}
//@@@@@@//
//oo/Singleton.java
//@@@@@@//
/** An example of a Singleton implementation in Java.
 * The Singleton design pattern is described in GOF; the idea is to ensure
 * that only one instance of the class will exist in a given application.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Singleton.java,v 1.7 2004/02/09 03:33:58 ian Exp $
 */
public class Singleton {

	private static Singleton singleton = new Singleton();

	/** A private Constructor prevents any other class from instantiating. */
	private Singleton() {
	}

	/** Static 'instance' method */
	public static Singleton getInstance() {
		return singleton;
	}

	// other methods protected by singleton-ness would be here...

	/** A simple demo method */
	public String demoMethod() {
		return "demo";
	}
}
//@@@@@@//
//oo/SingletonCheat1.java
//@@@@@@//
/** Cheat on a Singleton by calling its clone method?
 */
public class SingletonCheat1 {
	public static void main(String[] args) {
		Singleton s = Singleton.getInstance();
		try {
			s.clone();	// EXPECT COMPILE ERROR - clone is protected!
		} catch (CloneNotSupportedException ex) {
			System.out.println("You can'd do it this way either: " + ex);
		}
	}
}
//@@@@@@//
//oo/SingletonCheat2.java
//@@@@@@//
/** Cheat on a Singleton by cloning it? */
public class SingletonCheat2 extends Singleton { // EXPECT COMPILE ERROR
	public Object clone() {
		Object n;
		try {
			n = super.clone();
		} catch (CloneNotSupportedException ex) {
			System.out.println("caught it now! " + ex);
		}
		return n;
	}

	public static void main(String[] args) {
		SingletonCheat2 s1 = (SingletonCheat2)SingletonCheat2.getInstance();
		System.out.println(s1);

		Object s2 = s1.clone();
		System.out.println(s2);
	}
}
//@@@@@@//
//oo/SingletonDemo.java
//@@@@@@//
public class SingletonDemo {
	public static void main(String[] args) {
		Singleton tmp = Singleton.getInstance();
		tmp.demoMethod();
	}
}
//@@@@@@//
//oo/SingletonTest.java
//@@@@@@//
import junit.framework.*;

/** Some JUnit test cases for the Singleton demo.
 * @version $Id: SingletonTest.java,v 1.2 2003/11/25 17:29:27 ian Exp $
 */
public class SingletonTest extends TestCase {

	Singleton d1, d2;

	/** setup method */
	public void setUp() {
		d1 = Singleton.getInstance();
		d2 = Singleton.getInstance();
	}

	/** constructor plumbing for junit */
	public SingletonTest(String name) {
		super(name);
	}

	public void testSingleness() { 
		assertTrue(d1 == d2);
	}

	public void testCorrectClass() {
		assertTrue(d1 instanceof Singleton);
	}

	public void testDemoMethod() {
		assertEquals(d1.demoMethod(), "demo");
	}
}
//@@@@@@//
//oo/SomeClass.java
//@@@@@@//
public class SomeClass {
	public boolean equals(Object o2) {
		if (!(o2 instanceof SomeClass))
			return false;
		// compare fields; if any differ, return false.
		return true;
	}
}
//@@@@@@//
//oo/StringParse.java
//@@@@@@//
import com.darwinsys.lang.MutableInteger;

/** Show use of MutableInteger to "pass back" a value in addition
 * to a function's return value.
 */
public class StringParse {
	/** This is the function that has a return value of true but
	 * also "passes back" the offset into the String where a
	 * value was found. Contrived example!
	 */
	public static boolean parse(String in, char lookFor, MutableInteger whereFound) {
		int i = in.indexOf(lookFor);
		if (i == -1)
			return false;	// not found
		whereFound.setValue(i);	// say where found
		return true;		// say that it was found
	}

	public static void main(String[] args) {
		MutableInteger mi = new MutableInteger();
		String text = "Hello, World";
		char c = 'W';
		if (parse(text, c, mi)) {
			System.out.println("Character " + c + " found at offset " + mi + " in " + text);
		} else {
			System.out.println("Not found");
		}
	}
}
//@@@@@@//
//oo/ToStringWith.java
//@@@@@@//
/* Demonstrate toString() with an override */
public class ToStringWith {
	int x, y;

	/** Simple constructor */
	public ToStringWith(int anX, int aY) {
		x = anX; y = aY;
	}

	/** Override toString */
	public String toString() {
		return "ToStringWith[" + x + "," + y + "]";
	}
	/** Main just creates and prints an object */
	public static void main(String[] args) { 
		System.out.println(new ToStringWith(42, 86));
	}
}
//@@@@@@//
//oo/ToStringWithout.java
//@@@@@@//
/* Demonstrate toString() without an override */
public class ToStringWithout {
	int x, y;

	/** Simple constructor */
	public ToStringWithout(int anX, int aY) {
		x = anX; y = aY;
	}

	/** Main just creates and prints an object */
	public static void main(String[] args) { 
		System.out.println(new ToStringWithout(42, 86));
	}
}
//@@@@@@//
//otherlang/ExecDemoFiles.java
//@@@@@@//
import com.darwinsys.lang.ExecAndPrint;

/**
 * Create, list and remove some files
 */
public class ExecDemoFiles {
	public static void main(String av[]) throws Exception {
		
		// Get and save the Runtime object.
		Runtime rt = Runtime.getRuntime();

		// Create three temporary files
		rt.exec("mktemp file1");
		rt.exec("mktemp file2");
		rt.exec("mktemp file3");

		// Run the "ls" (directory lister) program
		// with its output sent into a file
		String[] args = { "ls", "-l", "file1", "file2", "file3" };
		ExecAndPrint.run(args);

		rt.exec("rm file1 file2 file3");
	}
}
//@@@@@@//
//otherlang/ExecDemoLs.java
//@@@@@@//
import com.darwinsys.util.Debug;

import java.io.*;

/**
 * ExecDemo shows how to execute an external program (in this case
 * the UNIX directory lister /bin/ls) and read its output.
 */
public class ExecDemoLs {
	/** The program to run */
	public static final String PROGRAM = "ls"; // "dir" for Windows
	/** Set to true to end the loop */
	static boolean done = false;

	public static void main(String argv[]) throws IOException {

		final Process p; 		// Process tracks one external native process
		BufferedReader is;	// reader for output of process
		String line;
		
		p = Runtime.getRuntime().exec(PROGRAM);

		Debug.println("exec", "In Main after exec");

		// Optional: start a thread to wait for the process to terminate.
		// Don't just wait in main line, but here set a "done" flag and
		// use that to control the main reading loop below.
		Thread waiter = new Thread() {
			public void run() {
				try {
					p.waitFor();
				} catch (InterruptedException ex) {
					// OK, just quit.
					return;
				}
				System.out.println("Program terminated!");
				done = true;
			}
		};
		waiter.start();

		// getInputStream gives an Input stream connected to
		// the process p's standard output (and vice versa). We use
		// that to construct a BufferedReader so we can readLine() it.
		is = new BufferedReader(new InputStreamReader(p.getInputStream()));

		while (!done && ((line = is.readLine()) != null))
			System.out.println(line);
		
		Debug.println("exec", "In Main after EOF");

		return;
	}
}
//@@@@@@//
//otherlang/ExecDemoNS.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;
import java.net.*;
import java.util.*;

import com.darwinsys.util.Debug;

/**
 * ExecDemoNS shows how to execute a program from within Java.
 */
public class ExecDemoNS extends JFrame {
	/** The name of the help file. */
	protected final static String HELPFILE = "./help/index.html";

	/** A stack of process objects; each entry tracks one external running process */
	Stack<Process> pStack = new Stack<Process>();

	/** main - instantiate and run */
	public static void main(String av[]) throws Exception {
		String program = av.length == 0 ? "netscape" : av[0];
		new ExecDemoNS(program).setVisible(true);
	}

	/** The path to the binary executable that we will run */
	protected static String program;

	/** Constructor - set up strings and things. */
	public ExecDemoNS(String prog) {
		super("ExecDemo: " + prog);
		String osname = System.getProperty("os.name");
		if (osname == null)
			throw new IllegalArgumentException("no os.name");
		if (prog.equals("netscape"))
			program = // Windows or UNIX only for now, sorry Mac fans
				(osname.toLowerCase().indexOf("windows")!=-1) ?
				"c:/program files/netscape/communicator/program/netscape.exe" :
				"/usr/local/netscape/netscape";
		else
			program = prog;

		Container cp = getContentPane();
		cp.setLayout(new FlowLayout());
		JButton b;
		cp.add(b=new JButton("Exec"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				runProg();
			}
		});
		cp.add(b=new JButton("Wait"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				doWait();
			}
		});
		cp.add(b=new JButton("Exit"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				System.exit(0);
			}
		});
		pack();
	}

	/** Start the help, in its own Thread. */
	public void runProg() {

		new Thread() {
			public void run() {

				try {
					// Get the URL for the Help File
					URL helpURL = this.getClass().getClassLoader().
						getResource(HELPFILE);

					// Start Netscape from the Java Application.

					pStack.push(Runtime.getRuntime().exec(program + " " + helpURL));

					Debug.println("trace", "In main after exec " + pStack.size());

				} catch (Exception ex) {
					JOptionPane.showMessageDialog(ExecDemoNS.this,
						"Error" + ex, "Error",
						JOptionPane.ERROR_MESSAGE);
				}
			}
		}.start();

	}

	public void doWait() {
		if (pStack.size() == 0) return;
		Debug.println("trace", "Waiting for process " + pStack.size());
		try {
			pStack.peek().waitFor();
				// wait for process to complete (does not work as expected for Windows programs)
			Debug.println("trace", "Process " + pStack.size() + " is done");
		} catch (Exception ex) {
			JOptionPane.showMessageDialog(this,
				"Error" + ex, "Error",
				JOptionPane.ERROR_MESSAGE);
		}
		pStack.pop();
	}

}
//@@@@@@//
//otherlang/ExecDemoPartial.java
//@@@@@@//
import com.darwinsys.util.Debug;

import java.io.*;

/**
 * ExecDemo shows how to execute an external program (in this case
 * the UNIX directory lister /bin/ls) and read its output.
 * This version handles the case where the program may exit abnormally.
 */
public class ExecDemoPartial {
	/** The program to run */
	public static final String PROGRAM = "ls";
	/** Set to true to end the loop */
	static boolean done = false;

	public static void main(String argv[]) throws IOException {

		BufferedReader is;	// reader for output of process
		String line;
		
		final Process p = Runtime.getRuntime().exec(PROGRAM);

		Debug.println("exec", "In Main after exec");


		Thread waiter = new Thread() {
			public void run() {
				try {
					p.waitFor();
				} catch (InterruptedException ex) {
					// OK, just quit this thread.
					return;
				}
				System.out.println("Program terminated!");
				done = true;
			}
		};
		waiter.start();

		// getInputStream gives an Input stream connected to
		// the process p's standard output (and vice versa). We use
		// that to construct a BufferedReader so we can readLine() it.
		is = new BufferedReader(new InputStreamReader(p.getInputStream()));

		while (!done && ((line = is.readLine()) != null))
			System.out.println(line);
		
		Debug.println("exec", "In Main after end of read loop");

		return;
	}
}
//@@@@@@//
//otherlang/ExecDemoRm.java
//@@@@@@//
import java.io.*;

/*
 * create some temp files, ls them, and rm them
 */
public class ExecDemoRm {
	public static void main(String[] args) throws IOException {
		for (int i=0; i<10; i++) {
			new File("/tmp/ww" + i).createNewFile();
		}
		Runtime.getRuntime().exec("ls -l /tmp/ww? > /tmp/report");
		Runtime.getRuntime().exec("rm -f /tmp/ww?");
	}
}
//@@@@@@//
//otherlang/ExecDemoSimple.java
//@@@@@@//
/**
 * ExecDemo shows how to execute an external program and read its output.
 */
public class ExecDemoSimple {
	public static void main(String av[]) throws Exception {
		
		// Run the "notepad" program or a similar editor
		Process p = Runtime.getRuntime().exec("kwrite");

		p.waitFor();
	}
}
//@@@@@@//
//otherlang/ExecDemoWait.java
//@@@@@@//
import java.io.*;

/**
 * ExecDemo shows how to execute an external program
 * read its output, and print its exit status.
 */
public class ExecDemoWait {

	public static void main(String argv[]) throws IOException {

		// A Runtime object has methods for dealing with the OS
		Runtime r = Runtime.getRuntime();
		Process p; 		// Process tracks one external native process
		BufferedReader is;	// reader for output of process
		String line;
		
		// Our argv[0] contains the program to run; remaining elements
		// of argv contain args for the target program. This is just
		// what is needed for the String[] form of exec.
		p = r.exec(argv);

		System.out.println("In Main after exec");

		// getInputStream gives an Input stream connected to
		// the process p's standard output. Just use it to make
		// a BufferedReader to readLine() what the program writes out.
		is = new BufferedReader(new InputStreamReader(p.getInputStream()));

		while ((line = is.readLine()) != null)
			System.out.println(line);
		
		System.out.println("In Main after EOF");
		System.out.flush();
		try {
			p.waitFor();	// wait for process to complete
		} catch (InterruptedException e) {
			System.err.println(e);	// "Can'tHappen"
			return;
		}
		System.err.println("Process done, exit status was " + p.exitValue());
		return;
	}
}
//@@@@@@//
//otherlang/ExecShellArgs.java
//@@@@@@//
import java.io.*;

/*
 * Show how to use exec to pass complex args (which are almost
 * certainly system-dependant) to a command-line interpreter.
 */
public class ExecShellArgs {
	public static void main(String[] args) throws IOException {
		Runtime r = Runtime.getRuntime();
		String[] nargs = { "sh", "-c", "for i in 1 2 3; do echo $i; done" };
		Process p = r.exec(nargs);
		BufferedReader is =
			new BufferedReader(new InputStreamReader(p.getInputStream()));
		String line;
		while ((line = is.readLine()) != null)
			System.out.println(line);
	}
}
//@@@@@@//
//otherlang/ProcessBuilderDemo.java
//@@@@@@//
import com.darwinsys.util.Debug;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.io.IOException;

/**
 * ProcessBuilderDemo shows how to execute an external 
 * program (in this case the MS-Windows notepad program).
 */
public class ProcessBuilderDemo {

	public static void main(String argv[]) 
	throws InterruptedException, IOException {
		
		List<String> command = new ArrayList<String>();
		command.add("notepad");
		command.add("foo.txt");
		ProcessBuilder builder = new ProcessBuilder(command);
		Map<String, String> environ = builder.environment();
		environ.put("PATH", "/windows;/windows/system32;/winnt");
		builder.directory(
			new File(System.getProperty("user.home")));

		final Process godot = builder.start();
		
		Debug.println("exec", "Waiting for Godot");
		godot.waitFor();

		System.out.println("Program terminated!");
		return;
	}
}
//@@@@@@//
//otherlang/StringDistance.java
//@@@@@@//
/** Example of a Java Class that calls a Perl function.
 * <br/>
 * Does not run on its own -- for usage, see StringDistance.pl!
 */

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import org.perl.inline.java.*;
// requires classpath to include this file; usually something like
// .;<perldir>/site/lib/Inline/Java/InlineJavaServer.jar

/** The test class. */
public class StringDistance extends InlineJavaPerlCaller {
  JFrame frame;           // visual container
  JTextField tf[], dist;  // text input fields, result output field
  JButton go, exit;       // action buttons

  /* The constructor with possibly 2 initial strings */
  public StringDistance(String[] strs) throws InlineJavaException {
    frame = new JFrame("StringDistance");
    Container p = frame.getContentPane();
    p.setLayout(new GridLayout(0,2));

    // The input fields, including labels:
    tf = new JTextField[2];
    for (int i=0; i<2; i++) {
      p.add(new JLabel("String " + i + ":"));
      tf[i] = new JTextField(20);
      if ((strs != null) && (i < strs.length)) tf[i].setText(strs[i]);
      p.add(tf[i]);
    }

    // The output field, including label:
    p.add(new JLabel("Distance:"));
    dist = new JTextField(5);
    dist.setEditable(false);
    p.add(dist);

    // The main action button:
    go = new JButton("Compute distance");
    go.addActionListener(new ActionListener() {
               public void actionPerformed(ActionEvent ae) {
                 dist.setText(Integer.toString(match(tf[0].getText(),
                                                     tf[1].getText())));
               }
             }
           );
    p.add(go);

    // To finish off:
    exit = new JButton("Exit");
    exit.addActionListener(new ActionListener() {
               public void actionPerformed(ActionEvent ae) {
                 frame.dispose(); System.exit(0);
               }
             }
           );
    p.add(exit);

    if ((strs != null) && (strs.length > 1))
      dist.setText(Integer.toString(match(tf[0].getText(),
                   tf[1].getText())));
    frame.pack();
  }


  // Alternative constructors:
  public StringDistance(String s0, String s1)
      throws InlineJavaException {
    this(new String[] { s0, s1 });
  }

  public StringDistance(String s0) throws InlineJavaException {
    this(new String[] { s0 });
  }

  public StringDistance() throws InlineJavaException {
    this((String[])null);
  }


  /** This shows everything */
  public void show() { frame.setVisible(true); }


  /* Optionally for pre-filling the input fields. */
  public void setText(int fieldno, String str) {
    tf[fieldno].setText(str);
  }


  /** The central interface function to Perl. */
  public int match(String s0, String s1) {
    try {
      String str = (String)CallPerl("Text::Levenshtein", "distance",
                                    new Object [] {s0, s1});
      return Integer.parseInt(str);
    } catch (InlineJavaPerlException e) {
      System.err.println("Inline Java Perl Exception: " + e);
    } catch (InlineJavaException e) {
      System.err.println("Inline Java Exception: " + e);
    }
    return 0;
  }

}
//@@@@@@//
//packaging/GetResourceDemo.java
//@@@@@@//
import java.io.*;
import java.util.*;

/** Show using classLoader.getResource() to load a file.
 * This is required under Java Web Start.
 */
public class GetResourceDemo {
	public static void main(String[] args) {
		new GetResourceDemo().demo();
	}

	/** The demo itself */
	public void demo() {
		// Find the ClassLoader that loaded us.
		// Regard it as the One True ClassLoader for this app.
		ClassLoader loader = this.getClass().getClassLoader();

		// Use the loader's getResource() method to open the file.
		InputStream is = loader.getResourceAsStream("widgets.properties");
		if (is == null) {
			System.err.println("Can't load properties file");
			return;
		}

		// Create a Properties object
		Properties p = new Properties();

		// Load the properties file into the Properties object
		try {
			p.load(is);
		} catch (IOException ex) {
			System.err.println("Load failed: " + ex);
			return;
		}

		// List it to confirm that we loaded it.
		p.list(System.out);
	}
}
//@@@@@@//
//packaging/HelloApplet.java
//@@@@@@//
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JApplet;
import javax.swing.JButton;

/**
 * HelloApplet is a simple applet that toggles a message
 * when you click on a Draw button.
 */
public class HelloApplet extends JApplet {

	/** The flag which controls drawing the message. */
	protected boolean requested;

	/** init() is an Applet method called by the browser to initialize */
	public void init() {
		JButton b;
		requested = false;
		Container cp = (Container)getContentPane();
		cp.setLayout(new FlowLayout());
		String buttonLabel = getParameter("buttonlabel");
		if (buttonLabel == null) {
			buttonLabel = "Draw/Don't Draw";
		}
		cp.add(b = new JButton(buttonLabel));
		b.addActionListener(new ActionListener() {
			/*  Button - toggle the state of the "requested" flag, to draw or
			 *  not to draw.
			 */
			public void actionPerformed(ActionEvent e) {
				String arg = e.getActionCommand();
				// Invert the state of the draw request.
				requested = !requested;
				do_the_work();
			}
		});
	}

	/** paint() is an AWT Component method, called when the 
	 *  component needs to be painted.
	 */
	public void do_the_work() {
		/* If the Draw button is selected, draw something */
		if (requested) {
			showStatus("Welcome to Java!");
		} else {
			showStatus("");	// retract welcome? :-)
		}
	}
}
//@@@@@@//
//packaging/HelloWorld.java
//@@@@@@//
import javax.swing.JFrame;
import javax.swing.JLabel;

/**
 * Your basic, minimal, Hello World type program in Java.
 * $Id: HelloWorld.java,v 1.2 2003/11/25 17:29:31 ian Exp $
 */
public class HelloWorld {
	public static void main(String[] argv) {
		String message = "Hello, World of Java";
		JFrame jf = new JFrame(message);
		jf.getContentPane().add(new JLabel(message));
		jf.pack();
		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		jf.setVisible(true);
	}
}
//@@@@@@//
//Plotter/Penman.java
//@@@@@@//
import java.io.*;
import javax.comm.*;
import java.util.*;

/**
 * A Plotter subclass for drawing on a Penman plotter.
 * These were made in the UK and sold into North American markets.
 * It is a little "turtle" style robot plotter that communicates
 * over a serial port. For this, we use the "Java Communicatons" API.
 * Java Communications is a "standard extention" and must be downloaded
 * and installed separately from the JDK before you can even compile this 
 * program.
 *
 * @author	Ian Darwin, http://www.darwinsys.com/
 */
public class Penman extends Plotter {
	private final String OK_PROMPT = "\r\n!";
	private final int MAX_REPLY_BYTES = 50;	// paranoid upper bound
	private SerialPort tty;
	private DataInputStream is;
	private DataOutputStream os;

	/** Construct a Penman plotter object */
	public Penman() throws NoSuchPortException,PortInUseException,
			IOException,UnsupportedCommOperationException {
		super();
		init_comm("COM2");		// setup serial commx
		init_plotter();		// set plotter to good state
	}

	private void init_plotter() {
		send("I"); expect('!');	// eat VERSION etc., up to !
		send("I"); expect('!');	// wait for it!
		send("H");		// find home position
		expect('!');	// wait for it!
		send("A");		// Set to use absolute coordinates
		expect('!');
		curx = cury = 0;
		penUp();
	}

	//
	// PUBLIC DRAWING ROUTINES
	//

	public void setFont(String fName, int fSize) {
		// Font name is ignored for now...

		// Penman's size is in mm, fsize in points (inch/72).
		int size = (int)(fSize*25.4f/72);
		send("S"+size + ","); expect(OK_PROMPT);
		System.err.println("Font set request: " + fName + "/" + fSize);
	}

	public void drawString(String mesg) {
		send("L" + mesg + "\r"); expect(OK_PROMPT);
	}

	/** Move to a relative location */
	public void rmoveTo(int incrx, int incry){
		moveTo(curx + incrx, cury + incry);
	}

	/** move to absolute location */
	public void moveTo(int absx, int absy) {
		System.err.println("moveTo ["+absx+","+absy+"]");
		curx = absx;
		cury = absy;
		send("M" + curx + "," + cury + ","); expect(OK_PROMPT);
	}

	private void setPenState(boolean up) {
		penIsUp = up;
		System.err.println("Pen Up is ["+penIsUp+"]");
	}

	public void penUp() {
		setPenState(true);
		send("U"); expect(OK_PROMPT);
	}
	public void penDown() {
		setPenState(false);
		send("D"); expect(OK_PROMPT);
	}
	public void penColor(int c) {
		penColor = (c%3)+1;		// only has 3 pens, 4->1
		System.err.println("PenColor is ["+penColor+"]");
		send("P" + c + ","); expect(OK_PROMPT);
	}

	//
	// PRIVATE COMMUNICATION ROUTINES
	//

	/** Set up communication. 
	 * <br/>
	 * XXX: Should probably re-use CommPortOpen instead.
	 */
	private void init_comm(String portName) throws NoSuchPortException,PortInUseException,
			IOException,UnsupportedCommOperationException {

		// get list of ports available on this particular computer.
		// Enumeration pList = CommPortIdentifier.getPortIdentifiers();

		// Print the list. A GUI program would put these in a chooser!
		// while (pList.hasMoreElements()) {
			// CommPortIdentifier cpi = (CommPortIdentifier)pList.nextElement();
			// System.err.println("Port " + cpi.getName());
		// }
		
		// Open a port. 
		CommPortIdentifier port =
			CommPortIdentifier.getPortIdentifier(portName);

		// This form of open takes an Application Name and a timeout.
		tty = (SerialPort) port.open("Penman Driver", 1000);

		// set up the serial port
		tty.setSerialPortParams(9600, SerialPort.DATABITS_8,
			SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);
		tty.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_OUT|
			SerialPort.FLOWCONTROL_RTSCTS_OUT);

		// Get the input and output streams
		is = new DataInputStream(tty.getInputStream());
		os = new DataOutputStream(tty.getOutputStream());
	}

	/** Send a command to the plotter. Although the argument is a String,
	 * we send each char as a *byte*, so avoid 16-bit characters!
	 * Not that it matters: the Penman only knows about 8-bit chars.
	 */
	private	void send(String s) {
		System.err.println("sending " + s + "...");
		try {
			for (int i=0; i<s.length(); i++)
				os.writeByte(s.charAt(i));
		} catch(IOException e) {
			e.printStackTrace();
		}
	}

	/** Expect a given CHAR for a result */
	private	void expect(char s) {
		byte b;
		try {
			for (int i=0; i<MAX_REPLY_BYTES; i++){
				if ((b = is.readByte()) == s) {
						return;
				}
				System.err.print((char)b);
			}
		} catch (IOException e) {
			System.err.println("Penman:expect(char "+s+"): Read failed");
			System.exit(1);
		}
		System.err.println("ARGHH!");
	}

	/** Expect a given String for a result */
	private	void expect(String s) {
		byte ans[] = new byte[s.length()];

		System.err.println("expect " + s + " ...");
		try {
			is.read(ans);
		} catch (IOException e) {
			System.err.println("Penman:expect(String "+s+"): Read failed");
			System.exit(1);
		};
		for (int i=0; i<s.length() && i<ans.length; i++)
			if (ans[i] != s.charAt(i)) {
				System.err.println("MISMATCH");
				break;
			}
		System.err.println("GOT: " + new String(ans));

	}
}
//@@@@@@//
//Plotter/PlotDriver.java
//@@@@@@//
/** Main program, driver for Plotter class.
 * This is to simulate a larger graphics application such as GnuPlot.
 */
public class PlotDriver {

	/** Construct a Plotter driver, and try it out. */
	public static void main(String[] argv)
	{
		Plotter r ;
		if (argv.length != 1) {
			System.err.println("Usage: PlotDriver driverclass");
			return;
		}
		try {
			Class c = Class.forName(argv[0]);
			Object o = c.newInstance();
			if (!(o instanceof Plotter))
				throw new ClassNotFoundException("Not instanceof Plotter");
			r = (Plotter)o;
		} catch (ClassNotFoundException e) {
			System.err.println("Sorry, "+argv[0]+" not a plotter class");
			return;
		} catch (Exception e) {
			e.printStackTrace();
			return;
		}
		r.penDown();
		r.penColor(1);
		r.moveTo(200, 200);
		r.penColor(2);
		r.drawBox(123, 200);
		r.rmoveTo(10, 20);
		r.penColor(3);
		r.drawBox(123, 200);
		r.penUp();
		r.moveTo(300, 100);
		r.penDown();
		r.setFont("Helvetica", 14);
		r.drawString("Hello World");
		r.penColor(4);
		r.drawBox(10, 10);
	}
}
//@@@@@@//
//Plotter/Plotter.java
//@@@@@@//
/**
 * Plotter abstract class. Must be subclassed 
 * for X, DOS, Penman, HP plotter, etc.
 *
 * Coordinate space: X = 0 at left, increases to right.
 *		Y = 0 at top, increases downward (same as AWT).
 *
 * @author	Ian F. Darwin
 */
public abstract class Plotter {
	public final int MAXX = 800;
	public final int MAXY = 600;
	/** Current X co-ordinate (same reference frame as AWT!) */
	protected int curx;
	/** Current Y co-ordinate (same reference frame as AWT!) */
	protected int cury;
	/** The current state: up or down */
	protected boolean penIsUp;
	/** The current color */
	protected int penColor;

	Plotter() {
		penIsUp = true;
		curx = 0; cury = 0;
	}
	abstract void rmoveTo(int incrx, int incry);
	abstract void moveTo(int absx, int absy);
	abstract void penUp();
	abstract void penDown();
	abstract void penColor(int c);

	abstract void setFont(String fName, int fSize);
	abstract void drawString(String s);

	/* Concrete methods */

	/** Draw a box of width w and height h */
	public void drawBox(int w, int h) {
		penDown();
		rmoveTo(w, 0);
		rmoveTo(0, h);
		rmoveTo(-w, 0);
		rmoveTo(0, -h);
		penUp();
	}

	/** Draw a box given an AWT Dimension for its size */
	public void drawBox(java.awt.Dimension d) {
		drawBox(d.width, d.height);
	}

	/** Draw a box given an AWT Rectangle for its location and size */
	public void drawBox(java.awt.Rectangle r) {
		moveTo(r.x, r.y);
		drawBox(r.width, r.height);
	}
}
//@@@@@@//
//Plotter/PlotterAWT.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;

import com.darwinsys.swingui.WindowCloser;

/**
 * A Plotter subclass for drawing into an AWT Window. Reflecting back
 * to AWT gives us a "known working" plotter to test on.
 * You can also steal this as a basis for your own plotter driver.
 * @author	Ian Darwin
 */
public class PlotterAWT extends Plotter {
	Frame f;
	PCanvas p;
	Graphics g;
	Font font;
	FontMetrics fontMetrics;
	PlotterAWT() {
		super();
		f = new Frame("Plotter");
		p = new PCanvas(MAXX, MAXY);
		f.add(p);
		f.pack();
		f.setVisible(true);
        f.addWindowListener(new WindowCloser(f, true));
		g = p.getOsGraphics();
	}

	public void drawBox(int w, int h) {
		g.drawRect(curx, cury, w, h);
		p.repaint();
	}

	public void rmoveTo(int incrx, int incry){
		moveTo(curx += incrx, cury += incry);
	}

	public void moveTo(int absx, int absy){
		if (!penIsUp)
			g.drawLine(curx, cury, absx, absy);
		curx = absx;
		cury = absy;
	}

	public void setdir(float deg){}
	void penUp(){ penIsUp = true; }
	void penDown(){ penIsUp = false; }
	void penColor(int c){
		switch(c) {
		case 0: g.setColor(Color.white); break;
		case 1: g.setColor(Color.black); break;
		case 2: g.setColor(Color.red); break;
		case 3: g.setColor(Color.green); break;
		case 4: g.setColor(Color.blue); break;
		default: g.setColor(new Color(c)); break;
		}
	}
	void setFont(String fName, int fSize) {
		font = new Font(fName, Font.BOLD, fSize);
		fontMetrics = p.getFontMetrics(font);
	}
	void drawString(String s) {
		g.drawString(s, curx, cury);
		curx += fontMetrics.stringWidth(s);
	}

	/** A Member Class that contains an off-screen Image that is
	 * drawn into; this component's paint() copies from there to
	 * the screen. This avoids having to keep a list of all the
	 * things that have been drawn.
	 */
	class PCanvas extends Canvas {
		Image offScreenImage;
		int width;
		int height;
		Graphics pg;

		PCanvas(int w, int h) {
			width = w;
			height = h;
			setBackground(Color.white);
			setForeground(Color.red);
		}

		public Graphics getOsGraphics() {
			return pg;
		}

		/** This is called by AWT after the native window peer is created,
		 * and before paint() is called for the first time, so
		 * is a good time to create images and the like.
		 */
		public void addNotify() {
			super.addNotify();
			offScreenImage = createImage(width, height);
			// assert (offScreenImage != null);
			pg = offScreenImage.getGraphics();
		}

		public void paint(Graphics pg) {
			pg.drawImage(offScreenImage, 0, 0, null);
		}
		public Dimension getPreferredSize() {
			return new Dimension(width, height);
		}
	}
}
//@@@@@@//
//Plotter/PlotterDummy.java
//@@@@@@//
import java.io.*;
import java.lang.*;

/** Plotter class for testing higher-level software. */
public class PlotterDummy extends Plotter {

	/** Constructor: nothing to do */
	PlotterDummy() {
		super();
	}

	/** move to absolute location */
	void moveTo(int absx, int absy) {
		curx = absx;
		cury = absy;
		System.out.println("moveTo ["+curx+","+cury+"]");
	}
	/** move to relative location */
	void rmoveTo(int incrx, int incry) {
		curx += incrx;
		cury += incry;
		System.out.println("rmoveTo ["+curx+","+cury+"]");
	}
	public void setFont(java.lang.String fName, int fSize) {
		System.out.println("set Font to " + fName);
	}

	public void drawString(java.lang.String s) {
		System.out.println("Draw the string \"" + s + "\"");
	}

	void setPenState(boolean up) {
		penIsUp = up;
		System.out.println("Pen Up is ["+penIsUp+"]");
	}
	void penUp() {
		setPenState(true);
	}
	void penDown() {
		setPenState(false);
	}
	void penColor(int c) {
		penColor = c;
		System.out.println("PenColor is ["+penColor+"]");
	}
}
//@@@@@@//
//quizzes/src/DoTestServlet.java
//@@@@@@//
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

/** A Java Servlet to administer the tests over the Web.
 *	Saves exam and status session object to avoid having to reload it, but also
 *		to keep the exam constant during a session!
 * @version $Id: DoTestServlet.java,v 1.11 2002/04/05 17:03:36 ian Exp $
 */
public class DoTestServlet extends HttpServlet {

	/** Where to find the exams du jour */
	protected static String DIRECTORY;
	/** The body color */
	protected final static String BGCOLOR = "white";

	/** Inner class to track the student's progress */
	class Progress {
		Exam exam;			// exam being taken
		boolean done;		// exam is finished.
		String category;	// name of exam, in effect
		int  curQuest;		// Question number working on, 0-origin
		int  correct;		// number gotten right on first try
	}

	public void init() {
		DIRECTORY = getServletContext().getInitParameter("quizzes.dir");
		if (DIRECTORY == null) {
			throw new IllegalArgumentException(
				"getInitParam(quizzes.dir) returns null");
		}
		log("Quizzes: DIRECTORY set to " + DIRECTORY);
	}

	/** Service is used to service each request. */
	public void service(HttpServletRequest request,
		HttpServletResponse response) throws IOException, ServletException {

		PrintWriter out = response.getWriter();
		HttpSession session;
		Progress progress;
		String reqCategory, reqSubject;

		// Set response type to HTML. Print the HTML header.
		response.setContentType("text/html");
		out.println("<HTML>");

		// Find the requested category
		reqCategory = request.getParameter("category");
		reqSubject  = request.getParameter("subject");	// unix or java

		// Request the user's session, creating it if new.
		session = request.getSession(true);
		if (session.isNew()) {
			log("<B>NEW SESSION</B>");
			progress = new Progress();
			progress.category = reqCategory;
			session.putValue("progress", progress);
		} else {
			progress = (Progress) session.getValue("progress");
		}

		if (reqCategory != null && progress.category != null && 
			!reqCategory.equals(progress.category)) {
			
			// CHANGE OF CATEGORIES
			log("<B>NEW PROGRESS CUZ " + 
				reqCategory + " != " +progress.category + "</B>");
			progress = new Progress();
			progress.category = reqCategory;
			session.putValue("progress", progress);
		}
		if (progress.exam == null) {
			XamDataAccessor ls = new XamDataAccessor();
			try {
				progress.exam = ls.load(DIRECTORY + reqSubject + "/" +
					progress.category + ".xam");
			} catch (IOException ex) {
				eHandler(out, ex, "We had some problems loading that exam!");
			} catch (NullPointerException ex) {
				eHandler(out, ex, "Hmmm, that exam file seems to be corrupt!");
			}
		}

		// Now that we have "exam", use it to get Title. 
		out.print("<TITLE>Questions on ");
			out.print(progress.exam.getCourseTitle()); out.println("</TITLE>");
		out.print("<BODY BGCOLOR=\""); out.print(BGCOLOR); out.println("\">");
		out.print("<H1>");
			out.print(progress.exam.getCourseTitle());
			out.println("</H1>");

		// Guard against reloading last page
		if (progress.done) {
			out.println("<HR><a href=\"/quizzes/\">Another Quiz?</a>");
			out.flush();
			return;
		}

		// Are we asking a question, or marking it?
		out.println("<P>");
		String answer =request.getParameter("answer");
		int theirAnswer = -1;
		if (answer != null) {
			// MARK IT.
			Q q = progress.exam.getQuestion(progress.curQuest);
			theirAnswer = Integer.parseInt(answer);
			if (theirAnswer == q.getAns()) {

				// WE HAVE A RIGHT ANSWER -- HURRAH!
				if (!q.tried) {
					out.println("<P><B>Right first try!</B>");
					progress.correct++;
				} else
					out.println("<P><B>Right. Knew you'd get it.</B>");
				q.tried = true;			// "Tried and true..."

				if (++progress.curQuest >= progress.exam.getNumQuestions()) {
					out.print("<P>END OF EXAM.");
					if (progress.correct == progress.curQuest) {
						out.println("<P><B>Awesome!</B> You got 100% right.");
					} else {
						out.print("You got ");
						out.print(progress.correct);
						out.print(" correct out of ");
						out.print(progress.curQuest);
						out.println(".");
					}
					out.println("<HR><a href=\"/quizzes/\">Another Quiz?</a>");

					// todo invalidate "progress" in case user retries 
					progress.done = true;

					// Return, so we don't try to print the next question!
					return;

				} else {
					out.print("Going on to next question");
					theirAnswer = -1;
				}
			} else {
				out.print("<B>Wrong answer</B>. Please try again.");
				q.tried = true;
			}
		}

		// Progress?
		out.print("<P>Question ");
		out.print(progress.curQuest+1);
		out.print(" of ");
		out.print(progress.exam.getNumQuestions());
		out.print(". ");
		if (progress.curQuest >= 2) {
			out.print(progress.correct);
			out.print(" correct out of ");
			out.print(progress.curQuest);
			out.print(" tried so far (");
			double pct = 100.0 * progress.correct  / progress.curQuest;
			out.print((int) pct);
			out.println("%).");
		}

		// Now generate a form for the next (or same) question
		out.print("<FORM ACTION=/quizzes/servlet/DoTestServlet METHOD=POST>");
		out.print("<INPUT TYPE=hidden NAME=category VALUE=");
			out.print(progress.category); out.println(">");
		out.println("<HR>");

		Q q = progress.exam.getQuestion(progress.curQuest);
		out.println(q.getQText());

		for (int j=0; j<q.getNumAnswers(); j++) {
				out.print("<BR><INPUT TYPE=radio NAME=answer VALUE=\"");
				out.print(j);
				out.print("\"");
				if (j==theirAnswer)
					out.print(" CHECKED");
				out.print(">");
				out.print(q.getAnsText(j));
				out.println("</INPUT>");
			}
		out.println("<HR>");

		out.println("<INPUT TYPE=SUBMIT VALUE=\"Mark it!\"");
		out.println("</FORM>");
		out.println("</HTML>");
		out.close();
	}

	void eHandler(PrintWriter out, Exception ex, String msg) {
		out.println("<H1>Error!</H1>");
		out.print("<B>");
		out.print(msg);
		out.println("</B>");
		out.println("<pre>");
		ex.printStackTrace(out);
		out.flush();
		out.close();
	}
}
//@@@@@@//
//quizzes/src/Exam.java
//@@@@@@//
import java.util.*;

/** TestEdit application model - information about one exam */
public class Exam extends Observable {

	/** the array of questions */
	private Vector questions;
	/** The number of questions this exam should have */
	private int numQuestions;

	/** Construct a new Exam */
	Exam() {
		questions = new Vector();
	}

	/** Install/replace the list of questions. */
	void setListData(Vector v) {
		for (int i=0; i<v.size(); i++)
			if (!(v.get(i) instanceof Q))
				throw new IllegalArgumentException(
					"setListData: must be a Vector of Q objects.");
		questions = v;
	}

	/** Export the questions. There MUST be a better way! */
	public Vector getListData() {
		return questions;
	}

	/** Add a question to the list. Construct and add its QView */
	void addQuestion(Q q) {
		questions.addElement(q);
	}

	Q getQuestion(int i) {
		return (Q)questions.elementAt(i);
	}

	/** The current course name */
	protected String crsName;

	public void setCourseTitle(String s) {
		crsName = s;
	}
	public String getCourseTitle() {
		return crsName;
	}

	/** The current course number */
	protected int crsNum;

	public void setCourseNumber(String s) {
		crsNum = Integer.parseInt(s);
	}
	public String getCourseNumber() {
		return Integer.toString(crsNum);
	}

	/** the current exam (a, b, or c) */
	protected char examName;

	public void setExamName(char c) {
		examName = c;
	}
	public char getExamName() {
		return examName;
	}

	/** the current exam version (A.1, etc) */
	protected String examVers;

	public void setExamVers(String s) {
		examVers = s;
	}
	public String getExamVers() {
		return examVers;
	}

	public int getNumQuestions() {
		return questions.size();
	}
}
//@@@@@@//
//quizzes/src/ExamInfo.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.io.*;
import java.util.*;

/** Pane for editing the Exam info. Instead of a full MVC paradigm,
 * we re-fetch the information whenever setVisible(true) is done,
 * and store the information whenever our Apply button is pushed.
 *
 * @author Ian F. Darwin, http://www.darwinsys.com/
 */
public class ExamInfo extends JPanel {
	/** The Data Model */
	TD theTD;
	/** The Exam part of it. */
	Exam theExam;
	/** Textfield for the Course Title */
	JTextField cTitle;
	/** Textfield for the Course Number */
	JTextField cNum;
	/** Textfield for the Exam Number */
	JTextField xNum;
	/** Textfield for the Course Version# */
	JTextField xVers;
	/** Textfield for the "Objectives" label */
	JTextField oLabel;
	/** Textfield for the Number of Questions */
	JTextField numQuestions;

	/** Construct an ExamInfo Dialog with a TD model */
	public ExamInfo(TD m) {
		// super("Exam Info");
		theTD = m;
		theExam = m.curX;

		// Container cp = getContentPane();	// in a Frame
		Container cp = this;				// in a Panel
		cp.setLayout(new GridLayout(0,2));

		cp.add(new JLabel("Course Title", JLabel.RIGHT));
		cp.add(cTitle = new JTextField("Coffee programming for Newbies Hands-On"));

		cp.add(new JLabel("Course Number", JLabel.RIGHT));
		cp.add(cNum = new JTextField("471"));
		cNum.setToolTipText("Number of this course");

		cp.add(new JLabel("Exam Number", JLabel.RIGHT));
		cp.add(xNum = new JTextField("A"));
		xNum.setToolTipText("Exam (A, B, or C)");

		cp.add(new JLabel("Exam Revision", JLabel.RIGHT));
		cp.add(xVers = new JTextField("D.1"));
		xVers.setToolTipText("Exam Version (A.1, ...)");

		cp.add(new JLabel("Objectives Label", JLabel.RIGHT));
		cp.add(oLabel = new JTextField(""));
		oLabel.setToolTipText("Chapter, Page, or Section reference");

		cp.add(new JLabel("Number of questions", JLabel.RIGHT));
		cp.add(numQuestions = new JTextField("99"));
		numQuestions.setToolTipText("Number of questions in this Exam");

		JButton b;
		cp.add(b = new JButton("Apply"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ce) {
				if (theTD == null)
					System.out.println("Changes would be applied");
				else {
					setValues();
				}
				// setVisible(false);
				// dispose();
			}
		});
		cp.add(b = new JButton("Cancel"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent ce) {
				System.out.println("No changes applied");
				// setVisible(false);
				// dispose();
			}
		});
		// pack();
	}

	/** Construct an ExamInfo Dialog with NO TD model */
	public ExamInfo() {
		this(null);
	}

	/** Whenever Apply is pushed, store the information back to the model. */
	protected void setValues() {
		theExam.setCourseTitle(cTitle.getText());
		theExam.setCourseNumber(cNum.getText());
		// XXX
	}

	/** Whenever we're displayed, update the information */
	public void setVisible(boolean vis) {
		if (vis && theTD!=null) {
			cTitle.setText(theExam.getCourseTitle());
			cNum.setText(theExam.getCourseNumber());
			// XXX
		}
		// super.setVisible(vis);
	}

	public static void main(String a[]) {
		Frame frm = new Frame("Testing ExamInfo");
		frm.add(new ExamInfo());
		frm.pack();
		frm.setVisible(true);
	}
}
//@@@@@@//
//quizzes/src/MyHelp.java
//@@@@@@//
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.io.*;

/*
 * Simple Help Frame based on JFC JEditorPane
 * May someday rewrite using JavaHelp API.
 */
public class MyHelp extends JFrame implements HyperlinkListener {
	/** The contentpane */
	protected Container cp;
	/** The editorpane */
	JEditorPane help;

	/* Construct a Help object. Just construct a JEditorPane
	 * with a URL, and it does all the help from there.
	 */
    public MyHelp() {
		super("Help Window");
		cp = getContentPane();
		getAccessibleContext().setAccessibleName("TestEdit Help Window");
		getAccessibleContext().setAccessibleDescription("A window for viewing TestEdit HELP, which is somewhat hyperlinked.");
	
		try {
			URL url = new URL("file:///"+ System.getProperty("user.dir")+
				"/help/index.html");
			// Only create the window once.
			if (help == null) {
				// System.out.println("Creat-ing help window for " + url);
				help = new JEditorPane(url);
				// System.out.println("Done!");
				help.setEditable(false);
				help.addHyperlinkListener(this);
				JScrollPane scroller = new JScrollPane();
				scroller.setBorder(BorderFactory.createTitledBorder("TestEdit Help"));
				scroller.getViewport().add(help);
				cp.add(BorderLayout.CENTER, scroller);
				addWindowListener(new WindowAdapter() {
					public void windowClosing(WindowEvent e) {
						MyHelp.this.setVisible(false);
						MyHelp.this.dispose();
					}
				});
				setSize(500,400);
			} else {
				System.out.println("Re-using help window!");
			}
		} catch (MalformedURLException e) {
			System.out.println("Malformed URL: " + e);
		} catch (IOException e) {
			System.out.println("IOException: " + e);
		}
    }

    /**
     * Notification of a change relative to a hyperlink. 
	 * From: java.swing.event.HyperlinkListener
     */
    public void hyperlinkUpdate(HyperlinkEvent e) {
		if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
			URL target = e.getURL();
			// System.out.println("linkto: " + target);

			// Get the help panel's cursor and the wait cursor
			Cursor oldCursor = help.getCursor();
			Cursor waitCursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);
			help.setCursor(waitCursor);

			// Now arrange for the page to get loaded asynchronously,
			// and the cursor to be set back to what it was.
			SwingUtilities.invokeLater(new PageLoader(target, oldCursor));
		}
	}

    /**
     * Inner class that loads a URL synchronously into the help panel.
	 * Loads it later than the request so that a cursor change
     * can be done at the very end.
	 * @author BORROWED FROM SUN'S SWING DEMO, UNTIL JAVAHELP AVAILABLE
     */
    class PageLoader implements Runnable {
		URL url;
		Cursor cursor;
	
		PageLoader(URL u, Cursor c) {
			url = u;
			cursor = c;
		}

        public void run() {
			// System.out.println("PageLoader: u=" + url);
			if (url == null) {
				// restore the original cursor
				help.setCursor(cursor);

				// PENDING(prinz) remove this hack when 
				// automatic validation is activated.
				Container parent = help.getParent();
				parent.repaint();
			} else {
				Document doc = help.getDocument();
				try {
					help.setPage(url);
				} catch (Exception ioe) {
					help.setDocument(doc);
					getToolkit().beep();
				} finally {
					// schedule the cursor to revert after
					// the paint has happended.
					url = null;
					SwingUtilities.invokeLater(this);
				}
			}
		}
    }

	/** Test case */
	public static void main(String a[]) {
		new MyHelp().setVisible(true);
	}
}
//@@@@@@//
//quizzes/src/PrintDraft.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import java.util.*;

public class PrintDraft {
	JFrame frm;
	Exam thisExam;
	PrintJob pjob;

	public PrintDraft(JFrame f, Exam m) {
		frm = f;
		thisExam = m;
	}

	public PrintDraft(Exam m) {
		this(null, m);
	}

	public void print() {

		Graphics pg = null;	// refers to current page

		System.out.println("Getting PrintJob");
		pjob = Toolkit.getDefaultToolkit().getPrintJob(frm,
			"Draft Printing", (Properties)null);
		if (pjob == null)          // User cancelled??
			return;

		// Just get and show dimenssions; should use in x,y calcs.
		Dimension pDim = pjob.getPageDimension();
		int pRes = pjob.getPageResolution();
		System.out.println("Page size " + pDim + "; Res " + pRes);

		// XXX RESTRUCTURE -- pass each question/answer string, maybe with
		// font.

		// Print up to "np" number of pages
		for (int pgNum=1; pgNum<=1; pgNum++) {
			System.out.println("Starting page # " + pgNum);
			pg = pjob.getGraphics();
			if (pg == null) 	// ??
				return;
			pg.setColor(Color.black);
			pg.setFont(new Font("Times", Font.PLAIN, 12));
			pg.drawString("Hello World", 100, 100);
			pg.drawString("Page" + pgNum, 300, 300);
			pg.dispose(); // flush page
			System.out.println("All done with page " + pgNum);
		}
		pjob.end();	// total end of print job.
		pjob = null;	// avoid redundant calls to pjob.end()
		return;
	}
}
//@@@@@@//
//quizzes/src/Q.java
//@@@@@@//
/**
 * A Q is one Question used in TestEdit.
 */
public class Q extends java.util.Observable {
	public static final String labels[] = {
			"A", "B", "C", "D"
	};
	/** The text of the question */
	String   question;
	/** The text of the alternative answers. */
	String[] ans;
	/** The number of the answer that is correct. Zero-based. */
	int      correct;
	/** The number of the chapter that this question relates to */
	int	objective;
	/** A Boolean for use by Interactive Programs */
	boolean tried = false;

	public String toString() {
		return "Q[" + question + "]";
	}

	/** construct a Q given the # of answers allowed. */
	Q(int n) {
		if (n<0 || n>10)
			throw new IllegalArgumentException("Q.init: Count " + n + " invalid");
		question = "";
		ans = new String[n];
		correct = objective = -1;
	}
	/** Get the number of questions.
	 * @deprecated See getNumAnswers.
	 */
	public int getCount() {
		return getNumAnswers();
	}
	/** Get the number of questions. */
	public int getNumAnswers() {
		return ans.length;
	}
	public int getAns() {
		return correct;
	}
	public void setAns(int i, boolean notify) {
		if (i<0 || i>=getCount())
			throw new IllegalArgumentException("Q.setAns: Count " + i + " invalid");
		correct = i;
		setChanged();
		// if (notify)
		// 	notifyObservers(new QChangeEvent(this,
		// 		QChangeEvent.CHANGE_ANSWER_NUMBER, i, null));
	}

	void setQText(String s, boolean notify) {
		question = s;
		setChanged();
		// if (notify)
		// 	notifyObservers(new QChangeEvent(this,
		// 		QChangeEvent.CHANGE_QUESTION_TEXT, -1, s));
	}
	String getQText() {
		return question;
	}

	void setAnsText(int i, String s, boolean notify) {
		if (i<0 || i>=getCount())
			throw new IllegalArgumentException("Q.setAnsText: Count " + i + " invalid");
		ans[i] = s;
		setChanged();
		// if (notify)
		// 	notifyObservers(new QChangeEvent(this,
		// 		QChangeEvent.CHANGE_ANSWER_TEXT, i, s));
	}
	String getAnsText(int i) {
		return ans[i];
	}

	void setObjective(int i) {
		objective = i;
	}
	int getObjective() {
		return objective;
	}
}
//@@@@@@//
//quizzes/src/QChangeEvent.java
//@@@@@@//
/** A Q sends a QChangeEvent to its observers when its question is changed.
 */
public class QChangeEvent extends java.awt.AWTEvent {
	public static final int CHANGE_QUESTION_TEXT = RESERVED_ID_MAX+1 + 0;
	public static final int CHANGE_ANSWER_NUMBER = RESERVED_ID_MAX+1 + 1;
	public static final int CHANGE_ANSWER_TEXT   = RESERVED_ID_MAX+1 + 2;
	private int ansNumber = -1;	// only for CHANGE_ANSWER_TEXT
	private String newText = null;
	Q q;

	/** Construct a given QChangeEvent */
	public QChangeEvent(Q qq, int type, int aNum, String txt) {
		super(qq, type);
		q = qq;
		ansNumber = aNum;
		newText = txt;
	}
	public int getAnsNumber() {
		return ansNumber;
	}
	public String getText() {
		return newText;
	}

	public String toString() {
		return "QChangeEvent[Question" + q + "; type " + fmt(getID()) + "]";
	}

	private String fmt(int type) {
		switch(type) {
		case CHANGE_QUESTION_TEXT:
			return "CHANGE_QUESTION_TEXT";
		case CHANGE_ANSWER_NUMBER:
			return "CHANGE_ANSWER_NUMBER";
		case CHANGE_ANSWER_TEXT:
			return "CHANGE_ANSWER_TEXT";
		default:
			return "UNKNOWN CHANGE EVENT TYPE!!";
		}
	}
}
//@@@@@@//
//quizzes/src/QView.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.util.*;

/** The View/Controller for ONE QUESTION in the TestEdit program.
 * This is normally used in e.g., a TabPanel, to show one question.
 * It would be lower overhead, but not true MVC, to have one of these
 * and just load its contents when the question number changes.
 */
public class QView extends JPanel implements Observer {
	/** The question's text */
	protected JTextArea quesText;
	/** The question as a Q object */
	protected Q q;
	/** The choices - CheckBox */
	protected JCheckBox cb[];
	/** A ButtonGroup to make cb[] act as a radiobutton */
	protected ButtonGroup cbg;
	/** The choices - answer texts */
	protected JTextArea tf[];
	/** Chapter Number Chooser */
	protected JComponent cnc;

	/** Construct a QView, given the Q it is to maintain */
	QView(Q q) {
		this.q = q;
		setupGUI();

		loadGUI();
	}

	private void setupGUI() {
		GridBagLayout gbl = new GridBagLayout();
		setLayout(gbl);
		
		// Top Left, and wide: the question text
		GridBagConstraints gbcQuesText = new GridBagConstraints();
		gbcQuesText.fill = GridBagConstraints.BOTH;
		gbcQuesText.gridx = 0;
		gbcQuesText.gridwidth = 5;
		gbcQuesText.weightx = 1.0;
		gbcQuesText.weighty = 1.0;

		// Top Right Left, and narrow: for the Chapter Number label
		GridBagConstraints gbcLabel = new GridBagConstraints();
		gbcLabel.fill = GridBagConstraints.BOTH;
		gbcLabel.gridwidth = GridBagConstraints.RELATIVE;
		gbcLabel.gridx = 5;
		gbcLabel.weighty = 1.0;

		// Top Right Right, and narrow: for the Chapter Number chooser
		GridBagConstraints gbcChoice = new GridBagConstraints();
		gbcChoice.fill = GridBagConstraints.BOTH;
		gbcChoice.gridwidth = GridBagConstraints.REMAINDER;
		gbcChoice.gridx = 7;
		gbcChoice.weighty = 1.0;

		// Left and narrow: for the CheckBoxes
		GridBagConstraints gbcCheckBox = new GridBagConstraints();
		gbcCheckBox.fill = GridBagConstraints.BOTH;
		gbcCheckBox.gridwidth = 1;
		gbcCheckBox.gridx = 0;
		gbcCheckBox.weighty = 1.0;
		gbcCheckBox.anchor = GridBagConstraints.EAST;

		// Right and wide: for the text question
		GridBagConstraints gbcAnsText = new GridBagConstraints();
		gbcAnsText.fill = GridBagConstraints.BOTH;
		gbcAnsText.gridwidth = GridBagConstraints.REMAINDER;
		gbcAnsText.gridx = GridBagConstraints.RELATIVE;
		gbcAnsText.weightx = 1.0;
		gbcAnsText.weighty = 1.0;

		// Now add stuff, starting with the question text
		quesText = new JTextArea(3,80);
		quesText.setLineWrap(true);
		gbl.setConstraints(quesText, gbcQuesText);
		add(quesText);

		JLabel cnl = new JLabel("Chapter", JLabel.RIGHT);
		gbl.setConstraints(cnl, gbcLabel);
		add(cnl);

		cnc = new JTextField("    0");
		gbl.setConstraints(cnc, gbcChoice);
		add(cnc);

		quesText.getDocument().addDocumentListener(new QListener(q, -1, quesText));
		quesText.setBackground(Color.pink);

		cbg = new ButtonGroup();
		cb = new JCheckBox[q.getCount()];
		tf = new JTextArea[q.getCount()];

		for (int i=0; i<q.getCount(); i++) {
			cb[i] = new JCheckBox(Q.labels[i], false);
			cb[i].setBackground(Color.red);
			gbl.setConstraints(cb[i], gbcCheckBox);
			add(cb[i]);
			cbg.add(cb[i]);
			tf[i] = new JTextArea(2,80);
			tf[i].setBackground(Color.green);
			add(tf[i]);
			gbl.setConstraints(tf[i], gbcAnsText);
			add(tf[i]);
			tf[i].setLineWrap(true);
			tf[i].getDocument().addDocumentListener(new QListener(q, i, tf[i]));
		}
		q.addObserver(this);
	}

	private void loadGUI() {
		quesText.setText(q.getQText());
		int theAnswer = q.getAns();
		if (theAnswer >= 0) {
			cb[theAnswer].setSelected(true);
		}
		// int nQs = q.getNum();
		// tf[q.getAns()].setText(ch.getText());
	}

	/** update is called from the model when its data changes. */
	public void update(Observable q, Object change) {
		// System.out.println("UPDATE: " + q + "-->" + change);
		QChangeEvent ch = (QChangeEvent)change;
		switch(ch.getID()) {
		case QChangeEvent.CHANGE_QUESTION_TEXT:
			quesText.setText(ch.getText());
			break;
		case QChangeEvent.CHANGE_ANSWER_NUMBER:
			cb[ch.getAnsNumber()].setSelected(true);
			break;
		case QChangeEvent.CHANGE_ANSWER_TEXT  :
			tf[ch.getAnsNumber()].setText(ch.getText());
			break;
		default:
			throw new IllegalArgumentException("QVIEW.update: " + change);
		}
	}

	/** A QListener is the text changed listener for one textArea;
	 * it updates one String in the Q object.
	 */
	class QListener implements DocumentListener {
		Q q;
		int whichAns;
		JTextArea textA;
		QListener(Q q, int i, JTextArea tf) {
			this.q = q;
			whichAns = i;
			textA = tf;
		}
		public void changedUpdate(DocumentEvent de) {
			textValueChanged();
		}
		public void insertUpdate(DocumentEvent de) {
			textValueChanged();
		}
		public void removeUpdate(DocumentEvent de) {
			textValueChanged();
		}
		private void textValueChanged() {
			// System.out.println("text changed in " + textA);
			if (whichAns < 0)
				q.setQText(textA.getText(), false);
			else
				q.setAnsText(whichAns, textA.getText(), false);
		}
	}
}
//@@@@@@//
//quizzes/src/QViewTest.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.util.*;

/** Simple test case for QView */
public class QViewTest {
	public static void main(String a[]) {
		JFrame f = new JFrame("QView Test");

		JTabbedPane cm = new JTabbedPane();
		f.setContentPane(cm);

		Q q = new Q(4);
		QView qv = new QView(q);
		cm.addTab("0", qv);
		q.setQText("To be or not to be, that is the question", true);
		q.setAnsText(0, "Hello world", true);
		q.setAnsText(1, "Goodbye cruel world", true);
		q.setAnsText(2, "Settle it with a bare bodkin, princikins", true);
		q.setAnsText(3, "42", true);
		q.setAns(2, false);

		q = new Q(4);
		q.setQText("Whether 'tis nobler in the mind to suffer the slings and arrows of outrageous fortune,", true);
		q.setAnsText(0, "Hello world", true);
		q.setAnsText(1, "Goodbye cruel world", true);
		q.setAnsText(2, "Settle it with a bare bodkin, princikins", true);
		q.setAnsText(3, "42", true);
		q.setAns(3, false);
		qv = new QView(q);
		cm.addTab("1", qv);

		f.setSize(600, 400);
		f.setLocation(100, 100);
		f.setVisible(true);
		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent we) {
				System.exit(0);
			}
		});
	}
}
//@@@@@@//
//quizzes/src/Splash.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;

/**
 * Generalized Splash Screen, for applications (not Applets)
 * The application that creates me should start a thread that
 * sleeps a while, then calls my done() method.
 */
public class Splash extends JFrame {
	/** The name of the Image */
	protected String imName;
	/** The Image used to paint the screen */
	protected Image im;
	/** MediaTracker to load the image for us. */
	MediaTracker mt;

	/** Construct a Splash screen with the given image */
	Splash(JFrame parent, String imgName) {
		super("TestEdit initializing");
		im = Toolkit.getDefaultToolkit().getImage(imgName);
		mt = new MediaTracker(this);
		mt.addImage(im, 0);
		try {
			mt.waitForID(0);
		} catch(InterruptedException e) {
			System.err.println("Wonkey! INTR in waitForID!");
			return;
		}
		if (mt.isErrorID(0)) {
			System.err.println("Couldn't load Splash Image " +
				imgName);
			return;
		}
		getContentPane().add(new SplImage(im));
		//add(new SplImage(im));
		pack();

		addMouseListener(new MouseAdapter() {
			/** Let the user kill the Splash Screen anytime they want. */
			public void mouseClicked(MouseEvent e) {
				done();
			}
		});
	}

	/** Shut down this window.  Called from this class' mouseClicked(),
	 * but also from the main application.
	 */
	public void done() {
		setVisible(false);
		dispose();
	}
	
	/** The obligatory tiny test program. Normal use requires
	 * a thread in an AWT application; see JabaDex for example.
	 */
	public static void main(String a[]) {
		//(new Splash("Testing...", "JabaSpl.gif")).setVisible(true);
		JFrame frm = new JFrame("Testing");
		frm.setVisible(true);
		(new Splash(frm, "JabaSpl.gif")).setVisible(true);
	}
}

class SplImage extends Component {
	/** The Image */
	Image im;
	/** The width and height of the image */
	protected int width = 300, height = 250;

	/** Construct an SplImage. 
	 */
	SplImage(Image image) {
		im = image;
		width = im.getWidth(this);
		height = im.getHeight(this);
	}

	/** Compute our best size. Assumes the Image has been *fully
	 * loaded*, as via a MediaTracker's .waitFor() method.
	 */
	public Dimension getPreferredSize() {
		return new Dimension(width, height);
	}

	/** Called by AWT to paint the screen. 
	 */
	public void paint(Graphics g) {
		if (im == null) {
			g.setColor(Color.red);
			g.fillRect(0, 0, width, height);
		} else {
			g.drawImage(im, 0, 0, this);
		}
	}
}
//@@@@@@//
//quizzes/src/TD.java
//@@@@@@//
import java.awt.FileDialog;
import java.io.*;
import java.util.*;

/** TestEdit application model */
public class TD extends Observable {
	/** The name of this program for printing purposes */
	public final static String PROGRAM = "TestEdit";
	/** The current datafile */
	String curFileName;
	/** The main view/control */
	TV viewctl;
	/** The current XamDataAccessor object */
	XamDataAccessor ls;

	Exam curX;

	/** "main program" method - just for testing. */
	public static void main(String av[]) {
		// create a TD object
		TD td = new TD();
		td.loadFile("toy.xam");
	}

	protected void setViewCtl(TV tv) {
		viewctl = tv;
	}

	/** Construct the data model */
	public TD() {
		super();

		doNew();
	}

	protected void doNew() {
		curX = new Exam();
	}

	/** Print the current exam */
	public void doPrint() {
		new PrintDraft(curX).print();
	}

	public void doStats() {
		TStat t = new TStat();
		t.nq = curX.getListData().size();
		t.n = new int[4];
		for (int i=0; i<t.nq; i++) {
			Q tq = curX.getQuestion(i);
			if (tq.question == null || tq.question.length() == 0) {
				++t.incomplete;
				continue;
			}
			t.complete++;
			if (tq.correct == 0) {
				++t.noAnswer;
				continue;
			}
			int ans = tq.correct;
			if (ans >= 0)
				t.n[ans]++;
			if (tq.objective < 0) {
				++t.noObjective;
				continue;
			}
		}
		// System.out.println("TStats t = " + t);
		viewctl.showStats(t);
	}

	public void loadFile(String fn) {
		if (ls == null)
			ls = new XamDataAccessor();
		String newFN;
		if (fn == null) {
			viewctl.fc.setVisible(true);	// blocking dialog
			if ((newFN = ((FileDialog)viewctl.fc).getFile()) == null)
				return;
			fn = newFN;
		}
		try {
			curX = ls.load(new BufferedReader(new FileReader(curFileName=fn)));
			viewctl.installQVs();
		} catch (FileNotFoundException e) {
			System.err.println("Can't find file " + curFileName);
		} catch (IOException e) {
			System.err.println("IO Error in processing " + curFileName + ": " + e);
		} catch (Exception e) {
			System.err.println("Error in data file " + curFileName + "\n");
			e.printStackTrace();
		}
    }

	/** Save the current file */
	public synchronized void saveFile() {
		saveFile(curFileName);
	}

	/** Save the current exam into a file */
	public synchronized void saveFile(String fName) {
		// System.out.println("Saving file...");
		try {
			ls.save(new PrintWriter(new FileWriter(fName), true), curX);
		} catch (IOException e) {
			System.err.println("I/O error " + e);
		}
		// System.out.println("Save done");
	}

	/** Save the current file AS HTML. This is just an interface to
	 * the XamDataAccessorHTML object, and should be done away with, once
	 * we hava a Properties listing all the different XamDataAccessor subclasses!
	 */
	public synchronized void saveHTML(String fName) {
		// System.out.println("Saving...");
		XamDataAccessorHTML hs = new XamDataAccessorHTML();
		try {
			hs.save(new PrintWriter(new FileWriter(fName), true), curX);
		} catch (IOException e) {
			System.err.println("I/O error " + e);
		}
		// System.out.println("Save done");
	}

	/** Exit method, just calls System.exit(). Synchronized to prevent
	 * calling System.exit() during a saveFile(), which would be very bad :-)
	 */
	public synchronized void exit(int n) {
		System.exit(n);
	}

	protected void mkTitle() {
		String newt = curX.crsNum + " Exam" +
			curX.examName + " " + curX.examVers + " " + curX.crsName;
		viewctl.setTitle(newt);
	}
}
//@@@@@@//
//quizzes/src/TestEdit.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/**
 * Main Program Application Driver for TestEdit
 */
public class TestEdit {
	/** The Data Model. */
	TD theTD;
	/** The Frame, for the View to reside in */
	JFrame frm;
	/** A toolbar for editing icons */
	JToolBar toolBar;
	/** The View, and the Controllers. */
	TV vc;
	/** The splash screen */
	Splash splat = null;

	/** Main program, just to start things off. */
	public static void main(String argv[]) {
		new TestEdit(argv);
	}

	/** Construct our Main Program */
	TestEdit(String args[]) {

		// Try to make us look like a MS-Windows application
		try {
			UIManager.setLookAndFeel(
				"com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
		} catch (Exception e) {
			// No error reporting is required.
		}

		// Construct the Frame
		// System.out.println("Constructing a JFrame...");
		frm = new JFrame("TestEdit");
		Container cp = frm.getContentPane();

		// Top is a Toolbar
		toolBar = new JToolBar();
		toolBar.setFloatable(false);
		toolBar.getAccessibleContext().setAccessibleName("File Toolbar");
		cp.add(BorderLayout.NORTH, toolBar);

		JButton b;
		b = TV.addTool(toolBar, "New");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (theTD != null)
					theTD.doNew();
			}
		});
		b = TV.addTool(toolBar, "Open");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (theTD != null)
					theTD.loadFile(null);
			}
		});
		b = TV.addTool(toolBar, "Save");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (theTD != null)
					theTD.saveFile();
			}
		});
		b = TV.addTool(toolBar, "Print");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (theTD != null)
					theTD.doPrint();
			}
		});


		// Splash screen.
		splat = new Splash(frm, "TestEditSpl.gif");
		TV.centre(splat);
		splat.setVisible(true);

		// To the JFrame, add a componentListener that:
		//	1) removes itself, so this all only happens once.
		//	2) kills the splash screen when the main window appears;
		//	3) nulls the Splash object, so it can be GC'd.
		frm.addComponentListener(new ComponentAdapter() {
			public void componentShown(ComponentEvent e) {
				frm.removeComponentListener(this);
				splat.done();
				splat = null;
			}
		});

		// Construct the data model
		System.out.println("Making a TD (data model)...");
		theTD = new TD();

		// Build the Exam Info dialog and add it in.
		// Stick it in a Panel so it's not the full size of the window.
		ExamInfo exInfo = new ExamInfo(theTD);
		JPanel exInfoPanel = new JPanel();
		exInfoPanel.add(exInfo);

		// Construct the View (GUI + Controller): TVM extends TV, adds Menus.
		System.out.println("Making a ViewCtl...");
		vc = new TVM(frm, theTD);

		System.out.println("Inter-connecting the two");
		theTD.setViewCtl(vc);

		// Set up the mainpanel as a JTabbedPane, adding the ExamInfo
		// panel and the main ViewCtrl in as the only two tabs in it.
		// When done, remember to add it to the main window!
		JTabbedPane mainPane = new JTabbedPane();
		mainPane.addTab("Exam Info", exInfoPanel);
		//mainPane.setSelectedComponent(exInfoPanel);
		mainPane.addTab("Questions", vc);
		mainPane.setSelectedComponent(vc);
		cp.add(BorderLayout.CENTER, mainPane);

		// Tell the Frame what to do on CLOSE actions
        frm.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				// if unsavedChanges()
				//	prompt to save;
				theTD.exit(0);
			}
		});

		// Load the default datafile XXX make variable, remember last filename
		System.out.println("Loading your file...");
		if (args.length == 0)
			theTD.loadFile(null);
		else
			theTD.loadFile(args[0]);

		// Resize the main window, and make the Frame appear.
		System.out.println("Sizing and Showing your main window...");
		frm.pack();
		//frm.setSize(600, 500);
		TV.centre(frm);
		frm.setVisible(true);
	}
}
//@@@@@@//
//quizzes/src/TStat.java
//@@@@@@//
public class TStat {
	int nq;
	int n[];
	int complete;
	int incomplete;
	int noAnswer;
	int noObjective;

	public String toString() {
		StringBuffer sb = 
			new StringBuffer("TestEdit Exam Statistics:            \n");
		sb.append("Number of questions: ");
		sb.append(nq);
		sb.append("\n");
		for (int i=0; i<n.length; i++) {
			sb.append("Number of ");
			sb.append((char)(i + 'A'));
			sb.append(" answers = ");
			sb.append(n[i]);
			sb.append("\n");
		}
		if (incomplete > 0) {
			sb.append("Warning: ");
			sb.append(incomplete);
			sb.append(" questions incomplete!\n");
		}
		if (noAnswer > 0) {
			sb.append("Warning: ");
			sb.append(noAnswer);
			sb.append(" questions have no answer!\n");
		}
		if (noObjective > 0) {
			sb.append("Warning: ");
			sb.append(noAnswer);
			sb.append(" questions have no Objective!\n");
		}
		return sb.toString();
	}
}
//@@@@@@//
//quizzes/src/TV.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.io.*;
import java.util.*;

/** TV - Main GUI View of one Exam. Has a JToolbar and a JPanel managed
 * by a CardLayout to show one QView at a time.
 */
public class TV extends JPanel {
	/** The data model */
	TD theTD;
	/** The Frame above us */
	JFrame frm;
	/** A toolbar for editing icons */
	JToolBar toolBar;
	/** A cardLayout for the many questions */
	CardLayout myCardLayout;
	/** A number choice entry */
	JTextField numTF;
	/** A number chooser. */
	JSlider numSlider;
	/** A panel to hold all the qview's, managed by myCardLayout */
	JPanel questionsPanel;
	/** The obligatory file chooser */
	FileDialog fc;
	/** The data */
	ExamInfo xinfo;

	/** Construct the TV object - that is, the main GUI for the program */
	public TV(JFrame f, TD mod) {
		super();
		frm = f;
		theTD = mod;
		JButton b; 

		// Build the GUI

		toolBar = new JToolBar();
		toolBar.setFloatable(false);
		toolBar.getAccessibleContext().setAccessibleName("File Toolbar");
		toolBar.addSeparator();
		b = addTool(toolBar, "Cut");
		b = addTool(toolBar, "Copy");
		b = addTool(toolBar, "Paste");
		toolBar.addSeparator();
		toolBar.putClientProperty( "JToolBar.isRollover", Boolean.FALSE );
		
		// The Slider
		numSlider= new JSlider(JSlider.HORIZONTAL, 1, 40, 1);
		numSlider.setPaintTicks(true);
		numSlider.setPaintLabels(false);
		numSlider.setMajorTickSpacing(10);
		numSlider.setMinorTickSpacing( 2);
		numSlider.setExtent(1);
		numSlider.addChangeListener(new ChangeListener() {
			public void stateChanged(ChangeEvent ce) {
				// System.out.println("CHANGE: " + ce);
				setQNumber(((JSlider)(ce.getSource())).getValue());
			}
		});
		numSlider.setToolTipText("Slide to select question by number");
		toolBar.add(numSlider);

		// The Question# textfield
		toolBar.add(numTF = new JTextField("01"));
		numTF.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				String num = ((JTextField)e.getSource()).getText();
				int n = Integer.parseInt(num.trim());
				setQNumber(n);
			}
		});
		numTF.setToolTipText("Type number to select question by number");

		// The First Button
		b = addTool(toolBar, "First");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				setQNumber(1);
			}
		});

		// The Previous Button
		b = addTool(toolBar, "Previous");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (getQNumber() <= 1)
					return;
				setQNumber(getQNumber() - 1);
			}
		});

		// The Next Button
		b = addTool(toolBar, "Next");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				if (getQNumber() >= getNumQuestions())
					return;
				setQNumber(getQNumber() + 1);
			}
		});
  
		// The "Last" Button
		b = addTool(toolBar, "Last");
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				setQNumber(getNumQuestions());
			}
		});
  
		add(BorderLayout.NORTH, toolBar); 

		// Rest is a panel to hold the questions, one at a time.
		questionsPanel = new JPanel();
		questionsPanel.setLayout(myCardLayout = new CardLayout());

		add(BorderLayout.SOUTH, questionsPanel);

		fc = new FileDialog(frm);
		fc.setFilenameFilter(new FilenameFilter() {
			public boolean accept(File ff, String fname) {
				// System.out.println("accept("+fname+")");
				// XXX TODO list of extentions, from properties.
				return fname.endsWith(".xam");
			}
		});
		TV.centre(fc);
	}

	/** Simple convenience routine for adding a button/icon to a Toolbar */
    public static JButton addTool(JToolBar toolBar, String name) {
		JButton b; 
		b = new JButton(new ImageIcon("images/" + name + ".gif",name));
		toolBar.add(b);
		b.setToolTipText(name);
		b.setMargin(new Insets(0,0,0,0));
		b.getAccessibleContext().setAccessibleName(name);
		return b;
    }

	/** Set the maximum number of questions */
	public void setNumQuestions(int i) {
		numSlider.setMaximum(i);
	}

	/** Connect the vector of QV's into the main View */
	public void installQVs() {
		Exam thisExam = theTD.curX;
		Vector qv = thisExam.getListData();
		for (int i=0; i<qv.size(); i++) {
			// Use question number (1-origin) as string name.
			// System.out.println("Add question " +i +" to " + questionsPanel);
			questionsPanel.add(Integer.toString(i+1),
				new QView((Q)qv.elementAt(i)));
		}
		myCardLayout.first(questionsPanel);
	}

	/** Change the view to display a given question number (1-origin) */
	protected void setQNumber(int nn) {
		String userShowNumber = Integer.toString(nn);

		System.out.println("setQNumber(" + userShowNumber + ");");

		// notify the model
		//	TODO -- if necessary!

		// update the view
		numTF.setText(userShowNumber);
		numSlider.setValue(nn);

		// show the right question
		myCardLayout.show(questionsPanel, userShowNumber);
	}

	/** Return the currently selected number */
	protected int getQNumber() {
		return numSlider.getValue();
	}

	/** Return the number of questions */
	protected int getNumQuestions() {
		return theTD.curX.getNumQuestions();
	}

	protected void showStats(TStat t) {
		JOptionPane.showMessageDialog(frm, t.toString());
	}

	public void setTitle(String s) {
		frm.setTitle(s);
	}
		
	/** Centre a Window on the screen */
	public static void centre(Window w) {
		Dimension us = w.getSize(), 
			them = Toolkit.getDefaultToolkit().getScreenSize();
		int newX = (them.width - us.width) / 2;
		int newY = (them.height- us.height)/ 2;
		w.setLocation(newX, newY);
	}

	/** Pure guesswork */
	public Dimension getPreferredSize() {
		return new Dimension(500, 400);
	}
}
//@@@@@@//
//quizzes/src/TVM.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.io.*;
import java.util.*;

/** TestEdit View JMenu for application */
public class TVM extends TV {
	JMenuBar mb;
	JMenu fm, em, vm, om, hm;	// File, Edit, View, Options, Help
	JCheckBoxMenuItem cb;	// Option that can be on or off.

	/** Construct the object including its GUI */
	public TVM(JFrame f, TD mod) {
		super(f, mod);

		// Set up the JMenu hierarchy
		JMenuItem mi;
		mb = new JMenuBar();
		frm.setJMenuBar(mb);		// Frame implements JMenuContainer

		// The File JMenu...
		fm = new JMenu("File");
			fm.add(mi = new JMenuItem("Open...", 'O'));
			mi.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
					theTD.loadFile(null);
				}
			});
			fm.add(mi = new JMenuItem("New..."));
			mi.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
					theTD.doNew();
				}
			});
			fm.add(mi = new JMenuItem("Save", 'S'));
			mi.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
					theTD.saveFile();
				}
			});
			fm.add(mi = new JMenuItem("Save As..."));
			mi.setEnabled(false);
			fm.add(mi = new JMenuItem("Close", 'W'));
			mi.setEnabled(false);
			fm.addSeparator();
			fm.add(mi = new JMenuItem("Export to RTF..."));
			mi.setEnabled(false);
			fm.add(mi = new JMenuItem("Export to Sylvan Prometric..."));
			mi.setEnabled(false);
			fm.add(mi = new JMenuItem("Export to HTML..."));
			mi.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
					theTD.saveHTML("test.html");
				}
			});
			fm.addSeparator();
			fm.add(mi = new JMenuItem("Print draft", 'P'));
			mi.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
					theTD.doPrint();
				}
			});
			fm.add(mi = new JMenuItem("Print Student copy"));
			mi.setEnabled(false);
			fm.addSeparator();
			fm.add(mi = new JMenuItem("Exit"));
			mi.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					theTD.exit(0);
				}
			});
		mb.add(fm);

		// The Edit JMenu...
		em = new JMenu("Edit");
			em.add(mi = new JMenuItem("Find...", 'F'));
			em.addSeparator();
			em.add(mi = new JMenuItem("Copy Entire Question"));
			mi.setEnabled(false);
			em.add(mi = new JMenuItem("Cut Entire Question"));
			mi.setEnabled(false);
			em.add(mi = new JMenuItem("Paste Question"));
			mi.setEnabled(false);
			em.addSeparator();
			em.add(mi = new JMenuItem("Preferences"));
			mi.setEnabled(false);
		mb.add(em);

		// The View JMenu...
		vm = new JMenu("View");
			vm.add(mi = new JMenuItem("Exam Information..."));
			mi.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					// TD.mainPane.show("Exam Info");
				}
			});
			vm.add(mi = new JMenuItem("Statistics..."));
			mi.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
					theTD.doStats();	// calls us back at showStats();
				}
			});
			vm.addSeparator();
			vm.add(mi = new JMenuItem("Windows Look and Feel"));
			mi.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent wlfe) {
					try {
						UIManager.setLookAndFeel(
						"com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
						SwingUtilities.updateComponentTreeUI(frm);
					} catch (Exception e) {
						JOptionPane.showMessageDialog(null,
							"setLookAndFeel didn't work: " + e,
							"UI Failure",
							JOptionPane.INFORMATION_MESSAGE);
					}
				}
			});
			vm.add(mi = new JMenuItem("Java Look and Feel"));
			mi.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent jlfe) {
					try {
						UIManager.setLookAndFeel(
						"com.sun.java.swing.plaf.metal.MetalLookAndFeel");
						SwingUtilities.updateComponentTreeUI(frm);
					} catch (Exception e) {
						JOptionPane.showMessageDialog(null,
							"setLookAndFeel didn't work: " + e,
							"UI Failure",
							JOptionPane.INFORMATION_MESSAGE);
					}
				}
			});
		mb.add(vm);

		// The Options JMenu...
		om = new JMenu("Options");
			cb = new JCheckBoxMenuItem("AutoSave");
			cb.setState(true);
			om.add(cb);
		mb.add(om);

		// The Help JMenu...
		hm = new JMenu("Help");
			hm.add(mi = new JMenuItem("About"));
			mi.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
				JOptionPane.showMessageDialog(frm, 
		"TestEdit - an Exam Question Editor\n" +
		"Copyright (c) 1995-1997 by Ian F. Darwin, http://www.darwinsys.com/.\n" +
		"Information available from http://www.darwinsys.com/testedit"
					);
				}
			});
			hm.add(mi = new JMenuItem("Topics"));
			mi.addActionListener(new ActionListener() {
                public void actionPerformed(ActionEvent e) {
					Window jh = new MyHelp();
					centre(jh);
					jh.setVisible(true);
				}
			});
		// mb.setHelpJMenu(hm);
		mb.add(hm);
	}
}
//@@@@@@//
//quizzes/src/TVTest.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;

public class TVTest {

	/** "main program" for testing TV by itself. */
	public static void main(String av[]) {
		TD td = new TD();
		JFrame jf = new JFrame("Testing TV");
		TV tv = new TV(jf, td);
		Exam tex = td.curX;
		Q q;
		tex.addQuestion(q=new Q(3));
		q.setQText("How much is the universe?", false);
		tex.addQuestion(q=new Q(3));
		q.setQText("Does time fly like a banana?", false);
		tv.installQVs();

		jf.getContentPane().add(tv);
		jf.pack();
		jf.setVisible(true);
	}
}
//@@@@@@//
//quizzes/src/XamDataAccessor.java
//@@@@@@//
import java.io.*;
import java.util.*;

/** TestEdit DataAccessor (aka Load/Save) - text version*/
public class XamDataAccessor {

	public XamDataAccessor() {
	}

	/** load an exam file, given its name */
	public Exam load(String name) throws IOException {
		return load(new BufferedReader(new FileReader(name)));
	}

    /** load one file, given an open BufferedReader */
    public Exam load(BufferedReader is) throws IOException {
		Exam theExam = new Exam();
		String inputLine;
		StringTokenizer st;

		if ((inputLine = is.readLine()) == null ||
			!inputLine.startsWith("X"))
			throw new IllegalArgumentException("File " + "testdata" +
				" does not begin with X line!");
		if ((st = new StringTokenizer(inputLine)).countTokens() != 4)
			throw new IllegalArgumentException("File " + "testdata" +
				" begins with invalid X line!");
		st.nextToken();
		theExam.crsNum = Integer.parseInt(st.nextToken());
		theExam.examName = st.nextToken().charAt(0);
		theExam.examVers = st.nextToken();
		System.out.println("Loading Course " + theExam.crsNum + ", " +
			"Exam " + theExam.examName + ", Version " + theExam.examVers);
		if ((inputLine = is.readLine()) == null ||
			!inputLine.startsWith("T "))
			throw new IllegalArgumentException("File " + "testdata" +
				" does not have T line second!");
		theExam.setCourseTitle(inputLine.substring(2));

		Vector al = new Vector();
		theExam.setListData(al);

			Q curQ = null;
            while ((inputLine = is.readLine()) != null) {
                // System.out.println(inputLine);
				if (inputLine.length() == 0)
					continue;
				switch(inputLine.charAt(0)) {
				case '#':
					continue;
				case 'Q':
					// System.out.println("It's a question: " + inputLine);
					curQ = new Q(4);
					al.addElement(curQ);
					curQ.setQText(inputLine.substring(4).trim(), true); // STRTOK ME
					break;
				case 'R':
					// System.out.println("It's an answer!");
					int n = inputLine.charAt(2) - 'A'; // A->0, B->1, etc.
					if (n < 0)
						break;
					curQ.setAns(n, true);
					break;
				case 'O':	// chapter objectives
					// System.out.println("It's the chapter objective!");
					int on = Integer.parseInt(inputLine.substring(2).trim());
					if (on >= 0)
						curQ.setObjective(on);
					break;
				case 'A':
				case 'B':
				case 'C':
				case 'D':
					int an = inputLine.charAt(0) - 'A'; // A->0, B->1, etc.
					curQ.setAnsText(an, inputLine.substring(2), true);
					break;
				default:
					// left over, presume multi-line question
					if (curQ == null || curQ.getQText() == null) {
						System.err.println("XamDataAccessor: ignoring " +
							inputLine);
						continue;
					}
					curQ.setQText(curQ.getQText() + "\n" + inputLine, true);
					break;
				}
        }
		is.close();
		return theExam;
    }

	public void save(PrintWriter out, Exam model) {
		out.println("X " + model.crsNum + " " + model.examName + " " + model.examVers);
		out.println("T " + model.crsName);
		out.println("N " + model.getNumQuestions());
		out.println("");
		for (int i=0; i<model.getNumQuestions(); i++) {
			Q q = (Q)model.getQuestion(i);
			if (q.getQText() == null || q.getQText().length() == 0)
				continue;
			out.println("Q " + (i+1) + " " + q.getQText());
			out.println("R " + (char)('A'+q.getAns()));
			out.println("O " + q.getObjective());
			for (int j=0; j<q.getCount(); j++)
				out.println((char)('A'+j) + " " + q.getAnsText(j));
			out.println("");
		} 
	}
}
//@@@@@@//
//quizzes/src/XamDataAccessorHTML.java
//@@@@@@//
import java.io.*;
import java.util.*;

/** TestEdit Load/Save model - HTML version*/
public class XamDataAccessorHTML extends XamDataAccessor {

	public XamDataAccessorHTML() {
		super();
	}

    /** load one file, given an open BufferedReader */
    public Exam load(BufferedReader is) throws IOException {
		throw new IllegalArgumentException(
			"XamDataAccessorHTML cannot LOAD files");
    }

	/** Member class used to un-sort (sort randomly) list of answers */
	class link {
		/** Question Number */
		int qn;
		/** A random number */
		int r;
		/** A Question */
		Q   q;
		/** This Answer (A, B, C, or D) */
		int a;
		/** Construct a link */
		link(int qn, int r, Q q, int a) {
			this.qn = qn;
			this.r = r;
			this.q = q;
			this.a = a;
		}
	}

	public void save(PrintWriter out, Exam model) {
		Random r = new Random();
		Vector v = new Vector();
		out.println("<HTML><HEAD>");
		out.println("<TITLE>" + model.crsNum + " " + model.examName + " " + model.examVers + " " + model.crsName + "</TITLE>");
		out.println("</HEAD>");
		out.println("<BODY>");
		out.println("<H1>" + model.crsNum + " " + model.examName + " " + model.examVers + " " + model.crsName + "</H1>");
		out.println("<UL>");		// START OF PASS 1 - LIST
		for (int i=0; i<model.getNumQuestions(); i++) {
			Q q = model.getQuestion(i);
			if (q.getQText() == null || q.getQText().length() == 0)
				continue;
			out.println("<LI><A NAME=Q" + (i+1) + ">" + (i+1) + ". " + q.getQText() + "</A>");
			out.println("<UL>");		// start of one question
			for (int j=0; j<q.getCount(); j++) {
				char c = (char)('A'+j);
				out.println("<LI><A HREF=#Q"+(i+1)+"_"+c +">" + c + ". " + q.getAnsText(j) + "</A>");
				v.addElement(new link(i+1, r.nextInt(), q, j));
				}
			out.println("</UL>");		// end of one question
		} 
		out.println("</UL>");			// END OF PASS ONE

		// Depends upon JDK 1.2
		// Collections.sort(v, new Comparator() {
		// 	public int compare(Object o1, Object o2) {
		// 		link l1 = (link) o1;
		// 		link l2 = (link) o2;
		// 		if (l1.r < l2.r)
		// 			return -1;
		// 		else if (l1.r > l2.r)
		// 			return 1;
		// 		else
		// 			return 0;
		// 	}
		// });

		// PASS TWO: Print the answers; use a DL (DT and DD) for formatting
		out.println("<HR>");
		out.println("<H1>Answers - no peeking!</H1>");
		out.println("<P>The following are the answers. No peeking by reading sequentially");
		out.println("<HR>");
		out.println("<DL>");			// START PASS 2 - LIST
		for (int i=0; i<v.size(); i++) {
			link l = (link)v.elementAt(i);
			out.print("<DT><A NAME=Q"+l.qn+"_"+(char)('A'+l.a)+">"+l.q.getAnsText(l.a)+ "</A>");
			out.print("<DD>");
			out.print("<BR><BR><BR><BR><BR>");
			if (l.q.getAns() == l.a) {
				out.print("CORRECT!. <A HREF=#Q" + (l.qn+1) + ">Next question</A>");
			} else {
				out.print("Sorry, that's not the answer we expected here.<A HREF=#Q" + l.qn + ">Try again</A>");
			}
			out.println("<BR><BR><BR><BR><BR>");
		}
		out.println("</DL>");

		out.println("<H1><A NAME=Q" + (v.size()+1) + ">That's all folks!</A></H1>");
		out.println("You've done all the questions.</A>");
		out.println("<HR>");
		out.println("<A HREF=\"#top\">Back to top of page</A>");

		// print blank lines so # links near end work OK
		for (int i=0; i<10; i++) {
			out.println("<BR>");
		}
		out.println("</BODY>");
		out.println("</HTML>");
	}
}
//@@@@@@//
//quizzes/src/XamDataAccessorXML.java
//@@@@@@//
import java.io.*;
import java.util.*;

/** TestEdit Load/Save model - XML version.
 * Not written yet, but at least I thought of it. :-)
 * DOM will probably be a good approach here.
 */
public class XamDataAccessorXML extends XamDataAccessor {

	public XamDataAccessorXML() {
		super();
	}

    /** load one file, given an open BufferedReader */
    public Exam load(BufferedReader is) throws IOException {
		throw new IllegalArgumentException(
			"XamDataAccessorXML cannot yet LOAD files");
		// TODO: use DOM to parse it.
    }

	public void save(PrintWriter out, Exam model) {
		throw new IllegalArgumentException(
			"XamDataAccessorXML cannot yet SAVE files");
		// TODO convert to DOM, and end with
		// tree.write(out);
	}
}
//@@@@@@//
//RE/BookRank.java
//@@@@@@//
import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.darwinsys.io.FileIO;
import com.darwinsys.util.FileProperties;

/** Graph of a book's sales rank on a given bookshop site.
 * @author Ian F. Darwin, http://www.darwinsys.com/, Java Cookbook author,
 *	originally translated fairly literally from Perl into Java.
 * @author Patrick Killelea <p@patrick.net>: original Perl version,
 *	from the 2nd edition of his book "Web Performance Tuning".
 * @version $Id: BookRank.java,v 1.8 2004/03/20 20:48:03 ian Exp $
 */
public class BookRank {
	public final static String DATA_FILE = "book.sales";
	public final static String GRAPH_FILE = "book.png";

	/** Grab the sales rank off the web page and log it. */
	public static void main(String[] args) throws Exception {

		Properties p = new FileProperties(
			args.length == 0 ? "bookrank.properties" : args[1]);
		String title = p.getProperty("title", "NO TITLE IN PROPERTIES");
		// The url must have the "isbn=" at the very end, or otherwise
		// be amenable to being string-catted to, like the default.
		String url = p.getProperty("url", "http://test.ing/test.cgi?isbn=");
		// The 10-digit ISBN for the book.
		String isbn  = p.getProperty("isbn", "0000000000");
		// The RE pattern (MUST have ONE capture group for the number)
		String pattern = p.getProperty("pattern", "Rank: (\\d+)");

		// Looking for something like this in the input:
		//	 <b>QuickBookShop.web Sales Rank: </b>
		//	 26,252
		//	 </font><br>

		Pattern r = Pattern.compile(pattern);

		// Open the URL and get a Reader from it.
		BufferedReader is = new BufferedReader(new InputStreamReader(
			new URL(url + isbn).openStream()));
		// Read the URL looking for the rank information, as
		// a single long string, so can match RE across multi-lines.
		String input = FileIO.readerToString(is);
		// System.out.println(input);

		// If found, append to sales data file.
		Matcher m = r.matcher(input);
		if (m.find()) {
			PrintWriter pw = new PrintWriter(
				new FileWriter(DATA_FILE, true));
			String date = // `date +'%m %d %H %M %S %Y'`;
				new SimpleDateFormat("MM dd hh mm ss yyyy ").
				format(new Date());
			// Paren 1 is the digits (and maybe ','s) that matched; remove comma
			Matcher noComma = Pattern.compile(",").matcher(m.group(1));
			pw.println(date + noComma.replaceAll(""));
			pw.close();
		} else {
			System.err.println("WARNING: pattern `" + pattern +
				"' did not match in `" + url + isbn + "'!");
		}

		// Whether current data found or not, draw the graph, using 
		// external plotting program against all historical data.
		// Could use gnuplot, R, any other math/graph program.
		// Better yet: use one of the Java plotting APIs.

		String gnuplot_cmd = 
			"set term png\n" + 
			"set output \"" + GRAPH_FILE + "\"\n" +
			"set xdata time\n" +
			"set ylabel \"Book sales rank\"\n" +
			"set bmargin 3\n" +
			"set logscale y\n" +
			"set yrange [1:60000] reverse\n" +
			"set timefmt \"%m %d %H %M %S %Y\"\n" +
			"plot \"" + DATA_FILE + 
				"\" using 1:7 title \"" + title + "\" with lines\n" 
		;

		Process proc = Runtime.getRuntime().exec("/usr/local/bin/gnuplot");
		PrintWriter gp = new PrintWriter(proc.getOutputStream());
		gp.print(gnuplot_cmd);
		gp.close();
	}
}
//@@@@@@//
//RE/CanonEqDemo.java
//@@@@@@//
import java.util.regex.*;

/**
 * CanonEqDemo - show use of Pattern.CANON_EQ, by comparing varous ways of
 * entering the Spanish word for "equal" and see if they are considered equal
 * by the RE-matching engine.
 * 
 * @version $Id: CanonEqDemo.java,v 1.3 2004/03/21 20:06:20 ian Exp $
 */
public class CanonEqDemo {
	public static void main(String[] args) {
		String pattStr = "\u00e9gal"; // gal
		String[] input = {
				"\u00e9gal", // gal - this one had better match :-)
				"e\u0301gal", // e + "Combining acute accent"
				"e\u02cagal", // e + "modifier letter acute accent"
				"e'gal", // e + single quote
				"e\u00b4gal", // e + Latin-1 "acute"
		};
		Pattern pattern = Pattern.compile(pattStr, Pattern.CANON_EQ);
		for (int i = 0; i < input.length; i++) {
			if (pattern.matcher(input[i]).matches()) {
				System.out.println(pattStr + " matches input " + input[i]);
			} else {
				System.out.println(pattStr + " does not match input " + input[i]);
			}
		}
	}
}
//@@@@@@//
//RE/CaseMatch.java
//@@@@@@//
import java.util.regex.*;

/**
 * Show case control using RE class.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: CaseMatch.java,v 1.4 2004/02/09 03:33:41 ian Exp $
 */
public class CaseMatch {
	public static void main(String[] argv) {
		String pattern = "^q[^u]\\d+\\.";
		String input = "QA777. is the next flight. It is on time.";

		Pattern reCaseInsens = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);
		Pattern reCaseSens = Pattern.compile(pattern);

		boolean found;
		Matcher m;
		m = reCaseInsens.matcher(input);	// will match any case
		found = m.lookingAt();				// will match any case
		System.out.println("IGNORE_CASE match " + found);

		m = reCaseSens.matcher(input);	// Get matcher w/o case-insens flag
		found = m.lookingAt();		// will match case-sensitively
		System.out.println("MATCH_NORMAL match was " + found);

	}
}
//@@@@@@//
//RE/GetParen0.java
//@@@@@@//
import java.util.regex.*;

public class GetParen0 {
	public static void main(String[] args) {
		Pattern myRE = Pattern.compile("d.*ian");
		Matcher matcher = myRE.matcher(
		"darwinian pterodactyls soared over the devonian space");
		matcher.lookingAt();
		String result = matcher.group(0);
		System.out.println(result);
	}
}
//@@@@@@//
//RE/GetParen1.java
//@@@@@@//
import java.util.regex.*;

public class GetParen1 {
	public static void main(String[] args) {
		Pattern patt = Pattern.compile("(\\w+)\\s(\\d+)"); 
		Matcher matcher = patt.matcher("Bananas 123"); 
		matcher.lookingAt();
		System.out.println("Name: " + matcher.group(1)); 
		System.out.println("Number: " + matcher.group(2)); 
	}
}
//@@@@@@//
//RE/Grep0.java
//@@@@@@//
import java.io.*;
import java.util.regex.*;

/** Grep0 - Match lines from stdin against the pattern on the command line.
 */
public class Grep0 {
	public static void main(String[] args) throws IOException {
		BufferedReader is =
			new BufferedReader(new InputStreamReader(System.in));
		if (args.length != 1) {
			System.err.println("Usage: MatchLines pattern");
			System.exit(1);
		}
		Pattern patt = Pattern.compile(args[0]);
		Matcher matcher = patt.matcher("");
		String line = null;
		while ((line = is.readLine()) != null) {
			matcher.reset(line);
			if (matcher.find()) {
				System.out.println("MATCH: " + line);
			}
		}
	}
}
//@@@@@@//
//RE/Grep1.java
//@@@@@@//
import java.util.regex.*;
import java.io.*;

/** A command-line grep-like program. No options, but takes a pattern
 * and an arbitrary list of text files.
 */
public class Grep1 {
	/** The pattern we're looking for */
	protected Pattern pattern;
	/** The matcher for this pattern */
	protected Matcher matcher;

	/** Main will make a Grep object for the pattern, and run it
	 * on all input files listed in argv.
	 */
	public static void main(String[] argv) throws Exception {

		if (argv.length < 1) {
		    System.err.println("Usage: Grep1 pattern [filename]");
		    System.exit(1);
		}

		Grep1 pg = new Grep1(argv[0]);

		if (argv.length == 1)
			pg.process(new BufferedReader(new InputStreamReader(System.in)),
				"(standard input)", false);
		else
			for (int i=1; i<argv.length; i++) {
				pg.process(new BufferedReader(new FileReader(argv[i])),
					argv[i], true);
			}
	}

	/** Construct a Grep1 program */
	public Grep1(String patt) {
		pattern = Pattern.compile(patt);
		matcher = pattern.matcher("");
	}

	/** Do the work of scanning one file
	 * @param ifile BufferedReader object already open
	 * @param fileName String Name of the input file
	 * @param printFileName Boolean - true to print filename
	 * before lines that match.
	 */
	public void process(
		BufferedReader inputFile, String fileName, boolean printFileName) {

		String inputLine;

		try {
			while ((inputLine = inputFile.readLine()) != null) {
				matcher.reset(inputLine);
				if (matcher.lookingAt()) {
					if (printFileName) {
						System.out.print(fileName + ": ");
					}
					System.out.println(inputLine);
				}
			}
			inputFile.close();
		} catch (IOException e) { System.err.println(e); }
	}
}
//@@@@@@//
//RE/Grep2.java
//@@@@@@//
import java.io.*;
import java.util.*;
import java.util.regex.*;

import com.darwinsys.lang.GetOpt;

/** A command-line grep-like program. Accepts some command-line options,
 * and takes a pattern and a list of text files.
 */
public class Grep2 {
	/** The pattern we're looking for */
	protected Pattern pattern;
	/** The matcher for this pattern */
	protected Matcher matcher;
	/** The Reader for the current file */
    protected BufferedReader d;
	/** Are we to only count lines, instead of printing? */
	protected boolean countOnly = false;
	/** Are we to ignore case? */
	protected boolean ignoreCase = false;
	/** Are we to suppress printing of filenames? */
	protected boolean dontPrintFileName = false;
	/** Are we to only list names of files that match? */
	protected boolean listOnly = false;
	/** are we to print line numbers? */
	protected boolean numbered = false;
	/** Are we to be silent about errors? */
	protected boolean silent = false;
	/** are we to print only lines that DONT match? */
	protected boolean inVert = false;

	/** Construct a Grep2 object for each pattern, and run it
	 * on all input files listed in argv.
	 * Be aware that a few of the command-line options are not
	 * acted upon in this version - this is an exercise for the reader!
	 */
	public static void main(String[] argv) {

		if (argv.length < 1) {
		    System.err.println(
			"Usage: Grep2 pattern [-chilsnv][-f pattfile][filename...]");
		    System.exit(1);
		}
		String patt = null;

		GetOpt go = new GetOpt("cf:hilnsv");
		BitSet args = new BitSet();

		char c;
		while ((c = go.getopt(argv)) != 0) {
			switch(c) {
				case 'c':
					args.set('C');
					break;
				case 'f':
					try {
						BufferedReader b = new BufferedReader(new FileReader(go.optarg()));
						patt = b.readLine();
						b.close();
					} catch (IOException e) {
						System.err.println("Can't read pattern file " + go.optarg());
						System.exit(1);
					}
					break;
				case 'h':
					args.set('H');
					break;
				case 'i':
					args.set('I');
					break;
				case 'l':
					args.set('L');
					break;
				case 'n':
					args.set('N');
					break;
				case 's':
					args.set('S');
					break;
				case 'v':
					args.set('V');
					break;
			}
		}

		int ix = go.getOptInd();

		if (patt == null)
			patt = argv[ix];

		Grep2 pg = null;
		try {
			pg = new Grep2(patt, args);
		} catch (PatternSyntaxException ex) {
			System.err.println("RE Syntax error in " + patt);
			return;
		}

		if (argv.length == ix)
			pg.process(new InputStreamReader(System.in), "(standard input)");
		else
			for (int i=ix; i<argv.length; i++) {
				try {
					pg.process(new FileReader(argv[i]), argv[i]);
				} catch(Exception e) {
					System.err.println(e);
				}
			}
	}

	/** Construct a Grep2 object.
	 * @param patt The pattern to look for
	 * @param args the command-line options.
	 */
	public Grep2(String patt, BitSet args) throws PatternSyntaxException {
		// compile the regular expression
		if (args.get('C'))
			countOnly = true;
		if (args.get('H'))
			dontPrintFileName = true;
		if (args.get('I'))
			ignoreCase = true;
		if (args.get('L'))
			listOnly = true;
		if (args.get('N'))
			numbered = true;
		if (args.get('S'))
			silent = true;
		if (args.get('V'))
			inVert = true;
		int caseMode = ignoreCase ?
			Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE :
			0;
		pattern = Pattern.compile(patt, caseMode);
		matcher = pattern.matcher("");
	}
        
	/** Do the work of scanning one file
	 * @param	ifile	Reader	Reader object already open
	 * @param	fileName String	Name of the input file
	 */
	public void process(Reader ifile, String fileName) {

		String inputLine;
		int matches = 0;

		try {
			d = new BufferedReader(ifile);
		    
			while ((inputLine = d.readLine()) != null) {
				matcher.reset(inputLine);
				if (matcher.lookingAt()) {
					if (countOnly)
						matches++;
					else {
					if (!dontPrintFileName)
						System.out.print(fileName + ": ");
					System.out.println(inputLine);
					}
				} else if (inVert) {
					System.out.println(inputLine);
				}
			}
			if (countOnly)
				System.out.println(matches + " matches in " + fileName);
			d.close();
		} catch (IOException e) { System.err.println(e); }
	}
}
//@@@@@@//
//RE/GrepNIO.java
//@@@@@@//
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;
import java.util.regex.*;

/** A grep-like program using NIO but NOT LINE BASED.
 * Pattern and file name(s) must be on command line.
 */
public class GrepNIO {
	public static void main(String[] args) throws IOException {

		if (args.length < 2) {
			System.err.println("Usage: GrepNIO patt file [...]");
			System.exit(1);
		}

		Pattern p=Pattern.compile(args[0]);
		for (int i=1; i<args.length; i++)
			process(p, args[i]);
	}

	static void process(Pattern pattern, String fileName) throws IOException {

		// Get a FileChannel from the given file.
		FileChannel fc = new FileInputStream(fileName).getChannel();

		// Map the file's content
		ByteBuffer buf = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());

		// Decode ByteBuffer into CharBuffer
		CharBuffer cbuf =
			Charset.forName("ISO-8859-1").newDecoder().decode(buf);

		Matcher m = pattern.matcher(cbuf);
		while (m.find()) {
			System.out.println(m.group(0));
		}
	}
}
//@@@@@@//
//RE/GrepSun.java
//@@@@@@//
// Sun Microsystems Example Code @(#)Grep.java	1.1 01/05/10

// Search a list of files for lines that match a given regular-expression
// pattern.  Demonstrates NIO mapped byte buffers, charsets, and regular
// expressions.

import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;
import java.util.regex.*;


public class GrepSun {

    // Charset and decoder for ISO-8859-15
    private static Charset charset = Charset.forName("ISO-8859-15");
    private static CharsetDecoder decoder = charset.newDecoder();

    // Pattern used to parse lines
    private static Pattern linePattern
	= Pattern.compile(".*\r?\n");

    // The input pattern that we're looking for
    private static Pattern pattern;

    // Compile the pattern from the command line
    //
    private static void compile(String pat) {
	try {
	    pattern = Pattern.compile(pat);
	} catch (PatternSyntaxException x) {
	    System.err.println(x.getMessage());
	    System.exit(1);
	}
    }

    // Use the linePattern to break the given CharBuffer into lines, applying
    // the input pattern to each line to see if we have a match
    //
    private static void grep(File f, CharBuffer cb) {
	Matcher lm = linePattern.matcher(cb);	// Line matcher
	Matcher pm = null;			// Pattern matcher
	int lines = 0;
	while (lm.find()) {
	    lines++;
	    CharSequence cs = lm.group(); 	// The current line
	    if (pm == null)
		pm = pattern.matcher(cs);
	    else
		pm.reset(cs);
	    if (pm.find())
		System.out.print(f + ":" + lines + ":" + cs);
	    if (lm.end() == cb.limit())
		break;
	}
    }

    // Search for occurrences of the input pattern in the given file
    //
    private static void grep(File f) throws IOException {

	// Open the file and then get a channel from the stream
	FileInputStream fis = new FileInputStream(f);
	FileChannel fc = fis.getChannel();

	// Get the file's size and then map it into memory
	int sz = (int)fc.size();
	MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, sz);

	// Decode the file into a char buffer
	CharBuffer cb = decoder.decode(bb);

	// Perform the search
	grep(f, cb);

	// Close the channel and the stream
	fc.close();
    }

    public static void main(String[] args) {
	if (args.length < 2) {
	    System.err.println("Usage: java Grep pattern file...");
	    return;
	}
	compile(args[0]);
	for (int i = 1; i < args.length; i++) {
	    File f = new File(args[i]);
	    try {
		grep(f);
	    } catch (IOException x) {
		System.err.println(f + ": " + x);
	    }
	}
    }

}
//@@@@@@//
//RE/LogExample.java
//@@@@@@//
/**
 * Common fields for Apache Log demo.
 */
public interface LogExample {
	/** The number of fields that must be found. */
	public static final int NUM_FIELDS = 9;

	/** The sample log entry to be parsed. */
	public static final String logEntryLine = "123.45.67.89 - - [27/Oct/2000:09:27:09 -0400] \"GET /java/javaResources.html HTTP/1.0\" 200 10450 \"-\" \"Mozilla/4.6 [en] (X11; U; OpenBSD 2.8 i386; Nav)\"";

}
//@@@@@@//
//RE/LogRegExp.java
//@@@@@@//
import java.util.regex.*;

/**
 * Parse an Apache log file with Regular Expressions
 */
public class LogRegExp implements LogExample {

	public static void main(String argv[]) {

		String logEntryPattern = "^([\\d.]+) (\\S+) (\\S+) \\[([\\w:/]+\\s[+\\-]\\d{4})\\] \"(.+?)\" (\\d{3}) (\\d+) \"([^\"]+)\" \"([^\"]+)\"";

		System.out.println("Using RE Pattern:");
		System.out.println(logEntryPattern);

		System.out.println("Input line is:");
		System.out.println(logEntryLine);

		Pattern p = Pattern.compile(logEntryPattern);
		Matcher matcher = p.matcher(logEntryLine);
		if (!matcher.matches() || 
			NUM_FIELDS != matcher.groupCount()) {
			System.err.println("Bad log entry (or problem with RE?):");
			System.err.println(logEntryLine);
			return;
		}
		System.out.println("IP Address: " + matcher.group(1));
		System.out.println("Date&Time: " + matcher.group(4));
		System.out.println("Request: " + matcher.group(5));
		System.out.println("Response: " + matcher.group(6));
		System.out.println("Bytes Sent: " + matcher.group(7));
		if (!matcher.group(8).equals("-"))
			System.out.println("Referer: " + matcher.group(8));
		System.out.println("Browser: " + matcher.group(9));
	}
}
//@@@@@@//
//RE/LogStrTok.java
//@@@@@@//
import java.util.*;

/**
 * Parse an Apache log file with StringTokenizer
 */
public class LogStrTok implements LogExample {
	public static void main(String argv[]) {

		StringTokenizer matcher = new StringTokenizer(logEntryLine);

		System.out.println("tokens = " + matcher.countTokens());
		// StringTokenizer CAN NOT count if you are changing the delimiter!
		// if (matcher.countTokens() != NUM_FIELDS) {
		// 	System.err.println("Bad log entry (or bug in StringTokenizer?):");
		// 	System.err.println(logEntryLine);
		// }

		System.out.println("Hostname: " + matcher.nextToken());
		// StringTokenizer makes you ask for tokens in order to skip them:
		matcher.nextToken(); // eat the "-"
		matcher.nextToken(); // again
		System.out.println("Date/Time: " + matcher.nextToken("]"));
		//matcher.nextToken(" "); // again
		System.out.println("Request: " + matcher.nextToken("\""));
		matcher.nextToken(" "); // again
		System.out.println("Response: " + matcher.nextToken());
		System.out.println("ByteCount: " + matcher.nextToken());
		System.out.println("Referer: " + matcher.nextToken("\""));
		matcher.nextToken(" "); // again
		System.out.println("User-Agent: " + matcher.nextToken("\""));
	}
}
//@@@@@@//
//RE/NLMatch.java
//@@@@@@//
import java.util.regex.*;

/**
 * Show line ending matching using RE class.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: NLMatch.java,v 1.6 2004/02/09 03:33:42 ian Exp $
 */
public class NLMatch {
	public static void main(String[] argv) {

		String input = "I dream of engines\nmore engines, all day long";
		System.out.println("INPUT: " + input);
		System.out.println();

		String[] patt = {
			"engines.more engines",
			"engines$"
		};

		for (int i = 0; i < patt.length; i++) {
			System.out.println("PATTERN " + patt[i]);

			boolean found;
			Pattern p1l = Pattern.compile(patt[i]);
			found = p1l.matcher(input).find();
			System.out.println("DEFAULT match " + found);

			Pattern pml = Pattern.compile(patt[i], 
				Pattern.DOTALL|Pattern.MULTILINE);
			found = pml.matcher(input).find();
			System.out.println("MultiLine match " + found);
			System.out.println();
		}
	}
}
//@@@@@@//
//RE/PatternConvenience.java
//@@@@@@//
import java.util.regex.*;

/**
 * PatternConvenience -- demonstrate java.util.regex.Pattern convenience routine
 * @author Ian F. Darwin
 * @version $Id: PatternConvenience.java,v 1.1 2003/05/09 19:25:50 ian Exp $
 */
public class PatternConvenience {

	public static void main(String[] argv) {

		String pattern = ".*Q[^u]\\d+\\..*";
		String line = "Order QT300. Now!";
		if (Pattern.matches(pattern, line)) {
			System.out.println(line + " matches \"" + pattern + "\"");
		} else {
			System.out.println("NO MATCH");
		}
	}
}
//@@@@@@//
//RE/RE_QnotU_Args.java
//@@@@@@//
import java.util.regex.*;

/**
 * Match the "Q[^u] pattern against strings from command line.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: RE_QnotU_Args.java,v 1.4 2004/02/09 03:33:42 ian Exp $
 */
public class RE_QnotU_Args {
	public static void main(String[] argv) {
		String patt = "^Q[^u]\\d+\\.";
		Pattern r = Pattern.compile(patt);
		for (int i=0; i<argv.length; i++) {
			Matcher m = r.matcher(argv[i]);
			boolean found = m.lookingAt();
			System.out.println(patt +
				(found ? " matches " : " doesn't match ") + argv[i]);
		}
	}
}
//@@@@@@//
//RE/ReaderIter.java
//@@@@@@//
import java.util.regex.*;
import java.io.*;

/**
 * Print all the strings that match a given pattern from a file.
 */
public class ReaderIter {
	public static void main(String[] args) throws IOException {
		// The RE pattern
		Pattern patt = Pattern.compile("[A-Za-z][a-z]+");
		// A FileReader (see the I/O chapter)
		BufferedReader r = new BufferedReader(new FileReader(args[0]));

		// For each line of input, try matching in it.
		String line;
		while ((line = r.readLine()) != null) {
			// For each match in the line, extract and print it.
			Matcher m = patt.matcher(line);
			while (m.find()) {
				// Simplest method:
				// System.out.println(m.group(0));

				// Get the starting position of the text
				int start = m.start(0);
				// Get ending position
				int end = m.end(0);
				// Print whatever matched.
				// Use CharacterIterator.substring(offset, end);
				System.out.println(line.substring(start, end));
			}
		}
	}
}
//@@@@@@//
//RE/REDemo.java
//@@@@@@//
import java.awt.*;
import javax.swing.*;
import javax.swing.event.*;
import java.util.regex.*;

/** Standalone Swing GUI application for demonstrating REs.
 * <br/>
 * TODO: 
 * Show the entire match, and $1 and up as captures that matched.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version #Id$
 */
public class REDemo extends JPanel {
	protected Pattern pattern;
	protected Matcher matcher;
	protected JTextField patternTF, stringTF;
	protected JCheckBox compiledOK;
	protected JRadioButton match, find, findAll;
	protected JTextField matchesTF;

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		JFrame f = new JFrame("REDemo");
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		REDemo comp = new REDemo();
		f.setContentPane(comp);
		f.pack();
		f.setLocation(200, 200);
		f.setVisible(true);
	}

	/** Construct the REDemo object including its GUI */
	public REDemo() {
		super();

		JPanel top = new JPanel();
		top.add(new JLabel("Pattern:", JLabel.RIGHT));
		patternTF = new JTextField(20);
		patternTF.getDocument().addDocumentListener(new PatternListener());
		top.add(patternTF);
		top.add(new JLabel("Syntax OK?"));
		compiledOK = new JCheckBox();
		top.add(compiledOK);

		ChangeListener cl = new ChangeListener() {
			public void stateChanged(ChangeEvent ce) {
				tryMatch();
			}
		};
		JPanel switchPane = new JPanel();
		ButtonGroup bg = new ButtonGroup();
		match = new JRadioButton("Match");
		match.setSelected(true);
		match.addChangeListener(cl);
		bg.add(match);
		switchPane.add(match);
		find = new JRadioButton("Find");
		find.addChangeListener(cl);
		bg.add(find);
		switchPane.add(find);
		findAll = new JRadioButton("Find All");
		findAll.addChangeListener(cl);
		bg.add(findAll);
		switchPane.add(findAll);

		JPanel strPane = new JPanel();
		strPane.add(new JLabel("String:", JLabel.RIGHT));
		stringTF = new JTextField(20);
		stringTF.getDocument().addDocumentListener(new StringListener());
		strPane.add(stringTF);
		strPane.add(new JLabel("Matches:"));
		matchesTF = new JTextField(3);
		strPane.add(matchesTF);

		setLayout(new GridLayout(0, 1, 5, 5));
		add(top);
		add(strPane);
		add(switchPane);
	}

	protected void setMatches(boolean b) {
		if (b)
			matchesTF.setText("Yes");
		else
			matchesTF.setText("No");
	}

	protected void setMatches(int n) {
		matchesTF.setText(Integer.toString(n));
	}

	protected void tryCompile() {
		pattern = null;
		try {
			pattern = Pattern.compile(patternTF.getText());
			matcher = pattern.matcher("");
			compiledOK.setSelected(true);
		} catch (PatternSyntaxException ex) {
			compiledOK.setSelected(false);
		}
	}

	protected boolean tryMatch() {
		if (pattern == null)
			return false;
		matcher.reset(stringTF.getText());
		if (match.isSelected() && matcher.matches()) {
			setMatches(true);
			return true;
		}
		if (find.isSelected() && matcher.find()) {
			setMatches(true);
			return true;
		}
		if (findAll.isSelected()) {
			int i = 0;
			while (matcher.find()) {
				++i;
			}
			if (i > 0) {
				setMatches(i);
				return true;
			}
		}
		setMatches(false);
		return false;
	}

	/** Any change to the pattern tries to compile the result. */
	class PatternListener implements DocumentListener {

		public void changedUpdate(DocumentEvent ev) {
			tryCompile();
		}

		public void insertUpdate(DocumentEvent ev) {
			tryCompile();
		}

		public void removeUpdate(DocumentEvent ev) {
			tryCompile();
		}
	}

	/** Any change to the input string tries to match the result */
	class StringListener implements DocumentListener {


		public void changedUpdate(DocumentEvent ev) {
			tryMatch();
		}

		public void insertUpdate(DocumentEvent ev) {
			tryMatch();
		}

		public void removeUpdate(DocumentEvent ev) {
			tryMatch();
		}
	}
}
//@@@@@@//
//RE/REDemo2.java
//@@@@@@//
import java.awt.BorderLayout;
import java.awt.Container;

import javax.swing.JFrame;
import javax.swing.JTextArea;

/* Like REDemo but shows the groups in a TextField
 */
public class REDemo2 extends REDemo {

	JTextArea logTextArea;
	
	/** "main program" method - construct and show */
	public static void main(String[] av) {
		JFrame f = new JFrame("REDemo2");
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		REDemo2 comp = new REDemo2();
		Container cp = f.getContentPane();
		cp.add(comp, BorderLayout.NORTH);
		cp.add(comp.logTextArea, BorderLayout.SOUTH);
		f.pack();
		f.setVisible(true);
	}

	REDemo2() {
		super();
		logTextArea = new JTextArea(10,40);
		add(logTextArea);
	}

	protected boolean tryMatch() {
		if (pattern == null) {
			return false;
		}
		logTextArea.setText("");
		if (!super.tryMatch()) {
			return false;
		}
		int n = matcher.groupCount();
		matcher.reset(stringTF.getText());
		if (match.isSelected() && matcher.matches()) {
			logTextArea.setText(matcher.group());
			return true;
		}
		if (find.isSelected() && matcher.find()) {
			logTextArea.setText(matcher.group());
			return true;
		}
		if (findAll.isSelected()) {
			int i;
			for (i = 0; i < n; i++) {
				matcher.find();
				logTextArea.append(i + ": " + matcher.group(i) + "\n");
			}
			if (i > 0) {
				return true;
			}
		}
		setMatches(false);
		return false;
	}
}
//@@@@@@//
//RE/REmatch.java
//@@@@@@//
import java.util.regex.*;

/**
 * REmatch -- demonstrate RE Match -> group()
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: REmatch.java,v 1.5 2004/02/28 02:21:26 ian Exp $
 */
public class REmatch {
	public static void main(String[] argv) {

		String patt = "Q[^u]\\d+\\.";
		Pattern r = Pattern.compile(patt);
		String line = "Order QT300. Now!";
		Matcher m = r.matcher(line);
		if (m.find()) {
			System.out.println(patt + " matches \"" +
				m.group(0) +
				"\" in \"" + line + "\"");
		} else {
			System.out.println("NO MATCH");
		}
	}
}
//@@@@@@//
//RE/REmatchTwoFields.java
//@@@@@@//
import java.util.regex.*;

/*
 * Reverse the order of two fields.
 * Input:
 * Adams, John Quincy
 * Output:
 * John Quincy Adams
 */
public class REmatchTwoFields {
	public static void main(String[] args) {
		String inputLine = "Adams, John Quincy";
		// Construct an RE with parens to "grab" both field1 and field2
		Pattern r = Pattern.compile("(.*), (.*)");
		Matcher m = r.matcher(inputLine);
		if (!m.matches())
			throw new IllegalArgumentException("Bad input");
		System.out.println(m.group(2) + ' ' + m.group(1));
	}
}
//@@@@@@//
//RE/ReplaceDemo.java
//@@@@@@//
import java.util.regex.*;

/**
 * Quick demo of RE substitution: correct "demon" and other
 * spelling variants to the correct, non-satanic "daemon".
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: ReplaceDemo.java,v 1.5 2004/02/09 03:33:42 ian Exp $
 */
public class ReplaceDemo {
	public static void main(String[] argv) {

		// Make an RE pattern to match almost any form (deamon, demon, etc.).
		String patt = "d[ae]{1,2}mon";	// i.e., 1 or 2 'a' or 'e' any combo

		// A test input.
		String input = "Unix hath demons and deamons in it!";
		System.out.println("Input: " + input);

		// Run it from a RE instance and see that it works
		Pattern r = Pattern.compile(patt);
		Matcher m = r.matcher(input);
		System.out.println("ReplaceAll: " + m.replaceAll("daemon"));

		// Show the appendReplacement method
		m.reset();
		StringBuffer sb = new StringBuffer();
		System.out.print("Append methods: ");
		while (m.find()) {
			m.appendReplacement(sb, "daemon");	// Copy to before first match,
												// plus the word "daemon"
		}
		m.appendTail(sb);						// copy remainder
		System.out.println(sb.toString());
	}
}
//@@@@@@//
//RE/RESimple.java
//@@@@@@//
import java.util.regex.*;

/**
 * Simple example of using RE class.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: RESimple.java,v 1.4 2004/02/28 02:14:11 ian Exp $
 */
public class RESimple {
	public static void main(String[] argv) {
		String pattern = "^Q[^u]\\d+\\.";
		String input = "QA777. is the next flight. It is on time.";

		Pattern p = Pattern.compile(pattern);

		boolean found = p.matcher(input).lookingAt();

		System.out.println("'" + pattern + "'" +
			(found ? " matches '" : " doesn't match '") + input + "'");
	}
}
//@@@@@@//
//RE/REString.java
//@@@@@@//
/**
 * Simple example of using RE functionality in String class.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: REString.java,v 1.4 2004/02/23 02:37:34 ian Exp $
 */
public class REString {
	public static void main(String[] argv) {
		String pattern = "^Q[^u]\\d+\\..*";
		String input = "QA777. is the next flight. It is on time.";

		boolean found = input.matches(pattern);

		System.out.println("'" + pattern + "'" +
			(found ? " matches " : " doesn't match '") + input + "'");
	}
}
//@@@@@@//
//RE/REsubstr.java
//@@@@@@//
import java.util.regex.*;

/**
 * REsubstr -- demonstrate RE Match -> String.substring()
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: REsubstr.java,v 1.3 2004/02/09 03:33:42 ian Exp $
 */
public class REsubstr {
	public static void main(String[] argv) {
		//+
		String patt = "Q[^u]\\d+\\.";
		Pattern r = Pattern.compile(patt);
		String line = "Order QT300. Now!";
		Matcher m = r.matcher(line);
		if (m.find()) {
			System.out.println(patt + " matches \"" +
				line.substring(m.start(0), m.end(0)) +
				"\" in \"" + line + "\"");
		} else {
			System.out.println("NO MATCH");
		}
	}
}
//@@@@@@//
//RE/Split.java
//@@@@@@//
import java.util.regex.*;

/** Split a String into a Java Array of Strings divided by an RE
 */
public class Split {
	public static void main(String[] args) {
		String[] x = 
			Pattern.compile("ian").split(
				"the darwinian devonian explodian chicken");
		for (int i=0; i<x.length; i++) {
			System.out.println(i + " \"" + x[i] + "\"");
		}
	}
}
//@@@@@@//
//RE/StringConvenience.java
//@@@@@@//
/**
 * StringConvenience -- demonstrate java.lang.String convenience routine
 * @author Ian F. Darwin
 * @version $Id: StringConvenience.java,v 1.2 2004/02/23 02:37:34 ian Exp $
 */
public class StringConvenience {
	public static void main(String[] argv) {

		String pattern = ".*Q[^u]\\d+\\..*";
		String line = "Order QT300. Now!";
		if (line.matches(pattern)) {
			System.out.println(line + " matches \"" + pattern + "\"");
		} else {
			System.out.println("NO MATCH");
		}
	}
}
//@@@@@@//
//rmi/agent/agents/Agent.java
//@@@@@@//
package agents;

import java.rmi.*;

public interface Agent {
	public void setThreshold(double d) throws RemoteException;
	public double getThreshold() throws RemoteException;
}
//@@@@@@//
//rmi/agent/agents/AgentImpl.java
//@@@@@@//
package agents;

import java.rmi.*;
import java.io.*;

/** This is the "real" agent, which gets run remotely by the server.
 * Since it is created on the Client but exported by the Server, it
 * MUST be "Remote" but NOT "UnicastRemoteObject".
 */
public class AgentImpl implements Remote, Serializable {

	private double thresh = 100;
	
	public void setThreshold(double d) throws RemoteException {
		System.out.println("Client asked agent to set Threshold to " + d);
		thresh = d;
	}
	public double getThreshold() throws RemoteException {
		return thresh;
	}
}
//@@@@@@//
//rmi/agent/ClientProgram.java
//@@@@@@//
import agents.*;
import servers.*;

import java.lang.reflect.*;
import java.io.*;
import java.rmi.*;
import java.rmi.server.*;

/** This class tries to be all things to all people:
 *	- main program for client to run.
 *  - creator of the "Agent" object to run remotely.
 *	- "server" program for remote to use Client of
 */
public class ClientProgram {

	protected final static String host = "localhost";

	/** This is the main program, just to get things started. */
	public static void main(String[] argv) throws Exception {
		new ClientProgram().do_the_work();
	}

	/** This is the server program part */
	private void do_the_work() throws Exception {

		System.out.println("Client starting");

		// Find the server, and register with it
		System.out.println("Finding server");
		RunServer server = 
			(RunServer)Naming.lookup("rmi://" + host + "/" +
			RunServer.LOOKUP_NAME);

		// Create the Agent as an un-exported Remote
		AgentImpl guts = new AgentImpl();

		// This should cause the server to call us back.
		System.out.println("Passing Agent to server");
		RemoteStub rs = server.connect(guts);
		System.out.println(rs);
		RemoteRef rr = rs.getRef();

		System.out.println("Client program ready.");

		Class[] args = { double.class };
		Method setThreshold = Agent.class.getMethod("setThreshold", args);
		Method getThreshold = Agent.class.getMethod("getThreshold", null);
		//Agent myClient = null;
		for (int i = 0; i < 10; i++) {

			//myClient.setThreshold(10 * i);
			Object[] setArgs = { new Double(10) };
			rr.invoke(rs, setThreshold, setArgs, setThreshold.hashCode());

			//System.out.println("Threshold now " + myClient.getThreshold());
			// ...
			try { Thread.sleep(1000); } catch (Exception ex) { /* */ }
		}
	}
}
//@@@@@@//
//rmi/agent/ServerMain.java
//@@@@@@//
import java.rmi.*;

import agents.*;
import servers.*;

public class ServerMain {
	public static void main(String[] args) {
		// System.setSecurityManager(new RMISecurityManager());
		try {
			System.out.println("Server: Constructing RunServerImpl");
			RunServerImpl im = new RunServerImpl();

			System.out.println("Server: Registering with RMI...");
			Naming.rebind(RunServer.LOOKUP_NAME, im);
			System.out.println("Server: bound and ready.");
		} catch (Exception e) {
			System.err.println(e);
			System.exit(1);
		}
	}
}
//@@@@@@//
//rmi/agent/servers/RunServer.java
//@@@@@@//
package servers;

import agents.*;

import java.rmi.*;
import java.rmi.server.*;

public interface RunServer extends java.rmi.Remote {
	public static final String LOOKUP_NAME = "RunService";
	public RemoteStub connect(AgentImpl d) throws java.rmi.RemoteException;
}
//@@@@@@//
//rmi/agent/servers/RunServerImpl.java
//@@@@@@//
package servers;

import agents.*;

import java.rmi.*;
import java.rmi.server.*;
import java.util.*;

/** This is the main class of the server */
public class RunServerImpl
	extends UnicastRemoteObject
	implements RunServer
{
	/** The list of Agents we've received */
	List list;

	public RunServerImpl() throws RemoteException {
		list = new ArrayList();
	}

	/** The remote method that "does all the work". This won't get
	 * called until the client starts up.
	 */
	public RemoteStub connect(AgentImpl da) throws RemoteException {
		System.out.print("Adding client " + da);
		try {
			System.out.print(" from ");
			System.out.print(getClientHost());
		} catch (Exception ex) {
			// nothing
		}
		System.out.println();
		list.add(da);

		// exportObject() returns the Stub; we return it to the client.
		return UnicastRemoteObject.exportObject(da);
	}
}
//@@@@@@//
//rmi/callback/Client.java
//@@@@@@//
package com.darwinsys.client;

import java.rmi.*;

/** Client -- the interface for the client callback */
public interface Client extends Remote {
	public void alert(String mesg) throws RemoteException;
}
//@@@@@@//
//rmi/callback/ClientProgram.java
//@@@@@@//
package com.darwinsys.client;

import com.darwinsys.callback.*;

import java.io.*;
import java.rmi.*;
import java.rmi.server.*;

/** This class tries to be all things to all people:
 *	- main program for client to run.
 *	- "server" program for remote to use Client of
 */
public class ClientProgram extends UnicastRemoteObject implements Client
{
	protected final static String host = "localhost";

	/** No-argument constructor required as we are a Remote Object */
	public ClientProgram() throws RemoteException {
	}

	/** This is the main program, just to get things started. */
	public static void main(String[] argv) throws IOException, NotBoundException {
		new ClientProgram().do_the_work();
	}

	/** This is the server program part */
	private void do_the_work() throws IOException, NotBoundException {

		System.out.println("Client starting");

		// First, register us with the RMI registry
		// Naming.rebind("Client", this);
	
		// Now, find the server, and register with it
		System.out.println("Finding server");
		TickerServer server = 
			(TickerServer)Naming.lookup("rmi://" + host + "/" +
			TickerServer.LOOKUP_NAME);

		// This should cause the server to call us back.
		System.out.println("Connecting to server");
		server.connect(this);

		System.out.println("Client program ready.");
	}

	/** This is the client callback */
	public void alert(String message) throws RemoteException {
		System.out.println(message);
	}
}
//@@@@@@//
//rmi/callback/TickerServer.java
//@@@@@@//
package com.darwinsys.callback;

import com.darwinsys.client.*;

import java.rmi.Remote;
import java.rmi.RemoteException;

public interface TickerServer extends Remote {
	public static final String LOOKUP_NAME = "Ticker_Service";
	public void connect(Client d) throws RemoteException;
}
//@@@@@@//
//rmi/callback/TickerServerImpl.java
//@@@@@@//
package com.darwinsys.callback;

import com.darwinsys.client.*;

import java.rmi.*;
import java.rmi.server.*;
import java.util.*;

/** This is the main class of the server */
public class TickerServerImpl
	extends UnicastRemoteObject
	implements TickerServer, Runnable
{
	ArrayList list = new ArrayList();

	/** Construct the object that implements the remote server.
	 * Called from main, after it has the SecurityManager in place.
	 */
	public TickerServerImpl() throws RemoteException {
		super();	// sets up networking
	}

	/** Start background thread to track stocks :-) and alert users. */
	public void start() {
		new Thread(this).start();
	}

	/** The remote method that "does all the work". This won't get
	 * called until the client starts up.
	 */
	public void connect(Client da) throws RemoteException {
		System.out.println("Adding client " + da);
		list.add(da);
	}

	boolean done = false;
	Random rand = new Random();

	public void run() {
		while (!done) {
			try {
				Thread.sleep(10 * 1000);
				System.out.println("Tick");
			} catch (InterruptedException unexpected) {
				System.out.println("WAHHH!");
				done = true;
			}
			Iterator it = list.iterator();
			while (it.hasNext()){
				String mesg = ("Your stock price went " +
					(rand.nextFloat() > 0.5 ? "up" : "down") + "!");
				// Send the alert to the given user.
				// If this fails, remove them from the list
				try {
					((Client)it.next()).alert(mesg);
				} catch (RemoteException re) {
                    System.out.println(
						"Exception alerting client, removing it.");
					System.out.println(re);
					it.remove();
				}
			}
		}
	}
}
//@@@@@@//
//rmi/DateApplet.java
//@@@@@@//
package darwinsys.distdate;

import java.awt.*;
import java.awt.event.*;
import java.applet.*;
import java.rmi.*;
import java.util.*;

public class DateApplet extends Applet {
	RemoteDate netConn = null;
	Button b;
	Label statusLabel;

	public void init() {
		try {
			netConn = (RemoteDate)Naming.lookup(RemoteDate.LOOKUPNAME);
		} catch (Exception e) {
			System.err.println("RemoteDate exception: " + e.getMessage());
			e.printStackTrace();
		}
		add(b = new Button("Get Date"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				if (netConn == null) {
					showStatus("Connection failed, bye");
					return;
				}
				try {
					Date today = netConn.getRemoteDate();
					showStatus(today.toString()); // XX use a DateFormat...
				} catch (Exception ex) {
					System.err.println("RemoteDate exception: " + ex.getMessage());
					showStatus("RemoteDate failed, see Java Console");
				}
			}
		});
	}
}
//@@@@@@//
//rmi/DateClient.java
//@@@@@@//
package darwinsys.distdate;

import java.rmi.*;
import java.util.*;

/* A very simple client for the RemoteDate service. */
public class DateClient {

	/** The local proxy for the service. */
	protected static RemoteDate netConn = null;

	public static void main(String[] args) {
		try {
			netConn = (RemoteDate)Naming.lookup(RemoteDate.LOOKUPNAME);
			Date today = netConn.getRemoteDate();
			System.out.println(today.toString()); // Could use a DateFormat...
		} catch (Exception e) {
			System.err.println("RemoteDate exception: " + e.getMessage());
			e.printStackTrace();
		}
	}
}
//@@@@@@//
//rmi/DateServer.java
//@@@@@@//
package darwinsys.distdate;

import java.rmi.*;

public class DateServer {
	public static void main(String[] args) {

		// You may want a SecurityManager for downloading of classes:
		// System.setSecurityManager(new RMISecurityManager());

		try {
			// Create an instance of the server object
			RemoteDateImpl im = new RemoteDateImpl();

			System.out.println("DateServer starting...");
			// Locate it in the RMI registry.
			Naming.rebind(RemoteDate.LOOKUPNAME, im);

			System.out.println("DateServer ready.");
		} catch (Exception e) {
			System.err.println(e);
			System.exit(1);
		}
	}
}
//@@@@@@//
//rmi/ListRMI.java
//@@@@@@//
import java.rmi.*;

public class ListRMI {
	public static void main(String[] args) throws Exception {

		String theURL = "rmi://localhost:1099/";

		String[] names = Naming.list(theURL);
		for (int i=0; i<names.length; i++) {
			System.out.println(i + ": " + names[i] + "\n");
		}

	}
}
//@@@@@@//
//rmi/NonSerNonRem.java
//@@@@@@//
package darwinsys.distdate;

/** This is an example of a class that is neither Serializable nor Remote. */
public class NonSerNonRem {
	public NonSerNonRem() {
	}
}
//@@@@@@//
//rmi/RemoteDate.java
//@@@@@@//
package darwinsys.distdate;

import java.rmi.*;
import java.util.Date;

/** A statement of what the client & server must agree upon. */
public interface RemoteDate extends java.rmi.Remote {

	/** The method used to get the current date on the remote */
	public Date getRemoteDate() throws java.rmi.RemoteException;

	/** The name used in the RMI registry service. */
	public final static String LOOKUPNAME = "RemoteDate";
}
//@@@@@@//
//rmi/RemoteDateImpl.java
//@@@@@@//
package darwinsys.distdate;

import java.rmi.*;
import java.rmi.server.*;
import java.util.*;

public class RemoteDateImpl extends UnicastRemoteObject implements RemoteDate
{
	/** Construct the object that implements the remote server.
	 * Called from main, after it has the SecurityManager in place.
	 */
	public RemoteDateImpl() throws RemoteException {
		super();	// sets up networking
	}

	/** The remote method that "does all the work". This won't get
	 * called until the client starts up.
	 */
	public Date getRemoteDate() throws RemoteException {
		return new Date();
	}
}
//@@@@@@//
//servlet/CalEventMaker.java
//@@@@@@//
import java.io.*;
import java.util.*;
import java.text.*;

/** Program to generate an iCalendar event.
 * Can be used as a main program or as a Servlet.
 */
public class CalEventMaker extends javax.servlet.http.HttpServlet {

	static int nEvent;
	static Random r = new Random();

	public static void main(String[] args) throws IOException {
		String TMPFILE = "j.ics";
		PrintWriter out = new PrintWriter(new FileWriter(TMPFILE));
		writeEvent(out, 
			args[0], 					// description
			Integer.parseInt(args[1]),	// mm start
			Integer.parseInt(args[2]),	// dd start
			Integer.parseInt(args[3]),	// mm end
			Integer.parseInt(args[4]));	// dd end
		out.close();
		// This is Mac OS X specific; on MS-Windows use "start".
		Runtime.getRuntime().exec("open" + ' ' + TMPFILE);
	}

	public void doGet(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {

		String event = request.getParameter("description");

		String yyStart = request.getParameter("yyStart");
		String mmStart = request.getParameter("mmStart");
		String ddStart = request.getParameter("ddStart");

		String yyEnd = request.getParameter("yyEnd");
		String mmEnd = request.getParameter("mmEnd");
		String ddEnd = request.getParameter("ddEnd");

		response.setContentType("ical");	// BLEARGH

		writeEvent(out, event,
			Integer.parseInt(yyStart),
			Integer.parseInt(mmStart),
			Integer.parseInt(ddStart),
			Integer.parseInt(yyEnd),
			Integer.parseInt(mmEnd),
			Integer.parseInt(ddEnd));
	}
	
	/** Write an event in the current year */
	public static void writeEvent(PrintWriter out, String event,
			int startMon, int startDay,
			int endMon, int endDay)
	{
		int thisyear = Calendar.getInstance().get(Calendar.YEAR);
		writeEvent(out, event, 
			2003, startMon, startYear,
			2003, endMon, endYear);
	}

	/** Write an event.
	 * @param out - the PrintWriter to use.
	 * @param event - a textual description of the event.
	 * @param startYear - starting year (e.g., 2010)
	 * @param startMon  - starting month (
	 * @param startDay
	 * @param endYear - ending year (e.g., 2010)
	 * @param endMon
	 * @param endDay
	 */
	public static void writeEvent(PrintWriter out, String event,
			int startYear, int startMon, int startDay,
			int endYear, int endMon, int endDay)
	{
		out.println("BEGIN:VCALENDAR");
		out.println("CALSCALE:GREGORIAN");
		out.println("X-WR-TIMEZONE;VALUE=TEXT:Canada/Eastern");
		out.println("METHOD:PUBLISH");
		out.println("PRODID:-//Darwin Open Systems//CalEventMaker 1.0//EN");
		out.println("X-WR-CALNAME;VALUE=TEXT:Work");
		out.println("VERSION:2.0");
		out.println("BEGIN:VEVENT");
		out.println("SEQUENCE:" + nEvent++);
		out.println("UID:27F0307F-37A6-21D7-AD6A-" + r.nextInt(9999999));
		out.println("SUMMARY:" + event);
		out.println("STATUS:TENTATIVE");
		out.println("DTSTART;VALUE=DATE:" +
			int4digit(startYear) + int2digit(startMon) + int2digit(startDay));
		out.println("DTEND;VALUE=DATE:" +
			int4digit(endYear) + int2digit(endMon) + int2digit(endDay));
		out.println("END:VEVENT");
		out.println("END:VCALENDAR");
	}

	private static NumberFormat format4d = new DecimalFormat("0000");
	public static String int4digit(int yyyy) {
		return format4d.format(yyyy);
	}

	private static NumberFormat format2d = new DecimalFormat("00");
	public static String int2digit(int mm) {
		return format2d.format(mm);
	}
}
//@@@@@@//
//servlet/chartservlet/ChartServlet.java
//@@@@@@//
import java.awt.*;
import java.awt.image.*;
import javax.imageio.*;	// IF THIS FAILS TO COMPILE YOU NEED JDK1.4.
import javax.imageio.stream.*;
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

/** Servlet to draw a Graphical Chart in response to a user request
 */
public class ChartServlet extends HttpServlet {
	private static int W = 300, H = 200;

	/** Draw a Graphical Chart in response to a user request */
	public void doGet(HttpServletRequest request,
		HttpServletResponse response)
	throws IOException {

		response.setContentType("image/jpeg");

		// Create an Image
		BufferedImage img =
			new BufferedImage(W, H,
			BufferedImage.TYPE_INT_RGB);

		// Get the Image's Graphics, and draw.
		Graphics2D g = img.createGraphics();

		// In real life this would call some charting software...
		g.setColor(Color.white);
		g.fillRect(0,0, W, H);
		g.setColor(Color.green);
		g.fillOval(100, 75, 50, 50);

		// Write the output
		OutputStream os = response.getOutputStream();
		ImageOutputStream ios = ImageIO.createImageOutputStream(os);

		if (!ImageIO.write(img, "jpeg", ios)) {
			log("Boo hoo, failed to write JPEG");
		}
		ios.close();
		os.close();
	}
}
//@@@@@@//
//servlet/chat/ChatConstants.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 2002.
 * All rights reserved. Software written by Ian F. Darwin.
 * $Id: ChatConstants.java,v 1.2 2004/02/09 03:34:01 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating and standardizing the Java 
 * language and environment is gratefully acknowledged.
 */

package darwinsys.chat;

public interface ChatConstants {
	/** The name for the Application State object, in the Context */
	public static final String APP_STATE = "darwinsys.chat.applicationState";

	/** The name for this user's State, in his/her Session */
	public static final String USER_STATE = "darwinsys.chat.userState";
}
//@@@@@@//
//servlet/chat/ChatListener.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 2002.
 * All rights reserved. Software written by Ian F. Darwin.
 * $Id: ChatListener.java,v 1.2 2004/02/09 03:34:01 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating and standardizing the Java 
 * language and environment is gratefully acknowledged.
 */

package darwinsys.chat;

import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

/**
 * Package darwinsys.chat implements a simple servlet-based chat application.
 * This class does much of the work of the Chat application,
 * including registering/deregistering users in the List
 */
public class ChatListener 
	implements ChatConstants, HttpSessionListener, ServletContextListener {


	/** Called when a new user comes along. Create a null
	 * UserState object and store it in the session.
	 */
	public void sessionCreated(HttpSessionEvent e) {
		HttpSession sess = e.getSession();
		sess.setAttribute(USER_STATE, new UserState());
		// XXX Get the ServletContext and add the user to it.
		System.out.println("Chat User Set Up");
	}

	public void sessionDestroyed(HttpSessionEvent e) {
		// Log this, but the Session is already destroyed.
		System.out.println("Chat User Removed");
	}

	/**
	 * The Chat Application is starting up. Create all of its global data!
 	 */
	public void contextInitialized(ServletContextEvent e) {
		ServletContext ctx = e.getServletContext();
		ctx.setAttribute(APP_STATE, new ChatState());
		System.out.println("Chat Application Initialized");
	}

	public void contextDestroyed(ServletContextEvent e) {
		System.out.println("Chat Application Destroyed");
	}
}
//@@@@@@//
//servlet/chat/ChatServlet.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 2002.
 * All rights reserved. Software written by Ian F. Darwin.
 * $Id: ChatServlet.java,v 1.2 2004/02/09 03:34:01 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating and standardizing the Java 
 * language and environment is gratefully acknowledged.
 */

package darwinsys.chat;

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;

/*
 * ChatServlet
 * @author  Ian Darwin
 * @version $Id: ChatServlet.java,v 1.2 2004/02/09 03:34:01 ian Exp $
 */
public class ChatServlet extends HttpServlet implements ChatConstants {

	/** Called in response to a GET request (data encoded in the URL) */
	public void doPost(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {

		ServletContext application = getServletContext();

		ChatState chat = (ChatState)application.getAttribute(APP_STATE);
		// assert(chat != null);

		// to do: logic code and main HTML goes HERE.
		String iSay = request.getParameter("iSay");
		if (iSay != null) {
			iSay = iSay.trim();
			if (iSay.length() != 0) {
				synchronized(chat) {
					chat.chat.add(iSay);
					chat.last++;
				}
			}
		}

		// Output section in MVC: dispatch to JSP to display the work.
		// (Remember the URL for an RD **MUST** be absolute).
		RequestDispatcher rd = application.getRequestDispatcher("/chat.jsp");
		rd.forward(request, response);
		/*NOTREACHED*/
	}

}
//@@@@@@//
//servlet/chat/ChatState.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 2002.
 * All rights reserved. Software written by Ian F. Darwin.
 * $Id: ChatState.java,v 1.2 2004/02/09 03:34:01 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating and standardizing the Java 
 * language and environment is gratefully acknowledged.
 */

package darwinsys.chat;

import java.util.*;

public class ChatState {
	/** The list of messages */
	public List chat;
	/** The list of users */
	public List users;
	/** The lower bound of current messages */
	public int first;
	/** The upper bound of current messages */
	public int last;

	public ChatState() {
		chat = new ArrayList();
		users = new ArrayList();
		first = last = 0;
	}
}
//@@@@@@//
//servlet/chat/UserState.java
//@@@@@@//
package darwinsys.chat;

public class UserState {
	public int firstViewed;
	public int lastViewed;
}
//@@@@@@//
//servlet/CodeRed.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;
import javax.mail.*;
import javax.mail.internet.*; 

/* This servlet responds to CodeRed by sending an email
 * to "administrator@" (and "root@") the infected site.
 * Keeps a hashtable in Application scope to only nag
 * each infested site once.
 * You will typically see "probe" entries like this in your
 * Apache logfile:
 * <pre>
 * 211.218.252.9 - - [02/Aug/2001:06:01:38 -0400] "GET /default.ida?NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN%u9090%u6858%ucbd3%u7801%u9090%u6858%ucbd3%u7801%u9090%u6858%ucbd3%u7801%u9090%u9090%u8190%u00c3%u0003%u8b00%u531b%u53ff%u0078%u0000%u00=a  HTTP/1.0" 400 326 "-" "-"
 * 193.255.201.85 - - [02/Aug/2001:09:27:59 -0400] "GET /default.ida?NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN%u9090%u6858%ucbd3%u7801%u9090%u6858%ucbd3%u7801%u9090%u6858%ucbd3%u7801%u9090%u9090%u8190%u00c3%u0003%u8b00%u531b%u53ff%u0078%u0000%u00=a  HTTP/1.0" 400 326 "-" "-"
 * </pre>
 * These are CodeRed probes: attempting to take over your IIS server
 * by overrunning a buffer in the ".ida" handler and installing the
 * executable program listed at the end of the overflowed buffer.
 */
public class CodeRed extends HttpServlet {
	// Change this to the (FQDN?) name of your mail host
	protected final String SMTPSERVER = "localhost";
	/** This, too, should be updated to something more FQ */
	protected final String MYADDR = "root@darwinsys.com";
	/** The JavaMail session object XXX Is it threadsafe? */
	protected Session session;

	public void init() {

		Properties props = new Properties();
		props.put("mail.smtp.host", SMTPSERVER);

		// Create the Mail Session object
		session = Session.getDefaultInstance(props, null);
		session.setDebug(true);		// Verbose!
	}

	public void service(HttpServletRequest request, 
		HttpServletResponse response) 
	throws IOException, ServletException {

		ServletContext ctx = getServletContext();
		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		out.println("<html>");
		out.println("<head><title>Default.ida</title></head>");
		out.println("<body text=\"white\" bgcolor=\"black\">");
	
		HashMap list = 
			(HashMap)ctx.getAttribute("codered.notified");

		if (list == null) {
			list = new HashMap();
			ctx.setAttribute("codered.notified", list);
		}

		String hostIP = request.getRemoteAddr();

		if (list.get(hostIP) != null) {
			// log("Already tried to notify " + hostIP);
			return;
		}

		String message_body = 
		"Your site, whose IP address is " +  hostIP + ", " +
		"has requested a \".ida\" file from a web site " +
		"that doesn't run the bug-infested Microsoft IIS server. " +
		"This typically indicates that your site " +
		"has been compromised by the \"CodeRed\" virus. " +
		"You should (1) immediately reboot the offending machine and " +
		"(2) To protect your system from re-infection: Install Microsoft's " +
		"patch for the Code Red vulnerability problem: " +
		"Windows NT version 4.0: " +
		"http://www.microsoft.com/Downloads/Release.asp?ReleaseID=30833 " +
		"Windows 2000 Professional, Server and Advanced Server: " +
		"http://www.microsoft.com/Downloads/Release.asp?ReleaseID=30800 " +
		"(3) update your virus protection software and do a full scan.";

		out.println(message_body);

		try {

			/** The JavaMail message object */
			Message mesg;

			// create a message
			mesg = new MimeMessage(session);

			// From Address - this should come from a Properties...
			mesg.setFrom(new InternetAddress(MYADDR));

			// TO Address 
			InternetAddress toAddress = new InternetAddress(
				"administrator@[" + hostIP + "]");
			mesg.addRecipient(Message.RecipientType.TO, toAddress);

			// CC Address
			// InternetAddress ccAddress = new InternetAddress(message_cc);
			// mesg.addRecipient(Message.RecipientType.CC, ccAddress);

			// The Subject
			mesg.setSubject("VIRUS ALERT");

			// Now the message body.
			mesg.setText(message_body);
			// XXX I18N: use setText(msgText.getText(), charset)
			
			// Finally, send the message!
			Transport.send(mesg);

		} catch (MessagingException ex) {
			out.println("<hr><h1>Mail error</h1>");
			out.println("Rats! An error occurred sending a mail notification");
			out.println("<pre>");
			while ((ex = (MessagingException)ex.getNextException()) != null) {
				ex.printStackTrace(out);
			}
			log("Failed to notify " + hostIP);
			out.flush();
			return;
		}
		log("Sent notification for " + hostIP);
		list.put(hostIP, "");
		out.flush();
	}
}
//@@@@@@//
//servlet/ColorCustServlet.java
//@@@@@@//
import java.io.*;
import java.util.Random;
import javax.servlet.*;
import javax.servlet.http.*;

/** Color customization servlet */
public class ColorCustServlet extends HttpServlet {

	protected final static String DEFAULT_COLOR = "white";
	protected String faveColor = DEFAULT_COLOR;

	public void doGet(HttpServletRequest request, HttpServletResponse response)
	throws IOException {
		response.setContentType("text/html");
		PrintWriter out = response.getWriter();

		String cand=request.getParameter("color_name");
		if (cand != null) {
			faveColor = cand;
			Cookie c = new Cookie(CookieServlet.PREFS_BGCOLOR, faveColor);
			c.setMaxAge(60*60*24*365);
			response.addCookie(c);
		}
		response.sendRedirect("/servlet/CookieServlet");
	}
}
//@@@@@@//
//servlet/ContactServlet.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;
import javax.mail.*;
import javax.mail.internet.*; 

/* This servlet responds to the Contact form by mailing the 
 * contact form contents "as if" from a regular user.
 * $Id: ContactServlet.java,v 1.6 2002/08/25 01:30:36 ian Exp $
 */
public class ContactServlet extends HttpServlet {
	/** The mail server, usually localhost. Should be a parameter. */
	protected String SMTPSERVER = "localhost";
	/** Contact. Gotten from a parameter. */
	protected String MYADDR;
	/** The JavaMail session object XXX Is it threadsafe? */
	protected Session session;

	public void init() throws ServletException {

		Properties props = new Properties();
		props.put("mail.smtp.host", SMTPSERVER);

		// Create the Mail Session object
		session = Session.getDefaultInstance(props, null);
		session.setDebug(true);		// Verbose!

		ServletContext ctx = getServletContext();
		MYADDR = ctx.getInitParameter("contact.email");
		if (MYADDR == null) {
			String error = "Context Parameter 'contact.email' not set!!";
			log(error);
			throw new ServletException(error);
		}
	}

	public void service(HttpServletRequest request, 
		HttpServletResponse response) 
	throws IOException, ServletException {

		ServletContext ctx = getServletContext();
		response.setContentType("text/html");

		PrintWriter out = response.getWriter();
	
		String hostIP = request.getRemoteAddr();

		String message_body = 
			"[This message is from host " +  hostIP + "]\n\n" +
			request.getParameter("message") +
			"\n";

		// out.println("<pre>" + message_body + "</pre>");

		try {

			/** Create a JavaMail message object */
			Message mesg = new MimeMessage(session);

			// TO (me) Address - should come from a Parameter...
			mesg.addRecipient(Message.RecipientType.TO,
				new InternetAddress(MYADDR));

			// FROM Address : request.name <request.email>
			mesg.setFrom(new InternetAddress(
				request.getParameter("name") + " <" +
				request.getParameter("email") + ">"));

			// The Subject
			String subject = request.getParameter("subject");
			if (subject == null || subject.length() == 0)
				subject = "DarwinSys Contact Form";
			mesg.setSubject(subject);

			// Now the message body.
			mesg.setText(message_body);
			// XXX I18N: use setText(msgText.getText(), charset)
			
			// Send the message!
			Transport.send(mesg);

			// No errors found at send time, confirm OK
			RequestDispatcher rd = 
				ctx.getRequestDispatcher("/contact-ack.jsp");
			rd.forward(request, response);

		} catch (MessagingException ex) {
			// Or something went wrong, complain to user.
			out.println("<html>");
			out.println("<head><title>Mail Error</title></head>");
			out.println("<body text=\"white\" bgcolor=\"black\">");
			out.println("<h1>Mail error</h1>");
			out.println("Rats! An error occurred sending a mail notification");
			out.println("<pre>");
			while ((ex = (MessagingException)ex.getNextException()) != null) {
				ex.printStackTrace(out);
			}
			out.println("</body>");
			out.println("</html>");
		} finally {
			out.flush();
			out.close();
		}
	}
}
//@@@@@@//
//servlet/CookieServlet.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

/** Simple Cookie-based Page Color Display servlet demo.
 * @author Ian Darwin
 * @version $Id: CookieServlet.java,v 1.1 2000/06/08 17:57:05 ian Exp $
 */
public class CookieServlet extends HttpServlet {
	/** The preferences cookie name */
	protected final static String PREFS_BGCOLOR = "prefs.bgcolor";
	/** Where to go if we have not yet been customized. */
	protected final static String CUSTOMIZER = "/ColorCustomize.html";
	/** The user's chosen color, if any */
	protected String faveColor = null;

	public void doGet(HttpServletRequest request, HttpServletResponse response)
	throws ServletException, IOException {

		// Go through all the cookies we have, looking for a faveColor.
		Cookie[] mySiteCookies = request.getCookies();
		for (int i=0; i<mySiteCookies.length; i++) {
			Cookie c = mySiteCookies[i];
			if (c.getName().equals(PREFS_BGCOLOR)) {
				faveColor = c.getValue();
				break;
			}
		}

		// if we did not find a faveColor in a cookie,
		// punt to customization servlet to bake one up for us.
		if (faveColor == null) {
			ServletContext sc = getServletContext();

			// Requires Servlet API 2.1 or later!
			// RequestDispatcher rd = 
			//	sc.getRequestDispatcher(CUSTOMIZER");
			//rd.forward(request, response);

			// Do it the old way
			response.sendRedirect(CUSTOMIZER);
		}

		// OK, we have a color, so we can do the page.
		PrintWriter out = response.getWriter();
		response.setContentType("text/html");

		out.println("<html><title>A Custom-Colored Page</title>");
		out.print("<body bgcolor=\"");
		out.print(faveColor);
		out.println("\">");
		out.println("<P>Welcome! We hope you like your colored page!</P>");
		out.println("</body></html>");
		out.flush();
	}
}
//@@@@@@//
//servlet/EJBServlet.java
//@@@@@@//
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import javax.naming.*;
import javax.rmi.*;

public class EJBServlet extends HttpServlet {

	protected Hello hello;	// EXPECT COMPILE ERRORS - demo only

	public void init() throws ServletException {

		try {
			Context initial = new InitialContext();

			Object objref = initial.lookup("Hello");

			HelloHome home =
				(HelloHome)PortableRemoteObject.narrow(objref, HelloHome.class);

			hello = home.create();

		} catch (Exception exc) {
			log(exc.toString());
			throw new ServletException(exc.getMessage());
		}
	}

	public void doGet(HttpServletRequest request, HttpServletResponse response)
		  throws ServletException, IOException {

		PrintWriter out = response.getWriter();
		response.setContentType("text/html");

		out.println("<html><head><title>Hello</title></head>");
		out.println("<body>");
		out.println("<p>There is an EJB here and it says...");

		out.println("<b>" + hello.hello() + "</b>");
		out.println("</p>");
		out.println("</body></html>");
	}
}
//@@@@@@//
//servlet/ForwardException.java
//@@@@@@//
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

/*
 * ForwardException - show forwarding an exception to an error page.
 * 
 * @author  Ian Darwin
 * @version $Id: ForwardException.java,v 1.2 2002/03/13 21:50:30 ian Exp $
 */
public class ForwardException extends HttpServlet
{
	/** Called in response to a GET request (data encoded in the URL) */
	public void doGet(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {

		ServletContext application = getServletContext();

		// BOILERPLATE beginning 
		response.setContentType("text/html");
		PrintWriter out = response.getWriter(); 

		try {
			// to do: logic code and main HTML goes here.

			// simulate an error condition happening at run time.
			if (this instanceof Servlet)
				throw new RuntimeException("Test exception");

			out.println("<!DOCTYPE html PUBLIC " +
				"\"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n" +
				"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\n" +
				">");
			out.println("<html>");
			out.println("<head><title>Servlet Output</title></head>");
			out.println("<body>");

			// BOILERPLATE ending
			out.println("</body>");
			out.println("</html>");
			out.close();

		} catch (Exception exc) {

			// dispatch to JSP to display the error.
			RequestDispatcher rd = application.getRequestDispatcher("/oops.jsp");
			request.setAttribute("javax.servlet.jsp.jspException", exc);
			rd.forward(request, response);
		}
	}
}

//@@@@@@//
//servlet/HelloServlet.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

/** Simple Hello World Servlet
 * @author Ian Darwin
 * @version $Id: HelloServlet.java,v 1.3 2002/03/29 15:00:49 ian Exp $
 */
public class HelloServlet extends HttpServlet{

	/** Called when the user clicks on a link to this servlet
	 * @parameter request Encapsulates the details about the input.
	 * @parameter response Encapsulates what you need to get a reply to the
	 *		user's browser.
	 */
	public void doGet(HttpServletRequest request,
		HttpServletResponse response) throws IOException {

		// Get a writer to generate the reply to user's browser
		PrintWriter out = response.getWriter();

		// Generate the HTTP header to say the response is in HTML
		response.setContentType("text/html");

		out.println("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"");
		out.println("\t\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"");
		out.println(">");
		out.println();

		out.println("<html><head><title>Hello from a Servlet</title></head>");
		out.println("<body>");
		out.println("<h1>Hello from a Servlet</h1>");
		out.println("<p>This servlet ran at ");
		out.println(new Date().toString());
		out.println("</p>");
		out.println("<p>Courtesy of " +
			"$Id: HelloServlet.java,v 1.3 2002/03/29 15:00:49 ian Exp $</p>");
		out.println("</body></html>");
	}
}
//@@@@@@//
//servlet/HelloServletMinimal.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.servlet.http.*;

public class HelloServletMinimal extends HttpServlet{

	public void doGet(HttpServletRequest request,
		HttpServletResponse response) throws IOException {

		PrintWriter out = response.getWriter();

		response.setContentType("text/html");

		out.println("<h1>Hello from a Servlet</h1>");
		out.println("<p>Server time is now ");
		out.println(new Date().toString());
	}
}
//@@@@@@//
//servlet/HttpSessionInfoServlet.java
//@@@@@@//
// package darwinsys;

import java.io.*;
import java.lang.reflect.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class HttpSessionInfoServlet extends HttpServlet
{
	public void init(ServletConfig config) throws ServletException
	{
		super.init(config);

		

	}

	public String getServletInfo()
	{
		return "HttpSessionInfoServlet";
	}

	public void doGet(HttpServletRequest req, HttpServletResponse resp)
	throws ServletException, IOException
	{
	    HttpSession sess = req.getSession(true);
		resp.setContentType("text/html");
		PrintWriter out = new PrintWriter(resp.getOutputStream());

		out.println("<HTML>");
		out.println("<HEAD><TITLE>HttpSessionInfoServlet Output</TITLE></HEAD>");
		out.println("<BODY BGCOLOR=\"white\">");

		out.println("<H1>HttpSessionInfoServlet Output</H1>");
		out.println("<P>Session object = " + sess.toString());
		if (sess instanceof Serializable) {
		    out.println("<P>Hurrah! Session object IS serializable");
		} else {
		    out.println("<P>Session object NOT serializable");
		}
		out.println("<P>Getting some fields...!");
		Class c = sess.getClass();
		Field[] f = c.getDeclaredFields();
		out.println("<OL>");
		for (int i=0; i<f.length; i++)
		    out.println("<LI>" + f[i]);
		out.println("<P>All done!");
		out.println("</BODY>");
		out.println("</HTML>");
		out.close();
	}
	
	

}
//@@@@@@//
//servlet/InitParams.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

/** Show both ServletContext.getInitParameter and Servlet.getInitParameter!
 * The following configuration info is for Tomcat and J2EE XML.
 *
 * N.B. The web.xml file MUST be that for the "web application", NOT
 * the master one for Tomcat which lives in /etc/tomcat (or whereever).
 *
 * The ServletContext init parameters are set as context-param in web.xml
 * as <context-param><param-name>...</param-name><param-value>...</param-value>
 * The Servlet's own init parameters are set in web.xml as
 *	<servlet>...<init-param><param-name>...</param-name>
 *		<param-value>...</param-value></servlet>
 */
public class InitParams extends HttpServlet {

	protected String CONTEXT_PARAM = "nothing";
	protected String CURR_DIR = "nowhere";
	protected String SERVLET_PARAM = "nuttin'";

	public void init() throws ServletException {

		ServletConfig config = getServletConfig();
		ServletContext ctx = config.getServletContext();

		CONTEXT_PARAM = ctx.getInitParameter("myParm");
		CURR_DIR = ctx.getRealPath("/");
	}

	public void service(HttpServletRequest request,
		HttpServletResponse response) 
		throws ServletException, IOException {

		SERVLET_PARAM = getInitParameter("myParm");
		response.setContentType("text/html");
		PrintWriter out = response.getWriter();
		out.println("<i>Hello</i>");
		out.println("<p>CONTEXT_PARAM = " + CONTEXT_PARAM);
		out.println("<p>SERVLET_PARAM = " + SERVLET_PARAM);
		out.println("<p>CURR_DIR = " + CURR_DIR);
		out.println("<h6>$Id: InitParams.java,v 1.5 2002/08/25 01:30:36 ian Exp $</h6>");
	}

}
//@@@@@@//
//servlet/IntsServlet.java
//@@@@@@//
import java.io.*;
import java.util.Random;
import javax.servlet.*;
import javax.servlet.http.*;

public class IntsServlet extends HttpServlet {
	protected final int DEFAULT_NUMBER = 5;

	/** Called when the form is filled in by the user. */
	public void doPost(HttpServletRequest req, HttpServletResponse resp)
	throws IOException {
		resp.setContentType("text/html");
		PrintWriter out = resp.getWriter();
	
		// The usual HTML setup stuff.
		out.println("<HTML>");
		out.println("<HEAD>");
		out.println("<BODY BGCOLOR=\"white\">");

		// HTML for this page
		out.println("<TITLE>Your Personal Random Numbers</TITLE>");
		out.println("<H1>Your Personal Random Numbers</H1>");
		out.println("<P>Here are your personal random numbers,");
		out.println("carefully selected by a");
		out.println("<A HREF=\"http://java.sun.com\">Java</A> program.");
		out.println("<OL>");

		// Figure out how many numbers to print.
		int n = DEFAULT_NUMBER;
		String num=req.getParameter("howmany");
		if (num != null && num.length() != 0) {
			try {
				n = Integer.parseInt(num);
			} catch (NumberFormatException e) {
				out.println("<P>I didn't think much of ");
				out.println(num);
				out.println(" as a number.</P>");
			}
		}

		// Now actually generate some random numbers.
		Random r = new Random();
		for (int i=0; i<n; i++) {
			out.print("<LI>");
			out.println(r.nextInt(49));	// for Lotto 6/49
		}
		out.println("</OL>");

		// Print a break and a back link.
		out.println("<HR></HR>");
		out.println("<A HREF=\"index.html\">Back to main Page</A>");
		out.println("</HTML>");
	}
}
//@@@@@@//
//servlet/ListParametersServlet.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

/** List all the values of all the Parameters */
public class ListParametersServlet extends HttpServlet {

	public void doGet(HttpServletRequest request, HttpServletResponse response)
	throws IOException, ServletException
	{

		PrintWriter out = response.getWriter();

		out.println("<html><head><title>List Parameters</title></head>");
		out.println("<body><h1>Parameters</h1>");
		out.println("<ul>");
		Enumeration e = request.getParameterNames();
		while (e.hasMoreElements()) {
			String key = (String)e.nextElement();
			String[] values = request.getParameterValues(key);
			for (int i=0; i<values.length; i++) {
				out.println("<li>" + key + "[" + i + "] = " + values[i] + "</li>");
			}
		}
		out.println("</ul>");
	}

	public void doPost(HttpServletRequest request, HttpServletResponse response)
	throws IOException, ServletException
	{
		doGet(request, response);
	}
}
//@@@@@@//
//servlet/OrderServlet.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

/**
 * OrderServlet implements order processing for Acme Widgets.
 * This dummy version just generates a thank-you notice.
 *
 * @author	Ian Darwin, http://www.darwinsys.com/, November, 1997
 */
public class OrderServlet extends HttpServlet {

	/** doPost() processes one POST request.
	 * Assuming weve been installed correctly, this can only 
	 * come from the order page, so we blindly respond, 
	 * without much validation of the order :-)
	 */
	public void doPost(HttpServletRequest req, HttpServletResponse resp) 
		throws ServletException, IOException {
		resp.setContentType("text/html");
		PrintWriter out = resp.getWriter();

		String cardType = req.getParameter("cardType");
		String cardNumber = req.getParameter("cardNumber");
		String expMonth = req.getParameter("expMonth");
		String expYear = req.getParameter("expYear");

		// Simple validation.
		if (cardType == null || cardNumber == null ||
			cardNumber.length() == 0 ||
			expMonth == null || expYear == null) {
			make_reply(false, out, "Acme Widgets: Thanks for trying...", 
				"Error!",
				"<P>We need a credit card type <B>and</B> a " +
				"valid credit card number, as well as the expiration "+
				"month and year. Please click your " +
				"browsers <I>Back</I> button and try again.\n" +
				"<P>Again, thank you for your order.");
			return;
		} 

		// Code here to phone the bank and validate the card.

		// Now make a nice thankyou to the user
		make_reply(true, out, "Acme Widgets: Thank you for your order",
				"Thank you for your credit card order",
				"We will bill it to your " + cardType + " credit card" +
				" which expires " + expMonth + "/" + expYear +
				"<P>Wile E. Coyote will process your order " +
				"as soon as he returns from his latest trip " +
				"to the bottom of the Grand Canyon.</P>");
		return;
	}

	/** Common code to generate a reply */
	void make_reply(boolean cardIsApproved, PrintWriter os, 
		String title, String h1, String txt) {

		// There would be code here to log the approve/deny status

		// Now make up the reply to the user.
		os.print("<HTML><HEAD>");
		os.print("<TITLE>");
		os.print(title);
		os.print("</TITLE>");
		os.print("<BODY><H1>");
		os.print(h1);
		os.print("</H1>");
		os.print(txt);
		os.print("</BODY></HTML>");
	}

	/** Some Servlet engines use this to report on the servlet */
	public String getServletInfo() {
		return "Acme Widgets Credit Card Validation";
	}
}
//@@@@@@//
//servlet/pdfcouponservlet/PDFCouponServlet.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;
import com.darwinsys.spdf.PDF;
import com.darwinsys.spdf.Page;
import com.darwinsys.spdf.Text;
import com.darwinsys.spdf.MoveTo;

/** Simple PDF-based Coupon Printer Servlet
 * @author Ian Darwin
 * @version $Id: PDFCouponServlet.java,v 1.2 2000/06/09 02:54:12 ian Exp $
 */
public class PDFCouponServlet extends HttpServlet {
	public void doGet(HttpServletRequest request,
		HttpServletResponse response) throws IOException {

		PrintWriter out = response.getWriter();
		response.setContentType("application/pdf");

		// Tell browser to try to display inline, but if not,
		// to save under the given filename.
		response.setHeader("Content-disposition",
			"inline; filename=\"MyCoupon.pdf\"");

		PDF p = new PDF(out);
		Page p1 = new Page(p);
		p1.add(new MoveTo(p, 100, 600));
		p1.add(new Text(p, 
			"This coupon good for one free coffee in the student lounge."));
		String name = request.getParameter("name");
		if (name == null)
			name = "unknown user";
		p1.add(new Text(p,
			"Printed for the exclusive use of " + name));
		p1.add(new Text(p,
			"by Ian Darwin's PDFCoupon Servlet and DarwinSys SPDF software"));
		p1.add(new Text(p, "at " + new Date().toString()));
		p.add(p1);
		p.setAuthor("Ian F. Darwin");

		// Write the PDF file page
		p.writePDF();
	}
}
//@@@@@@//
//servlet/Term.java
//@@@@@@//
public class Term {
	/** The term being defined */
	public String term;
	/** The definition of this term */
	public String definition;

	/** Constructor */
	public Term(String t, String d) {
		term = t;
		definition = d;
	}
}
//@@@@@@//
//servlet/Terms.java
//@@@@@@//
import java.io.*;
import java.util.*;

/** Statically pre-generate a Terms.html file. 
 * @author Ian Darwin
 * @version $Id: Terms.java,v 1.7 2002/01/30 14:05:48 ian Exp $
 */
public class Terms {
	public static void main(String[] args) throws IOException {
		PrintStream out = System.out;
		out.println("<HTML>");
		out.println("<TITLE>Ian Darwins Computer Terms and Acronyms</TITLE>");
		out.println("<BODY>");
		out.println("<H1>Ian Darwins Computer Terms and Acronyms</H1>");
		out.println("<TABLE BORDER=2>");
		out.println("<TR><TH>Term<TH>Meaning</TR>");

		// This part of the Servlet generates a list of lines like
		//	<TR> <TD>JSP <TD>Java Server Pages, a neat tool for ...
		TermsAccessor tax = new TermsAccessor("terms.txt");
		Iterator e = tax.iterator();
		while (e.hasNext()) {
			Term t = (Term)e.next();
			out.print("<TR><TD>");
			out.print(t.term);
			out.print("<TD>");
			out.print(t.definition);
			out.println("</TR>");
		}
		out.println("</TABLE>");
		out.println("<HR></HR>");
		out.println("<A HREF=\"servlet/TermsServletPDF\">Printer-friendly (Acrobat PDF) version</A>");
		out.println("<HR></HR>");
		out.println("<A HREF=\"http://www.darwinsys.com/contact.html\">Ask about another term</A>");
		out.println("<HR></HR>");
		out.println("<A HREF=\"index.html\">Back to HS</A> <A HREF=\"../\">Back to DarwinSys</A>");
		out.println("<HR></HR>");
		out.println("<H6>Produced by $Id: Terms.java,v 1.7 2002/01/30 14:05:48 ian Exp $");
		out.print(" using ");
		out.print(tax.ident);
		out.println("</H6>");
	}
}
//@@@@@@//
//servlet/TermsAccessor.java
//@@@@@@//
import java.io.*;
import java.util.*;

/** This class provides access to the list of terms and definitions,
 * hiding the physical location and organization of the data.
 */
public class TermsAccessor {
	protected BufferedReader is;
	protected String ident;

	/** constructor that takes a FileName */
	public TermsAccessor(String inputFileName) throws IOException {
		is = new BufferedReader(new FileReader(inputFileName));
		String ident = is.readLine();
	}

	/** return the identifier string from the source */
	public String getIdent() {
		return ident;
	}

	/** This iterator() method simply defines an inner class that
	 * each time hasNext() succeeds, calling next() will
	 * a Term object, containing the term and definition.
	 */
	public Iterator iterator() {
		return new Iterator() {
			String line, term, defn;

			/** The hasNext() method returns true up until end of file. */
			public boolean hasNext() {
				try {
					return ((line = is.readLine()) != null);
				} catch (IOException e) {
					System.err.println("IO Error: " + e);
					return false;
				}
			}

			/** The next() method returns the next available Term object */
			public Object next() {
				int i;
				// loop, ignoring invalid lines.
				while ((i = line.indexOf("\t"))<0 && hasNext());
					;
				if (line == null)
					throw new IllegalStateException("Invalid EOF state");
				term = line.substring(0, i);
				defn = line.substring(i+1);
				return new Term(term, defn);
			}

			/** The remove method is not implemented: just throws. */
			public void remove() {
				throw new UnsupportedOperationException();
			}
		};
	}
}
//@@@@@@//
//servlet/TermsServlet.java
//@@@@@@//
import java.io.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

/** A Servlet to list the dictionary terms.
 * @author Ian Darwin
 * @version $Id: TermsServlet.java,v 1.1 2000/04/06 19:28:19 ian Exp $
 */
public class TermsServlet extends HttpServlet {
	public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		PrintWriter out = resp.getWriter();
		out.println("<HTML>");
		out.println("<TITLE>Ian Darwin's Computer Terms and Acronyms</TITLE>");
		out.println("<BODY>");
		out.println("<H1>Ian Darwin's Computer Terms and Acronyms</H1>");
		out.println("<TABLE BORDER=2>");
		out.println("<TR><TH>Term<TH>Meaning</TR>");

		// This part of the Servlet generates a list of lines like
		//	<TR> <TD>JSP <TD>Java Server Pages, a neat tool for ...
		TermsAccessor tax = new TermsAccessor("terms.txt");
		Iterator e = tax.iterator();
		while (e.hasNext()) {
			Term t = (Term)e.next();
			out.print("<TR><TD>");
			out.print(t.term);
			out.print("<TD>");
			out.print(t.definition);
			out.println("</TR>");
		}
		out.println("</TABLE>");
		out.println("<HR></HR>");
		out.println("<A HREF=\"servlet/TermsServletPDF\">Printer-friendly (Acrobat PDF) version</A>");
		out.println("<HR></HR>");
		out.println("<A HREF=\"mailto:compquest@darwinsys.com/subject=Question\">Ask about another term</A>");
		out.println("<HR></HR>");
		out.println("<A HREF=\"index.html\">Back to HS</A> <A HREF=\"../\">Back to DarwinSys</A>");
		out.println("<HR></HR>");
		out.println("<H6>Produced by $Id: TermsServlet.java,v 1.1 2000/04/06 19:28:19 ian Exp $");
		out.print(" using ");
		out.print(tax.ident);
		out.println("</H6>");
	}
}
//@@@@@@//
//servlet/TermsServletPDF.java
//@@@@@@//
import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;
import java.util.*;
import com.pdflib.*;

/** Output the dictionary in fancy(?) PDF.
 * This version uses "PDFlib", from PDFLib.GmbH (www.pdflib.com).
 * @author Ian Darwin
 * @version $Id: TermsServletPDF.java,v 1.5 2004/02/09 03:34:01 ian Exp $
 */
public class TermsServletPDF extends HttpServlet {
	/** A printwriter for getting the response. */
	PrintWriter out;

	/** Handle the get request. */
	public void doGet(HttpServletRequest request,
		HttpServletResponse response) throws ServletException {

		try {

			out = new PrintWriter(response.getOutputStream());

			int font;
			pdflib p = new pdflib();

			if (p.open_file("") == -1) {
				warning(response,
					"Couldn't create in-memory PDF file", null);
				return;
			}

			p.set_info("Title", "Dictionary Project");
			p.set_info("Author", "Ian F. Darwin, http://www.darwinsys.com/");
			p.set_info("Creator", "www.darwinsys.com/dictionary");

			p.begin_page(595, 842);

			font = p.findfont("Helvetica", "host", 0);

			p.setfont(font, 14);

			// XXX for now just use one term from the Iterator
			Iterator e = new TermsAccessor("terms.txt").iterator();
			Term t = (Term)e.next();
			p.set_text_pos(50, 700);
			p.show("Term: ");
			p.continue_text(t.term);
			p.set_text_pos(70, 666);
			p.show("Definition: ");
			p.continue_text(t.definition);
			p.end_page();

			p.close();

			byte[] data = p.get_buffer();

			response.setContentType("application/pdf");
			response.getOutputStream().write(data);
		} catch (IOException e) {
			warning(response, "pdflib IO error:", e);
			return;
		} catch (Exception e) {
			warning(response, "pdflib error:", e);
			return;
		}
    }

	/** Generic error handler. 
	 * Can only use before writing to response's output stream.
	 */
	protected void warning(HttpServletResponse response, 
		String error, Exception e) {

		response.setContentType("text/html");
		try {
			PrintWriter out = response.getWriter();
		} catch (IOException exc) {
			// egad - we can't tell the user a thing!
			System.err.println("EGAD! IO error " + exc + " trying to tell user about " + error + " " + e);
			return;
		}
	    out.println("<H1>Error</H1>");
		out.print("<P>Oh dear. You seem to have run across an error in ");
		out.print("our dictionary formatter. We apologize for the inconvenience");
		out.print("<P>Error message is ");
		out.println(error);

		if (e != null) {
			out.print("<P>Exception is: ");
			out.println(e.toString());
			out.print("Traceback is: ");
			out.print("<PRE>");
			e.printStackTrace(out);
			out.print("</PRE>");
		}
		System.out.print("DictionaryServletPDF: ");
		System.out.println(error);
		if (e != null) {
			System.out.println(e.toString());
		}
	}
}
//@@@@@@//
//servlet/UploadServlet.java
//@@@@@@//
import javax.servlet.http.*;
import java.util.*;
import java.io.*;

public class UploadServlet extends HttpServlet {

	public void doPut(HttpServletRequest request,
			HttpServletResponse response)
	throws IOException, javax.servlet.ServletException {

		PrintWriter out = response.getWriter();
		Enumeration headers = request.getHeaderNames();
		while (headers.hasMoreElements()) {
			String name = headers.nextElement().toString();
			out.println("<li>" + name + " --> " +
				request.getHeader(name));
		}
		out.println("<HR>");
		int size = request.getIntHeader("content-length");
		// if (size > some_threshold) {
		//	out.println("<P>Too big!</P>");
		//	return;
		// }
		File f = new File("/tmp/abc.upload");
		//if (!f.createNewFile()) {
		//	out.println("File already exists");
		//	return;
		//}
		InputStream is = request.getInputStream();

		// DANGER WILL ROBINSON!! YOU MUST ADD CODE HERE TO
		// CHECK FOR TRAPS LIKE . or / or \ or : or File.separator in the filename

		OutputStream os = new FileOutputStream(f.getPath());
		
		byte[] b = new byte[1024];
		int n;
		while ((n = is.read(b)) > 0)
			os.write(b, 0, n);
		is.close();
		os.close();
		out.println("Successfully uploaded!");

		// Now you have to use JAF or something to
		// handle the MIME headers in the stream...
	}
}
//@@@@@@//
//spdf/Demo.java
//@@@@@@//
import com.darwinsys.spdf.PDF;
import com.darwinsys.spdf.Page;
import com.darwinsys.spdf.Text;
import com.darwinsys.spdf.MoveTo;
import java.io.*;

/** A simple text test of SPDF package
 */
public class Demo {
	public static void main(String[] argv) throws IOException {
		PrintWriter pout;
		if (argv.length == 0) {
			pout = new PrintWriter(System.out);
		} else {
			if (new File(argv[0]).exists()) {
				throw new IOException(
				"Output file " + argv[0] + " already exists");
			}
			pout = new PrintWriter(new FileWriter(argv[0]));
		}
		PDF p = new PDF(pout);
		Page p1 = new Page(p);
		p1.add(new MoveTo(p, 100, 600));
		p1.add(new Text(p, "Hello world, live on the web."));
		p1.add(new Text(p, "Hello world, line 2 on the web."));
		p.add(p1);
		p.setAuthor("Ian F. Darwin");
		p.writePDF();
	}
}
//@@@@@@//
//spdf/MoveTo.java
//@@@@@@//
package com.darwinsys.spdf;

/** Represent one Move object ("moveto") in a PDF file. */
public class MoveTo extends PDFObject {
	protected int x, y;

	public MoveTo(PDF m, int x, int y) {
		super(m);
		this.x = x;
		this.y = y;
	}

	public void print() {
		throw new IllegalStateException("print() called on a Text obj");
	}

	public void print(StringBuffer sb) {
		sb.append(x);
		sb.append(' ');
		sb.append(y);
		sb.append(" Td\n");
	}
}
//@@@@@@//
//spdf/Page.java
//@@@@@@//
package com.darwinsys.spdf;

import java.io.*;
import java.util.*;

/** Represent one Page of a PDF file. */
public class Page extends PDFDict {
	protected ArrayList objects = new ArrayList();

	public Page(PDF m) {
		super(m);
		dict.put("Type", "/Page");
		dict.put("Parent", "4 0 R");
		dict.put("Resources", "<< /Font << /F1 8 0 R >> /ProcSet 7 0 R >>");
		dict.put("MediaBox", "[0 0 612 792]");
		dict.put("Contents", "6 0 R");
		
	}

	public void add(PDFObject po) {
		objects.add(po);
	}

	/** Print all the objects on the page.
	 * For now, just print all the Text objects, as one Stream.
	 */
	protected void print() {
		// Print the Page object
		super.print();

		// Now do the Text objects as one PDF obj
		master.addXref();
		startObj();

		StringBuffer sb = new StringBuffer();
		sb.append("BT\n");
		sb.append("/F1 12 Tf\n");

		for (int i=0; i<objects.size(); i++) {
			PDFObject po = (PDFObject)objects.get(i);
			if (po instanceof Text)
				((Text)po).print(sb);
			else if (po instanceof MoveTo)
				((MoveTo)po).print(sb);
			// else if (po instanceof Font)
			//	...
			else
				System.err.println("PDFPage: ignoring " + po);
		}
		sb.append("ET\n");

		master.println("<< /Length " + sb.length() + " >>");
		master.println("stream");
		master.print(sb);
		master.println("endstream");
		endObj();
	}
}
//@@@@@@//
//spdf/PDF.java
//@@@@@@//
package com.darwinsys.spdf;

import java.io.*;
import java.text.*;
import java.util.*;

/** The main class for the Darwin Open Systems
 * {Simple,Stupid,Simplistic} PDF API.
 * PDF is Adobe's Portable Document Format, and is probably a trademark
 * of Adobe Systems Inc, Mountain View, California.
 * The Adobe PDF Specification which they publish grants everyone
 * permission to write code to generate and/or process PDF files.
 * A PDF Object represents one PDF file.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: PDF.java,v 1.6 2004/02/09 03:34:02 ian Exp $
 */
public class PDF {
	/** The output writer */
	protected PrintWriter out;

	/** The list of pages */
	protected ArrayList pages;

	/** The list of object xrefs */
	protected ArrayList xrefs;

	/** The root object */
	PDFObject rootObj = new RootObject(this);

	/** The Info object */
	InfoObject infoObj = new InfoObject(this);

	/** The outlines (outline font) object */
	OutlinesObject outlinesObj = new OutlinesObject(this);

	/** The Pages object */
	PagesObject pagesObj = new PagesObject(this);

	/** The Font Dictionary */
	FontDict fontDict = new FontDict(this);

	/** The object number of the current object */
	protected int currObj = 1;

	/** A flag to avoid writing twice */
	protected boolean startedWriting = false;

	/** A magic number that identifies the output as a PDF file */
	protected final static String PDF_MAGIC = "%PDF-1.0";

	/** Constructor */
	public PDF(PrintWriter o) {
		out = o;

		pages = new ArrayList();
		xrefs = new ArrayList();

	}

	public void add(Page p) {
		pages.add(p);
	}

	public void insertPage(int where, Page p) {
		pages.add(where, p);
	}

	// OUTPUT METHODS -- we provide our own print/println, so we
	// can keep track of file offsets (it was either that, or kludgily
	// use a RandomAccessFile and the getFilePointer() method).

	long offset = 0;

	/** Print a String */
	protected void print(String s){
		out.print(s);
		offset += s.length();
	}

	/** Println a String */
	protected void println(String s) {
		print(s);
		print("\n");
	}

	/** Print an Object */
	protected void print(Object o) {
		print(o.toString());
	}

	/** Println an Object */
	protected void println(Object o) {
		println(o.toString());
	}

	/** Print an int */
	protected void print(int i) {
		String s = Integer.toString(i);
		print(s);
	}

	/** Println an int */
	protected void println(int i) {
		String s = Integer.toString(i);
		print(s);
	}

	/** Println with no args */
	protected void println() {
		print("\n");
	}

	// END OF OUTPUT METHODS 

	/** Add an entry into the offset table */
	protected void addXref() {
		xrefs.add(new Long(offset));
	}

	/** Write the entire output */
	public void writePDF() {
		if (startedWriting) {
			throw new IllegalStateException(
				"writePDF() can only be called once.");
		}
		startedWriting = true;

		writePDFHeader();
		writePDFbody();
		writeXrefs();
		writePDFTrailer();
		out.flush();
		out.close();
	}

	protected void writePDFHeader() {
		println(PDF_MAGIC);

		rootObj.print();	// 1

		infoObj.print();	// 2

		outlinesObj.print(); // 3

		pagesObj.print();	// 4
	}

	protected void writePDFbody() {

		for (int i=0; i<pages.size(); i++) {
			 ((Page)pages.get(i)).print();		// 5, 6
		}

		addXref();
		print(currObj++); println(" 0 obj");
		println("[/PDF /Text]");
		println("endobj");

		fontDict.print();		// 8
	}

	DecimalFormat nf10 = new DecimalFormat("0000000000");
	DecimalFormat nf5 = new DecimalFormat("00000");

	/** Write one Xref, in the format 0000000000 65535 f */
	protected void printXref(long n, int where, char inUse) {
		println(nf10.format(n) + " " +  nf5.format(where) + " " + inUse);
	}

	long xrefStart;

	/** Write all the xrefs, using the format above */
	protected void writeXrefs() {
		xrefStart = offset;
		println("xref");
		print(0);
		print(" ");
		print(xrefs.size() + 1);
		println();
		// "fake" entry at 0, always 0, -1, f(free).
		printXref(0, 65535, 'f');
		// Remaining xref entries are for real objects.
		for (int i=0; i<xrefs.size(); i++) {
			Long lo = (Long)xrefs.get(i);
			long l = lo.longValue();
			printXref(l, 0, 'n');
		}

	}

	protected void writePDFTrailer() {
		println("trailer");
		println("<<");
		println("/Size " + (xrefs.size() + 1));
		println("/Root 1 0 R");
		println("/Info 2 0 R");
		println(">>");
		println("% startxref");
		println("% " + xrefStart);
		println("%%EOF");
	}

	class RootObject extends PDFDict {
		protected RootObject(PDF m) {
			super(m);
			dict.put("Type", "/Catalog");
			dict.put("Outlines", "3 0 R");
			dict.put("Pages", "4 0 R");
		}
	}

	class InfoObject extends PDFDict {
		protected InfoObject(PDF m) {
			super(m);
			dict.put("Title", "(Sample PDF by SPDF)");
			dict.put("Creator", "(Darwin Open Systems SPDF Software)");
			dict.put("Created", "(D:20000516010203)");
		}
	}
	
	public void setAuthor(String au) {
		infoObj.dict.put("Author", "(" + au + ")");
	}

	class OutlinesObject extends PDFDict {
		protected OutlinesObject(PDF m) {
			super(m);
			dict.put("Type", "/Outlines");
			dict.put("Count", "0");
		}
	}
	class PagesObject extends PDFDict {
		protected PagesObject(PDF m) {
			super(m);
			dict.put("Type", "/Pages");
			dict.put("Count", "1");
			dict.put("Kids", "[5 0 R]");
		}
	}

	class FontDict extends PDFDict {
		protected FontDict(PDF m) {
			super(m);
			dict.put("Type", "/Font");
			dict.put("Subtype", "/Type1");
			dict.put("Name", "/F1");
			dict.put("BaseFont", "/Helvetica");
			dict.put("Encoding", "/MacRomanEncoding");
		}
	}
}
//@@@@@@//
//spdf/PDFDict.java
//@@@@@@//
package com.darwinsys.spdf;

import java.util.*;

/** A PDFDict ias a PDFObject that is all, or mostly, a Dictionary.
 * @author Ian Darwin, http://www.darwinsys.com/
 */
public abstract class PDFDict extends PDFObject {
	/** The Dictionary is a HashTable. Put the keys without a 
	 * leading slash, since they always have it. Values can
	 * be /names, (strings), or whatever.
	 */
	protected Hashtable dict;

	PDFDict(PDF m) {
		super(m);
		dict = new Hashtable();
	}

	/** Write the object to the Output Writer. The default implementation
	 * of this method in PDFDict just calls startObj, printDict, and endObj.
	 */
	protected void print() {
		startObj();
		printDict();
		endObj();
	}

	protected void startObj() {
		// Record the starting position of this Obj in the xref table
		master.addXref();

		// Print out e.g., "42 0 obj"
		master.print(master.currObj++);
	 	master.print(" 0 obj");
		master.println();
	}

	protected void endObj() {
		master.println("endobj");
	}

	protected void printDict() {
		master.println("<<");
		Enumeration enum = dict.keys();
		while (enum.hasMoreElements()) {
			master.print("\t/");
			String key = (String)enum.nextElement();
			master.print(key);
			master.print(" ");
			master.print(dict.get(key));
			master.println();
		}
		master.println(">>");
	}
}
//@@@@@@//
//spdf/PDFObject.java
//@@@@@@//
package com.darwinsys.spdf;

import java.util.*;

/** A PDFObject represents one node in the tree of a PDF file.
 * @author Ian Darwin, http://www.darwinsys.com/
 */
public abstract class PDFObject extends java.lang.Object {
	/** The containing PDF file */
	protected PDF master;

	PDFObject(PDF m) {
		master = m;
	}

	/** Write the object to the Output Writer */
	protected abstract void print();

	protected void startObj() {
		// Record the starting position of this Obj in the xref table
		master.addXref();

		// Print out e.g., "42 0 obj"
		master.print(master.currObj++);
	 	master.print(" 0 obj");
		master.println();
	}

	protected void endObj() {
		master.println("endobj");
	}
}
//@@@@@@//
//spdf/Text.java
//@@@@@@//
package com.darwinsys.spdf;

import java.io.*;
import java.util.*;

/** Represent one Text object in a PDF file. */
public class Text extends PDFObject {
	protected int x, y;
	protected String text;

	public Text(PDF m, String s) {
		super(m);
		text = s;
	}

	public void print() {
		throw new IllegalStateException("print() called on a Text obj");
	}

	public void print(StringBuffer sb) {
		sb.append("0 -18 Td (");
		sb.append(text);	// TODO must substitute escaped characters
		sb.append(") Tj\n");
	}
}
//@@@@@@//
//starting/Buggy.java
//@@@@@@//
/** This program exhibits some bugs, so we can use a debugger */
public class Buggy {
	static String name;

	public static void main(String[] args) {
		int n = name.length();	// bug # 1

		System.out.println(n);

		name += "; The end.";	// bug #2
		System.out.println(name); // #3
	}
}
//@@@@@@//
//starting/circular/A.java
//@@@@@@//
public class A {
	B bample;

	public void foo() {
		bample.bar();
	}

	public void ingrid() {
		System.out.println("Hello. Ingrid.");
	}
}
//@@@@@@//
//starting/circular/B.java
//@@@@@@//
public class B {
	A ample;

	public void bar() {
		ample.ingrid();
	}
}
//@@@@@@//
//starting/circular/X.java
//@@@@@@//
public class X {
	Y yample;

	public void foo() {
		yample.bar();
	}

	public void close() {
		System.out.println("The circle of life is unbroken.");
	}
}
//@@@@@@//
//starting/circular/Y.java
//@@@@@@//
public class Y {
	Z zample;

	public void bar() {
		zample.czar();
	}
}
//@@@@@@//
//starting/circular/Z.java
//@@@@@@//
public class Z {
	X example;

	public void czar() {
		example.close();
	}
}
//@@@@@@//
//starting/Deprec.java
//@@@@@@//
import java.util.Date;

/** Demonstrate deprecation warning */
public class Deprec {

	public static void main(String[] av) {

		// Create a Date object for May 5, 1986
		Date d = 
			new Date(86, 04, 05);	// May 5, 1986 // EXPECT DEPRECATION WARNING
		System.out.println("Date is " + d);
	}
}
//@@@@@@//
//starting/EchoArgv.java
//@@@@@@//
/**
 * Simple echo/print client -- print command line arguments (argv) back
 * to the standard oubput.
 */
public class EchoArgv {
	public static void main(String[] args) {
		new EchoArgv().func(args);
	}
	private void func(String args[]) {
		for (int i=0; i<args.length; i++) {
			System.out.print(args[i] + " ");
		}
		System.out.println("");		// end with newline
	}
}
//@@@@@@//
//starting/Fetch.java
//@@@@@@//
public class Fetch {
	public static void main(String[] args) { 
		String name = "poem", value;
		Fetch f = new Fetch();
		if (System.getProperty("debug.fetch") != null) {
			System.err.println("Fetching " + name);
		}
		value = f.fetch(name);
	}
	public String fetch(String name) {
		// in real life this would look up "name" in some table or database
		return "jabberwocky";
	}
}
//@@@@@@//
//starting/FetchDebug.java
//@@@@@@//
import com.darwinsys.util.Debug;

public class FetchDebug {
	public static void main(String[] args) { 
		String name = "poem", value;
		Fetch f = new Fetch();
		Debug.println("fetch", "Fetching " + name);
		value = f.fetch(name);
	}
	public String fetch(String name) {
		// in real life this would look up "name" in some table or database
		return "jabberwocky";
	}
}
//@@@@@@//
//starting/FinalMethods.java
//@@@@@@//
/** Investigate inlining of final methods.
 * You need to investigate the resulting class file
 * when generated from various compilers and options.
 */
public final class FinalMethods {
	public static void main(String[] args) {
		new FinalMethods().work();
	}

	public void work() {
		methodA();
		methodB();
		methodC();
	}

	public void methodA() {
		System.out.println("In MethodA");
	}

	private final void methodB() {
		System.out.println("In MethodB");
	}

	public void methodC() {
		System.out.println("In MethodC");
	}
}
//@@@@@@//
//starting/GetJavaVersion.java
//@@@@@@//
/**
 * Just print the Java runtime version, e.g., 1.3, 1.4, 1.5, ...
 */
public class GetJavaVersion {
	public static void main(String[] args) {
		System.out.println(System.getProperty("java.specification.version"));
	}
}
//@@@@@@//
//starting/HelloWorld.java
//@@@@@@//
/**
 * Your basic, minimal, Hello World type program in Java.
 */
public class HelloWorld {
	public static void main(String[] argv) {
		System.out.println("Hello, World");

	}
}
//@@@@@@//
//starting/IfDef.java
//@@@@@@//
/** Simple test to show if compilers exclude code that can't be reached. */
public class IfDef {
	public static void main(String[] argv) {
		final boolean DEBUG = false;
		System.out.println("Hello, World");
		if (DEBUG)
			System.out.println("Life is a voyage, not a destination.");
	}
}
//@@@@@@//
//starting/TestFor1_1.java
//@@@@@@//
/** Check *by features* for JDK >= 1.1 */
public class TestFor1_1 {
	public static void main(String[] args) {
		try {
			Class.forName("java.lang.reflect.Constructor");
			System.out.println("OK, pal, this JVM is 1.1 or later");
		} catch (ClassNotFoundException e) {
			String failure = 
				"Sorry, but this program needs a Java\n" +
				"Runtime based on Java JDK 1.1 or later";
			System.err.println(failure);
			throw new IllegalArgumentException(failure);
		}
	}
}
//@@@@@@//
//starting/TestForClass.java
//@@@@@@//
/** Test for presence of class named in argv[0] on classpath at runtime.
 * This uses Reflectance (see chapter "Introspection, or a Class named Class")
 * to find out if the given class (named on the command line) is present
 * in the user's classpath at runtime. The class should not be "import"ed
 * because we don't want to check it at compile time, only at runtime.
 @ @return 0 if OK, 1 if class not found, 2 if used incorrectly.
 */
public class TestForClass {
	public static void main(String[] argv) {
		if (argv.length != 1) {
			System.err.println("Usage: TestForClass className");
			System.exit(2);
		}
		try {
			String className = argv[0];
			Class.forName(className);
			System.exit(0);		// It worked.
		} catch (ClassNotFoundException e) {
			// No diagnostic message printed: this is for use in
			// batch files to set the exit status only.
			System.exit(1);		// Class not found.
		}
		/** NotReached */
		System.exit(2);
	}
}
//@@@@@@//
//starting/TestForSwing.java
//@@@@@@//
/** Test for presence of Swing on classpath at runtime.
 */
public class TestForSwing {
	public static void main(String[] args) {
		try {
			Class.forName("javax.swing.JButton");
		} catch (ClassNotFoundException e) {
			String failure = 
				"Sorry, but this version of MyApp needs \n" +
				"a Java Runtime with JFC/Swing components\n" +
				"having the final names (javax.swing.*)";
			System.err.println(failure);
			// Make something appear in the GUI. Either a JOptionPane, or:
			// myPanel.add(new Label(failure));
			throw new IllegalArgumentException(failure);
		}
		// No need to print anything here - the GUI should work...
	}
}
//@@@@@@//
//strings/AllTests.java
//@@@@@@//
import junit.framework.Test;
import junit.framework.TestSuite;

/**
 * JUnit tests for some of my String demos.
 */
public class AllTests {

	public static void main(String[] args) {
		junit.textui.TestRunner.run(AllTests.class);
	}

	public static Test suite() {
		TestSuite suite = new TestSuite("Test for default package");
		//$JUnit-BEGIN$
		suite.addTestSuite(CSVTest.class);
		suite.addTestSuite(CSVRETest.class);
		suite.addTestSuite(EnTabTest.class);
		suite.addTestSuite(SoundexTest.class);
		suite.addTestSuite(StringAlignTest.class);
		suite.addTestSuite(TabsTest.class);
		suite.addTestSuite(DeTabTest.class);
		//$JUnit-END$
		return suite;
	}
}
//@@@@@@//
//strings/Case.java
//@@@@@@//
/**
 * Control case.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Case.java,v 1.3 2004/02/09 03:34:03 ian Exp $
 */
public class Case {
	public static void main(String[] argv) {
		//+
		String name = "Java Cookbook";
		System.out.println("Normal:\t" + name);
		System.out.println("Upper:\t" + name.toUpperCase());
		System.out.println("Lower:\t" + name.toLowerCase());
		String javaName = "java cookBook"; // If it were Java identifiers :-)
		if (!name.equals(javaName))
			System.err.println("equals() correctly reports false");
		else
			System.err.println("equals() incorrectly reports true");
		if (name.equalsIgnoreCase(javaName))
			System.err.println("equalsIgnoreCase() correctly reports true");
		else
			System.err.println("equalsIgnoreCase() incorrectly reports false");
		//-
	}
}
//@@@@@@//
//strings/CheckSum.java
//@@@@@@//
import java.io.*;

/** CheckSum - print the checksum of a file
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: CheckSum.java,v 1.6 2004/06/16 20:40:47 ian Exp $
 */

public class CheckSum {
    public static void main(String[] av) {
        CheckSum c = new CheckSum();
		int sum = 0;
        if (av.length == 0)
            sum = c.process(new BufferedReader(
					new InputStreamReader(System.in)));
        else for (int i=0; i<av.length; i++)
			try {
				sum += c.process(new BufferedReader(new FileReader(av[i])));
			} catch (FileNotFoundException e) {
				System.err.println(e);
			}
		System.out.println(sum);
    }


    /** CheckSum one text file, given an open BufferedReader.
	 * Checksumm does not include line endings, so will give the
	 * same value for given text on any platform. Do not use
	 * on binary files!
	 */
    public int process(BufferedReader is) {
		int sum = 0;
        try {
            String inputLine;

            while ((inputLine = is.readLine()) != null) {
				int i;
				for (i=0; i<inputLine.length(); i++) {
					sum += inputLine.charAt(i);
				}
            }
            is.close();
        } catch (IOException e) {
            System.out.println("IOException: " + e);
		}
		return sum;
    }
}
//@@@@@@//
//strings/CSV.java
//@@@@@@//
import java.util.*;

import com.darwinsys.util.Debug;

/** Parse comma-separated values (CSV), a common Windows file format.
 * Sample input: "LU",86.25,"11/4/1998","2:19PM",+4.0625
 * <p>
 * Inner logic adapted from a C++ original that was
 * Copyright (C) 1999 Lucent Technologies
 * Excerpted from 'The Practice of Programming'
 * by Brian W. Kernighan and Rob Pike.
 * <p>
 * Included by permission of the http://tpop.awl.com/ web site, 
 * which says:
 * "You may use this code for any purpose, as long as you leave 
 * the copyright notice and book citation attached." I have done so.
 * @author Brian W. Kernighan and Rob Pike (C++ original)
 * @author Ian F. Darwin (translation into Java and removal of I/O)
 * @author Ben Ballard (rewrote advQuoted to handle '""' and for readability)
 */
public class CSV {	

	public static final char DEFAULT_SEP = ',';

	/** Construct a CSV parser, with the default separator (`,'). */
	public CSV() {
		this(DEFAULT_SEP);
	}

	/** Construct a CSV parser with a given separator. 
	 * @param sep The single char for the separator (not a list of
	 * separator characters)
	 */
	public CSV(char sep) {
		fieldSep = sep;
	}

	/** The fields in the current String */
	protected List list = new ArrayList();

	/** the separator char for this parser */
	protected char fieldSep;

	/** parse: break the input String into fields
	 * @return java.util.Iterator containing each field 
	 * from the original as a String, in order.
	 */
	public List parse(String line)
	{
		StringBuffer sb = new StringBuffer();
		list.clear();			// recycle to initial state
		int i = 0;

		if (line.length() == 0) {
			list.add(line);
			return list;
		}

		do {
            sb.setLength(0);
            if (i < line.length() && line.charAt(i) == '"')
                i = advQuoted(line, sb, ++i);	// skip quote
            else
                i = advPlain(line, sb, i);
            list.add(sb.toString());
            Debug.println("csv", sb.toString());
			i++;
		} while (i < line.length());

		return list;
	}

	/** advQuoted: quoted field; return index of next separator */
	protected int advQuoted(String s, StringBuffer sb, int i)
	{
		int j;
		int len= s.length();
        for (j=i; j<len; j++) {
            if (s.charAt(j) == '"' && j+1 < len) {
                if (s.charAt(j+1) == '"') {
                    j++; // skip escape char
                } else if (s.charAt(j+1) == fieldSep) { //next delimeter
                    j++; // skip end quotes
                    break;
                }
            } else if (s.charAt(j) == '"' && j+1 == len) { // end quotes at end of line
                break; //done
			}
			sb.append(s.charAt(j));	// regular character.
		}
		return j;
	}

	/** advPlain: unquoted field; return index of next separator */
	protected int advPlain(String s, StringBuffer sb, int i)
	{
		int j;

		j = s.indexOf(fieldSep, i); // look for separator
		Debug.println("csv", "i = " + i + ", j = " + j);
        if (j == -1) {               	// none found
            sb.append(s.substring(i));
            return s.length();
        } else {
            sb.append(s.substring(i, j));
            return j;
        }
    }
}
//@@@@@@//
//strings/CSVFile.java
//@@@@@@//
import java.io.*;
import java.util.*;

/** CSV in action: lines from a file and print. */
public class CSVFile {

	public static void main(String[] args) throws IOException {
	
		// Construct a new CSV parser.
		CSV csv = new CSV();

		if (args.length == 0) {	// read standard input
			BufferedReader is = new BufferedReader(
				new InputStreamReader(System.in));
			process(csv, is);
		} else {
			for (int i=0; i<args.length; i++) {
				process(csv, new BufferedReader(new FileReader(args[i])));
			}
		}
	}

	protected static void process(CSV csv, BufferedReader is) throws IOException {
		String line;
		while ((line = is.readLine()) != null) {
			System.out.println("line = `" + line + "'");
			Iterator e = csv.parse(line).iterator();
			int i = 0;
			while (e.hasNext()) 
				System.out.println("field[" + i++ + "] = `" +
					e.next() + "'");
		}
	}
}
//@@@@@@//
//strings/CSVRE.java
//@@@@@@//
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/* Simple demo of CSV matching using Regular Expressions.
 * Does NOT use the "CSV" class defined in the Java CookBook, but uses
 * a regex pattern simplified from Chapter 7 of <em>Mastering Regular 
 * Expressions</em> (p. 205, first edn.)
 * @version $Id: CSVRE.java,v 1.16 2004/04/25 19:43:32 ian Exp $
 */
public class CSVRE {	
	/** The rather involved pattern used to match CSV's consists of three
	 * alternations: the first matches aquoted field, the second unquoted,
	 * the third a null field.
	 */
	public static final String CSV_PATTERN = "\"([^\"]+?)\",?|([^,]+),?|,";
	private static Pattern csvRE;

	public static void main(String[] argv) throws IOException {
		System.out.println(CSV_PATTERN);
		new CSVRE().process(new BufferedReader(new InputStreamReader(System.in)));
	}
	
	/** Construct a regex-based CSV parser. */
	public CSVRE() {
		csvRE = Pattern.compile(CSV_PATTERN);
	}
	
	/** Process one file. Delegates to parse() a line at a time */
	public void process(BufferedReader in) throws IOException {
		String line;

		// For each line...
		while ((line = in.readLine()) != null) {
			System.out.println("line = `" + line + "'");
			List l = parse(line);
			System.out.println("Found " + l.size() + " items.");
			for (int i = 0; i < l.size(); i++) {
				System.out.print(l.get(i) + ",");
			}
			System.out.println();
		}
	}
	
	/** Parse one line.
	 * @return List of Strings, minus their double quotes
	 */
	public List parse(String line) {
		List list = new ArrayList();
		Matcher m = csvRE.matcher(line);
		// For each field
		while (m.find()) {
			String match = m.group();
			if (match == null)
				break;
			if (match.endsWith(",")) {	// trim trailing ,
				match = match.substring(0, match.length() - 1);
			}
			if (match.startsWith("\"")) { // assume also ends with
				match = match.substring(1, match.length() - 1);
			}
			if (match.length() == 0)
				match = null;
			list.add(match);
		}
		return list;
	}
}
//@@@@@@//
//strings/CSVRETest.java
//@@@@@@//
import java.util.List;

import junit.framework.TestCase;

/**
 * name - purpose
 * @version $Id: CSVRETest.java,v 1.3 2004/04/25 19:43:32 ian Exp $
 */
public class CSVRETest extends TestCase {
	CSVRE target = new CSVRE();
	
	public void testCanonical() {
		List list = target.parse("\"a\",\"b\",\"c\"");
		assertEquals(3, list.size());
		assertEquals("a", list.get(0));
		assertEquals("b", list.get(1));
		assertEquals("c", list.get(2));
	}
	public void testNullField() {
		List list = target.parse("\"a\",,\"c\"");
		assertEquals(3, list.size());
		assertEquals("a", list.get(0));
		assertEquals(null, list.get(1));
		assertEquals("c", list.get(2));
	}
	public void testNotAllQuoted() {
		List list = target.parse("\"a\",b,\"c\"");
		assertEquals(3, list.size());
		assertEquals("a", list.get(0));
		assertEquals("b", list.get(1));
		assertEquals("c", list.get(2));
	}
	public void testAllUnQuoted() {
		List list = target.parse("a,b,c");
		assertEquals(3, list.size());
		assertEquals("a", list.get(0));
		assertEquals("b", list.get(1));
		assertEquals("c", list.get(2));
	}
	public void testMixedField() {
		List list = target.parse("\"LU\",86.25|\"11/4/1998\"|\"2:19PM\"|+4.0625");
		assertEquals(2, list.size());
	}
}
//@@@@@@//
//strings/CSVSimple.java
//@@@@@@//
import java.util.*;

/* Simple demo of CSV parser class.
 */
public class CSVSimple {	
	public static void main(String[] args) {
		CSV parser = new CSV();
		List list = parser.parse(
			"\"LU\",86.25,\"11/4/1998\",\"2:19PM\",+4.0625");
		Iterator it = list.iterator();
		while (it.hasNext()) {
			System.out.println(it.next());
		}

		// Now test with a non-default separator
		parser = new CSV('|');
		list = parser.parse(
			"\"LU\"|86.25|\"11/4/1998\"|\"2:19PM\"|+4.0625");
		it = list.iterator();
		while (it.hasNext()) {
			System.out.println(it.next());
		}
	}
}
//@@@@@@//
//strings/CSVTest.java
//@@@@@@//
import java.util.Iterator;
import java.util.List;

import junit.framework.TestCase;


/**
 * @author ian
 */
public class CSVTest extends TestCase {

	public static void main(String[] args) {
		junit.textui.TestRunner.run(CSVTest.class);
	}
	
	CSV csv = new CSV();

	String[] data = { 
		"abc",
		"hello, world",
		"a,b,c",
		"a\"bc,d,e",
		"\"a,a\",b,\"c:\\foo\\bar\"",
		"\"he\"llo",
		"123,456",
		"\"LU\",86.25,\"11/4/1998\",\"2:19PM\",+4.0625",
		"bad \"input\",123e01",
		//"XYZZY,\"\"|\"OReilly & Associates| Inc."|"Darwin| Ian"|"a \"glug\" bit|"|5|"Memory fault| core NOT dumped"

	};
	int[] listLength = {
					1,
					2,
					3,
					3,
					3,
					1,
					2,
					5,
					2
	};
	
	/** test all the Strings in "data" */
	public void testCSV() {
		for (int i = 0; i < data.length; i++){
			List l = csv.parse(data[i]);
			assertEquals(l.size() , listLength[i]);
			for (int k = 0; k < l.size(); k++){
				System.out.print("[" + l.get(k) + "],");
			}
			System.out.println();
		}
	}
	
	/** Test one String with a non-default delimiter */
	public void testBarDelim() {
		// Now test slightly-different string with a non-default separator
		CSV parser = new CSV('|'); 
		List l = parser.parse(
			"\"LU\"|86.25|\"11/4/1998\"|\"2:19PM\"|+4.0625");
		assertEquals(l.size(), 5);
		Iterator it = l.iterator();
		while (it.hasNext()) {
			System.out.print("[" + it.next() + "],");
		}
		System.out.println();
	}
}
//@@@@@@//
//strings/DeTab.java
//@@@@@@//
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

/** detab- replace blanks by tabs and blanks.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: DeTab.java,v 1.3 2004/02/22 21:16:39 ian Exp $
 */
public class DeTab {
	Tabs ts;
	
	public static void main(String[] argv) throws IOException {
		DeTab dt = new DeTab(8);
		dt.detab(new BufferedReader(new InputStreamReader(System.in)),
				new PrintWriter(System.out));
	}

	public DeTab(int n) {
		ts = new Tabs(n);
	}
	public DeTab() {
		ts = new Tabs();
	}

	/** detab one file (replace tabs with spaces)
	 * @param is - the file to be processed
	 * @param out - the updated file
	 */
	public void detab(BufferedReader is, PrintWriter out) throws IOException {
		String line;
		char c;
		int col;
		while ((line = is.readLine()) != null) {
			out.println(detabLine(line));
		}
	}
	
	/** detab one line (replace tabs with spaces)
	 * @param line - the line to be processed
	 * @return the updated line
	 */
	public String detabLine(String line) {
		char c;
		int col;
		StringBuffer sb = new StringBuffer();
		col = 0;
		for (int i = 0; i < line.length(); i++) {
			// Either ordinary character or tab.
			if ((c = line.charAt(i)) != '\t') {
				sb.append(c); // Ordinary
				++col;
				continue;
			}
			do { // Tab, expand it, must put >=1 space
				sb.append(' ');
			} while (!ts.isTabStop(++col));
		}
		return sb.toString();
	}
}

//@@@@@@//
//strings/DeTabTest.java
//@@@@@@//
import junit.framework.TestCase;

/**
 * Simple tests for DeTab.
 */
public class DeTabTest extends TestCase {

	DeTab dt = new DeTab(8);
	
	protected void setUp() throws Exception {
		super.setUp();
	}

	public static void main(String[] args) {
		junit.textui.TestRunner.run(DeTabTest.class);
	}

	public void testIdempotency() {
		assertEquals("", dt.detabLine(""));
		assertEquals(" a ", dt.detabLine(" a "));
	}
	
	public void testDetabLine(){
		assertEquals("       A", dt.detabLine("\tA"));
	}
}
//@@@@@@//
//strings/EnTab.java
//@@@@@@//
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.io.PrintWriter;

import com.darwinsys.util.Debug;

/**
 * EnTab: replace blanks by tabs and blanks. Transmuted from K&R Software Tools
 * book into C. Transmuted again, years later, into Java. Totally rewritten to
 * be line-at-a-time instead of char-at-a-time.
 * 
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: EnTab.java,v 1.11 2004/02/22 21:21:44 ian Exp $
 */
public class EnTab {
	/** The Tabs (tab logic handler) */
	protected Tabs tabs;

	/**
	 * Delegate tab spacing information to tabs.
	 * 
	 * @return
	 */
	public int getTabSpacing() {
		return tabs.getTabSpacing();
	}

	/**
	 * Main program: just create an EnTab object, and pass the standard input
	 * or the named file(s) through it.
	 */
	public static void main(String[] argv) throws IOException {
		EnTab et = new EnTab(8);
		if (argv.length == 0) // do standard input
			et.entab(
				new BufferedReader(new InputStreamReader(System.in)),
				System.out);
		else
			for (int i = 0; i < argv.length; i++) { // do each file
				et.entab(
					new BufferedReader(new FileReader(argv[i])),
					System.out);
			}
	}

	/**
	 * Constructor: just save the tab values.
	 * 
	 * @param n
	 *            The number of spaces each tab is to replace.
	 */
	public EnTab(int n) {
		tabs = new Tabs(n);
	}

	public EnTab() {
		tabs = new Tabs();
	}

	/**
	 * entab: process one file, replacing blanks with tabs.
	 * 
	 * @param is A BufferedReader opened to the file to be read.
	 * @param out a PrintWriter to send the output to.
	 */
	public void entab(BufferedReader is, PrintWriter out) throws IOException {
		String line;
		int c, col = 0, newcol;

		// main loop: process entire file one line at a time.
		while ((line = is.readLine()) != null) {
			out.println(entabLine(line));
		}
	}
	/**
	 * entab: process one file, replacing blanks with tabs.
	 * 
	 * @param is A BufferedReader opened to the file to be read.
	 * @param out A PrintStream to write the output to.
	 */
	public void entab(BufferedReader is, PrintStream out) throws IOException {
		entab(is, new PrintWriter(out));
	}

	/**
	 * entabLine: process one line, replacing blanks with tabs.
	 * 
	 * @param line -
	 *            the string to be processed
	 */
	public String entabLine(String line) {
		int N = line.length(), outCol = 0;
		StringBuffer sb = new StringBuffer();
		char ch;
		int consumedSpaces = 0;
		
		for (int inCol = 0; inCol < N; inCol++) {
			ch = line.charAt(inCol);
			// If we get a space, consume it, don't output it.
			// If this takes us to a tab stop, output a tab character.
			if (ch == ' ') {
				Debug.println("space", "Got space at " + inCol);
				if (!tabs.isTabStop(inCol)) {
					consumedSpaces++;
				} else {
					Debug.println("tab", "Got a Tab Stop " + inCol);
					sb.append('\t');
					outCol += consumedSpaces;
					consumedSpaces = 0;
				}
				continue;
			}

			// We're at a non-space; if we're just past a tab stop, we need
			// to put the "leftover" spaces back out, since we consumed
			// them above.
			while (inCol-1 > outCol) {
				Debug.println("pad", "Padding space at " + inCol);
				sb.append(' ');
				outCol++;
			}

			// Now we have a plain character to output.
			sb.append(ch);
			outCol++;

		}
		// If line ended with trailing (or only!) spaces, preserve them.
		for (int i = 0; i < consumedSpaces; i++) {
			Debug.println("trail", "Padding space at end # " + i);
			sb.append(' ');
		}
		return sb.toString();
	}
}
//@@@@@@//
//strings/EnTabTest.java
//@@@@@@//
import junit.framework.TestCase;

/**
 * @author ian
 * 
 * To change the template for this generated type comment go to Window -
 * Preferences - Java - Code Generation - Code and Comments
 */
public class EnTabTest extends TestCase {

	public static void main(String[] args) {
		junit.textui.TestRunner.run(EnTabTest.class);
	}
	EnTab t4, t8;

	/* (non-Javadoc)
	 * @see junit.framework.TestCase#setUp()
	 */
	protected void setUp() throws Exception {
		super.setUp();
		t4 = new EnTab(4);
		t8 = new EnTab();
		// For com.darwinsys.util.Debug: uncomment only 
		// "when you find yourself in times of trouble..."
		//System.setProperty("debug.tab", "true");
		//System.setProperty("debug.pad", "true");
		//System.setProperty("debug.space", "true");
	}

	public void testGetTabSpacingDelegation() {
		assertEquals(4, t4.getTabSpacing());
		assertEquals(8, t8.getTabSpacing());
	}
	
	public void testIdempotency() {
		assertEquals("", t4.entabLine(""));
		assertEquals("", t8.entabLine(""));
		assertEquals(" ", t4.entabLine(" "));
		assertEquals("abcde", t4.entabLine("abcde"));
	}
	
	public void testLeadingTabs() {
		System.out.println(t4.entabLine("    A"));
		assertEquals("\tA", t4.entabLine("    A"));
	}
}
//@@@@@@//
//strings/Equality.java
//@@@@@@//
public class Equality {
	public static void main(String[] args) { 
		new Equality().run();
	}

	public void run() {
		String x = "hello";

		String y = Equality2.getString();
	
		// Assuming Equality2 uses a String constant, this prints true,true
		compare(x, y);

		// A "new String" is uniquely created, so this prints false, true
		compare(x, new String(y));

		// The substring operator creates a new String, prints false, true
		compare(x, "hello world".substring(0, 5));

		// The intern() operator returns a string from the pool of unique
		// strings, so this should print true, true.
		compare(x, new String(x).intern());
	}

	public void compare(String s1, String s2) {

		System.out.print("==:       ");
		System.out.println(s1 == s2);
		System.out.println(".equals():" + s1.equals(s2));
		System.out.println(); 
	}
}
//@@@@@@//
//strings/Equality2.java
//@@@@@@//
public class Equality2 {
	public static String getString() {
		return "hello";
	}
}
//@@@@@@//
//strings/Fmt.java
//@@@@@@//
import java.io.*;
import java.util.*;

/**
 * Fmt - format text (like Berkeley UNIX fmt).
 */
public class Fmt {
	/** The maximum column width */
	public static final int COLWIDTH=72;
	/** The file that we read and format */
	BufferedReader in;

	/** If files present, format each, else format the standard input. */
	public static void main(String[] av) throws IOException {
		if (av.length == 0)
			new Fmt(System.in).format();
		else for (int i=0; i<av.length; i++)
			new Fmt(av[i]).format();
	}

	/** Construct a Formatter given a filename */
	public Fmt(String fname) throws IOException {
		in = new BufferedReader(new FileReader(fname));
	}

	/** Construct a Formatter given an open Stream */
	public Fmt(InputStream file) throws IOException {
		in = new BufferedReader(new InputStreamReader(file));
	}

	/** Format the File contained in a constructed Fmt object */
	public void format() throws IOException {
		String w, f;
		int col = 0;
		while ((w = in.readLine()) != null) {
			if (w.length() == 0) {	// null line
				System.out.print("\n");		// end current line
				if (col>0) {
					System.out.print("\n");	// output blank line
					col = 0;
				}
				continue;
			}

			// otherwise it's text, so format it.
			StringTokenizer st = new StringTokenizer(w);
			while (st.hasMoreTokens()) {
				f = st.nextToken();

				if (col + f.length() > COLWIDTH) {
					System.out.print("\n");
					col = 0;
				}
				System.out.print(f + " ");
				col += f.length() + 1;
			}
		}
		if (col>0) System.out.print("\n");
		in.close();
	}
}
//@@@@@@//
//strings/Fmt2.java
//@@@@@@//
import java.io.*;
import java.util.*;

/**
 * Fmt - format text (like Berkeley UNIX fmt, with a few troff commands).
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Fmt2.java,v 1.6 2004/02/09 03:34:03 ian Exp $
 */
public class Fmt2 extends Fmt {
	/** The maximum column width */
	public static final int COLWIDTH=72;
	/** The constant for formatted mode */
	protected final int MODE_FI = 1;
	/** The constant for UNformatted mode */
	protected final int MODE_NF = 0;
	/** The current formatting mode */
	protected int mode = MODE_FI;
	/** The current output column. */
	protected int col = 0;

	public static void main(String[] av) throws IOException {
		if (av.length == 0)
			new Fmt2("-").format();
		else for (int i=0; i<av.length; i++)
			new Fmt2(av[i]).format();
	}

	/** Construct a Formatter given a filename, or "-" for stdin */
	public Fmt2(String fname) throws IOException {
		super(fname);
	}

	/** The Array of commands */
	Command[] commands = {
		new Command("br") { void action() { spaceLine(0); } },
		new Command("bp") { void action() { put("\f"); /*formfeed*/} },
		new Command("fi") { void action() { mode = MODE_FI; } },
		new Command("nf") { void action() { mode = MODE_NF; spaceLine(0);} },
		new Command("sp") { void action() { spaceLine(1); } },
	};

	/** Format the File contained in a constructed Fmt object */
	public void format() throws IOException {
		String w, f;
		col = 0;
outer:
		while ((w = in.readLine()) != null) {
			if (w.length() == 0) {	// null line
				spaceLine(1);
				continue;
			}
			if (w.startsWith(".")) {// troff command, handle it.
				for (int i=0; i<commands.length; i++) {
					Command v = commands[i];
					if (v.cmdName.equals(w.substring(1, 3))) {
						v.action();
						continue outer;
					} 
				}
				// else an unrecognized troff command
				if (col>0) putln();	// flush
				putln(w);
				col = 0;
				continue;
			}

			// otherwise it's text, so deal with it.
			if (mode == MODE_NF) {
				putln(w);
				continue;
			}

			// else, we have to format it.
			StringTokenizer st = new StringTokenizer(w);
			while (st.hasMoreTokens()) {
				f = st.nextToken();

				if (col + f.length() > COLWIDTH) {
					putln();
					col = 0;
				}
				put(f + " ");
				col += f.length() + 1;
			}
		}
		if (col>0) putln();
		in.close();
	}

	/* Break the current line, and output nLines blank lines */
	void spaceLine(int nLines) {
		if (col>0) {
			putln();	// output blank line
			col = 0;
		}
		for (int i=0; i<nLines; i++)
			putln();
	}

	/** Put a string to the output, with a newline, i.e., output a newline */
	protected void putln(String s) {
		System.out.println(s);
	}

	/** Put the null string to the output as a line */
	protected void putln() {
		System.out.println();
	}

	/** Put a string to the output */
	protected void put(String s) {
		System.out.print(s);
	}
}

/** A Command is a formatter command: it has a name and an action. */
abstract class Command {
	String cmdName;
	abstract void  action();
	Command(String s) {
		cmdName = s;
	}
}
//@@@@@@//
//strings/Indent.java
//@@@@@@//
import java.io.*;

/** Indent - prepend leading spaces
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Indent.java,v 1.3 2004/02/09 03:34:03 ian Exp $
 */

public class Indent {
	/** the default number of spaces. */
	static int nSpaces = 10;

    public static void main(String[] av) {
        Indent c = new Indent();
        switch(av.length) {
            case 0: c.process(new BufferedReader(
                        new InputStreamReader(System.in))); break;
            default:
		for (int i=0; i<av.length; i++)
			try {
				c.process(new BufferedReader(new FileReader(av[i])));
			} catch (FileNotFoundException e) {
				System.err.println(e);
			}
        }
    }

    /** print one file, given an open BufferedReader */
    public void process(BufferedReader is) {
        try {
            String inputLine;

			//+
            while ((inputLine = is.readLine()) != null) {
				for (int i=0; i<nSpaces; i++) System.out.print(' ');
                System.out.println(inputLine);
            }
			//-
            is.close();
        } catch (IOException e) {
            System.out.println("IOException: " + e);
        }
    }
}
//@@@@@@//
//strings/NullChar.java
//@@@@@@//
/**
 * NullChar - see if you can have null characters in a String.
 */
public class NullChar {
	public static void main(String[] argv) {
		System.out.println("ABC\u0000DEF");
	}
}
//@@@@@@//
//strings/Replace.java
//@@@@@@//
public class Replace {
	public static void main(String[] args) {
		System.out.println(
			replace("lazy", "supine", "A quick bronze fox lept a lazy bovine"));
		System.out.println(
			replace("$DIR", "/home/ian", "$DIR/xxx"));
	}

	public static String replace(String oldStr, String newStr, String inString) {
		int start = inString.indexOf(oldStr);
		if (start == -1) {
			return inString;
		}
		StringBuffer sb = new StringBuffer();
		sb.append(inString.substring(0, start));
		sb.append(newStr);
		sb.append(inString.substring(start+oldStr.length()));
		return sb.toString();
	}
} 
//@@@@@@//
//strings/Soundex.java
//@@@@@@//
import com.darwinsys.util.Debug;

/**
 * Soundex - the Soundex Algorithm, as described by Knuth
 * <p>
 * This class implements the soundex algorithm as described by Donald
 * Knuth in Volume 3 of <I>The Art of Computer Programming</I>.  The
 * algorithm is intended to hash words (in particular surnames) into
 * a small space using a simple model which approximates the sound of
 * the word when spoken by an English speaker.  Each word is reduced
 * to a four character string, the first character being an upper case
 * letter and the remaining three being digits. Double letters are
 * collapsed to a single digit.
 * 
 * <h2>EXAMPLES</h2>
 * Knuth's examples of various names and the soundex codes they map
 * to are:
 * <b>Euler, Ellery -> E460
 * <b>Gauss, Ghosh -> G200
 * <b>Hilbert, Heilbronn -> H416
 * <b>Knuth, Kant -> K530
 * <b>Lloyd, Ladd -> L300
 * <b>Lukasiewicz, Lissajous -> L222
 * 
 * <h2>LIMITATIONS</h2>
 * As the soundex algorithm was originally used a <B>long</B> time ago
 * in the United States of America, it uses only the English alphabet
 * and pronunciation.
 * <p>
 * As it is mapping a large space (arbitrary length strings) onto a
 * small space (single letter plus 3 digits) no inference can be made
 * about the similarity of two strings which end up with the same
 * soundex code.  For example, both "Hilbert" and "Heilbronn" end up
 * with a soundex code of "H416".
 * <p>
 * The soundex() method is static, as it maintains no per-instance
 * state; this means you never need to instantiate this class.
 *
 * @author Perl implementation by Mike Stok (<stok@cybercom.net>) from
 * the description given by Knuth.  Ian Phillips (<ian@pipex.net>) and
 * Rich Pinder (<rpinder@hsc.usc.edu>) supplied ideas and spotted
 * mistakes.
 * @author Ian Darwin, http://www.darwinsys.com/ (Java Version)
 * @version $Id: Soundex.java,v 1.9 2004/02/23 00:30:49 ian Exp $
 */
public class Soundex {

	/* Implements the mapping
	 * from: AEHIOUWYBFPVCGJKQSXZDTLMNR
	 * to:   00000000111122222222334556
	 */
	public static final char[] MAP = {
		//A  B   C   D   E   F   G   H   I   J   K   L   M
		'0','1','2','3','0','1','2','0','0','2','2','4','5',
		//N  O   P   W   R   S   T   U   V   W   X   Y   Z
		'5','0','1','2','6','2','3','0','1','0','2','0','2'
	};

	/** Convert the given String to its Soundex code.
	 * @return null If the given string can't be mapped to Soundex.
	 */
	public static String soundex(String s) {

		// Algorithm works on uppercase (mainframe era).
		String t = s.toUpperCase();

		StringBuffer res = new StringBuffer();
		char c, prev = '?';

		// Main loop: find up to 4 chars that map.
		for (int i=0; i<t.length() && res.length() < 4 &&
			(c = t.charAt(i)) != ','; i++) {

			// Check to see if the given character is alphabetic.
			// Text is already converted to uppercase. Algorithm
			// only handles ASCII letters, do NOT use Character.isLetter()!
			// Also, skip double letters.
			if (c>='A' && c<='Z' && c != prev) {
				prev = c;

				// First char is installed unchanged, for sorting.
				if (i==0)
					res.append(c);
				else {
					char m = MAP[c-'A'];
					Debug.println("inner", c + " --> " + m);
					if (m != '0')
						res.append(m);
				}
			}
		}
		if (res.length() == 0)
			return null;
		for (int i=res.length(); i<4; i++)
			res.append('0');
		return res.toString();
	}
}

//@@@@@@//
//strings/SoundexSimple.java
//@@@@@@//
/** Simple demonstration of Soundex.  */
public class SoundexSimple {

	/** main */
	public static void main(String[] args) { 
		String[] names = {
			"Darwin, Ian",
			"Davidson, Greg",
			"Darwent, William",
			"Derwin, Daemon"
		};
		for (int i = 0; i< names.length; i++)
			System.out.println(Soundex.soundex(names[i]) + ' ' + names[i]);
	}
}
//@@@@@@//
//strings/SoundexTest.java
//@@@@@@//
import junit.framework.*;

/** Soundex Test program. Knuth's original examples, and mine. */
public class SoundexTest extends TestCase {

	/** JUnit test classes require this constructor */
	public SoundexTest(String name) {
		super(name);
	}

	public void testKnuth0() {
		assertEquals("E460", Soundex.soundex("Euler, Ellery"));
	}
	public void testKnuth1() {
		assertEquals("G200", Soundex.soundex("Gauss, Ghosh"));
	}
	public void testKnuth2() {
		assertEquals("H416", Soundex.soundex("Hilbert, Heilbronn"));
	}
	public void testKnuth3() {
		assertEquals("K530", Soundex.soundex("Knuth, Kant"));
	}
	public void testKnuth4() {
		assertEquals("L300", Soundex.soundex("Lloyd, Ladd"));
	}
	public void testKnuth5() {
		assertEquals("L222",
			Soundex.soundex("Lukasiewicz, Lissajous"));
	}
	public void testDarwin1() {
		assertEquals("D650", Soundex.soundex("Darwin"));
	}
	public void testDarwin2() {
		assertEquals("D653", Soundex.soundex("Darwent"));
	}
	public void testDarwin3() {
		assertEquals("D650", Soundex.soundex("Derwin"));
	}
}
//@@@@@@//
//strings/StrCharAt.java
//@@@@@@//
/** StrCharAt - show String.charAt()
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: StrCharAt.java,v 1.3 2004/02/09 03:34:03 ian Exp $
 */

public class StrCharAt {
    public static void main(String[] av) {
        String a = "A quick bronze fox lept a lazy bovine";
		for (int i=0; i < a.length(); i++)
			System.out.println("Char " + i + " is " + a.charAt(i));
	}
}
//@@@@@@//
//strings/StringAlign.java
//@@@@@@//
import java.text.*;

/** Bare-minimum String formatter (string aligner).
 * XXX When 1.5 is common, change from ints to enum for alignment.
 */
public class StringAlign extends Format {
	/* Constant for left justification. */
	public static final int JUST_LEFT = 'l';
	/* Constant for centering. */
	public static final int JUST_CENTRE = 'c';
	/* Centering Constant, for those who spell "centre" the American way. */
	public static final int JUST_CENTER = JUST_CENTRE;
	/** Constant for right-justified Strings. */
	public static final int JUST_RIGHT = 'r';

	/** Current justification */
	private int just;
	/** Current max length */
	private int maxChars;

    /** Construct a StringAlign formatter; length and alignment are
     * passed to the Constructor instead of each format() call as the
     * expected common use is in repetitive formatting e.g., page numbers.
     * @param nChars - the length of the output
     * @param just - one of JUST_LEFT, JUST_CENTRE or JUST_RIGHT
     */
	public StringAlign(int maxChars, int just) {
		switch(just) {
		case JUST_LEFT:
		case JUST_CENTRE:
		case JUST_RIGHT:
			this.just = just;
			break;
		default:
			throw new IllegalArgumentException("invalid justification arg.");
		}
		if (maxChars < 0) {
			throw new IllegalArgumentException("maxChars must be positive.");
		}
		this.maxChars = maxChars;
	}

	/** Format a String.
     * @param input _ the string to be aligned.
     * @parm where - the StringBuffer to append it to.
     * @param ignore - a FieldPosition (may be null, not used but
     * specified by the general contract of Format).
     */
	public StringBuffer format(
		Object obj, StringBuffer where, FieldPosition ignore)  {

		String s = (String)obj;
		String wanted = s.substring(0, Math.min(s.length(), maxChars));

		// Get the spaces in the right place.
		switch (just) {
			case JUST_RIGHT:
				pad(where, maxChars - wanted.length());
				where.append(wanted);
				break;
			case JUST_CENTRE:
				int toAdd = maxChars - wanted.length();
				pad(where, toAdd/2);
				where.append(wanted);
				pad(where, toAdd - toAdd/2);
				break;
			case JUST_LEFT:
				where.append(wanted);
				pad(where, maxChars - wanted.length());
				break;
			}
		return where;
	}

	protected final void pad(StringBuffer to, int howMany) {
		for (int i=0; i<howMany; i++)
			to.append(' ');
	}

	/** Convenience Routine */
	String format(String s) {
		return format(s, new StringBuffer(), null).toString();
	}

	/** ParseObject is required, but not useful here. */
	public Object parseObject (String source, ParsePosition pos)  {
		return source;
	}

}
//@@@@@@//
//strings/StringAlignDemo.java
//@@@@@@//
public class StringAlignDemo {

	/** Demonstrate and test StringAlign class */
	public static void main(String[] argv) {
		String[] mesg = {"JavaFun", "JavaFun!" };
		for (int i=0; i<mesg.length; i++) {
			System.out.println("Input String \"" + mesg[i] + "\"");
			dump(StringAlign.JUST_LEFT, 5,
				new StringAlign(5, StringAlign.JUST_LEFT).format(mesg[i]));
			dump(StringAlign.JUST_LEFT, 10,
				new StringAlign(10, StringAlign.JUST_LEFT).format(mesg[i]));
			dump(StringAlign.JUST_CENTER, 5,
				new StringAlign(5, StringAlign.JUST_CENTER).format(mesg[i]));
			dump(StringAlign.JUST_CENTER, 10,
				new StringAlign(10, StringAlign.JUST_CENTER).format(mesg[i]));
			dump(StringAlign.JUST_RIGHT, 5,
				new StringAlign(5, StringAlign.JUST_RIGHT).format(mesg[i]));
			dump(StringAlign.JUST_RIGHT, 10,
				new StringAlign(10, StringAlign.JUST_RIGHT).format(mesg[i]));
		}
	}

	private static void dump(int format, int len, String s) {
		System.out.print((char)format + "[" + len + "]");
		System.out.print(" ==> \"");
		System.out.print(s);
		System.out.print('"');
		System.out.println();
	}
}
//@@@@@@//
//strings/StringAlignSimple.java
//@@@@@@//
/* Align a page number on a 70-character line. */
public class StringAlignSimple {

	public static void main(String[] args) {
		// Construct a "formatter" to center strings.
		StringAlign formatter = new StringAlign(70, StringAlign.JUST_CENTER);
		// Try it out, for page "i"
		System.out.println(formatter.format("- i -"));
		// Try it out, for page 4. Since this formatter is
		// optimized for Strings, not specifically for page numbers,
		// we have to convert the number to a String
		System.out.println(formatter.format(Integer.toString(4)));
	}
}
//@@@@@@//
//strings/StringAlignTest.java
//@@@@@@//
import junit.framework.*;

/** StringAlign Test program.  */
public class StringAlignTest extends TestCase {

	String[] mesg = {"JavaFun", "JavaFun!" };

	/** The object being tested */
	protected StringAlign sa;

	/** JUnit test classes require(?) this constructor */
	public StringAlignTest(String name) {
		super(name);
	}

	public void testLeft() {
		for (int i=0; i<mesg.length; i++) {
			assertEquals(mesg[i].substring(0, 5),
				new StringAlign(5, StringAlign.JUST_LEFT).format(mesg[i]));
			String result = new StringAlign(10, StringAlign.JUST_LEFT).
					format(mesg[i]);
			assertEquals(mesg[i], result.trim());
			assertEquals(result.length(), 10);
		}
	}

	public void testCentre() {
		for (int i=0; i<mesg.length; i++) {
			assertEquals(mesg[i].substring(0, 5),
				new StringAlign(5, StringAlign.JUST_CENTER).format(mesg[i]).trim());
			assertEquals(" " + mesg[i],
				new StringAlign(10, StringAlign.JUST_CENTER).format(mesg[i]).substring(0, mesg[i].length()+1));
		}
	}

	public void testRight() {
		for (int i=0; i<mesg.length; i++) {
			System.out.println("Input String \"" + mesg[i] + "\"");
			assertEquals(mesg[i].substring(0, 5),
				new StringAlign(5, StringAlign.JUST_RIGHT).format(mesg[i]).trim());
			// XXX need to test this more.
			dump(StringAlign.JUST_RIGHT, 10,
				new StringAlign(10, StringAlign.JUST_RIGHT).format(mesg[i]));
		}
	}

	public void testNullString() {
		assertEquals("     ", new StringAlign(5, StringAlign.JUST_RIGHT).format(""));
	}

	// Consider phasing out this method.
	void dump(int x, int len, String mesg) {
		System.out.println(mesg);
	}
}
//@@@@@@//
//strings/StringBufferCommaList.java
//@@@@@@//
import java.util.StringTokenizer;

public class StringBufferCommaList {
	public static void main(String[] args) {
		StringTokenizer st = new StringTokenizer("Alpha Bravo Charlie");
		StringBuffer sb = new StringBuffer();
		while (st.hasMoreElements()) {
			sb.append(st.nextToken());
			if (st.hasMoreElements()) {
				sb.append(", ");
			}
		}
		System.out.println(sb);
	}
}
//@@@@@@//
//strings/StringBufferDemo.java
//@@@@@@//
/**
 * StringBufferDemo: construct the same String three different ways.
 */
public class StringBufferDemo {
	public static void main(String[] argv) {
		String s1 = "Hello" + ", " + "World";
		System.out.println(s1);

		// Build a StringBuffer, and append some things to it.
		StringBuffer sb2 = new StringBuffer();
		sb2.append("Hello");
		sb2.append(',');
		sb2.append(' ');
		sb2.append("World");

		// Get the StringBuffer's value as a String, and print it.
		String s2 = sb2.toString();
		System.out.println(s2);

		// Now do the above all over again, but in a more 
		// concise (and typical "real-world" Java) fashion.

		StringBuffer sb3 = new StringBuffer().append("Hello").
			append(',').append(' ').append("World");
		System.out.println(sb3.toString());

		// Exercise for the reader: do it all AGAIN but without
		// creating any temporary variables.
	}
}
//@@@@@@//
//strings/StringBuilderDemo.java
//@@@@@@//
/**
 * StringBuilderDemo: construct the same String three different ways.
 */
public class StringBuilderDemo {

	public static void main(String[] argv) {

		String s1 = "Hello" + ", " + "World";
		System.out.println(s1);

		// Build a StringBuilder, and append some things to it.
		StringBuilder sb2 = new StringBuilder();
		sb2.append("Hello");
		sb2.append(',');
		sb2.append(' ');
		sb2.append("World");

		// Get the StringBuilder's value as a String, and print it.
		String s2 = sb2.toString();
		System.out.println(s2);

		// Now do the above all over again, but in a more 
		// concise (and typical "real-world" Java) fashion.

		StringBuilder sb3 = new StringBuilder().append("Hello").
			append(',').append(' ').append("World");
		System.out.println(sb3.toString());
	}
}
//@@@@@@//
//strings/StringEscapes.java
//@@@@@@//
/**
 * StringEscapes.java - show string escapes.
 * Note that they may not print correctly on all platforms.
 */
public class StringEscapes {
	public static void main(String[] argv) {
		System.out.println("Java Strings in action:");
		// System.out.println("An alarm or alert: \a");	// not supported
		System.out.println("An alarm entered in Octal: \007");
		System.out.println("A tab key: \t(what comes after)");
		System.out.println("A newline: \n(what comes after)");
		System.out.println("A UniCode character: \u0207");
		System.out.println("A backslash character: \\");
	}
}
//@@@@@@//
//strings/StringIgnoreCaseComparator.java
//@@@@@@//
/** Simple Comparator for the common case of sortings Strings
 * in a case-insensitive way.
 * NOT NEEDED IN JAVA2; use String.CASE_INSENSITIVE_ORDER.
 */
public class StringIgnoreCaseComparator implements java.util.Comparator {
	public int compare(Object o1, Object o2) {
		String s1 = o1.toString().toLowerCase();
		String s2 = o2.toString().toLowerCase();
		return s1.compareTo(s2);
	}
}
//@@@@@@//
//strings/StringRevChar.java
//@@@@@@//
/**
 * Reverse a string by character
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: StringRevChar.java,v 1.3 2004/02/09 03:34:03 ian Exp $
 */
public class StringRevChar {
	public static void main(String[] argv) {
		//+
		String sh = "FCGDAEB";
		System.out.println(sh + " -> " + new StringBuffer(sh).reverse());
		//-
	}
}
//@@@@@@//
//strings/StringReverse.java
//@@@@@@//
import java.util.*;

/**
 * Show String Reversals
 * @version $Id: StringReverse.java,v 1.4 2000/11/25 17:56:18 ian Exp $
 */
public class StringReverse {
	public static void main(String[] argv) {
		//+
		String s = "Father Charles Goes Down And Ends Battle";

		// Put it in the stack frontwards
		Stack myStack = new Stack();
		StringTokenizer st = new StringTokenizer(s);
		while (st.hasMoreTokens()) myStack.push(st.nextElement());

		// Print the stack backwards
		System.out.print('"' + s + '"' + " backwards by word is:\n\t\"");
		while (!myStack.empty()) { 
			System.out.print(myStack.pop());
			System.out.print(' ');
		}
		System.out.println('"');
		//-
	}
}
//@@@@@@//
//strings/StrTokDemo.java
//@@@@@@//
import java.util.*;

/**
 * Simple StringTokenizer demo program.
 */
public class StrTokDemo {
	public static void main(String[] argv) {
		StringTokenizer st = new StringTokenizer("Hello World of Java");

		while (st.hasMoreTokens())
			System.out.println("Token: " + st.nextToken());
	}
}
//@@@@@@//
//strings/StrTokDemo2.java
//@@@@@@//
import java.util.*;

/**
 * Simple StringTokenizer demo program.
 */ 
public class StrTokDemo2 {
	public static void main(String[] argv) {
		StringTokenizer st = 
			new StringTokenizer("Hello, World|of|Java", ", |");

		while (st.hasMoreElements())
			System.out.println("Token: " + st.nextElement());
	}
}
//@@@@@@//
//strings/StrTokDemo3.java
//@@@@@@//
import java.util.*;

/**
 * Simple StringTokenizer demo program.
 */ 
public class StrTokDemo3 {
	public static void main(String[] argv) {
		StringTokenizer st = 
			new StringTokenizer("Hello, World|of|Java", ", |", true);

		while (st.hasMoreElements())
			System.out.println("Token: " + st.nextElement());
	}
}
//@@@@@@//
//strings/StrTokDemo4.java
//@@@@@@//
import java.util.*;

/** Show using a StringTokenizer including getting the delimiters back */
public class StrTokDemo4 {
	public final static int MAXFIELDS = 5;
	public final static String DELIM = "|";

	/** Processes one String, returns it as an array of Strings */
	public static String[] process(String line) {
		String[] results = new String[MAXFIELDS];

		// Unless you ask StringTokenizer to give you the tokens,
		// it silently discards multiple null tokens.
		StringTokenizer st = new StringTokenizer(line, DELIM, true);

		int i = 0;
		// stuff each token into the current slot in the array.
		while (st.hasMoreTokens()) {
			String s = st.nextToken();
			if (s.equals(DELIM)) {
				if (i++>=MAXFIELDS)
					// This is messy: See StrTokDemo4b which uses 
					// a List to allow any number of fields.
					throw new IllegalArgumentException("Input line " +
						line + " has too many fields");
				continue;
			}
			results[i] = s;
		}
		return results;
	}

	public static void printResults(String input, String[] outputs) {
		System.out.println("Input: " + input);
		for (int i=0; i<outputs.length; i++)
			System.out.println("Output " + i + " was: " + outputs[i]);
	}

	public static void main(String[] a) {
		printResults("A|B|C|D", process("A|B|C|D"));
		printResults("A||C|D", process("A||C|D"));
		printResults("A|||D|E", process("A|||D|E"));
	}
}
//@@@@@@//
//strings/StrTokDemo4b.java
//@@@@@@//
import java.util.*;

/** Show using a StringTokenizer including getting the delimiters back */
public class StrTokDemo4b {
	/** The delimiter used between fields on input. */
	public final static String DELIM = "|";

	/** Processes one String, returns it as an array of Strings */
	public static String[] process(String line) {
		// ArrayList is an array-like container that grows dynamically;
		// see the chapter on Java Collections.
		List results = new ArrayList();

		// Unless you ask StringTokenizer to give you the tokens,
		// it silently discards multiple null tokens.
		StringTokenizer st = new StringTokenizer(line, DELIM, true);

		int i = 0;
		// Stuff each token into the ArrayList
		while (st.hasMoreTokens()) {
			String s = st.nextToken();
			if (s.equals(DELIM)) {
				// Just ignore the "tokens" that consist of DELIM
				// But do insert something for consecutive delimiters
				if (results.size() < ++i)
					results.add(null);
				continue;
			}
			results.add(s);
		}

		// Make an Array just the right size, ask the
		// ArrayList to copy its data into it, and return it.
		String[] sResults = new String[results.size()];
		results.toArray(sResults);
		return sResults;
	}

	public static void printResults(String input, Object[] outputs) {
		System.out.println("Input: " + input);
		for (int i=0; i<outputs.length; i++)
			System.out.println("Output " + i + " was: " + outputs[i]);
	}

	public static void main(String[] a) {
		printResults("A|B|C|D", process("A|B|C|D"));
		printResults("A||C|D", process("A||C|D"));
		printResults("A|||D|E", process("A|||D|E"));
	}
}
//@@@@@@//
//strings/StrTokDemo4c.java
//@@@@@@//
import java.util.*;

/** Show using a StringTokenizer including getting the delimiters back
 * This final version returns a List instead of converting to an array.
 */
public class StrTokDemo4c {
	/** The delimiter used between fields on input. */
	public final static String DELIM = "|";

	/** Processes one String, returns it as an array of fields */
	public static List process(String line) {
		// A ArrayList is an array-like container that grows dynamically;
		// see the chapter on Java Collections.
		ArrayList results = new ArrayList();

		// Unless you ask StringTokenizer to give you the tokens,
		// it silently discards multiple null tokens.
		StringTokenizer st = new StringTokenizer(line, DELIM, true);

		int i = 0;
		// Stuff each token into the Vector
		while (st.hasMoreTokens()) {
			String s = st.nextToken();
			if (s.equals(DELIM)) {
				// Just ignore the "tokens" that consist of DELIM
				// But leave a blank entry corresponding to the missing field
				if (results.size() < ++i)
					results.add(null);
				continue;
			}
			results.add(s);
		}
		
		return results;
	}

	public static void printResults(String input, List outputs) {
		System.out.println("Input: " + input);
		Iterator it = outputs.iterator();
		for (int i=0; it.hasNext(); i++)
			System.out.println("Output " + i + " was: " + it.next());
	}

	public static void main(String[] a) {
		printResults("A|B|C|D", process("A|B|C|D"));
		printResults("A||C|D", process("A||C|D"));
		printResults("A|||D|E", process("A|||D|E"));
	}
}
//@@@@@@//
//strings/StrTokInts.java
//@@@@@@//
import java.util.StringTokenizer;

/** 
 * Given the problem of "I have a String with a fixed number of
 * Integers in it, how do I extract them?". Here's my best
 * readable solution.
 */
public class StrTokInts {
	public static void main(String[] args) {
		String in = "1  4   5   6   7  908  1231  23  53a";
		StringTokenizer st = new StringTokenizer(in);
		int iKnowHowMany = 9;
		for (int i=0; i<iKnowHowMany; i++) {
			String next = st.nextToken();
			try {
				int n = Integer.parseInt(next);
				System.out.println(i + " --> " + n);
			} catch (NumberFormatException ex) {
				System.out.println(i + " NOT A NUMBER (" + next + ")");
			}
		}
	}
}
//@@@@@@//
//strings/SubStringDemo.java
//@@@@@@//
public class SubStringDemo {
	public static void main(String[] av) {
		String a = "Java is great.";
		System.out.println(a);
		String b = a.substring(5);	// b is the String "is great."
		System.out.println(b);
		String c = a.substring(5,7);// c is the String "is"
		System.out.println(c);
		String d = a.substring(5,a.length());// d is "is great."
		System.out.println(d);
	}
}
//@@@@@@//
//strings/Tabs.java
//@@@@@@//
import com.darwinsys.util.Debug;

/** Basic tab-character handling stuff.
 * <p>
 * N.B. Can only handle equally-spaced tab stops as written.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Tabs.java,v 1.9 2004/02/28 02:48:15 ian Exp $
 */
public class Tabs {
	/** tabs every so often */
	public final static int DEFTABSPACE =   8;
	/** the current tab stop setting. */
	protected int tabSpace = DEFTABSPACE;
	/** The longest line that we initially set tabs for. */
	public final static int MAXLINE  = 255;
	/** the current tab stops */
	protected boolean[] tabstops;

	/** Construct a Tabs object with a given tab stop settings */
	public Tabs(int n) {
		if (n <= 0) {
			n = 1;
		}
		tabstops = new boolean[MAXLINE];
		tabSpace = n;
		settabs();
	}

	/** Construct a Tabs object with a default tab stop settings */
	public Tabs() {
		this(DEFTABSPACE);
	}

	/** settabs - set initial tab stops */
	private void settabs() {
		for (int i = 0; i < tabstops.length; i++) {
			tabstops[i] = ((i+1) % tabSpace) == 0;
			Debug.println("tabs", "Tabs[" + i + "]=" + tabstops[i]);
		}
	}
	
	/**
	 * @return Returns the tabSpace.
	 */
	public int getTabSpacing() {
		return tabSpace;
	}
	
	/** isTabStop - returns true if given column is a tab stop.
	 * @param col - the current column number
	 */
	public boolean isTabStop(int col) {
		if (col > tabstops.length - 1) {
			tabstops = new boolean[tabstops.length * 2];
			settabs();
		}
		return tabstops[col];
	}
}
//@@@@@@//
//strings/TabsTest.java
//@@@@@@//
import junit.framework.TestCase;


/**
 * @author ian
 *
 * To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Generation - Code and Comments
 */
public class TabsTest extends TestCase {

	public static void main(String[] args) {
		junit.textui.TestRunner.run(TabsTest.class);
	}

	private Tabs t4, t8;
	
	public void setUp() {
		t4 = new Tabs(4);
		t8 = new Tabs();
	}
	
	public void testGetTabSpacing() {
		assertEquals(t4.getTabSpacing(), 4);
		assertEquals(t8.getTabSpacing(), Tabs.DEFTABSPACE);
	}
	
	public  void testIsTabStop() {
		assertEquals(false, t4.isTabStop(0));
		assertEquals(false, t4.isTabStop(1));
		assertEquals(false, t4.isTabStop(2));
		assertEquals(true,  t4.isTabStop(3));
		assertEquals(false, t4.isTabStop(4));
		assertEquals(false, t4.isTabStop(5));
		assertEquals(false, t4.isTabStop(6));
		assertEquals(true,  t4.isTabStop(7));
		assertEquals(false, t4.isTabStop(8));
	}
}
//@@@@@@//
//strings/Undent.java
//@@@@@@//
import java.io.*;

/** Undent - remove leading spaces
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Undent.java,v 1.5 2004/02/22 21:45:02 ian Exp $
 */
public class Undent {
	/** the maximum number of spaces to remove. */
	protected int nSpaces;

	Undent(int n) {
		nSpaces = n;
	}

    public static void main(String[] av) {
        Undent c = new Undent(5);
        switch(av.length) {
            case 0: c.process(new BufferedReader(
                        new InputStreamReader(System.in))); break;
            default:
		for (int i=0; i<av.length; i++)
			try {
				c.process(new BufferedReader(new FileReader(av[i])));
			} catch (FileNotFoundException e) {
				System.err.println(e);
			}
        }
    }

    /** print one file, given an open BufferedReader */
    public void process(BufferedReader is) {
        try {
            String inputLine;

			//+
            while ((inputLine = is.readLine()) != null) {
				int toRemove = 0;
				for (int i=0; i<nSpaces && i < inputLine.length() && 
				Character.isWhitespace(inputLine.charAt(i)); i++)
						++toRemove;
                System.out.println(inputLine.substring(toRemove));
            }
			//-
            is.close();
        } catch (IOException e) {
            System.out.println("IOException: " + e);
        }
    }
}
//@@@@@@//
//strings/UnicodeCast.java
//@@@@@@//
/** Convert among Unicode, ASCII and byte/int. */
public class UnicodeCast {
	public static void main(String[] args) {

		// Simple arithmetic on chars - VERY BAD for internationalization!
		System.out.println("'a' + 1 = " + (char)('a' + 1));

		// Truncate characters by casting to byte (16-bit to 8-bit casting)
		char yen = '\u00a5';		// Japanese Yen
		char aeAcute = '\u01FC';	// Roman AE with acute accent
		System.out.println("Yen as byte: " + (byte)yen);
		System.out.println("AE' as byte: " + (byte)aeAcute);
		System.out.println("Yen as byte to char: " + (char)(byte)yen);
		System.out.println("AE' as byte to char: " + (char)(byte)aeAcute);

		// Convert ints to chars
		int iYen = 0xa5;
		int iaeAcute = 0x01fc;
		System.out.println("Yen from int = " + (char)iYen);
		System.out.println("AE' from int = " + (char)iaeAcute);

	}
}
//@@@@@@//
//strings/UnicodeChars.java
//@@@@@@//
/**
 * Conversion between Unicode characters and Strings.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: UnicodeChars.java,v 1.5 2004/02/22 18:25:46 ian Exp $
 */
public class UnicodeChars {
	public static void main(String[] argv) {
		//+
		StringBuffer b = new StringBuffer();
		for (char c = 'a'; c<'d'; c++) {
			b.append(c);
		}
		b.append('\u00a5');	// Japanese Yen symbol
		b.append('\u01FC');	// Roman AE with acute accent
		b.append('\u0391');	// GREEK Capital Alpha
		b.append('\u03A9');	// GREEK Capital Omega

		for (int i=0; i<b.length(); i++) {
			System.out.println("Character #" + i + " is " + b.charAt(i));
		}
		System.out.println("Accumulated characters are " + b);
		//-
	}
}
//@@@@@@//
//strings/WolfInStringsClothing.java
//@@@@@@//
/**
 * If this class could be compiled, Java security would be a myth.
 */
public class WolfInStringsClothing 
	extends java.lang.String {//EXPECT COMPILE ERROR

	public void setCharAt(int index, char newChar) {
		// The implementation of this method
		// would be left as an exercise for the reader.
		// Hint: compile this code exactly as-is before bothering!
	}
}
//@@@@@@//
//structure/Array0.java
//@@@@@@//
/** Simple example
 * @author Ian Darwin
 * @version $Id: Array0.java,v 1.1 2002/11/09 16:27:49 ian Exp $
 */
public class Array0  {
	// Use this initializer form when the data are fixed:
	static int monthLen[] = {
			31, 28, 31, 30,
			31, 30, 31, 31,
			30, 31, 30, 31,
	};
		
	public static void main(String[] argv) {
		for (int i=0; i<monthLen.length; i++) {
			System.out.println("Month " + (i+1) + " has " +
				monthLen[i] + " days.");
		}
	}
}
//@@@@@@//
//structure/Array1.java
//@@@@@@//
import java.util.Calendar;

/** Review examples of arrays: shows array allocation, processing,
 * storing objects in Arrays,, two-dimensional arrays, and lengths.
 *
 * @author Ian Darwin
 * @version $Id: Array1.java,v 1.6 2004/03/07 23:51:43 ian Exp $
 */
public class Array1  {
	public static void main(String[] argv) {
		int[] monthLen1;			// declare a reference
		monthLen1 = new int[12];		// construct it
		int[] monthLen2 = new int[12];	// short form
		// even shorter is this initializer form:
		int[] monthLen3 = {
				31, 28, 31, 30,
				31, 30, 31, 31,
				30, 31, 30, 31,
		};
		
		final int MAX = 10;
		Calendar[] days = new Calendar[MAX];
		for (int i=0; i<MAX; i++) {
			// Note that this actually stores GregorianCalendar
			// etc. instances into a Calendar Array
			days[i] = Calendar.getInstance();
		}
	 
		// Two-Dimensional Arrays
		// Want a 10-by-24 array
		int[][] me = new int[10][];
		for (int i=0; i<10; i++)
			me[i] = new int[24];

		// Remember that an array has a ".length" attribute
		System.out.println(me.length);
		System.out.println(me[0].length);

	}
}
//@@@@@@//
//structure/Array2.java
//@@@@@@//
import java.util.Calendar;

/** Re-allocate an array, bigger...
 * @author Ian Darwin
 * @version $Id: Array2.java,v 1.6 2004/03/07 23:52:55 ian Exp $
 */
public class Array2  {
	public static void main(String[] argv) {
		int nDates = 0;
		final int MAX = 10;
		Calendar[] dates = new Calendar[MAX];
		Calendar c;
		StructureDemo source = new StructureDemo(21);
		while ((c=(Calendar)source.getDate()) != null) {

			// if (nDates >= dates.length) {
			// 	System.err.println("Too Many Dates! Simplify your life!!");
			// 	System.exit(1);  // wimp out
			// }

			// better: reallocate, making data structure dynamic
			if (nDates >= dates.length) {
				Calendar[] tmp = new Calendar[dates.length + 10];
				System.arraycopy(dates, 0, tmp, 0, dates.length);
				dates = tmp;    // copies the array reference
				// old array will be garbage collected soon...
			}
			dates[nDates++] = c;
		}
		System.out.println("Array size = " + dates.length);
	}
}
//@@@@@@//
//structure/ArrayDemo.java
//@@@@@@//
/** Try to collect all the Array Chapter examples from 471 into one file
 * @author Ian Darwin
 * @version $Id: ArrayDemo.java,v 1.5 2000/11/25 17:56:20 ian Exp $
 */
public class ArrayDemo  {
	public static void main(String[] argv) {
		int ages[];			// declare a reference
		ages = new int[10];		// construct it
		int ages2[] = new int[10];	// short form
		// an even shorter form is the initializer form:
		int monthLen[] = {
				31, 28, 31, 30,
				31, 30, 31, 31,
				30, 31, 30, 31
		};
		
		final int MAX = 10;
		Employee staff[] = new Employee[MAX];
		for (int i=0; i<MAX; i++)
			   staff[i] = new Employee("NoName", i);
	 
		// Two-Dimensional Arrays
		// Want a 10-by-24 array
		int me[][] = new int[10][];
		for (int i=0; i<10; i++)
			me[i] = new int[24];

		System.out.println(me.length);
		System.out.println(me[0].length);

		int me2[][];				// shorter
		me2 = new int[10][24];
		
		int me3[][] = new int[10][24];	// shortest

		double data[][] = {
			{24, 100},
			{10, 20},
			{32, 98.6},
		};
		System.out.println("Should print 98.6: " + data[2][1] );

		int nEmployees = 0;
		// allocate array
		staff = new Employee[MAX];
		staff[nEmployees++] = new Employee();// allocate Employee an object
		if (nEmployees >= staff.length) {
			System.err.println("Too Many Staff Hired!!");
			System.exit(1);  // wimp out
		}

		// better to reallocate, making the data structure dynamic
		if (nEmployees >= staff.length) {
			Employee tmpstaff[] = new Employee[staff.length + 10];
			for (int i=0; i<staff.length; i++) { //or System.arraycopy()
					tmpstaff[i] = staff[i];
			}
			staff = tmpstaff;       // copies the array reference
		   // old array will be garbage collected soon...
		}
	}

}
//@@@@@@//
//structure/ArrayHunt.java
//@@@@@@//
import java.util.*;

/** Array Hunt "game" (pathetic: computer plays itself).
 * @author Ian Darwin
 * @version $Id: ArrayHunt.java,v 1.3 2004/03/08 00:11:18 ian Exp $
 */
public class ArrayHunt  {
	/** the maximum (and actual) number of random ints to allocate */
	protected final static int MAX    = 4000;
	/** the value to look for */
	protected final static int NEEDLE = 1999;
	int[] haystack;
	Random r;

	public static void main(String[] argv) {
		ArrayHunt h = new ArrayHunt();
		if (argv.length == 0)
			h.play();
		else {
			int won = 0;
			int games = Integer.parseInt(argv[0]);
			for (int i=0; i<games; i++)
				if (h.play())
					++won;
			System.out.println("Computer won " + won + 
				" out of " + games + ".");
		}
	}

	/** Construct the hunting ground */
	public ArrayHunt() {
		haystack = new int[MAX];
		r = new Random();
	}

	/** Play one game. */
	public boolean play() {
		int i;

		// Fill the array with random data (hay?)
		for (i=0; i<MAX; i++) {
			haystack[i] = (int)(r.nextFloat() * MAX);
		}

		// Precondition for binary search is that data be sorted!
		Arrays.sort(haystack);

		// Look for needle in haystack
		i = Arrays.binarySearch(haystack, NEEDLE);

		if (i >= 0) {		// Found it, we win.
			System.out.println("Value " + NEEDLE +
				" occurs at haystack[" + i + "]");
			return true;
		} else {		// Not found, we lose.
			System.out.println("Value " + NEEDLE +
				" does not occur in haystack; nearest value is " +
				haystack[-(i+2)] + " (found at " + -(i+2) + ")");
			return false;
		}
	}
}
//@@@@@@//
//structure/ArrayListDemo.java
//@@@@@@//
import java.util.*;

/**
 * ArrayListDemo done over using an ArrayList
 */
public class ArrayListDemo {
	public static void main(String[] argv) {
		ArrayList al = new ArrayList();

		// Create a source of Objects
		StructureDemo source = new StructureDemo(15);

		// Add lots of elements to the ArrayList...
		al.add(source.getDate());
		al.add(source.getDate());
		al.add(source.getDate());

		// First print them out using a for loop.
		System.out.println("Retrieving by index:");
		for (int i = 0; i<al.size(); i++) {
			System.out.println("Element " + i + " = " + al.get(i));
		}
	}
}
//@@@@@@//
//structure/ArrayToVector.java
//@@@@@@//
import java.util.*;

/** Convert an Array to a Vector. */
public class ArrayToVector {
	public static void main(String[] args) {
		Object[] a1d = {
			"Hello World",
			new Date(),
			Calendar.getInstance(),
		};
		// Arrays.asList(Object[]) --> List
		List l = Arrays.asList(a1d);

		// Vector contstructor takes Collection
		// List is a subclass of Collection
		Vector v;
		v = new Vector(l);

		// Or, more simply:
		v = new Vector(Arrays.asList(a1d));

		// Just to prove that it worked.
		Enumeration e = v.elements();
		while (e.hasMoreElements()) {
			System.out.println(e.nextElement());
		}
	}
}
//@@@@@@//
//structure/ArrayTwoDObjects.java
//@@@@@@//
/** Show Two-Dimensional Array of Objects */
public class ArrayTwoDObjects {

	/** Return list of subscript names (unrealistic; just for demo). */
	public static String[][] getArrayInfo() {
		String info[][];
		info = new String[10][10];
		for (int i=0; i < info.length; i++) {
			for (int j = 0; j < info[i].length; j++) {
				info[i][j] = "String[" + i + "," + j + "]";
			}
		}
		return info;
	}

	/** Return list of allowable parameters (Applet method). */
	public static String[][] getParameterInfo() {
		String param_info[][] = {
			{"fontsize",    "9-18",    "Size of font"},
			{"URL",    "-",    "Where to download"},
		};
		return param_info;
	}

	/** Run both initialization methods and print part of the results */
	public static void main(String[] args) {
		print("from getArrayInfo", getArrayInfo());
		print("from getParameterInfo", getParameterInfo());
	}

	/** Print selected elements from the 2D array */
	public static void print(String tag, String[][] array) {
		System.out.println("Array " + tag + " is " + array.length + " x " + 
			array[0].length);
		System.out.println("Array[0][0] = " + array[0][0]);
		System.out.println("Array[0][1] = " + array[0][1]);
		System.out.println("Array[1][0] = " + array[1][0]);
		System.out.println("Array[0][0] = " + array[0][0]);
		System.out.println("Array[1][1] = " + array[1][1]);
	}
}
//@@@@@@//
//structure/BitSetDemo.java
//@@@@@@//
import java.util.BitSet;
/**
 * Bitset demo
 */
public class BitSetDemo {
	public static void main(String[] argv) {
		BitSet bs = new BitSet();
		bs.set(65);
		System.out.println("Bit 65 is " + bs.get(65));
	}
}
//@@@@@@//
//structure/CallTrack.java
//@@@@@@//
import java.util.List;
import java.util.ArrayList;

/** Code Fragmment showing how to insert in two lists (an ArrayList
 * and an AWT List) in sorted order, using a simple linear search
 * of the ArrayList to find the object (or end of list) before which
 * to insert the new user. 
 */
public class CallTrack {

	/** The list of Person objects. */
	protected List usrList = new ArrayList();

	/** The scrolling list */
	protected java.awt.List visList = new java.awt.List();

	/** Add one (new) Person to the list, keeping the list sorted. */
	protected void add(Person p) {
		String lastName = p.getLastName();
		int i;
		for (i=0; i<usrList.size(); i++)
			if (lastName.compareTo(((Person)(usrList.get(i))).getLastName()) <= 0)
				break;
		usrList.add(i, p);
		visList.add(p.getName(), i);
		visList.select(i);      // ensure current
	}

}
//@@@@@@//
//structure/CallTrackTest.java
//@@@@@@//
import junit.framework.TestCase;

import java.util.List;

/**
 * Make sure that CallTrack fragment actually works as shown.
 */
public class CallTrackTest extends TestCase {
	Person[] testData = {
		new Person("Ian", "Darwin"),		// 1
		new Person("Davy", "Jones"),		// 3
		new Person("Donald", "Duck"),		// 2
		new Person("Austine", "Azalia"),	// 0
	};

	protected CallTrack ct = new CallTrack();

	public void testIt() {
		for (int i = 0; i < testData.length; i++) {
			ct.add(testData[i]);
		}
		List it = ct.usrList;
		assertEquals(it.get(0), testData[3]);
		assertEquals(it.get(1), testData[0]);
		assertEquals(it.get(2), testData[2]);
		assertEquals(it.get(3), testData[1]);
	}
}
//@@@@@@//
//structure/Employee.java
//@@@@@@//
/* Degenerate subset of Employee class, just enough to make
 * array demo code compile.
 */
public class Employee {
	protected String name;
	protected long personellNumber;

	Employee() {
		// Null constructor.
	}

	Employee(String name, int pnum) {
		this.name = name;
		this.personellNumber = pnum;
	}
	public String getName() {
		return name;
	}
}
//@@@@@@//
//structure/ExecDemoSort.java
//@@@@@@//
import java.io.*;

/**
 * ExecDemo shows how to execute an external program and read its output.
 */
public class ExecDemoSort {
	public static void main(String[] av) throws IOException { 

		// A Runtime object has methods for dealing with the OS
		Runtime r = Runtime.getRuntime();

		// A process object tracks one external running process
		Process p;
		
		// file contains unsorted data
		p = r.exec("sort sortdemo.txt");

		// getInputStream gives an Input stream connected to 
		// the process p's standard output (and vice versa). We use
		// that to construct a BufferedReader so we can readLine() it.
		BufferedReader is = new BufferedReader(
			new InputStreamReader(p.getInputStream()));

		System.out.println("Here is your sorted data:");

		String aLine;
		while ((aLine = is.readLine()) != null)
			System.out.println(aLine);
		
		System.out.println("That is all, folks!");

		return;
	}
}
//@@@@@@//
//structure/ExecDemoSort2.java
//@@@@@@//
/**
 * ExecDemo shows how to execute an external program and read its output.
 * This version tries to let the sort's standard output appear at the terminal.
 */
public class ExecDemoSort2 {
	public static void main(String[] av) { 

		// A Runtime object has methods for dealing with the OS
		Runtime r = Runtime.getRuntime();

		// A process object tracks one external running process
		Process p;

		try {
			// file contains unsorted data
			p = r.exec("sort sortdemo.txt");

			p.waitFor();
		} catch (java.io.IOException  e) {
			System.err.println("I/O error: " + e);
		} catch (InterruptedException e) {
			// nothing to do
		} 
	}
}
//@@@@@@//
//structure/HashMapDemo.java
//@@@@@@//
import java.util.*;

/**
 * Demonstrate the HashMap class, and an Iterator.
 * @see HashTableDemo, for the older Hashtable.
 */
public class HashMapDemo {

	public static void main(String[] argv) {

		// Construct and load the hash. This simulates loading a
		// database or reading from a file, or wherever the data is.

		Map map = new HashMap();

		// The hash maps from company name to address.
		// In real life this might map to an Address object...
		map.put("Adobe", "Mountain View, CA");
		map.put("IBM", "White Plains, NY");
		map.put("Learning Tree", "Los Angeles, CA");
		map.put("Microsoft", "Redmond, WA");
		map.put("Netscape", "Mountain View, CA");
		map.put("O'Reilly", "Sebastopol, CA");
		map.put("Sun", "Mountain View, CA");

		// Two versions of the "retrieval" phase.
		// Version 1: get one pair's value given its key
		// (presumably the key would really come from user input):
		String queryString = "O'Reilly";
		System.out.println("You asked about " + queryString + ".");
		String resultString = (String)map.get(queryString);
		System.out.println("They are located in: " + resultString);
		System.out.println();

		// Version 2: get ALL the keys and pairs 
		// (maybe to print a report, or to save to disk)
		Iterator k = map.keySet().iterator();
		while (k.hasNext()) {
			String key = (String) k.next();
			System.out.println("Key " + key + "; Value " +
				(String) map.get(key));
		}
	}
}
//@@@@@@//
//structure/HashtableDemo.java
//@@@@@@//
import java.util.*;

/**
 * Demonstrate the Hashtable class, and an Enumeration.
 * @see HashMapDemo, for the newer HashMap class.
 */
public class HashtableDemo {

	public static void main(String[] argv) {

		// Construct and load the hash. This simulates loading a
		// database or reading from a file, or wherever the data is.

		Hashtable h = new Hashtable();

		// The hash maps from company name to address.
		// In real life this might map to an Address object...
		h.put("Adobe", "Mountain View, CA");
		h.put("IBM", "White Plains, NY");
		h.put("Learning Tree", "Los Angeles, CA");
		h.put("Microsoft", "Redmond, WA");
		h.put("Netscape", "Mountain View, CA");
		h.put("O'Reilly", "Sebastopol, CA");
		h.put("Sun", "Mountain View, CA");

		// Two versions of the "retrieval" phase.
		// Version 1: get one pair's value given its key
		// (presumably the key would really come from user input):
		String queryString = "O'Reilly";
		System.out.println("You asked about " + queryString + ".");
		String resultString = (String)h.get(queryString);
		System.out.println("They are located in: " + resultString);
		System.out.println();

		// Version 2: get ALL the keys and pairs 
		// (maybe to print a report, or to save to disk)
		Enumeration k = h.keys();
		while (k.hasMoreElements()) {
			String key = (String) k.nextElement();
			System.out.println("Key " + key + "; Value " +
				(String) h.get(key));
		}
	}
}
//@@@@@@//
//structure/IteratorDemo.java
//@@@@@@//
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

/** Iterator used to walk through a List.
 * @version $Id: IteratorDemo.java,v 1.2 2004/03/08 00:42:18 ian Exp $
 */
public class IteratorDemo {

	public static void main(String[] argv) {

		List l = new ArrayList();
		StructureDemo source = new StructureDemo(15);

		// Add lots of elements to the list...
		l.add(source.getDate());
		l.add(source.getDate());
		l.add(source.getDate());

		int i = 0;

		Iterator it = l.iterator();

		// Process the data structure using an iterator.
		// This part of the code does not know or care
		// if the data is an an array, a List, a Vector, or whatever.
		while (it.hasNext()) {
			Object o = it.next();
			System.out.println("Element " + i++ + " = " + o);
		}
	}
}
//@@@@@@//
//structure/LinkedListDemo.java
//@@@@@@//
import java.util.*;

/**
 * Demo of 1.2 java.util.LinkedList class
 * using same example as my older LinkList class.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version $Id: LinkedListDemo.java,v 1.4 2004/02/09 03:34:04 ian Exp $
 */
public class LinkedListDemo {
	public static void main(String[] argv) {
		System.out.println("Here is a demo of Java 1.2's LinkedList class");
		LinkedList l = new LinkedList();
		l.add(new Object());
		l.add("Hello");
		l.add("end of the list");

		System.out.println("Here is a list of all the elements");
		ListIterator li = l.listIterator(0);
		while (li.hasNext())
			System.out.println("Next to: " + li.next());

		if (l.indexOf("Hello") < 0)
			System.err.println("Lookup does not work");
		else
			System.err.println("Lookup works");

		// Now, for added fun, let's walk the linked list backwards.
		while (li.hasPrevious()) {
			System.out.println("Back to: " + li.previous());
		}
	}
}
//@@@@@@//
//structure/LinkList.java
//@@@@@@//
import java.util.*;

/**
 * Linked list class, written in Java.
 * This is <b>not</b> intended to be a usable List, and it is certainly
 * not going to be optimal in terms of performance; it is just
 * here to remind you how much work the existing List implementations do.
 * <br/>
 * TODO: scrap this and start again, subclassing AbstractSequentialList
 * @deprecated	Supplanted by LinkedList
 * @author	Ian Darwin
 */
public class LinkList implements List {

	/* A TNode stores one node or item in a Linked List */
	class TNode {
		TNode next;
		Object data;
		TNode(Object o) {
			data = o;
			next = null;
		}
	}

	/** The root or first TNode in the list. */
	protected TNode first;
	/** The last TNode in the list */
	protected TNode last;

	/** Construct a LinkList: initialize the first and last nodes */
	public LinkList() {
		super();
		clear();
	}

	/** Construct a LinkList given another Collection.
	 * This method is recommended by the general contract of List.
	 */
	public LinkList(Collection c) {
		this();
		addAll(c);
		throw new IllegalArgumentException("Can't construct(Collection) yet");
	}

	/** Set the List (back) to its initial state.
	 * Any references held will be discarded.
	 */
    public void clear() {
		first = new TNode(this);
		last = first;
	}

	/** Add one object to the end of the list. Update the "next"
	 * reference in the previous end, to refer to the new node.
	 * Update "last" to refer to the new node. 
	 */
	public boolean add(Object o) {
		last.next = new TNode(o);
		last = last.next;
		return true;
	}

    public void add(int where, Object o) {
		TNode t = first;
		for (int i=0; i<where; i++)
			t = t.next;
		TNode t2 = t;
		t.next = new TNode(o);
		t.next = t2;
	}

	public boolean lookup(Object o) {
		for (TNode p=first.next; p != null; p = p.next)
			if (p.data==o || p.data.equals(o))
				return true;
		return false;
	}

    public int size() {
		TNode t = first;
		int i;
		for (i=0; ; i++) {
			if (t == null)
				break;
			t = t.next;
		}
		return i - 1;	// subtract one for mandatory head node.
	}

    public boolean isEmpty() {
		return size() == 0;
	}

    public Object get(int where) {
		TNode t = first;
		for (int i=0; i<where; i++) {
			t = t.next;
		}
		return t.data;
	}

    public Object set(int i, Object o) {
		return null;
	}
    public boolean contains(Object o) {
		return false;
	}
    public Object[] toArray() {
		return null;
	}
    public Object[] toArray(Object[] data) {
		return null;
	}
    public boolean remove(Object o) {
		return false;
	}
    public Object remove(int i) {
		return null;
	}
    public boolean containsAll(Collection c) {
		return false;
	}
    public boolean addAll(Collection c) {
		return false;
	}
    public boolean addAll(int i, Collection c) {
		return false;
	}

    public boolean removeAll(Collection c) {
		return false;
	}
    public boolean retainAll(Collection c) {
		return false;
	}

    public int indexOf(Object o) {
		return 0;
	}

    public int lastIndexOf(Object o) {
		return 0;
	}

    public ListIterator listIterator() {
		throw new UnsupportedOperationException("listIterator");
	}

    public Iterator iterator() {
		return new Iterator() {
			TNode t = first;
			int i = 0;
			public boolean hasNext() {
				return t != last;
			}
			public Object next() {
				if (t == last)
					throw new ArrayIndexOutOfBoundsException();
				return t = t.next;
			}
			public void remove() {
				throw new UnsupportedOperationException("remove");
			}
		};
	}

    public ListIterator listIterator(int where) {
		return null;
	}

    public List subList(int sub1, int sub2) {
		return null;
	}
}
//@@@@@@//
//structure/LinkListTest.java
//@@@@@@//
import java.util.*;
import junit.framework.TestCase;

/**
 * Linked list class, written out in full using Java.
 * @deprecated	Supplanted by java.util.LinkedList
 * @author	Ian Darwin, http://www.darwinsys.com/
 */
public class LinkListTest extends TestCase {
	LinkList list;
	public void setUp() {
		System.out.println("Here is a demo of implementing a List in Java");
		System.out.println("(you know it don't come easy....)");
		list = new LinkList();
		list.add(new Object());
		list.add("Hello");
		list.add("End of list");
		System.out.println("Here is a list of all the elements, from get");
		System.out.println(list.get(0));
		System.out.println(list.get(1));
		System.out.println(list.get(2));
	}

	public void testGet() {

		assertTrue(list.lookup("Hello"));
		System.out.println("Lookup seems to work");
	}

	public void testSize() {
		assertEquals(3, list.size());
	}

	public void testIterator() {

		Iterator li = list.iterator();
		assertNotNull(li);

		// Run the list frontwards
		while (li.hasNext()) {
			System.out.println("Next to: " + li.next());
		}
	}
}
//@@@@@@//
//structure/Manager.java
//@@@@@@//
public class Manager extends Employee {
	// name and personellNumber are inherited from Employee

	/** The name of this manager's Department */
	String managedDepartment;

	/** The manager's Administrative Assistant */
	Employee adminAssistant;

	/** Construct a Manager object */
	public Manager(String dept, Employee aa) {
		managedDepartment = dept;
		adminAssistant = aa;
	}

	/** Return this manager's department's name */
	public String getManagedDepartment() {
		return managedDepartment;
	}

	/** Update this manager's department's name */
	public void setManagedDepartment(String newName) {
		managedDepartment = newName;
	}
}
//@@@@@@//
//structure/ManagerInArray.java
//@@@@@@//
/**
 * This is a toy program that shows creating a Manager object.
 */
public class ManagerInArray {
	public static void main(String[] args) {
		Employee aa;
		Employee staff[] = {
			new Employee("Jon Jonsson", 45678),
			aa=new Employee("Robin Smith", 12345),
			new Manager("Finance", aa)
		};
		for (int i=0; i<staff.length; i++) {
			System.out.println("Employee's name is " + staff[i].getName());
			if (staff[i] instanceof Manager) {
				Manager mgr = (Manager)staff[i];
				System.out.println("\tIS A MANAGER; department is " +
					mgr.getManagedDepartment());
			}
		}
	}
}
//@@@@@@//
//structure/MapEntrySetDemo.java
//@@@@@@//
import java.util.*;

/**
 * Demonstrate the HashMap class, and an Iterator.
 * @see HashTableDemo, for the older Hashtable.
 */
public class MapEntrySetDemo {

	public static void main(String[] argv) {

		// Construct and load the hash. This simulates loading a
		// database or reading from a file, or wherever the data is.

		Map map = new HashMap();

		// The hash maps from company name to address.
		// In real life this might map to an Address object...
		map.put("Adobe", "Mountain View, CA");
		map.put("IBM", "White Plains, NY");
		map.put("Learning Tree", "Los Angeles, CA");
		map.put("Microsoft", "Redmond, WA");
		map.put("Netscape", "Mountain View, CA");
		map.put("O'Reilly", "Sebastopol, CA");
		map.put("Sun", "Mountain View, CA");

		// List the entries using entrySet()
        Set entries = map.entrySet();
        Iterator it = entries.iterator();
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry)it.next();
            System.out.println(entry.getKey() + "-->" + entry.getValue());
        }
	}
}
//@@@@@@//
//structure/MHProperties.java
//@@@@@@//
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

/**
 * A Properties file specialized to read a UNIX user's MH Mail System profile.
 */
public class MHProperties extends java.util.Properties {
	public static String PROFILE_NAME = ".mh_profile";

	public MHProperties() {
		super();
		try {
			load();
		} catch (FileNotFoundException ex) {
			System.err.println("You do not appear to have a " + PROFILE_NAME);
		} catch (IOException ex) {
			System.err.println(ex);
		}
	}

	/** Load the .mhprofile; like load(InputStream) but simpler. */
	public void load() throws IOException {

		String fName = System.getProperty("user.home") +
			System.getProperty("file.separator") +
			PROFILE_NAME;
		BufferedReader is = new BufferedReader(new FileReader(fName));
		String line;
		while ((line = is.readLine()) != null) {
			if (line.startsWith("#"))
				continue;
			int where = line.indexOf(':');
			put(line.substring(0, where), line.substring(where+1).trim());
		}
	}
}
//@@@@@@//
//structure/MHPropertiesTest.java
//@@@@@@//
public class MHPropertiesTest {
	public static void main(String[] args) throws java.io.IOException {
		MHProperties mp = new MHProperties();
		if (mp.size() == 0) {
			System.out.println("# No properties loaded from " +
				MHProperties.PROFILE_NAME);
		} else {
			mp.store(System.out, "Properties loaded from " +
				MHProperties.PROFILE_NAME);
		}
	}
}
//@@@@@@//
//structure/MyMap.java
//@@@@@@//
import java.util.*;

/** A simple Map implementation, implemented in terms of a
 * pair of ArrayLists just to show what a Map has to do (it would 
 * have been easier, but less informative, to subclass AbstractMap).
 * This Map implementation, like TreeSet, guarantees that the 
 * Map's contents will be kept in ascending element order, 
 * sorted according to the natural order of the elements;
 * see Comparable. This does not (yet) allow you to specify your own
 * Comparator.
 * <p>
 * It is a requirement that all objects inserted be able to 
 * call compareTo on all other objects, i.e., they must all
 * be of the same or related classes.
 * <p>
 * Be warned that the entrySet() method is <b>not implemented</b> yet.
 */
public class MyMap implements Map {

	private ArrayList keys;
	private ArrayList values;

	public MyMap() {
		keys = new ArrayList();
		values = new ArrayList();
	}

	/** Return the number of mappings in this Map. */
	public int size() {
		return keys.size();
	}

	/** Return true if this map is empty. */
	public boolean isEmpty() {
		return size() == 0;
	}

	/** Return true if o is contained as a Key in this Map. */
	public boolean containsKey(Object o) {
		return keys.contains(o);
	}

	/** Return true if o is contained as a Value in this Map. */
	public boolean containsValue(Object o) {
		return keys.contains(o);
	}

	/** Get the object value corresponding to key k. */
	public Object get(Object k) {
		int i = keys.indexOf(k);
		if (i == -1)
			return null;
		return values.get(i);
	}

	/** Put the given pair (k, v) into this map, by maintaining "keys"
	 * in sorted order.
	 */
	public Object put(Object k, Object v) {
		for (int i=0; i < keys.size(); i++) {
			Object old = keys.get(i);

			/* Does the key already exist? */
			if (((Comparable)k).compareTo(keys.get(i)) == 0) {
				keys.set(i, v);
				return old;
			}

			/* Did we just go past where to put it?
			 * i.e., keep keys in sorted order.
			 */
			if (((Comparable)k).compareTo(keys.get(i)) == +1) {
				int where = i > 0 ? i -1 : 0;
				keys.add(where, k);
				values.add(where, v);
				return null;
			}
		}

		// Else it goes at the end.
		keys.add(k);
		values.add(v);
		return null;
	}

	/** Put all the pairs from oldMap into this map */
	public void putAll(java.util.Map oldMap) {
		Iterator keysIter = oldMap.keySet().iterator();
		while (keysIter.hasNext()) {
			Object k = keysIter.next();
			Object v = oldMap.get(k);
			put(k, v);
		}
	}

	public Object remove(Object k) {
		int i = keys.indexOf(k);
		if (i == -1)
			return null;
		Object old = values.get(i);
		keys.remove(i);
		values.remove(i);
		return old;
	}

	public void clear() {
		keys.clear();
		values.clear();
	}

	public java.util.Set keySet() {
		return new TreeSet(keys);
	}

	public java.util.Collection values() {
		return values;
	}

	/** The Map.Entry objects contained in the Set returned by entrySet().
	 */
	private class MyMapEntry implements Map.Entry, Comparable {
		private Object key, value;
		MyMapEntry(Object k, Object v) {
			key = k;
			value = v;
		}
		public Object getKey() { return key; }
		public Object getValue() { return value; }
		public Object setValue(Object nv) {
			throw new UnsupportedOperationException("setValue");
		}
		public int compareTo(Object o2) {
			if (!(o2 instanceof MyMapEntry))
				throw new IllegalArgumentException(
					"Huh? Not a MapEntry?");
			Object otherKey = ((MyMapEntry)o2).getKey();
			return ((Comparable)key).compareTo((Comparable)otherKey);
		}
    }

	/** The set of Map.Entry objects returned from entrySet(). */
	private class MyMapSet extends AbstractSet {
		List list;
		MyMapSet(ArrayList al) {
			list = al;
		}
		public Iterator iterator() {
			return list.iterator();
		}
		public int size() {
			return list.size();
		}
	}

	/** Returns a set view of the mappings contained in this Map.
	 * Each element in the returned set is a Map.Entry.
	 * NOT guaranteed fully to implement the contract of entrySet
	 * declared in java.util.Map.
	 */
    public java.util.Set entrySet() {
		if (keys.size() != values.size())
			throw new IllegalStateException(
				"InternalError: keys and values out of sync");
		ArrayList al = new ArrayList();
		for (int i=0; i<keys.size(); i++) {
			al.add(new MyMapEntry(keys.get(i), values.get(i)));
		}
		return new MyMapSet(al); 
	}
}
//@@@@@@//
//structure/MyMapTest.java
//@@@@@@//
import java.util.*;

/**
 * Test the MyMap class.
 */
public class MyMapTest {

	public static void main(String[] argv) {

		// Construct and load the hash. This simulates loading a
		// database or reading from a file, or wherever the data is.

		Map map = new MyMap();

		// The hash maps from company name to address.
		// In real life this might map to an Address object...
		map.put("Adobe", "Mountain View, CA");
		map.put("Learning Tree", "Los Angeles, CA");
		map.put("IBM", "White Plains, NY");
		map.put("Netscape", "Mountain View, CA");
		map.put("Microsoft", "Redmond, WA");
		map.put("Sun", "Mountain View, CA");
		map.put("O'Reilly", "Sebastopol, CA");

		// Two versions of the "retrieval" phase.
		// Version 1: get one pair's value given its key
		// (presumably the key would really come from user input):
		String queryString = "O'Reilly";
		System.out.println("You asked about " + queryString + ".");
		String resultString = (String)map.get(queryString);
		System.out.println("They are located in: " + resultString);
		System.out.println();

		// Version 2: get ALL the keys and pairs 
		// (maybe to print a report, or to save to disk)
		Iterator k = map.keySet().iterator();
		while (k.hasNext()) {
			String key = (String) k.next();
			System.out.println("Key " + key + "; Value " +
				(String) map.get(key));
		}

		// Step 3 - try out the entrySet() method.
		Set es = map.entrySet();
		System.out.println("entrySet() returns " + es.size() + " Map.Entry's");
	}
}
//@@@@@@//
//structure/Person.java
//@@@@@@//
/** A sample class used in some of the notes accompanying this code set.
 * N.B. This is NOT "best practices": should all be private fields,
 * and get/set methods.  (Done this way so examples are shorter).
 */
public class Person {
	private String firstName, lastName;
	public String address;
	public String phone;
	public String Country;
	
	public Person(String f, String l) {
		firstName = f;
		lastName = l;
	}
	public String getFirstName() {
		return lastName;
	}
	public String getLastName() {
		return lastName;
	}
	public String getName() {
		return getFirstName() + ' ' + getLastName();
	}
	public String toString() {
		return getName();
	}
}
//@@@@@@//
//structure/PrefsDemo.java
//@@@@@@//
import java.util.prefs.Preferences;

/**
 * Simple demonstration of using Preferences.
 * @version $Id: PrefsDemo.java,v 1.2 2004/02/29 15:38:58 ian Exp $
 */
public class PrefsDemo {
	public static void main(String[] args) {

		// Setup the Preferences for this application, by class.
		Preferences prefs = Preferences.userNodeForPackage(PrefsDemo.class);

		// Retrieve some preferences previously stored, with defaults in case
		// this is the first run.
		String text    = prefs.get("textFontName", "lucida-bright");
		String display = prefs.get("displayFontName", "lucida-blackletter");
		System.out.println(text);
		System.out.println(display);

		// Assume the user chose new preference values: Store them back.
		prefs.put("textFontName", "times-roman");
		prefs.put("displayFontName", "helvetica");
	}
}
//@@@@@@//
//structure/PropsCompanies.java
//@@@@@@//
import java.util.Properties;

/**
 * Demonstrate Properties reading/writing.
 * @see HashTableDemo, for the older Hashtable.
 */
public class PropsComanies {

	public static void main(String[] argv) throws java.io.IOException {

		Properties props = new Properties();

		// Get my data
		props.put("Adobe", "Mountain View, CA");
		props.put("IBM", "White Plains, NY");
		props.put("Learning Tree", "Los Angeles, CA");
		props.put("Microsoft", "Redmond, WA");
		props.put("Netscape", "Mountain View, CA");
		props.put("O'Reilly", "Sebastopol, CA");
		props.put("Sun", "Mountain View, CA");

		// Now load additional properties
		props.load(System.in);

		// List merged properties, using System.out
		props.list(System.out);
	}
}
//@@@@@@//
//structure/PropsCust.java
//@@@@@@//
import java.io.*;
import java.util.*;

/**
 * Use a Properties object for customizing a program.
 */
public class PropsCust {
	Properties p;
	String userName;
	String userDir;

	/** A demonstration main program */
	public static void main(String[] argv) throws IOException {
		new PropsCust().process();
	}

	/** Construct a PropsCust program */
	PropsCust() throws IOException {
		p = new Properties();

		p.load(System.in);
	}

	/** Just show some properties */
	void process() {
		userName = p.getProperty("username", "Unknown User");
		userDir  = p.getProperty("directory", "/");

		System.out.println("Hello " + userName + ".");
		System.out.println("We are using the " + userDir + "directory today.");
	}
}
//@@@@@@//
//structure/PropsDemo.java
//@@@@@@//
import java.util.*;

/**
 * Demonstrate the Properties class
 */
public class PropsDemo {
	public static void main(String[] argv) {
	Properties ian = new Properties();

	// Set my data.
	ian.setProperty("name", "Ian Darwin");
	ian.setProperty("favorite popsicle", "cherry");
	ian.setProperty("favorite rock group", "Fleetwood Mac");
	ian.setProperty("favorite programming language", "Java");
	ian.setProperty("pencil color", "green");

	// should return the string "green".
	String ianColor = ian.getProperty("pencil color");

	// Don't know what it will return.
	String sysColor = System.getProperty("pencil color");

	// Now list the Properties, using System.out
	ian.list(System.out);
	}
}
//@@@@@@//
//structure/Queue.java
//@@@@@@//
/** Treat a LinkList as a Queue */
public class Queue extends java.util.LinkedList {
	public void q_add(Object o) {
		addLast(o);
	}

	public Object q_take() {
		return removeFirst();
	}

	public int q_len() {
		return size();
	}

	public boolean q_empty() {
		return size() == 0;
	}

	public Object q_check() {
		return getFirst();
	}

	// public void q_delete(Object o) {
	// }
}
//@@@@@@//
//structure/QueueTest.java
//@@@@@@//
import junit.framework.*;

/** A simple test case for Queue */
public class QueueTest extends TestCase {

	/** JUnit test classes require this constructor */
	public QueueTest(String name) {
		super(name);
	}

	protected Queue q;

	public void setUp() {
		q = new Queue();
		q.q_add("One");
		q.q_add("Two");
	}

	public void testQueue() {
		assertEquals(q.q_take(), "One");
		assertEquals(q.q_take(), "Two");
		q.q_add("Three");
		assertEquals(q.q_take(), "Three");
		assertTrue(q.size() ==  0);
		if (q.size() == 0)
			throw new IllegalArgumentException("q.size() returns 0 for 3");
		System.out.println("DONE");
	}
}
//@@@@@@//
//structure/SetDemo.java
//@@@@@@//
import java.util.*;
/**
 * Demonstrate the Set interface
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: SetDemo.java,v 1.4 2004/02/09 03:34:04 ian Exp $
 */
public class SetDemo {
	public static void main(String[] argv) {
		//+
		Set h = new HashSet();
		h.add("One");
		h.add("Two");
		h.add("One"); // DUPLICATE
		h.add("Three");
		Iterator it = h.iterator();
		while (it.hasNext()) {
			System.out.println(it.next());
		}
		//-
	}
}
//@@@@@@//
//structure/SetStuff.java
//@@@@@@//
import java.util.*;

/** Show the union and instersection of two sets. */
public class SetStuff {
	public static void main(String[] args) {

		// Create two sets.
		Set s1 = new HashSet();
		s1.add("Ian Darwin");
		s1.add("Bill Dooley");
		s1.add("Jesse James");

		Set s2 = new HashSet();
		s2.add("Ian Darwin");
		s2.add("Doolin' Dalton");

		Set union = new TreeSet(s1);
		union.addAll(s2);		// now contains the union

		print("union", union);

		Set intersect = new TreeSet(s1);
		intersect.retainAll(s2);

		print("intersection", intersect);

	}

	protected static void print(String label, Collection c) {

		System.out.println("--------------" + label + "--------------");

		Iterator it = c.iterator();
		while (it.hasNext()) {
			System.out.println(it.next());
		}
	}
}
//@@@@@@//
//structure/SortArray.java
//@@@@@@//
import java.util.*;

/** Demonstrate use of Arrays.sort()
 * @version $id$
 */
public class SortArray {
	public static void main(String[] unused) {
		String[] strings = {
			"painful", 
			"mainly",
			"gaining",
			"raindrops"
		};
		Arrays.sort(strings);
		for (int i=0; i<strings.length; i++)
			System.out.println(strings[i]);
	}
}
//@@@@@@//
//structure/SortBooleans.java
//@@@@@@//
import java.util.*;

/** Demonstrate use of Arrays.sort on Booleans(!).
 * Try it, you'll get a ClassCastException, as there is no ordering of Booleans
 * @version $Id: SortBooleans.java,v 1.2 2003/06/22 23:19:13 ian Exp $
 */
public class SortBooleans {
	public static void main(String[] unused) {
		Boolean[] data = {
			new Boolean(true),
			new Boolean(false),
			new Boolean(false),
			new Boolean(true),
		};
		Arrays.sort(data);		// EXPECT RUNTIME ERROR
		for (int i=0; i<data.length; i++)
			System.out.println(data[i]);
	}
}
//@@@@@@//
//structure/SortCollection.java
//@@@@@@//
import java.util.*;

/** Demonstrate use of Arrays.sort()
 * @version $id$
 */
public class SortCollection {
	public static void main(String[] unused) {
		List l = new ArrayList();
		l.add("painful");
		l.add("mainly");
		l.add("gaining");
		l.add("raindrops");
		
		Collections.sort(l);
		for (int i=0; i<l.size(); i++)
			System.out.println(l.get(i));
	}
}
//@@@@@@//
//structure/StringSort.java
//@@@@@@//

/* The contents of this file is borrowed from:
 * @(#)QSortAlgorithm.java	1.3   29 Feb 1996 James Gosling
 *
 * Copyright (c) 1994-1996 Sun Microsystems, Inc. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * and its documentation for NON-COMMERCIAL or COMMERCIAL purposes and
 * without fee is hereby granted. 
 * Please refer to the file http://www.javasoft.com/copy_trademarks.html
 * for further important copyright and trademark information and to
 * http://www.javasoft.com/licensing.html for further important
 * licensing information for the Java (tm) Technology.
 * 
 * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF
 * THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR
 * ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR
 * DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 * 
 * THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-
 * LINE CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE
 * PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT
 * NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE
 * SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE
 * SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE
 * PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES").  SUN
 * SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR
 * HIGH RISK ACTIVITIES.
 */

/**
 * A quick sort demonstration algorithm
 * SortAlgorithm.java
 *
 * @author James Gosling
 * @author Kevin A. Smith
 * @version 	@(#)QSortAlgorithm.java	1.3, 29 Feb 1996
 */
public class StringSort {

   /** This is a generic version of C.A.R Hoare's Quick Sort 
    * algorithm.  This will handle arrays that are already
    * sorted, and arrays with duplicate keys.<BR>
    *
    * If you think of a one dimensional array as going from
    * the lowest index on the left to the highest index on the right
    * then the parameters to this function are lowest index or
    * left and highest index or right.  The first time you call
    * this function it will be with the parameters 0, a.length - 1.
    *
    * @param a       a string array
    * @param lo0     left boundary of array partition
    * @param hi0     right boundary of array partition
    */
   void QuickSort(String a[], int lo0, int hi0)
   {
      int lo = lo0;
      int hi = hi0;
      String mid;

      if ( hi0 > lo0)
      {

         /* Arbitrarily establishing partition element as the midpoint of
          * the array.
          */
         mid = a[ ( lo0 + hi0 ) / 2 ];

         // loop through the array until indices cross
         while( lo <= hi ) {
            /* find the first element that is greater than or equal to 
             * the partition element starting from the left Index.
             */
            while( ( lo < hi0 ) && ( a[lo].compareTo(mid) < 0 ) )
               ++lo;

            /* find an element that is smaller than or equal to 
             * the partition element starting from the right Index.
             */
            while( ( hi > lo0 ) && ( a[hi].compareTo(mid) > 0 ) )
               --hi;

            // if the indexes have not crossed, swap
            if( lo <= hi ) 
            {
		String t = a[hi];
		a[hi] = a[lo];
		a[lo] = t;

               ++lo;
               --hi;
            }
         }

         /* If the right index has not reached the left side of array
          * must now sort the left partition.
          */
         if( lo0 < hi )
            QuickSort( a, lo0, hi );

         /* If the left index has not reached the right side of array
          * must now sort the right partition.
          */
         if( lo < hi0 )
            QuickSort( a, lo, hi0 );

	}

    }
}
//@@@@@@//
//structure/StrSort.java
//@@@@@@//
import java.util.*;

/**
 * StrSort demonstrates sorting of strings using Collections.sort.
 */
public class StrSort {
	/** The list of strings to be sorted */
	static public String rawStrings[] = {
		"Qwerty",
		"Ian",
		"de Raadt",
		"Java",
		"Gosling",
		"Alpha",
		"Zulu"
	};

	Vector v = new Vector();

	void load() {
		v = new Vector();
		for (int i=0; i<rawStrings.length; i++)
			v.addElement(rawStrings[i]);
	}

	void dump(String title) {
		System.out.println("***** " + title + " *****");
		for (int i=0; i<v.size(); i++)
			System.out.println("v["+i+"]="+v.elementAt(i));
	}

	/** Simple main program to test the sorting */
	public static void main(String[] argv) {
		System.out.println("StrSort Demo in Java");
		StrSort s = new StrSort();
		s.load();
		s.dump("Before");
		Collections.sort(s.v);
		s.dump("After");
	}
}
//@@@@@@//
//structure/StrSort1_0.java
//@@@@@@//
/**
 * StrSort demonstrates sorting of strings using a quicksort.
 * This is for JDK 1.0, which lacked the Collections API.
 * The actual sort is borrowed from the Java Demo Applet SortDemo,
 * whose copyright allows its use.
 */

public class StrSort1_0 {
	/** The list of strings to be sorted */
	static public String a[] = {
		"Qwerty",
		"Ian",
		"Java",
		"Gosling",
		"Alpha",
		"Zulu"
	};

	void dump(String a[], String title) {
		System.out.println("***** " + title + " *****");
		for (int i=0; i<a.length; i++)
			System.out.println("a["+i+"]="+a[i]);
	}

	/** Simple main program to test the sorting */
	public static void main(String[] argv) {
		System.out.println("StrSort Demo in Java");
		StrSort1_0 s = new StrSort1_0();
		s.dump(a, "Before");
		s.QuickSort(a, 0, a.length-1);
		s.dump(a, "After");
	}

/* The remainder of this file is borrowed from:
 * @(#)QSortAlgorithm.java	1.3   29 Feb 1996 James Gosling
 *
 * Copyright (c) 1994-1996 Sun Microsystems, Inc. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * and its documentation for NON-COMMERCIAL or COMMERCIAL purposes and
 * without fee is hereby granted. 
 * Please refer to the file http://www.javasoft.com/copy_trademarks.html
 * for further important copyright and trademark information and to
 * http://www.javasoft.com/licensing.html for further important
 * licensing information for the Java (tm) Technology.
 * 
 * SUN MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF
 * THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. SUN SHALL NOT BE LIABLE FOR
 * ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR
 * DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 * 
 * THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE
 * CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE
 * PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT
 * NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE
 * SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE
 * SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE
 * PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES").  SUN
 * SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR
 * HIGH RISK ACTIVITIES.
 */

/**
 * A quick sort demonstration algorithm
 * SortAlgorithm.java
 *
 * @author James Gosling
 * @author Kevin A. Smith
 * @version 	@(#)QSortAlgorithm.java	1.3, 29 Feb 1996
 */

   /** This is a generic version of C.A.R Hoare's Quick Sort 
    * algorithm.  This will handle arrays that are already
    * sorted, and arrays with duplicate keys.<BR>
    *
    * If you think of a one dimensional array as going from
    * the lowest index on the left to the highest index on the right
    * then the parameters to this function are lowest index or
    * left and highest index or right.  The first time you call
    * this function it will be with the parameters 0, a.length - 1.
    *
    * @param a       a string array
    * @param lo0     left boundary of array partition
    * @param hi0     right boundary of array partition
    */
   void QuickSort(String a[], int lo0, int hi0)
   {
      int lo = lo0;
      int hi = hi0;
      String mid;

      if ( hi0 > lo0)
      {

         /* Arbitrarily establishing partition element as the midpoint of
          * the array.
          */
         mid = a[ ( lo0 + hi0 ) / 2 ];

         // loop through the array until indices cross
         while( lo <= hi ) {
            /* find the first element that is greater than or equal to 
             * the partition element starting from the left Index.
             */
            while( ( lo < hi0 ) && ( a[lo].compareTo(mid) < 0 ) )
               ++lo;

            /* find an element that is smaller than or equal to 
             * the partition element starting from the right Index.
             */
            while( ( hi > lo0 ) && ( a[hi].compareTo(mid) > 0 ) )
               --hi;

            // if the indexes have not crossed, swap
            if( lo <= hi ) 
            {
		String t = a[hi];
		a[hi] = a[lo];
		a[lo] = t;

               ++lo;
               --hi;
            }
         }

         /* If the right index has not reached the left side of array
          * must now sort the left partition.
          */
         if( lo0 < hi )
            QuickSort( a, lo0, hi );

         /* If the left index has not reached the right side of array
          * must now sort the right partition.
          */
         if( lo < hi0 )
            QuickSort( a, lo, hi0 );

      }
   }
}
//@@@@@@//
//structure/StrSort1_1.java
//@@@@@@//
/**
 * StrSort demonstrates sorting of strings using a quicksort.
 * The actual sorting code, in StringSort.java, is borrowed from the 
 * Java Demo Applet SortDemo, whose copyright allows its use.
 * <p>
 * This may be useful on JDK1.1 (or even 1.0), which lacked the 
 * Collections API; on any modern Java, you'd use Arrays.sort() or 
 * Collections.sort() as appropriate; see StrSort.java.
 */

public class StrSort1_1 {
	/** The list of strings to be sorted */
	static public String a[] = {
		"Qwerty",
		"Ian",
		"Java",
		"Gosling",
		"Alpha",
		"Zulu"
	};

	/** Simple main program to test the sorting */
	public static void main(String[] argv) {
		System.out.println("StrSort Demo in Java");
		StringSort s = new StringSort();
		dump(a, "Before");
		s.QuickSort(a, 0, a.length-1);
		dump(a, "After");
	}

	static void dump(String a[], String title) {
		System.out.println("***** " + title + " *****");
		for (int i=0; i<a.length; i++)
			System.out.println("a["+i+"]="+a[i]);
	}

}
//@@@@@@//
//structure/StrSortCase.java
//@@@@@@//
import java.util.*;

/**
 * StrSortCase demonstrates sorting of strings using Collections.sort
 * AND ignoring case.
 */
public class StrSortCase {
	/** The list of strings to be sorted */
	static public String rawStrings[] = {
		"Qwerty",
		"Ian",
		"de Raadt",
		"Java",
		"Gosling",
		"Alpha",
		"Zulu"
	};

	Vector v = new Vector();

	void load() {
		v = new Vector();
		for (int i=0; i<rawStrings.length; i++)
			v.addElement(rawStrings[i]);
	}

	void dump(String title) {
		System.out.println("***** " + title + " *****");
		for (int i=0; i<v.size(); i++)
			System.out.println("v["+i+"]="+v.elementAt(i));
	}

	/** Simple main program to test the sorting */
	public static void main(String[] argv) {
		//+
		System.out.println("StrSort Demo Ignoring Case");
		StrSortCase s = new StrSortCase();
		s.load();
		s.dump("Before");
		Collections.sort(s.v, String.CASE_INSENSITIVE_ORDER);
		s.dump("After");
	}
}
//@@@@@@//
//structure/StructureDemo.java
//@@@@@@//
import java.util.*;

/** Dummy source of Objects, for structure demos.
 * @author Ian Darwin
 * @version $Id: StructureDemo.java,v 1.3 2004/03/07 23:54:07 ian Exp $
 */
public class StructureDemo {

	/** The max number of Objects to return */
	private final int MAX;

	/** Construct a StructureDemo */
	StructureDemo(int m) {
		MAX = m;
	}

	int n;


	/* Dummy method to return a sequence of 21 Calendar references,
	 * so the array should be sized >= 21.
	 */
	public Object getDate() {
		if (n++ > MAX)
			return null;
		return Calendar.getInstance();
	}
}
//@@@@@@//
//structure/SubstrCompDemo.java
//@@@@@@//
import java.util.*;

/** Demonstrate use of SubstringComparator.
 * @version $id$
 */
public class SubstrCompDemo {
	public static void main(String[] unused) {
		String[] strings = {
			"painful", 
			"mainly",
			"gaining",
			"raindrops"
		};
		Arrays.sort(strings);
		dump(strings, "Using Default Sort");
		Arrays.sort(strings, new SubstringComparator());
		dump(strings, "Using SubstringComparator");

	}
	static void dump(String[] args, String title) {
		System.out.println(title);
		for (int i=0; i<args.length; i++)
			System.out.println(args[i]);
	}
}
//@@@@@@//
//structure/SubstringComparator.java
//@@@@@@//
import java.util.Comparator;

/** Comparator for comparing strings ignoring first character.
 * @version $id$
 */
public class SubstringComparator implements Comparator {
	public int compare(Object o1, Object o2) {
		String s1 = o1.toString().substring(1);
		String s2 = o2.toString().substring(1);
		return s1.compareTo(s2);
		// or, more concisely:
		// return o1.toString().substring(1).equals(o2.toString().substring(1));
	}
}
//@@@@@@//
//structure/ToArray.java
//@@@@@@//
import java.util.*;

/** List to array */
public class ToArray {
	public static void main(String[] args) {
		List list = new ArrayList();
		list.add("Blobbo");
		list.add("Cracked");
		list.add("Dumbo");
		// list.add(new Date());	// Don't mix and match!

		// Convert a collection to Object[], which can store objects
		// of any type.
		Object[] ol = list.toArray();
		System.out.println("Array of Object has length " + ol.length);

		// This would throw an ArrayStoreException if the line
		// "list.add(new Date())" above were uncommented.
		String[] sl = (String[]) list.toArray(new String[0]);
		System.out.println("Array of String has length " + sl.length);
	}
}
//@@@@@@//
//structure/ToyStack.java
//@@@@@@//
/** Toy Stack. 
 * @version $Id: ToyStack.java,v 1.4 2004/03/08 00:44:19 ian Exp $
 */
public class ToyStack {

	/** The maximum stack depth */
	protected int MAX_DEPTH = 10;
	/** The current stack depth */
	protected int depth = 0;
	/* The actual stack */
	protected int[] stack = new int[MAX_DEPTH];

	/* Implement a toy stack version of push */
	protected void push(int n) {
		stack[depth++] = n;
	}
	/* Implement a toy stack version of pop */
	protected int pop() {
		return stack[--depth];
	}
	/* Implement a toy stack version of peek */
	protected int peek() {
		return stack[depth-1];
	}
}
//@@@@@@//
//structure/ToyStackTest.java
//@@@@@@//
import junit.framework.TestCase;

/**
 * @version $Id: ToyStackTest.java,v 1.1 2004/03/08 00:44:19 ian Exp $
 */
public class ToyStackTest extends TestCase {

	private ToyStack ts;

	public static void main(String[] args) {
		junit.textui.TestRunner.run(ToyStackTest.class);
	}

	public void setUp(){
		ts = new ToyStack();
	}
	public void testPushAndPop() {
		int i = 123987;
		ts.push(i);
		assertEquals(i, ts.pop());
	}

	public void testPeek() {
		int i = 1066;
		ts.push(i);
		assertEquals(i, ts.peek());
	}

}
//@@@@@@//
//structure/TreeSetDemo.java
//@@@@@@//
import java.util.*;

/**
 * TreeSet Demo.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: TreeSetDemo.java,v 1.3 2004/02/09 03:34:04 ian Exp $
 */
public class TreeSetDemo {
	public static void main(String[] argv) {
		//+
		/* A TreeSet keeps objects in sorted order. We use a
		 * Comparator published by String for case-insensitive
		 * sorting order.
		 */
		TreeSet tm = new TreeSet(String.CASE_INSENSITIVE_ORDER);
		tm.add("Gosling");
		tm.add("da Vinci");
		tm.add("van Gogh");
		tm.add("Java To Go");
		tm.add("Vanguard");
		tm.add("Darwin");
		tm.add("Darwin");	// TreeSet is Set, ignores duplicates.

		// Since it is sorted we can ask for various subsets
		System.out.println("Lowest (alphabetically) is " + tm.first());
		// Print how many elements are greater than "k"
		System.out.println(tm.tailSet("k").toArray().length + " elements higher than \"k\"");

		// Print the whole list in sorted order
		System.out.println("Sorted list:");
		java.util.Iterator t = tm.iterator();
		while (t.hasNext())
			System.out.println(t.next());
		//-
	}
}
//@@@@@@//
//structure/TwoDArrays.java
//@@@@@@//
// This is the Two-Dimensional Array Example from around 471-5-15.
public class TwoDArrays {
	static double data[][] = {
		{ 24, 100 },
		{ 10, 24 },
		{ 32, 98.6 },
	};
	public static void main(String[] av) {
		// Each row in the initialization winds up as a column
		// (see the diagram in the course notes!!), so this
		// is a 3 x 2 array.
		System.out.println("Width   = " + data.length);
		System.out.println("Height  = " + data[0].length);
		// The last element is data[2][1], NOT [1][2]!
		System.out.println("d[2][1] = " + data[2][1]); // prints 98.6
	}
}
//@@@@@@//
//structure/VectorDemo.java
//@@@@@@//
import java.util.*;

/**
 * Simple demo of the Vector class.
 */
public class VectorDemo {
	public static void main(String[] argv) {
		Vector v = new Vector();

		// Create a source of Objects
		StructureDemo source = new StructureDemo(15);

		// Add lots of elements to the Vector...
		v.add(source.getDate());
		v.add(source.getDate());
		v.add(source.getDate());

		// First print them out using a for loop.
		System.out.println("Retrieving by index:");
		for (int i = 0; i<v.size(); i++) {
			System.out.println("Element " + i + " = " + v.get(i));
		}
	}
}
//@@@@@@//
//structure/VectorIterator.java
//@@@@@@//
import java.util.*;
/** Iterator used to walk through a Vector.
 * @version $Id: VectorIterator.java,v 1.2 2000/11/25 17:56:25 ian Exp $
 */
public class VectorIterator {
	public static void main(String[] argv) {
		Vector v = new Vector();
		Enumeration e; 
		StructureDemo source = new StructureDemo(15);

		// Add lots of elements to the Vector...
		v.addElement(source.getDate());
		v.addElement(source.getDate());
		v.addElement(source.getDate());

		// Process the data structure using an iterator.
		int i = 0;
		Iterator it = v.iterator();

		// Remaining part of the code does not know or care
		// if the data is an an array, a Vector, or whatever.
		while (it.hasNext()) {
			Object o = it.next();
			System.out.println("Element " + i++ + " = " + o);
		}
	}
}
//@@@@@@//
//structure1.5/ArrayListGenericDemo.java
//@@@@@@//
import java.util.*;

public class ArrayListGenericDemo {
	public static void main(String[] args) {
		ArrayList<String> data = new ArrayList<String>();
		data.add("hello");
		data.add("goodbye");

		// data.add(new Date()); This won't compile!

		Iterator<String> it = data.iterator();
		while (it.hasNext()) {
			String s = it.next();
			System.out.println(s);
		}
	}
}//@@@@@@//
//structure1.5/AutoboxDemo.java
//@@@@@@//
public class AutoboxDemo {
	public static void main(String[] args) {
		int i = 42;
		foo(i);
	}

	public static void foo(Integer i) {
		System.out.println("Object = " + i);
	}
}//@@@@@@//
//structure1.5/EnumList.java
//@@@@@@//
/** Simple demo to print all the types of an enum. */
public class EnumList {
	public static void main(String[] args) {
		enum State { ON, OFF, UNKNOWN };
		for (State i : State.values()) {
			System.out.println(i);
		}
	}
}
//@@@@@@//
//structure1.5/ForeachArray.java
//@@@@@@//
public class ForeachArray {
	public static void main(String args[]) {
		String[] data = { "Toronto", "Stockholm" };
		for (String s : data) {
			System.out.println(s);
		}
	}
}
//@@@@@@//
//structure1.5/ForeachDemo.java
//@@@@@@//
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;

public class ForeachDemo {
	static void iterate(Collection<String> c) {
	    for (String s : c)
 		 System.out.println(s);
	}
	public static void main(String args[]) {
		List<String> l = new ArrayList<String>();
		l.add("Toronto");
		l.add("Stockholm");
		iterate(l);
	}
}
//@@@@@@//
//structure1.5/HashDemoGeneric.java
//@@@@@@//
import java.util.HashMap;

public class HashDemoGeneric {
	public static void main(String[] args) {
		HashMap<Integer,String> map = new HashMap<Integer,String>();

		map.put(1, "Ian");
		map.put(42, "Scott");
		map.put(123, "Somebody else");

		String name = map.get(42);
		System.out.println(name);
	}
}
//@@@@@@//
//structure1.5/Media.java
//@@@@@@//
/** These are the product categories that we sell
 */
public enum Media {

	book, music_cd, music_vinyl, movie_vhs, movie_dvd;

}
//@@@@@@//
//structure1.5/MediaDemo.java
//@@@@@@//
public class MediaDemo {
	public static void main(String[] args) {
		Media m = Media(3);
		System.out.println(m);
	}
}
//@@@@@@//
//structure1.5/MediaFactory.java
//@@@@@@//
/*
 * MediaFactory - give out Media enumeration constants
 * @version $Id: MediaFactory.java,v 1.2 2004/03/20 20:50:09 ian Exp $
 */
public class MediaFactory {

	public static void main(String[] args) {
		
		System.out.println(MediaFactory.getMedia("Book"));
	}
	public static Media getMedia(String s) {
		return Enum.valueOf(Media.class, s.toLowerCase());
	}
	public static Media getMedia(int n){
		return Media.values()[n];
	}
}
//@@@@@@//
//structure1.5/MediaFancy.java
//@@@@@@//
public enum MediaFancy {
	book {
		public String toString() { return "Book"; }
	},
	music_cd, music_vinyl, movie_vhs, movie_dvd;

	public static void main(String[] args) {
		MediaFancy[] data =  { book, movie_dvd, music_vinyl };
		for (MediaFancy mf : data) {
			System.out.println(mf);
		}
	}
}
//@@@@@@//
//structure1.5/MediaInvoicer.java
//@@@@@@//
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

/**
 * MediaInvoicer - Simple applicatin of Media, MediaFactory &c.
 * 
 * @author ian
 * @version $Id: MediaInvoicer.java,v 1.2 2004/03/08 03:30:59 ian Exp $
 */
public class MediaInvoicer {

	public static void main(String[] args) throws IOException {
		MediaInvoicer mi = new MediaInvoicer(System.in);
		Invoice i = mi.getInvoice();
		i.print(System.out);
	}
	BufferedReader myFile;
	public MediaInvoicer(InputStream is) {
		myFile = new BufferedReader(new InputStreamReader(is));
	}

	public Invoice getInvoice() throws IOException {
		String line;
		List < Item > items = new ArrayList < Item > ();
		while ((line = myFile.readLine()) != null) {
			if (line.startsWith("#")) {
				continue;
			}
			StringTokenizer st = new StringTokenizer(line);
			st.nextToken();
			Media m = MediaFactory.getMedia(st.nextToken());
			int stock = Integer.parseInt(st.nextToken());
			int qty = Integer.parseInt(st.nextToken());
			Item tmp = new Item(m, stock, qty);
			items.add(tmp);
		}
		return new Invoice(1, 3,
			(Item[]) items.toArray(new Item[items.size()]));
	}

	/** Inner class for line order item */
	class Item {
		Media product;
		int stockNumber;
		int quantity;
		/**
		 * @param product
		 * @param stockNumber
		 * @param quantity
		 */
		public Item(Media product, int stockNumber, int quantity) {
			super();
			this.product = product;
			this.stockNumber = stockNumber;
			this.quantity = quantity;
		}
		public String toString() {
			return "Item[" + product + " " + stockNumber + "]";
		}
	}
	/** Inner class for one invoice */
	class Invoice {
		int orderNumber;
		int custNumber;
		Item[] items;

		public Invoice(int orderNumber, int custNumber, Item[] items) {
			super();
			this.orderNumber = orderNumber;
			this.custNumber = custNumber;
			this.items = items;
		}
		public void print(PrintStream ps) {
			ps.println("*** Invoice ***");
			ps.println("Customer: " + custNumber + ")");
			ps.println("Our order number: " + orderNumber);
			for (int i = 0; i < items.length; i++) {
				Item it = items[i];
				ps.println(it);
			}
		}
	}
}
//@@@@@@//
//structure1.5/MediaList.java
//@@@@@@//
/** Simple demo to print all the types of media. */
public class MediaList {
	public static void main(String[] args) {
		for (Media m : Media.VALUES) {
			System.out.println(m);
		}
	}
}
//@@@@@@//
//structure1.5/MyStack.java
//@@@@@@//
/** A lax Stack implementation.
 * @version $Id: MyStack.java,v 1.4 2004/03/07 23:18:59 ian Exp $
 */
public class MyStack<T> {
	private int ix = 0;
	public static final int MAX = 10;
	private T[] data = (T[])new Object[MAX];

	public void push(T obj) {
		data[ix++] = obj;
	}

	public boolean hasNext() {
		return ix > 0;
	}

	public boolean hasRoom() {
		return ix < MAX;
	}

	public T pop() {
		if (hasNext()) {
			return data[--ix];
		}
		throw new ArrayIndexOutOfBoundsException(-1);
	}
}
//@@@@@@//
//structure1.5/MyStackDemo.java
//@@@@@@//
public class MyStackDemo {
	public static void main(String[] args) {
		MyStack<String> ms1 = new MyStack<String>();
		ms1.push("billg");
		ms1.push("scottm");

		while (ms1.hasNext()) {
			String name = ms1.pop();
			System.out.println(name);
		}

		// Old way of using Collections: not type safe.
		MyStack ms2 = new MyStack();
		ms2.push("billg");               // EXPECT WARNING
		ms2.push("scottm");              // EXPECT WARNING
		ms2.push(new java.util.Date());  // EXPECT WARNING
		
		// Show that it is broken 
		try {
			String bad = (String)ms2.pop();
			System.err.println("Didn't get expected exception!");
		} catch (ClassCastException ex) {
			System.out.println("Did get expected exception.");
		}

		// Removed the brokenness, print rest of it.
		while (ms2.hasNext()) {
			String name = (String)ms2.pop();
			System.out.println(name);
		}
	}
}
//@@@@@@//
//structure1.5/MyStackTest.java
//@@@@@@//
import junit.framework.TestCase;
import java.util.Date;

/**
 * JUnit test for MyStack.
 * @author ian
 */
public class MyStackTest extends TestCase {
	MyStack<String> ss;
	MyStack<Date> sd;
	
	public static void main(String[] args) {
		junit.textui.TestRunner.run(MyStackTest.class);
	}
	
	public void setUp() {
		ss = new MyStack<String>();
		sd = new MyStack<Date>();
	}
	public void testPush() {
		int i = 0; 
		do {
			ss.push("Hello #" + i++);
		} while (ss.hasRoom());
		assertEquals(i, MyStack.MAX);
	}

	public void testHasNext() {
	}

	public void testHasRoom() {
	}

	public void testPop() {
	}

}
//@@@@@@//
//structure1.5/Product.java
//@@@@@@//
import com.darwinsys.util.Debug;

public class Product {
	String title;
	String artist;
	Media  media;

	public Product(String artist, String title, Media media) {
		this.title = title;
		this.artist = artist;
		switch (media) {
		case book:
			Debug.println("media", title + " is a book");
			break;
		case music_cd:
			Debug.println("media", title + " is a CD");
			break;
		case music_vinyl:
			Debug.println("media", title + " is a relic");
			break;
		case movie_vhs:
			Debug.println("media", title + " is on tape");
			break;
		case movie_dvd:
			Debug.println("media", title + " is on DVD");
			break;
		default:
			Debug.println("media", "Warning: " + title + 
				": Unknown media " + media);
			break;
		}
		this.media = media;
	}
}
//@@@@@@//
//tar/TarEntry.java
//@@@@@@//
import java.io.*;

/** One entry in an archive file.
 * @author Ian Darwin
 * @version $Id: TarEntry.java,v 1.7 2004/03/06 21:16:19 ian Exp $
 * @note
 * Tar format info taken from John Gilmore's public domain tar program,
 * @(#)tar.h 1.21 87/05/01	Public Domain, which said:
 * "Created 25 August 1985 by John Gilmore, ihnp4!hoptoad!gnu."
 * John is now gnu@toad.com, and by another path tar.h is GPL'd in GNU Tar.
 */
public class TarEntry {
	/** Where in the tar archive this entry's HEADER is found. */
	public long fileOffset = 0;

	/** The maximum size of a name */
	public static final int	NAMSIZ	= 100;
	public static final int	TUNMLEN	= 32;
	public static final int	TGNMLEN	= 32;

	// Next fourteen fields constitute one physical record.
	// Padded to TarFile.RECORDSIZE bytes on tape/disk.
	// Lazy Evaluation: just read fields in raw form, only format when asked.

	/** File name */
	byte[]	name = new byte[NAMSIZ];
	/** permissions, e.g., rwxr-xr-x? */
	byte[]	mode = new byte[8];
	/* user */
	byte[]	uid = new byte[8];
	/* group */
	byte[]	gid = new byte[8];
	/* size */
	byte[]	size = new byte[12];
	/* UNIX modification time */
	byte[]	mtime = new byte[12];
	/* checksum field */
	byte[]	chksum = new byte[8];
	byte	type;
	byte[]	linkName = new byte[NAMSIZ];
	byte[]	magic = new byte[8];
	byte[]	uname = new byte[TUNMLEN];
	byte[]	gname = new byte[TGNMLEN];
	byte[]	devmajor = new byte[8];
	byte[]	devminor = new byte[8];

	// End of the physical data fields.

	/* The magic field is filled with this if uname and gname are valid. */
	public static final byte TMAGIC[] = {
		// 'u', 's', 't', 'a', 'r', ' ', ' ', '\0'
		0, 0, 0, 0, 0, 0, 0x20, 0x20, 0
	}; /* 7 chars and a null */

	/* Type value for Normal file, Unix compatibility */
	public static final int	LF_OLDNORMAL ='\0';		
	/* Type value for Normal file */
	public static final int	LF_NORMAL = '0';
	/* Type value for Link to previously dumped file */
	public static final int LF_LINK = 	'1';
	/* Type value for Symbolic link */
	public static final int LF_SYMLINK = '2';
	/* Type value for Character special file */
	public static final int LF_CHR = '3';
	/* Type value for Block special file */
	public static final int LF_BLK = '4';
	/* Type value for Directory */
	public static final int LF_DIR	 = '5';
	/* Type value for FIFO special file */
	public static final int LF_FIFO	 = '6';
	/* Type value for Contiguous file */
	public static final int LF_CONTIG = '7';

	/* Constructor that reads the entry's header. */
	public TarEntry(RandomAccessFile is) throws IOException, TarException {

		fileOffset = is.getFilePointer();

		// read() returns -1 at EOF
		if (is.read(name) < 0)
			throw new EOFException();
		// Tar pads to block boundary with nulls.
		if (name[0] == '\0')
			throw new EOFException();
		// OK, read remaining fields.
		is.read(mode);
		is.read(uid);
		is.read(gid);
		is.read(size);
		is.read(mtime);
		is.read(chksum);
		type = is.readByte();
		is.read(linkName);
		is.read(magic);
		is.read(uname);
		is.read(gname);
		is.read(devmajor);
		is.read(devminor);

		// Since the tar header is < 512, we need to skip it.
		is.skipBytes((int)(TarFile.RECORDSIZE -
			(is.getFilePointer() % TarFile.RECORDSIZE)));

		// TODO if checksum() fails,
		//	throw new TarException("Failed to find next header");

	}

	/** Returns the name of the file this entry represents. */
	public String getName() {
		return new String(name).trim();
	}

	public String getTypeName() {
		switch(type) {
		case LF_OLDNORMAL:
		case LF_NORMAL:
			return "file";
		case LF_LINK:
			return "link w/in archive";
		case LF_SYMLINK:
			return "symlink";
		case LF_CHR:
		case LF_BLK:
		case LF_FIFO:
			return "special file";
		case LF_DIR:
			return "directory";
		case LF_CONTIG:
			return "contig";
		default:
			throw new IllegalStateException("TarEntry.getTypeName: type " + type + " invalid");
		}
	}

	/** Returns the UNIX-specific "mode" (type+permissions) of the entry */
	public int getMode() {
		try {
			return Integer.parseInt(new String(mode).trim(), 8) & 0777;
		} catch (IllegalArgumentException e) {
			return 0;
		}
	}

	/** Returns the size of the entry */
	public int getSize() {
		try {
			return Integer.parseInt(new String(size).trim(), 8);
		} catch (IllegalArgumentException e) {
			return 0;
		}
	}

	/** Returns the name of the file this entry is a link to,
	 * or null if this entry is not a link.
	 */
	public String getLinkName() {
		// if (isLink())
		// 	return null;
		return new String(linkName).trim();
	}

	
	/** Returns the modification time of the entry */
	public long getTime() {
		try {
			return Long.parseLong(new String(mtime).trim(), 8);
		} catch (IllegalArgumentException e) {
			return 0;
		}
	}

	/** Returns the string name of the userid */
	public String getUname() {
		return new String(uname).trim();
	}

	/** Returns the string name of the group id */
	public String getGname() {
		return new String(gname).trim();
	}

	/** Returns the numeric userid of the entry */
	public int getuid() {
		try {
			return Integer.parseInt(new String(uid).trim());
		} catch (IllegalArgumentException e) {
			return -1;
		}
	}
	/** Returns the numeric gid of the entry */
	public int getgid() {
		try {
			return Integer.parseInt(new String(gid).trim());
		} catch (IllegalArgumentException e) {
			return -1;
		}
	}

	/** Returns true if this entry represents a file */
	boolean isFile() {
		return type == LF_NORMAL || type == LF_OLDNORMAL;
	}

	/** Returns true if this entry represents a directory */
	boolean isDirectory() {
		return type == LF_DIR;
	}

	/** Returns true if this a hard link (to a file in the archive) */
	boolean isLink() {
		return type == LF_LINK;
	}

	/** Returns true if this a symbolic link */
	boolean isSymLink() {
		return type == LF_SYMLINK;
	}

	/** Returns true if this entry represents some type of UNIX special file */
	boolean isSpecial() {
		return type == LF_CHR || type == LF_BLK || type == LF_FIFO;
	}

	public String toString() {
		return "TarEntry[" + getName() + ']';
	} 
}
//@@@@@@//
//tar/TarException.java
//@@@@@@//
/*
 * Exception for TarFile and TarEntry.
 * $Id: TarException.java,v 1.3 1999/10/06 15:13:53 ian Exp $
 */
public class TarException extends java.io.IOException {
	public TarException() {
		super();
	}
	public TarException(String msg) {
		super(msg);
	}
}
//@@@@@@//
//tar/TarFile.java
//@@@@@@//
import java.io.*;
import java.util.*;

/**
 * Tape Archive Lister, patterned loosely after java.util.ZipFile.
 * Since, unlike Zip files, there is no central directory, you have to
 * read the entire file either to be sure of having a particular file's
 * entry, or to know how many entries there are in the archive.
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: TarFile.java,v 1.12 2004/03/07 17:53:15 ian Exp $
 */

public class TarFile {
	/** True after we've done the expensive read. */
	protected boolean read = false;
	/** The list of entries found in the archive */
	protected Vector list;

	/** Size of header block. */
	public static final int	RECORDSIZE = 512;

	/* Size of each block, in records */
	protected int blocking;
	/* Size of each block, in bytes */
	protected int blocksize;

	/** File containing archive */
	protected String	fileName;

	/** Construct (open) a Tar file by name */
	public TarFile(String name) {
		fileName = name;
		list = new Vector();
	}

	/** Construct (open) a Tar file by File */
	public TarFile(java.io.File name) throws IOException {
		this(name.getCanonicalPath());
	}

	/** The main datastream. */
	protected RandomAccessFile is;

	/** Read the Tar archive in its entirety.
	 * This is semi-lazy evaluation, in that we don't read the file
	 * until we need to.
	 * A future revision may use even lazier evaluation: in getEntry,
	 * scan the list and, if not found, continue reading!
	 * For now, just read the whole file.
	 */
	protected void readFile() throws IOException, TarException {
	 	is = new RandomAccessFile(fileName, "r");
		TarEntry hdr;
		try {
			do {
				hdr = new TarEntry(is);
				if (hdr.getSize() < 0) {
					System.out.println("Size < 0");
					break;
				}
				// System.out.println(hdr.toString());
				list.addElement(hdr);
				// Get the size of the entry
				int nbytes = hdr.getSize(), diff;
				// Round it up to blocksize.
				if ((diff = (nbytes % RECORDSIZE)) != 0) {
					nbytes += RECORDSIZE - diff;
				}
				// And skip over the data portion.
				// System.out.println("Skipping " + nbytes + " bytes");
				is.skipBytes(nbytes);
			} while (true);
		} catch (EOFException e) {
			// OK, just stop reading.
		}
		// All done, say we've read the contents.
		read = true;
	}

	/* Close the Tar file. */
	public void close() {
		try {
			is.close();
		} catch (IOException e) {
			// nothing to do
		}
	}

	/* Returns an enumeration of the Tar file entries. */
	public Enumeration entries() throws IOException, TarException {
		if (!read) {
			readFile();
		}
		return list.elements();
	}

	/** Returns the Tar entry for the specified name, or null if not found. */
	public TarEntry getEntry(String name) {
		for (int i=0; i<list.size(); i++) {
			TarEntry e = (TarEntry)list.elementAt(i);
			if (name.equals(e.getName()))
				return e;
		}
		return null;
	}

	/** Returns an InputStream for reading the contents of the 
	 * specified entry from the archive.
	 * May cause the entire file to be read.
	 */
	public InputStream getInputStream(TarEntry entry) {
		return null;
	}

	/** Returns the path name of the Tar file. */
	public String getName() {
		return fileName;
	}

	/** Returns the number of entries in the Tar archive.
	 * May cause the entire file to be read.
	 * XXX Obviously not written yet, sorry.
	 */
	public int size() {
		return 0;
	}
}
//@@@@@@//
//tar/TarList.java
//@@@@@@//
import java.io.*;
import java.text.*;	// only for formatting
import java.util.*;

/**
 * Demonstrate the Tar archive lister.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: TarList.java,v 1.7 2004/03/07 17:47:35 ian Exp $
 */
public class TarList {
	public static void main(String[] argv) throws IOException, TarException {
		if (argv.length == 0) {
			System.err.println("Usage: TarList archive");
			System.exit(1);
		}
		new TarList(argv[0]).list();
	}
	/** The TarFile we are reading */
	TarFile tf;

	/** Constructor */
	public TarList(String fileName) {
		tf = new TarFile(fileName);
	}

	/** Generate and print the listing */
	public void list() throws IOException, TarException {
		Enumeration list = tf.entries();
		while (list.hasMoreElements()) {
			TarEntry e = (TarEntry)list.nextElement();
			System.out.println(toListFormat(e));
		}
	}

	protected StringBuffer sb;
	/** Shift used in formatting permissions */
	protected static int[] shft = { 6, 3, 0 };
	/** Format strings used in permissions */
	protected static String rwx[] = {
		"---", "--x", "-w-", "-wx",
		"r--", "r-x", "rw-", "rwx"
	};
	/** NumberFormat used in formatting List form string */
	NumberFormat sizeForm = new DecimalFormat("00000000");
	/** Date used in printing mtime */
	Date date = new Date();
	SimpleDateFormat dateForm =
		new SimpleDateFormat ("yyyy-MM-dd HH:mm");

	/** Format a TarEntry the same way that UNIX tar does */
	public String toListFormat(TarEntry e) {
		sb = new StringBuffer();
		switch(e.type) {
			case TarEntry.LF_OLDNORMAL:
			case TarEntry.LF_NORMAL:
			case TarEntry.LF_CONTIG:
			case TarEntry.LF_LINK:		// hard link: same as file
				sb.append('-');	// 'f' would be sensible
				break;
			case TarEntry.LF_DIR:
				sb.append('d');
				break;
			case TarEntry.LF_SYMLINK:
				sb.append('l');
				break;
			case TarEntry.LF_CHR:		// UNIX character device file
				sb.append('c');
				break;
			case TarEntry.LF_BLK:		// UNIX block device file
				sb.append('b');
				break;
			case TarEntry.LF_FIFO:		// UNIX named pipe
				sb.append('p');
				break;
			default:			// Can't happen?
				sb.append('?');
				break;
		}

		// Convert e.g., 754 to rwxrw-r--
		int mode = e.getMode();
		for (int i=0; i<3; i++) {
			sb.append(rwx[mode >> shft[i] & 007]);
		}
		sb.append(' ');

		// owner and group
		sb.append(e.getUname()).append('/').append(e.getGname()).append(' ');

		// size
		// DecimalFormat can't do "%-9d", so we do part of it ourselves
		sb.append(' ');
		String t = sizeForm.format(e.getSize());
		boolean digit = false;
		char c;
		for (int i=0; i<8; i++) {
			c = t.charAt(i);
			if (!digit && i<(8-1) && c == '0')
				sb.append(' ');		// leading space
			else {
				digit = true;
				sb.append(c);
			}
		}
		sb.append(' ');

		// mtime
		// copy file's mtime into Data object (after scaling
		// from "sec since 1970" to "msec since 1970"), and format it.
		date.setTime(1000*e.getTime());
		sb.append(dateForm.format(date)).append(' ');

		sb.append(e.getName());
		if (e.isLink())
			sb.append(" link to " ).append(e.getLinkName());
		if (e.isSymLink())
			sb.append(" -> " ).append(e.getLinkName());

		return sb.toString();
	}
}
//@@@@@@//
//template/AppApp.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

/**
 * Example of a class that can be used as an Applet or an Application
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version #Id$
 */
public class AppApp extends Applet {
	boolean inAnApplet = true;
	Label status;		// for Application showStatus()

	public void init() {
		add(new Label("This is my demo Applet"));
		showStatus("My applet is running");
	}

	public static void main(String[] av) {
		AppApp app = new AppApp();
		final Frame f = new Frame("AppApp Demo");
		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				f.hide();
				f.dispose();
			}
		});
		f.setLayout(new BorderLayout());
		app.inAnApplet = false;
		f.add("Center", app);
		// Must do this before init() since init() may use showStatus()
		f.add("South", app.status = new Label());
		f.setSize(300, 200);
		app.status.setSize(f.getSize().width, app.status.getSize().height);

		// Here we pretend to be a browser!
		// A fancier version would make an AppletStub and pass it
		// into the Applet with getAppletStub().
		app.init();
		app.start();

		f.setVisible(true);
	}
	public void showStatus(String s) {
		 if (inAnApplet) {
			 super.showStatus(s);	// call version in Browser
		 } else {
			 status.setText(s);		// do it yourself.
		 }
	}
}
//@@@@@@//
//template/Applet.java
//@@@@@@//
import java.applet.*;
import java.awt.*;

/* Example of an Applet.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version #Id$
 */
public class Applet extends java.applet.Applet {
	public void init() {
		// initialize your applet GUI here
	}

	public void paint(Graphics g) {
		g.drawString("Welcome to Java", 50, 50);
	}
}
//@@@@@@//
//template/Filter.java
//@@@@@@//
import java.io.*;

/** Filter - template line-mode filter.
 *
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Filter.java,v 1.4 2004/02/09 03:34:05 ian Exp $
 */

public class Filter {

    /** Process one file
	 */
    protected void process(String fileName, LineNumberReader is) {
        try {
            String inputLine;

            while ((inputLine = is.readLine()) != null) {
				// This template Null Filter copies to stdout.
				// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
				// Typically this is all you need to change.
				// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
				System.out.println(inputLine);
            }
            is.close();
        } catch (IOException e) {
            System.out.println("IOException: " + e);
        }
    }

	/** This simple main program looks after filenames and
	 * opening files and such like for you.
	 */
    public static void main(String[] av) {
        Filter o = new Filter();
        if (av.length == 0) {
            o.process("standard input", new LineNumberReader(
				new InputStreamReader(System.in)));
		} else {
			for (int i=0; i<av.length; i++)
				try {
					o.process(av[i],
						new LineNumberReader(new FileReader(av[i])));
				} catch (FileNotFoundException e) {
					System.err.println(e);
				}
        }
    }
}
//@@@@@@//
//template/G2D.java
//@@@@@@//
import java.awt.*;

/** Template Graphics2D object
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version #Id$
 */
public class G2D extends Component {

	/** Construct the drawing object */
	public G2D() {
		// setup any data here
	}

	/** Paint this component, casting "Graphics g" to a Graphics2D object */
	public void paint(Graphics g) {
		Graphics2D g2 = (Graphics2D)g;
		// g2.draw(something);
	}

	public Dimension getPreferredSize() {
		return new Dimension(200, 200);
	}
} 
//@@@@@@//
//template/GUIextendsFrame.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;

/** Template standalone GUI application.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version #Id$
 */
public class GUIextendsFrame extends Frame {
	boolean unsavedChanges = false;
	Button quitButton;

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create a GUIextendsFrame object, tell it to show up
		new GUIextendsFrame().setVisible(true);
	}

	/** Construct the object including its GUI */
	public GUIextendsFrame() {
		super("GUIextendsFrame");
		setLayout(new FlowLayout());
		add(new Label("Hello, and welcome to the world of Java"));
		add(quitButton = new Button("Exit"));
		quitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				setVisible(false);
				dispose();
				System.exit(0);
			}
		});
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		// addWindowListener(new WindowAdapter() {
		// 	public void windowClosing(WindowEvent e) {
		// 		setVisible(false);
		// 		dispose();
		// 		System.exit(0);
		// 	}
		// });
			
		pack();
	}
}
//@@@@@@//
//template/GUIwithFrame.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;

/** Simple GUI demonstration: construct a Frame and populate it.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version #Id$
 */
public class GUIwithFrame {

	/** "main" method */
	public static void main(String[] av) {
		Button quitButton;

		// create a GUIwithFrame object and make it show
		final Frame f = new Frame();
		f.setLayout(new FlowLayout());
		f.add(new Label("Hello, and welcome to the world of Java"));
		f.add(quitButton = new Button("Exit"));
		quitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				f.setVisible(false);
				f.dispose();
				System.exit(0);
			}
		});

		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		// Set the Frame's windowListener to be a trivial WindowAdapter
		// subclass that just calls System.exit(). Not ideal but works here.
		// DO NOT USE THIS in any program that saves user input in memory!
		// f.addWindowListener(new WindowAdapter() {
		// 	public void windowClosing(WindowEvent e) {
		// 		System.exit(0);
		// 		return;
		// 	}
		// });
		f.add(new TextArea(24,80));
		f.pack();
		f.setVisible(true);
	}
}
//@@@@@@//
//template/junitTest.java
//@@@@@@//
import junit.framework.*;

/** A simple test case for XXX.
 * This class' name should be XXXTest, where XXX is the class it tests.
 */
public class junitTest extends TestCase {

	protected String f;

	/** JUnit test classes require this constructor */
	public junitTest(String name) {
		super(name);
	}

	public void testXXX() {
		f = "...";
		assertEquals("Ian Darwin", f);
	}
}
//@@@@@@//
//template/main.java
//@@@@@@//
/**
 * Template for standalone, line-mode main program.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version ?Id$
 */
public class main {
	public static void main(String[] argv) {
		//+
		System.out.println("XXX ");
		//-
	}
}
//@@@@@@//
//template/mainopts.java
//@@@@@@//
import com.darwinsys.lang.GetOpt;

/** Template main program using GetOpt.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: mainopts.java,v 1.5 2004/02/09 03:34:05 ian Exp $
 */
public class mainopts {
	public static void main(String[] argv) {
		String argChars = "o:hv";
		GetOpt go = new GetOpt("ho:v");
		boolean verbose = false;

		char c;
		while ((c = go.getopt(argv)) != 0) {
			switch(c) {
				case 'h':
					System.out.println("HELP!!");
					break;
				case 'o':
					System.out.print("-o Option " + go.optarg());
					break;
				case 'v':
					verbose = true;
					break;
				default:
					System.err.println("Unknown option char " + ((char)c));
			}
		}
		for (int i = go.getOptInd(); i<argv.length; i++)
			System.out.println("Filename-like arg " + argv[i]);
	}
}
//@@@@@@//
//template/StrutsAction.java
//@@@@@@//
package actions;

import jabacart.*;

import org.apache.struts.action.*;

import javax.servlet.*;
import javax.servlet.http.*;
import java.util.Properties;

/** Dummy Action.
 */
public class DummyAction extends Action {

	public ActionForward execute( 
		ActionMapping mapping, ActionForm form,
		HttpServletRequest request, HttpServletResponse response) {

		ServletContext application = getServlet().getServletContext();
		HttpSession session = request.getSession();

		ActionErrors errors = new ActionErrors();
		ActionMessages messages = new ActionMessages();

        // if (!(form instanceof DynaActionForm)) {
		// 	throw new IllegalArgumentException( /* "can't happen" */
		// 		"Input form not a valid DynaForm, configuration error?");
		// }
		// DynaActionForm theForm = (DynaActionForm)form;

		// if (success) {
		// 	messages.add(ActionErrors.GLOBAL_MESSAGE,
		// 		new ActionMessage("success.added.member", member.getName()));
		// 	saveMessages(request, messages);
		// }

		// if (failure) {
		// 	errors.add(ActionErrors.GLOBAL_ERROR,
		// 		new ActionError("error.insert", p.getTitle()));
		// 	saveErrors(request, errors);
		// 	return new ActionForward(mapping.getInput());
		// }

		return mapping.findForward("notwrittenyet");
	}
}
//@@@@@@//
//template/Swing.java
//@@@@@@//
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/** Template standalone Swing GUI application.
 * @author	Ian Darwin, http://www.darwinsys.com/
 * @version #Id$
 */
public class Swing extends JComponent {
	boolean unsavedChanges = false;
	JButton quitButton;

	/** "main program" method - construct and show */
	public static void main(String[] av) {
		// create a Swing object, tell it to show up
		final JFrame f = new JFrame("Swing");
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		Swing comp = new Swing();
		f.getContentPane().add(comp);
		comp.quitButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				f.setVisible(false);
				f.dispose();
				System.exit(0);
			}
		});
		f.addWindowListener(new WindowAdapter() {
			public void windowClosing(WindowEvent e) {
				f.setVisible(false);
				f.dispose();
				System.exit(0);
			}
		});
		f.pack();
		f.setLocation(200, 200);
		f.setVisible(true);
	}

	/** Construct the object including its GUI */
	public Swing() {
		super();
		add(new Label("Hello, and welcome to the world of Java"));
		add(quitButton = new JButton("Exit")); 
	}

	// public Dimension getMinimumSize() {
	// 	return new Dimension(50, 50);
	// }

	// public Dimension getPreferredSize() {
	// 	return new Dimension(100, 100);
	// }
}
//@@@@@@//
//textproc/Diff.java
//@@@@@@//
// Diff -- text file difference utility.
// See full docu-comment at beginning of Diff class.

// $Id: Diff.java,v 1.6 2004/02/09 03:34:05 ian Exp $

import java.io.*;

/** This is the info kept per-file.     */
class fileInfo {		

	static final int MAXLINECOUNT = 20000;

	DataInputStream file;	/* File handle that is open for read.  */
	public int maxLine;	/* After input done, # lines in file.  */
	node symbol[]; /* The symtab handle of each line. */
	int other[]; /* Map of line# to line# in other file */
                                /* ( -1 means don't-know ).            */
				/* Allocated AFTER the lines are read. */

	/**
	 * Normal constructor with one filename; file is opened and saved.
	 */
	fileInfo( String filename ) {
		symbol = new node [ MAXLINECOUNT+2 ];
		other  = null;		// allocated later!
		try {
			file = new DataInputStream(
				new FileInputStream( filename));
		} catch (IOException e) {
			  System.err.println("Diff can't read file " +
				filename );
			  System.err.println("Error Exception was:" + e );
			  System.exit(1);
		}
	}
	// This is done late, to be same size as # lines in input file.
	void alloc() {
		other  = new int[symbol.length + 2];
	}
};

/**
 * diff         Text file difference utility.
 * ----         Copyright 1987, 1989 by Donald C. Lindsay,
 *              School of Computer Science,  Carnegie Mellon University.
 *              Copyright 1982 by Symbionics.
 *              Use without fee is permitted when not for direct commercial
 *              advantage, and when credit to the source is given. Other uses
 *              require specific permission.
 *
 * Converted from C to Java by Ian F. Darwin, http://www.darwinsys.com/, January, 1997.
 * Copyright 1997, Ian F. Darwin.
 *
 * Conversion is NOT FULLY TESTED.
 *
 * USAGE:      diff oldfile newfile
 *
 * This program assumes that "oldfile" and "newfile" are text files.
 * The program writes to stdout a description of the changes which would
 * transform "oldfile" into "newfile".
 *
 * The printout is in the form of commands, each followed by a block of
 * text. The text is delimited by the commands, which are:
 *
 *    DELETE AT n
 *         ..deleted lines
 *
 *    INSERT BEFORE n
 *         ..inserted lines
 *
 *    n MOVED TO BEFORE n
 *         ..moved lines
 *
 *    n CHANGED FROM
 *         ..old lines
 *    CHANGED TO
 *         ..newer lines
 *
 * The line numbers all refer to the lines of the oldfile, as they are
 *    numbered before any commands are applied.
 * The text lines are printed as-is, without indentation or prefixing. The
 *    commands are printed in upper case, with a prefix of ">>>>", so that
 *    they will stand out. Other schemes may be preferred.
 * Files which contain more than MAXLINECOUNT lines cannot be processed.
 *    This can be fixed by changing "symbol" to a Vector.
 * The algorithm is taken from Communications of the ACM, Apr78 (21, 4, 264-),
 *    "A Technique for Isolating Differences Between Files."
 *    Ignoring I/O, and ignoring the symbol table, it should take O(N) time.
 *    This implementation takes fixed space, plus O(U) space for the symbol
 *    table (where U is the number of unique lines). Methods exist to change
 *    the fixed space to O(N) space.
 * Note that this is not the only interesting file-difference algorithm. In
 *    general, different algorithms draw different conclusions about the
 *    changes that have been made to the oldfile. This algorithm is sometimes
 *    "more right", particularly since it does not consider a block move to be 
 *    an insertion and a (separate) deletion. However, on some files it will be
 *    "less right". This is a consequence of the fact that files may contain
 *    many identical lines (particularly if they are program source). Each
 *    algorithm resolves the ambiguity in its own way, and the resolution
 *    is never guaranteed to be "right". However, it is often excellent.
 * This program is intended to be pedagogic.  Specifically, this program was
 *    the basis of the Literate Programming column which appeared in the
 *    Communications of the ACM (CACM), in the June 1989 issue (32, 6,
 *    740-755).
 * By "pedagogic", I do not mean that the program is gracefully worded, or
 *    that it showcases language features or its algorithm. I also do not mean
 *    that it is highly accessible to beginners, or that it is intended to be
 *    read in full, or in a particular order. Rather, this program is an
 *    example of one professional's style of keeping things organized and
 *    maintainable.
 * The program would be better if the "print" variables were wrapped into
 *    a struct. In general, grouping related variables in this way improves
 *    documentation, and adds the ability to pass the group in argument lists.
 * This program is a de-engineered version of a program which uses less
 *    memory and less time.  The article points out that the "symbol" arrays
 *    can be implemented as arrays of pointers to arrays, with dynamic
 *    allocation of the subarrays.  (In C, macros are very useful for hiding 
 *    the two-level accesses.) In Java, a Vector would be used. This allows an
 *    extremely large value for MAXLINECOUNT, without dedicating fixed arrays.
 *    (The "other" array can be allocated after the input phase, when the exact
 *    sizes are known.) The only slow piece of code is the "strcmp" in the tree
 *    descent: it can be speeded up by keeping a hash in the tree node, and
 *    only using "strcmp" when two hashes happen to be equal.
 *
 * Change Log
 * ----------
 *  1Jan97 Ian F. Darwin: first working rewrite in Java, based entirely on
 * 	D.C.Lindsay's reasonable C version.
 *	Changed comments from /***************** to /**, shortened, added
 *	whitespace, used tabs more, etc.
 *  6jul89 D.C.Lindsay, CMU: fixed portability bug. Thanks, Gregg Wonderly.
 *         Just changed "char ch" to "int ch". 
 *         Also added comment about way to improve code.
 * 10jun89 D.C.Lindsay, CMU: posted version created.
 *         Copyright notice changed to ACM style, and Dept. is now School.
 *         ACM article referenced in docn.
 * 26sep87 D.C.Lindsay, CMU: publication version created.
 *         Condensed all 1982/83 change log entries.
 *         Removed all command line options, and supporting code. This 
 *         simplified the input code (no case reduction etc). It also
 *         simplified the symbol table, which was capable of remembering
 *         offsets into files (instead of strings), and trusting (!) hash
 *         values to be unique.
 *         Removed dynamic allocation of arrays: now fixed static arrays.
 *         Removed speed optimizations in symtab package.
 *         Removed string compression/decompression code.
 *         Recoded to Unix standards from old Lattice/MSDOS standards.
 *         (This affected only the #include's and the IO.)
 *         Some renaming of variables, and rewording of comments.
 * 1982/83 D.C.Lindsay, Symbionics: created.
 *
 * @author	Ian F. Darwin, Java version
 * @version	Java version 0.9, 1997
 * @author	D. C. Lindsay, C version (1982-1987)
 *
 */
public class Diff {

	/** block len > any possible real block len */
	final int UNREAL=Integer.MAX_VALUE;

	/** Keeps track of information about file1 and file2 */
	fileInfo oldinfo, newinfo;

	/** blocklen is the info about found blocks. It will be set to 0, except
	 * at the line#s where blocks start in the old file. At these places it
	 * will be set to the # of lines in the block. During printout ,
	 * this # will be reset to -1 if the block is printed as a MOVE block
	 * (because the printout phase will encounter the block twice, but
	 * must only print it once.)
	 * The array declarations are to MAXLINECOUNT+2 so that we can have two
	 * extra lines (pseudolines) at line# 0 and line# MAXLINECOUNT+1
	 * (or less).
	 */
	int blocklen[];

	/**
	 * main - entry point when used standalone.
	 * NOTE: no routines return error codes or throw any local
	 * exceptions. Instead, any routine may complain
	 * to stderr and then exit with error to the system.
	 */
	public static void main(String argstrings[])
	{
		if ( argstrings.length != 2 ) {
		  System.err.println("Usage: diff oldfile newfile" );
		  System.exit(1);
		}
		Diff d = new Diff();
		d.doDiff(argstrings[0], argstrings[1]);
		return;
	}

	/** Construct a Diff object. */
	Diff() {
	}

	/** Do one file comparison. Called with both filenames. */
	public void doDiff(String oldFile, String newFile) {
		println( ">>>> Difference of file \"" + oldFile + 
			"\" and file \"" + newFile + "\".\n");
		oldinfo = new fileInfo(oldFile);
		newinfo = new fileInfo(newFile);
		/* we don't process until we know both files really do exist. */
		try {
			inputscan( oldinfo );
			inputscan( newinfo );
		} catch (IOException e) {
			System.err.println("Read error: " + e);
		}

		/* Now that we've read all the lines, allocate some arrays.
		 */
		blocklen = new int[ (oldinfo.maxLine>newinfo.maxLine?
			oldinfo.maxLine : newinfo.maxLine) + 2 ];
		oldinfo.alloc();
		newinfo.alloc();

		/* Now do the work, and print the results. */
		transform();
		printout();
	}

	/**
	 * inputscan    Reads the file specified by pinfo.file.
	 * ---------    Places the lines of that file in the symbol table.
	 *              Sets pinfo.maxLine to the number of lines found.
	 */
	void inputscan( fileInfo pinfo ) throws IOException
	{
	     String linebuffer;

	     pinfo.maxLine = 0;
	     while ((linebuffer = pinfo.file.readLine()) != null) {
		       storeline( linebuffer, pinfo );
	     }
	}

	/**
	 * storeline    Places line into symbol table.
	 * ---------    Expects pinfo.maxLine initted: increments.
	 *              Places symbol table handle in pinfo.ymbol.
	 *              Expects pinfo is either oldinfo or newinfo.
	 */
	void storeline( String linebuffer, fileInfo pinfo )
	{
	     int linenum = ++pinfo.maxLine;    /* note, no line zero */
	     if ( linenum > fileInfo.MAXLINECOUNT ) {
		  System.err.println( "MAXLINECOUNT exceeded, must stop." );
		  System.exit(1);
	     }
	     pinfo.symbol[ linenum ] =
		  node.addSymbol( linebuffer, pinfo == oldinfo, linenum );
	}

	/*
	 * transform    
	 * Analyzes the file differences and leaves its findings in
	 * the global arrays oldinfo.other, newinfo.other, and blocklen.
	 * Expects both files in symtab.
	 * Expects valid "maxLine" and "symbol" in oldinfo and newinfo.
	 */
	void transform()
	{                                  
	     int oldline, newline;
	     int oldmax = oldinfo.maxLine + 2;  /* Count pseudolines at  */
	     int newmax = newinfo.maxLine + 2;  /* ..front and rear of file */

	     for (oldline=0; oldline < oldmax; oldline++ )
			oldinfo.other[oldline]= -1;
	     for (newline=0; newline < newmax; newline++ )
			newinfo.other[newline]= -1;

	     scanunique();  /* scan for lines used once in both files */
	     scanafter();   /* scan past sure-matches for non-unique blocks */
	     scanbefore();  /* scan backwards from sure-matches */
	     scanblocks();  /* find the fronts and lengths of blocks */
	}

	/*
	 * scanunique
	 * Scans for lines which are used exactly once in each file.
	 * Expects both files in symtab, and oldinfo and newinfo valid.
	 * The appropriate "other" array entries are set to the line# in
	 * the other file.
	 * Claims pseudo-lines at 0 and XXXinfo.maxLine+1 are unique.
	 */
	void scanunique()
	{
	     int oldline, newline;
	     node psymbol;

	     for( newline = 1; newline <= newinfo.maxLine; newline++ ) {
		  psymbol = newinfo.symbol[ newline ];
		  if ( psymbol.symbolIsUnique()) {        // 1 use in each file
		       oldline = psymbol.linenum;
		       newinfo.other[ newline ] = oldline; // record 1-1 map
		       oldinfo.other[ oldline ] = newline;
		  }
	     }
	     newinfo.other[ 0 ] = 0;
	     oldinfo.other[ 0 ] = 0;
	     newinfo.other[ newinfo.maxLine + 1 ] = oldinfo.maxLine + 1;
	     oldinfo.other[ oldinfo.maxLine + 1 ] = newinfo.maxLine + 1;
	}

	/*
	 * scanafter
	 * Expects both files in symtab, and oldinfo and newinfo valid.
	 * Expects the "other" arrays contain positive #s to indicate
	 * lines that are unique in both files.
	 * For each such pair of places, scans past in each file.
	 * Contiguous groups of lines that match non-uniquely are
	 * taken to be good-enough matches, and so marked in "other".
	 * Assumes each other[0] is 0.
	 */
	void scanafter()
	{
	     int oldline, newline;

	     for( newline = 0; newline <= newinfo.maxLine; newline++ ) {
		  oldline = newinfo.other[ newline ];
		  if ( oldline >= 0 ) {	/* is unique in old & new */
		       for(;;) {	/* scan after there in both files */
			    if ( ++oldline > oldinfo.maxLine   ) break; 
			    if ( oldinfo.other[ oldline ] >= 0 ) break;
			    if ( ++newline > newinfo.maxLine   ) break; 
			    if ( newinfo.other[ newline ] >= 0 ) break;

			    /* oldline & newline exist, and 
				aren't already matched */

			    if ( newinfo.symbol[ newline ] !=
				oldinfo.symbol[ oldline ] ) break;  // not same

			    newinfo.other[newline] = oldline; // record a match
			    oldinfo.other[oldline] = newline;
		       }
		  }
	     }
	}

	/**
	 * scanbefore
	 * As scanafter, except scans towards file fronts.
	 * Assumes the off-end lines have been marked as a match.
	 */
	void scanbefore()
	{
	     int oldline, newline;

	     for( newline = newinfo.maxLine + 1; newline > 0; newline-- ) {
		  oldline = newinfo.other[ newline ];
		  if ( oldline >= 0 ) {               /* unique in each */
		       for(;;) {
			    if ( --oldline <= 0                ) break;
			    if ( oldinfo.other[ oldline ] >= 0 ) break;
			    if ( --newline <= 0                ) break;
			    if ( newinfo.other[ newline ] >= 0 ) break;
     
			    /* oldline and newline exist,
				and aren't marked yet */

			    if ( newinfo.symbol[ newline ] !=
				oldinfo.symbol[ oldline ] ) break;  // not same

			    newinfo.other[newline] = oldline; // record a match
			    oldinfo.other[oldline] = newline;
		       }
		  }
	     }
	}

	/**
	 * scanblocks - Finds the beginnings and lengths of blocks of matches.
	 * Sets the blocklen array (see definition).
	 * Expects oldinfo valid.
	 */
	void scanblocks()
	{
	     int oldline, newline;
	     int oldfront = 0;      // line# of front of a block in old, or 0 
	     int newlast = -1;      // newline's value during prev. iteration

	     for( oldline = 1; oldline <= oldinfo.maxLine; oldline++ )
		       blocklen[ oldline ] = 0;
	     blocklen[ oldinfo.maxLine + 1 ] = UNREAL; // starts a mythical blk

	     for( oldline = 1; oldline <= oldinfo.maxLine; oldline++ ) {
		  newline = oldinfo.other[ oldline ];
		  if ( newline < 0 ) oldfront = 0;  /* no match: not in block */
		  else{                                   /* match. */
		       if ( oldfront == 0 )         oldfront = oldline;
		       if ( newline != (newlast+1)) oldfront = oldline;
		       ++blocklen[ oldfront ];            
		  }
		  newlast = newline;
	     }
	}

	/* The following are global to printout's subsidiary routines */
	// enum{ idle, delete, insert, movenew, moveold,
	// same, change } printstatus;
	public static final int
		idle = 0, delete = 1, insert = 2, movenew = 3, moveold = 4,
		same = 5, change = 6;
	int printstatus;
	boolean anyprinted;
	int printoldline, printnewline;     // line numbers in old & new file

	/**
	 * printout - Prints summary to stdout.
	 * Expects all data structures have been filled out.
	 */
	void printout()
	{
	     printstatus = idle;
	     anyprinted = false;
	     for( printoldline = printnewline = 1; ; ) {
		  if ( printoldline > oldinfo.maxLine ) { newconsume(); break;}
		  if ( printnewline > newinfo.maxLine ) { oldconsume(); break;}
		  if (      newinfo.other[ printnewline ] < 0 ) {
		       if ( oldinfo.other[ printoldline ] < 0 )
				showchange();
		       else
				showinsert();
		  }
		  else if ( oldinfo.other[ printoldline ] < 0 )
			showdelete();
		  else if ( blocklen[ printoldline ] < 0 )
			skipold();
		  else if ( oldinfo.other[ printoldline ] == printnewline )
			showsame();
		  else
			showmove();
	     }
	     if ( anyprinted == true ) println( ">>>> End of differences."  );
	     else                     println( ">>>> Files are identical." );
	}

	/*
	 * newconsume        Part of printout. Have run out of old file. 
	 * Print the rest of the new file, as inserts and/or moves.
	 */
	void newconsume()
	{
	     for(;;) {
		  if ( printnewline > newinfo.maxLine )
			break;        /* end of file */
		  if ( newinfo.other[ printnewline ] < 0 ) showinsert();
		  else                                    showmove();
	     }
	}

	/**
	 * oldconsume        Part of printout. Have run out of new file.
	 * Process the rest of the old file, printing any
	 * parts which were deletes or moves.
	 */
	void oldconsume()
	{
	     for(;;) {
		  if ( printoldline > oldinfo.maxLine )
			break;       /* end of file */
		  printnewline = oldinfo.other[ printoldline ];
		  if ( printnewline < 0 ) showdelete();
		  else if ( blocklen[ printoldline ] < 0 ) skipold();
		  else showmove();
	     }
	}

	/**
	 * showdelete        Part of printout.
	 * Expects printoldline is at a deletion.
	 */
	void showdelete()
	{
		if ( printstatus != delete )
			println( ">>>> DELETE AT " + printoldline);
		printstatus = delete;
		oldinfo.symbol[ printoldline ].showSymbol();
		anyprinted = true;
		printoldline++;
	}

	/*
	 * showinsert        Part of printout.
	 * Expects printnewline is at an insertion.
	 */
	void showinsert()
	{
	     if ( printstatus == change ) println( ">>>>     CHANGED TO" );
	     else if ( printstatus != insert ) 
		  println( ">>>> INSERT BEFORE " + printoldline );
	     printstatus = insert;
	     newinfo.symbol[ printnewline ].showSymbol();
	     anyprinted = true;
	     printnewline++;
	}

	/**
	 * showchange        Part of printout.
	 * Expects printnewline is an insertion.
	 *  Expects printoldline is a deletion.
	 */
	void showchange()
	{
	     if ( printstatus != change ) 
		  println( ">>>> " + printoldline + " CHANGED FROM");
	     printstatus = change;
	     oldinfo.symbol[ printoldline ].showSymbol();
	     anyprinted = true;
	     printoldline++;
	}

	/**
	 * skipold           Part of printout.
	 * Expects printoldline at start of an old block that has 
	 * already been announced as a move.
	 * Skips over the old block.
	 */
	void skipold()
	{
	     printstatus = idle;
	     for(;;) {
		  if ( ++printoldline > oldinfo.maxLine )
			break;     /* end of file  */
		  if ( oldinfo.other[ printoldline ] < 0 )
			break;    /* end of block */
		  if ( blocklen[ printoldline ]!=0)
			break;          /* start of another */
	     }
	}

	/**
	 * skipnew           Part of printout.
	 * Expects printnewline is at start of a new block that has
	 * already been announced as a move.
	 * Skips over the new block.
	 */
	void skipnew()
	{
	     int oldline;
	     printstatus = idle;
	     for(;;) {
		  if ( ++printnewline > newinfo.maxLine )
			break;    /* end of file  */
		  oldline = newinfo.other[ printnewline ];
		  if ( oldline < 0 )
			break;                         /* end of block */
		  if ( blocklen[ oldline ] != 0)
			break;              /* start of another */
	     }
	}

	/**
	 * showsame          Part of printout.
	 * Expects printnewline and printoldline at start of
	 * two blocks that aren't to be displayed.
	 */
	void showsame()
	{
	     int count;
	     printstatus = idle;
	     if ( newinfo.other[ printnewline ] != printoldline ) {
		  System.err.println("BUG IN LINE REFERENCING");
		  System.exit(1);
	     }
	     count = blocklen[ printoldline ];
	     printoldline += count;
	     printnewline += count;
	}

	/**
	 * showmove          Part of printout.
	 * Expects printoldline, printnewline at start of
	 * two different blocks ( a move was done).
	 */
	void showmove()
	{
	     int oldblock = blocklen[ printoldline ];
	     int newother = newinfo.other[ printnewline ];
	     int newblock = blocklen[ newother ];

	     if ( newblock < 0 ) skipnew();         // already printed.
	     else if ( oldblock >= newblock ) {     // assume new's blk moved.
		  blocklen[newother] = -1;         // stamp block as "printed".
		  println( ">>>> " + newother + 
			" THRU " + (newother + newblock - 1) + 
			" MOVED TO BEFORE " + printoldline );
		  for( ; newblock > 0; newblock--, printnewline++ )
		       newinfo.symbol[ printnewline ].showSymbol();
		  anyprinted = true;
		  printstatus = idle;

	     } else                /* assume old's block moved */
		  skipold();      /* target line# not known, display later */
	}

	/** Convenience wrapper for println */
	public void println(String s) {
		System.out.println(s);
	}
};				// end of main class!

/**
 * Class "node". The symbol table routines in this class all
 * understand the symbol table format, which is a binary tree.
 * The methods are: addSymbol, symbolIsUnique, showSymbol.
 */ 
class node{                       /* the tree is made up of these nodes */
	node pleft, pright;
	int linenum;

	static final int freshnode = 0,
	oldonce = 1, newonce = 2, bothonce = 3, other = 4;

	int /* enum linestates */ linestate;
	String line;

	static node panchor = null;    /* symtab is a tree hung from this */

	/**
	 * Construct a new symbol table node and fill in its fields.
	 * @param        string	A line of the text file
	 */
	node( String pline)
	{
	     pleft = pright = null;
	     linestate = freshnode;
	     /* linenum field is not always valid */     
	     line = pline;
	}

	/**
	 * matchsymbol       Searches tree for a match to the line.
	 * @param	String	pline, a line of text
	 * If node's linestate == freshnode, then created the node.
	 */
	static node matchsymbol( String pline )
	{
	     int comparison;
	     node pnode = panchor;
	     if ( panchor == null ) return panchor = new node( pline);
	     for(;;) {
		  comparison = pnode.line.compareTo(pline);
		  if ( comparison == 0 ) return pnode;          /* found */

		  if ( comparison < 0 ) {
		       if ( pnode.pleft == null ) {
			    pnode.pleft = new node( pline);
			    return pnode.pleft;
		       }
		       pnode = pnode.pleft;
		  }
		  if ( comparison > 0 ) {
		       if ( pnode.pright == null ) {
			    pnode.pright = new node( pline);
			    return pnode.pright;
		       }
		       pnode = pnode.pright;
		  }
	     }
	     /* NOTE: There are return stmts, so control does not get here. */
	}

	/**
	 * addSymbol(String pline) - Saves line into the symbol table.
	 * Returns a handle to the symtab entry for that unique line.
	 * If inoldfile nonzero, then linenum is remembered.
	 */
	static node addSymbol( String pline, boolean inoldfile, int linenum )
	{
		node pnode;
		pnode = matchsymbol( pline );  /* find the node in the tree */
		if ( pnode.linestate == freshnode ) {
			pnode.linestate = inoldfile ? oldonce : newonce;
		} else {
		  if (( pnode.linestate == oldonce && !inoldfile ) ||
		      ( pnode.linestate == newonce &&  inoldfile )) 
		       pnode.linestate = bothonce;
		  else pnode.linestate = other;
		}
		if (inoldfile) pnode.linenum = linenum;
		return pnode;
	}

	/**
	 * symbolIsUnique    Arg is a ptr previously returned by addSymbol.
	 * --------------    Returns true if the line was added to the
	 *                   symbol table exactly once with inoldfile true,
	 *                   and exactly once with inoldfile false.
	 */
	boolean symbolIsUnique()
	{
		return (linestate == bothonce );
	}

	/**
	 * showSymbol        Prints the line to stdout.
	 */
	void showSymbol()
	{
		System.out.println(line);
	}
}
//@@@@@@//
//textproc/PSFormatter.java
//@@@@@@//
import java.io.*;

/** Text to PS */
public class PSFormatter {
	/** The current input source */
	protected BufferedReader br;
	/** The current page number */
	protected int pageNum;
	/** The current X and Y on the page */
	protected int curX, curY;
	/** The current line number on page */
	protected int lineNum;
	/** The current tab setting */
	protected int tabPos = 0;
	public static final int INCH = 72;	// PS constant: 72 pts/inch

	// Page parameters
	/** The left margin indent */
	protected int leftMargin = 50;
	/** The top of page indent */
	protected int topMargin = 750;
	/** The bottom of page indent */
	protected int botMargin = 50;

	// FORMATTING PARAMETERS
	protected int points = 12;
	protected int leading = 14;

	public static void main(String[] av) throws IOException {
		if (av.length == 0) 
			new PSFormatter(
				new InputStreamReader(System.in)).process();
		else for (int i = 0; i < av.length; i++) {
			new PSFormatter(av[i]).process();
		}
	}

	public PSFormatter(String fileName) throws IOException {
		br = new BufferedReader(new FileReader(fileName));
	}

	public PSFormatter(Reader in) throws IOException {
		if (in instanceof BufferedReader)
			br = (BufferedReader)in;
		else
			br = new BufferedReader(in);
	}

	/** Main processing of the current input source. */
	protected void process() throws IOException {

		String line;

		prologue();			// emit PostScript prologue, once.

		startPage();		// emit top-of-page (ending previous)

		while ((line = br.readLine()) != null) {
			if (line.startsWith("\f") || line.trim().equals(".bp")) {
				startPage();
				continue;
			}
			doLine(line);
		}

		// finish last page, if not already done.
		if (lineNum != 0)
			println("showpage");
	}

	/** Handle start of page details. */
	protected void startPage() {
		if (pageNum++ > 0)
			println("showpage");
		lineNum = 0;
		moveTo(leftMargin, topMargin);
	}

	/** Process one line from the current input */
	protected void doLine(String line) {
		tabPos = 0;
		// count leading (not imbedded) tabs.
		for (int i=0; i<line.length(); i++) {
			if (line.charAt(i)=='\t')
				tabPos++;
			else
				break;
		}
		String l = line.trim(); // removes spaces AND tabs
		if (l.length() == 0) {
			++lineNum;
			return;
		}
		moveTo(leftMargin + (tabPos * INCH),
			topMargin-(lineNum++ * leading));
		println('(' + toPSString(l)+ ") show");

		// If we just hit the bottom, start a new page
		if (curY <= botMargin)
			startPage();
	}

	/** Overly-simplistic conversion to PS, e.g., breaks on "foo\)bar" */
	protected String toPSString(String o) {
		StringBuffer sb = new StringBuffer();
		for (int i=0; i<o.length(); i++) {
			char c = o.charAt(i);
			switch(c) {
				case '(':	sb.append("\\("); break;
				case ')':	sb.append("\\)"); break;
				default:	sb.append(c); break;
			}
		}
		return sb.toString();
	}

	protected void println(String s) {
		System.out.println(s);
	}

	protected void moveTo(int x, int y) {
		curX = x;
		curY = y;
		println(x + " " + y + " " + "moveto");
	}

	void prologue() {
		println("%!PS-Adobe");
		println("/Courier findfont " + points + " scalefont setfont ");
	}
}
//@@@@@@//
//threads/Animator.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: Animator.java,v 1.7 2004/03/26 03:30:23 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.applet.Applet;
import java.awt.Color;
import java.awt.Graphics;

/** Animator - move a rectangle diaganolly across the screen
 * using a Thread.
 */
public class Animator extends Applet implements Runnable {
	/** Where to draw the moving image: x coordinate */
	int x;
	/** Where to draw the moving image: y coordinate */
	int y;
	/** This is set true to stop the animation thread. */
	boolean done;

	/** Called by the browser to start the page */
	public void start() {
		done = false;
		new Thread(this).start();
	}

	/** Called by the browser when the user moves away from the page */
	public void stop() {
		done = true;
	}

	/**
	 * Move the rectangle around the screen at a 45-degree angle.
	 * Called by the Thread when there is CPU time available for me.
	 */
    public synchronized void run() {
		// Get the framesize
		int width = getSize().width;
		int height = getSize().height;

		// Start at a random location in it.
		x = (int)(Math.random() * width);
		y = (int)(Math.random() * height);

		while (!done) {
			// Obtain current size, in case resized.
			width = getSize().width;
			height = getSize().height;
			// Did we go off the deep end? :-)
			if (x++ >= width)
				x=0;	// return to shallow end 
			if (y++ >= height)
				y=0;
			repaint();		// Tell AWT to call our paint().
			try {
				Thread.sleep(250);
			} catch (InterruptedException e) {
				return;
			}
		}
	}

	/** paint -- just draw our image at its current location */
    public void paint(Graphics g) {
		g.setColor(Color.red);
		g.fillRect(x, y, 10, 10);
    }
}
//@@@@@@//
//threads/AutoSave.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: AutoSave.java,v 1.5 2004/03/14 02:03:47 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/** Demonstration of using a Thread to automatically save
 * the user's work periodically.
 */
public class AutoSave extends Thread {
	/** The FileSave interface is implemented by the main class. */
	protected FileSaver model;
	/** How long to sleep between tries */
	public static final int MINUTES = 5;
	private static final int SECONDS = MINUTES * 60;

	public AutoSave(FileSaver m) {
		super("AutoSave Thread");
		setDaemon(true);		// so we don't keep the main app alive
		model = m;
	}

	public void run() {
		while (true) {		// entire run method runs forever.
			try {
				sleep(SECONDS*1000);
			} catch (InterruptedException e) {
				// do nothing with it
			}
			if (model.wantAutoSave() && model.hasUnsavedChanges())
				model.saveFile(null);
		}
	}

	// Not shown:
	// 1) saveFile() must now be synchronized.
	// 2) method that shuts down main program be synchronized on *SAME* object
}

/** Local copy of FileSaver interface, for compiling AutoSave demo. */
interface FileSaver {
	/** Load new model from fn; if null, prompt for new fname */
	public void loadFile(String fn);

	/** Ask the model if it wants AutoSave done for it */
	public boolean wantAutoSave();

	/** Ask the model if it has any unsaved changes, don't save otherwise */
	public boolean hasUnsavedChanges();

	/** Save the current model's data in fn. 
	 * If fn == null, use current fname or prompt for a filename if null.
	 */
	public void saveFile(String fn);
}
//@@@@@@//
//threads/BallotBox.java
//@@@@@@//
import java.util.Iterator;
import java.util.List;

import com.darwinsys.util.ArrayIterator;

/**
 * BallotBox - keep track of voting. Only used in ReadersWritersDemo.
 * @version $Id: BallotBox.java,v 1.1 2004/04/25 22:53:57 ian Exp $
 */
class BallotBox {
	BallotPosition[] data;
	
	public Iterator iterator() {
		return new ArrayIterator(data);
	}
	
	BallotBox(List list) {
		data = new BallotPosition[list.size()];
		for (int i = 0; i < list.size(); i++) {
			data[i] = new BallotPosition((String)list.get(i));
		}
	}
	
	public void voteFor(int i) {
		++data[i].votes;
	}
	
	int getCandidateCount() {
		return data.length;
	}
}//@@@@@@//
//threads/BallotPosition.java
//@@@@@@//



class BallotPosition {
	String question;
	int votes;
	BallotPosition(String q) {
		question = q;
	}
	public String getName() {
		return question;
	}
	public int getVotes() {
		return votes;
	}
}//@@@@@@//
//threads/Bounce.java
//@@@@@@//
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;

/** This is the Bounce class; create and start Sprites, using Threads. */
public class Bounce extends Applet implements ActionListener {
	/** The main Panel */
	protected Panel p;
	/** The image, shared by all the Sprite objects */
	protected Image img;
	/** A Vector of Sprite objects. */
	protected Vector v;

    public void init() {
		Button b = new Button("Start");
		b.addActionListener(this);
		setLayout(new BorderLayout());
		add(b, BorderLayout.NORTH);
		add(p = new Panel(), BorderLayout.CENTER);
		p.setLayout(null);
		String imgName = getParameter("imagefile");
		if (imgName == null) imgName = "duke.gif";
		img = getImage(getCodeBase(), imgName);
		MediaTracker mt = new MediaTracker(this);
		mt.addImage(img, 0);
		try {
			mt.waitForID(0);
		} catch(InterruptedException e) {
			throw new IllegalArgumentException(
				"InterruptedException while loading image " + imgName);
		}
		if (mt.isErrorID(0)) {
			throw new IllegalArgumentException(
				"Couldn't load image " + imgName);
		}
		v = new Vector();
    }

    public void actionPerformed(ActionEvent e) {
		System.out.println("Creat-ing another one!");
		Sprite s = new Sprite(this, img);
		s.start();
		p.add(s);
		v.addElement(s);
    }

    public void stop() {
		for (int i=0; i<v.size(); i++) {
			((Sprite)(v.get(i))).stop();
		}
		v.clear();
    }
}

//@@@@@@//
//threads/BreakEnd.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: BreakEnd.java,v 1.12 2004/02/09 03:34:06 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.text.*;
import java.util.*;

import com.darwinsys.swingui.UtilGUI;

/** BreakEnd - 
 * Tool to display current time and time that class starts/resumes.
 *
 * This started as a quick hack when I saw the Windows
 * guys with a tool like this, but it has grown somewhat since then.
 *
 * TODO 
 * <ul>
 *	<li>add another Thread to flash the screen if the resume time is passed.
 * </ul>
 *
 * @author	Ian Darwin
 * @version	$Id: BreakEnd.java,v 1.12 2004/02/09 03:34:06 ian Exp $
 */
public class BreakEnd extends JFrame implements Runnable {
	/** Label for the current time. */
	protected JLabel nowLabel;
	/** Label for when break ends. */
	protected JLabel endsLabel;
	/** JSlider for font sizes */
	protected JSlider fontSize;
	/** A thread to run the clock ticker */
	protected Thread ticker;
	/** The font for the large text */
	protected Font f;
	/** The minimum allowable font size */
	protected static final int FONT_SIZE_MIN = 10;
	/** The maximum sensible font size given current monitors. */
	protected static final int FONT_SIZE_MAX = 150;
	/** Default point size */
	protected static final int FONT_SIZE_DEFAULT = 50;

	/** Main method to start me up. */
	public static void main(String[] av) {
		for (int i=0; i<av.length; i++) {
			// parse options...
		}

		if (av.length != 1) {
			System.err.println("Usage: javaBreak time");
			return;
		}
		BreakEnd b = new BreakEnd(av[0]);
		UtilGUI.centre(b);

		b.setVisible(true);
	}

	/** NumberFormat to format a non-localized two-digit number */
	protected NumberFormat form = new DecimalFormat("00");

	/** Get the Calendar into HHMM format */
	private String toHHMM_String(Calendar d) {
		String result = null;
		int h = d.get(Calendar.HOUR_OF_DAY);
		int m = d.get(Calendar.MINUTE);
		int s = d.get(Calendar.SECOND);
		try {
			result = form.format(h) + ":" +
				form.format(m) + ":" +
				form.format(s);
			// Why not just use a DateFormat for that?
		} catch (IllegalArgumentException iae) {
			JOptionPane.showMessageDialog(this,
				"Formatting Error!" + iae,	// message
				"Formatting Error!",					// titlebar
				JOptionPane.ERROR_MESSAGE);	// icon
		}
		return result;
	}

	public void run() {
		Calendar d /* = new GregorianCalendar() */; // For 1.4
		while (ticker.isAlive()) {
			//d.setTimeInMillis(System.currentTimeMillis()); // For 1.4
			d = new GregorianCalendar();
			nowLabel.setText("Time is now " + toHHMM_String(d));
			try {
				Thread.sleep(1000);
			} catch (Exception e) {
				return;
			}
		}
	}

	/** Constructor: set a font, initialize UI components. */
	public BreakEnd(String s) {
		super("Java Breaker: " + s);
		setBackground(Color.white);
		setForeground(Color.red);

		Container cp;
		cp = getContentPane();
		// cp = this;
		cp.setLayout(new BorderLayout());

		fontSize = new JSlider(JSlider.HORIZONTAL,
			FONT_SIZE_MIN, FONT_SIZE_MAX, FONT_SIZE_DEFAULT);
		fontSize.setMajorTickSpacing(10);
		fontSize.setMinorTickSpacing(5);
		fontSize.setSnapToTicks(true);
		fontSize.setPaintTicks(true);
		fontSize.setPaintLabels(true);
		fontSize.setBorder(BorderFactory.createEmptyBorder(0,0,10,0));


		fontSize.addChangeListener(new ChangeListener() {
			public void stateChanged(ChangeEvent e) {
				JSlider source = (JSlider)e.getSource();
				if (!source.getValueIsAdjusting()) {
					int points = (int)source.getValue();
					setFontSize(points);
				}
			}
		});
		//add the slider to the content pane
		cp.add(BorderLayout.NORTH, fontSize);

		// Make a panel for CENTER to hold two labels above each other
		JPanel timesPanel = new JPanel();
		timesPanel.setLayout(new GridLayout(2,1));

		cp.add(BorderLayout.CENTER, timesPanel);
		timesPanel.add(
			nowLabel =  new JLabel("Time now is: 00:00:00", JLabel.CENTER));
	
		String mesg = null;
		if (s.startsWith("+")) {	// "This will be HARDer..."
			Calendar d = new GregorianCalendar();
			int newMinutes = d.get(Calendar.MINUTE)+
				Integer.parseInt(s.substring(1))+1;
			d.set(Calendar.MINUTE, newMinutes);
			mesg = "We start at " + toHHMM_String(d);
		} else {
			mesg = "We start at " + s + " ";
		}
		timesPanel.add(BorderLayout.CENTER,
			endsLabel = new JLabel(mesg, JLabel.CENTER));
		setFontSize(FONT_SIZE_DEFAULT);
		JButton b;
		cp.add(BorderLayout.SOUTH, b = new JButton("Done"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				System.exit(0);
			}
		});

		// Pack should be done here so the ComponentAdapter's
		// componentResized doesn't fire and shrink the size
		pack();

		// Start the timer thread now. Tick, tick, tick.
		(ticker = new Thread(this)).start();

		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		addComponentListener(new ComponentAdapter() {
			public void componentResized(ComponentEvent e) {
				Dimension d = getSize();
				if (d.height < 100)
					setFontSize(15);
				else
					setFontSize(d.height/6);
			}
		});
	}

	/** Set the font to the given size */
    protected void setFontSize(int sz) {
		if (sz > FONT_SIZE_MAX)
			sz = FONT_SIZE_MAX;
		//System.out.println("Setting font size to " + sz);
		Font f = new Font("Helvetica", Font.PLAIN, sz);
		nowLabel.setFont(f);
		endsLabel.setFont(f);
		fontSize.setValue(sz);
	}
}
//@@@@@@//
//threads/BrokenServlet.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: BrokenServlet.java,v 1.5 2004/04/25 20:05:19 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

/*
 * BrokenServlet -- so where is it broken, anyway?
 * Servlet containers normally run a single instance of Servlets
 * with multiple Threads running in them; think what might happen
 * to the "out" field with multiple threads running.
 * 
 * @version $Id: BrokenServlet.java,v 1.5 2004/04/25 20:05:19 ian Exp $
 */
public class BrokenServlet extends HttpServlet
{
	protected PrintWriter out;

	/** Called in response to a GET request (data encoded in the URL) */
	public void doGet(HttpServletRequest request, HttpServletResponse response)
		throws ServletException, IOException {
		response.setContentType("text/html");

		out = response.getWriter(); 

		// Simulate a database lookup
		int result = 42;

		print(result);

	}

	protected void print(int result)
	{
		out.println("<!DOCTYPE html PUBLIC " +
			"\"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n" +
			"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\n" +
			">");
		out.println("<html>");
		out.println("<head><title>Servlet Output</title></head>");
		out.println("<body>");

		out.println("<h1>Results</h1>");
		out.println("<p>The result is " + result + "</p>");

		out.println("</body>");
		out.println("</html>");
		out.close();
	}
}
//@@@@@@//
//threads/buzzin/BuzzInServlet.java
//@@@@@@//
package buzzin;

/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: BuzzInServlet.java,v 1.15 2004/03/26 03:30:22 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import javax.servlet.*;
import javax.servlet.http.*;
import java.io.*;

/** A quiz-show "buzzer" servlet: the first respondant wins the chance
 * to answer the skill-testing question. 
 * <p>
 * Previous versions of this code used shared static variables, but this
 * is not reliable, since most web engines now use custom class loaders
 * that may load a servlet class more than once.  The "right" way is to 
 * synchronize on an object stored in the Servlet Application Context.
 */
public class BuzzInServlet extends HttpServlet {

	/** The attribute name used throughout. */
	protected final static String WINNER = "buzzin.winner";

	/** doGet is called from the contestants web page.
	 * Uses a synchronized code block to ensure that
	 * only one contestant can change the state of "buzzed".
	 */
	public void doGet(HttpServletRequest request, HttpServletResponse response)
	throws ServletException, IOException
	{
		ServletContext application = getServletContext();

		boolean iWon = false;
		String user = request.getRemoteHost() + '@' + request.getRemoteAddr();

		// Do the synchronized stuff first, and all in one place.
		synchronized(application) {
			if (application.getAttribute(WINNER) == null) {
				application.setAttribute(WINNER, user);
				application.log("BuzzInServlet: WINNER " + user);
				iWon = true;
			}
	 	}

		response.setContentType("text/html");
		PrintWriter out = response.getWriter();

		out.println("<html><head><title>Thanks for playing</title></head>");
		out.println("<body bgcolor=\"white\">");

		if (iWon) {
			out.println("<b>YOU GOT IT</b>");
			// TODO - output HTML to play a sound file :-)
		} else {
				out.println("Thanks for playing, " + request.getRemoteAddr());
				out.println(", but " + application.getAttribute(WINNER) + 
					" buzzed in first");
		}
		out.println("</body></html>");
	}

	/** The Post method is used from an Administrator page (which should
	 * only be installed in the instructor/host's localweb directory). 
	 * Post is used for administrative functions:
	 * 1) to display the winner;
	 * 2) to reset the buzzer for the next question.
	 */
	public void doPost(HttpServletRequest request, HttpServletResponse response)
	throws ServletException, IOException
	{
		ServletContext application = getServletContext();

		response.setContentType("text/html");
		HttpSession session = request.getSession();

		PrintWriter out = response.getWriter();

		if (request.isUserInRole("host")) {
			out.println("<html><head><title>Welcome back, " +
				request.getUserPrincipal().getName() + "</title><head>");
			out.println("<body bgcolor=\"white\">");
			String command = request.getParameter("command");
			if (command.equals("reset")) {

				// Synchronize what you need, no more, no less.
				synchronized(application) {
					application.setAttribute(WINNER, null);
				}
				session.setAttribute("buzzin.message", "RESET");
			} else if (command.equals("show")) {
				String winner = null;
				synchronized(application) {
					winner = (String)application.getAttribute(WINNER);
				}
				if (winner == null) {
					session.setAttribute("buzzin.message",
						"<b>No winner yet!</b>");
				} else {
					session.setAttribute("buzzin.message",
						"<b>Winner is: </b>" + winner);
				}
			}
			else {
				session.setAttribute("buzzin.message",
					"ERROR: Command " + command + " invalid.");
			}
			RequestDispatcher rd = application.getRequestDispatcher(
				"/hosts/index.jsp");
			rd.forward(request, response);
		} else {
			out.println("<html><head><title>Nice try, but... </title><head>");
			out.println("<body bgcolor=\"white\">");
			out.println(
				"I'm sorry, Dave, but you know I can't allow you to do that.");
			out.println("Even if you are " + request.getUserPrincipal());
		}
		out.println("</body></html>");
	}
}
//@@@@@@//
//threads/CatchMulti.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: CatchMulti.java,v 1.3 2004/02/09 03:34:06 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.awt.*;
import java.awt.event.*;
import java.util.*;

/** A failed attempt at catching interrupts thrown in the GUI
 * event thread.
 */
public class CatchMulti {
	public static void main(String[] args) {
		try {
			// Create the GUI, will implicitly create and start a GUI thread
			new ThrowAWT().setVisible(true); 
			// Wait a while.
			Thread.sleep(1000 * 20);
			// Create and start a thread that gives 
			// an ArrayIndexOutOfBoundsException
			new ThrowIndex().start();
		} catch (Exception ex) {
			System.out.println("Caught exception: " + ex);
			System.exit(1);
		}
	}
}

class ThrowAWT extends Frame {
	ThrowAWT() {
		Button b;
		add(b = new Button("Throw"));
		b.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				// Deliberately throw a null pointer exception
				Random r = null;
				int i = r.nextInt();
			}
		});
		setBounds(60, 60, 60, 60);	// x, y, width, height
	}
}

class ThrowIndex extends Thread {
	public void run() {
		int[] data = new int[10];
		for (int i=1; i<=10; i++)
			data[i] = i;
	}
}
//@@@@@@//
//threads/InstanceRunner.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: InstanceRunner.java,v 1.2 2004/02/09 03:34:06 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */
import java.lang.reflect.Method;

/** Runs a no-argument method from another class, showing
 * use of Method.invoke().
 */
public class InstanceRunner implements Runnable {

	public /*constructor*/ InstanceRunner(java.lang.Class c, String method) {
		targetClass = c;
		methodName = method;
	}

	private Class targetClass;
	private String methodName;

	/** This run method simply invokes a named method in
	 * the given target class.
	 */
	public void run() {
		try {
			Object o = targetClass.newInstance();
			Method m = targetClass.getMethod(methodName, new Class[0]);
			m.invoke(o, new Object[0]);
		} catch (Exception ex) {
			System.err.println("Caught Exception: " + ex);
		}
	}
}
//@@@@@@//
//threads/Intr.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: Intr.java,v 1.5 2004/02/09 03:34:06 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/**
 * Interrupt a read, and then resume it.
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 */
public class Intr implements Runnable {
	/** The Thread we are timing. */
	Thread timedThread;

	/** How long to give the Thread */
	int time;

	public Intr(int mSec) {
		time = mSec;
		timedThread = new Thread(this);
		System.out.println("Intr.<init>: Thread " + timedThread);
		timedThread.setPriority(Thread.MAX_PRIORITY);
		timedThread.setName("TimedThread");
		timedThread.start();
	}

	public void run() {
		while (timedThread != null) {
			System.out.println("About to sleep for " + time + "mSec");
			try {
				Thread.sleep(time);
			} catch (InterruptedException ie) {
				System.err.println("Unexpectedly interrupted time sleep!");
				return;
			}
			if (timedThread == null)
				return;
			// if we are still here, the timer went off, but the
			// main program hasn't nullified the thread yet.
			System.out.println("Will now interrupt sleep of " + timedThread);
			timedThread.interrupt();
		}
	}

	/** Simple test case */
	public static void main(String[] ap) {
		byte b[] = new byte[10];
		System.out.println("Creating Intr");
		Intr me = new Intr(2000);
		System.out.println("Starting read");
		for (int i=1; i<=5; i++) {
			try {
				// This read will block, unless you type something in
				// the console window (and you have to be pretty quick!).
				int n = System.in.read(b);
				System.out.print(">> ");
				for (int j=0; j<n; j++) {
					if (b[j] == '\n' || b[j] == '\r')
						break;
					System.out.print((char)b[j]);
				}
				System.out.println(" <<");
				if (b[0] == (byte)'Q')
					return;

			} catch (java.io.InterruptedIOException e) {
				System.out.println("Interrupted IO");
			} catch (Exception e) {
				// Other exceptions are more painful
				System.out.println("Caught " + e);
			}
		}
		me.timedThread = null;
		System.out.println("All done");
	}
}
//@@@@@@//
//threads/IntrSelf.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: IntrSelf.java,v 1.3 2004/02/09 03:34:06 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */
public class IntrSelf {
	public static void main(String[] args) {
		System.out.println("Starting");
		try {
			Thread.currentThread().interrupt();
		} catch (Throwable x) {
			System.out.println(x);
			return;
		}
		System.out.println("Interrupted Status = " +
			Thread.currentThread().isInterrupted());
		System.out.println("Done");
	}
}
//@@@@@@//
//threads/IOTimer.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: IOTimer.java,v 1.6 2004/02/09 03:34:06 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/**
 * Timer to interrupt a long-running call (like read, write, hence the name).
 * @author	Ian F. Darwin, http://www.darwinsys.com/
 */
public class IOTimer extends Thread {
	/** The Thread we are timing. */
	Thread timedThread;
	/** How long to give the Thread */
	int time;
	public IOTimer(Thread t, int mSec) {
		System.out.println("IOTimer.<init>: Thread " + t);
		setPriority(MAX_PRIORITY);
		timedThread = t;
		time = mSec;
	}

	public void run() {
		System.out.println("About to sleep for " + time + "mSec");
		try {
			sleep(time);
		} catch (InterruptedException ie) {
			System.out.println("You interrupted my sleep!");
			return;
		}
		// if we are still here, the timer went off
		System.out.println("Will now interrupt sleep of " + timedThread);
		timedThread.interrupt();
	}

	/** Simple test case */
	public static void main(String[] ap) {
		byte b[] = new byte[10];
		System.out.println("Creating IOTimer");
		new IOTimer(Thread.currentThread(), 1000).start();
		System.out.println("Starting read");
		try {
			// This read will block, unless you type something in
			// the console window (and you have to be pretty quick!).
			System.in.read(b);

		// Cannot catch InterruptedException, as read() doesn't declare it.
		} catch (Exception e) {
			System.out.println("Caught " + e);
		}
		System.out.println("All done");
	}
}
//@@@@@@//
//threads/Join.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: Join.java,v 1.3 2004/02/09 03:34:06 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/**
 * Demonstrate using Thread.join to rendezvous.
 */
public class Join {
	public static void main(String[] args) {
		Thread t = new Thread() {
			public void run() {
				System.out.println("Reading");
				try {
					System.in.read();
				} catch (java.io.IOException ex) {
					System.err.println(ex);
				}
				System.out.println("Thread Finished.");
			}
		};
		System.out.println("Starting");
		t.start();
		System.out.println("Joining");
		try {
			t.join();
		} catch (InterruptedException ex) {
			// should not happen:
			System.out.println("Who dares interrupt my sleep?");
		}
		System.out.println("Main Finished.");
	}
}
//@@@@@@//
//threads/Mover.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: Mover.java,v 1.11 2004/03/26 03:30:23 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.applet.Applet;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.MediaTracker;

/**
 * Mover -- move an image, slowly.
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: Mover.java,v 1.11 2004/03/26 03:30:23 ian Exp $
 */
public class Mover extends Applet implements Runnable {
	/** The done or not done flag */
	protected volatile boolean done = false;
	/** The current Image, or null */
	protected Image img;
	/** The NAME of the current Image, or null */
	protected String imageName;
	/** the size of the current image */
	protected int imgWid = 0, imgHt = 0;
	/** DEFAULT msec between updates */
	public final static int DEFAULT_INTERVAL = 40;
	/** msec between updates */
	protected int interval = DEFAULT_INTERVAL;
	/** Where we are */
	protected int offset = 0;
	/** The Thread that keeps us ticking */
	protected Thread ticker;

	// THESE CONSTRUCTORS ARE ONLY NEEDED FOR TESTING AS A NON-APPLET
	// YOU DON'T NEED THEM FOR AN APPLET-ONLY SOLUTION.

	/** Construct a Mover, given an Image and using a default pause interval. */
	public Mover(String imgName) {
		this(imgName, DEFAULT_INTERVAL);
	}

	/** Construct a Mover, given an Image and a pause interval. */
	public Mover(String imgName, int pauseInt) {
		interval = pauseInt;
		imageName = imgName;
		init();
	}

	/** Since we have the above Constructors, we need this one for Applet */
	public Mover() {
	}

	/** Setup a Mover applet. */
	public void init() {
		/** If set by non-default constructor, don't call Applet methods! */
		if (imageName == null)
			imageName = getParameter("imagename");
		if (imageName == null)
			imageName = "Mover.gif";
		System.out.println("imageName = " + imageName);
		setImage(imageName);
		System.out.println("setImage done");
	}

	public void start() {
		done = false;
		startThread();
	}

	protected void startThread() {
		ticker = new Thread(this);
		ticker.setName("Ticker animation");
		ticker.setPriority(Thread.MAX_PRIORITY);
		ticker.start();
	}

	public void stop() {
		done = true;
		ticker = null;
	}

	/** Set the image to the given file */
	public void setImage(String fn) {
		if (fn == null)
			return;

		imgWid = imgHt = 0;
		offset = 0;

		// img = Toolkit.getDefaultToolkit().getImage(fn);
		img = getImage(getDocumentBase(), fn);

		// Use a MediaTracker to show the "best"? way of waiting
		// for an image to load, and how to check for errors.
		MediaTracker mt = new MediaTracker(this);
		mt.addImage(img, 0);
		try {
			mt.waitForID(0);
		} catch(InterruptedException e) {
			throw new IllegalArgumentException(
				"Unexpected InterruptedException");
		}
		if (mt.isErrorID(0)) {
			throw new IllegalArgumentException(
				"Couldn't load image " + fn);
		}
	}

	/** Return how big we'd like to be. If image loaded, use its size.
	 * If not, use an arbitrary default.
	 */
	public Dimension getPreferredSize() {
		if (img == null || img.getWidth(this) < 0 || img.getHeight(this) < 0)
			return new Dimension(100, 100);
		return new Dimension(imgWid * 20, imgHt);
	}

	/** Pick a new position for the image, and ask it to be painted */
	public void run() {
		int w = getSize().width;
		// System.out.println("Width = " + w);
		while (!done) {
			if (offset++ > w)
				offset = 0;
			try {
				Thread.sleep(interval);
				repaint();
			} catch (InterruptedException canthappen) {
			}
		}
	}

	/** Actually draw the Image onto the screen */
	public void paint(Graphics g) {
		if (img == null) {
			g.setColor(Color.red);
			g.fillRect(0, 0, getSize().width, getSize().height);
		} else
			g.drawImage(img, offset, 0, this);
	}

	/** "main program" method - construct and show */
	public static void main(String[] av) {
	
		final Frame f = new Frame("Mover Demo");
		final Mover m = new Mover("mover.gif", 10);
		f.add(m);
		//f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		m.init();
		m.start();
		f.pack();
		f.setVisible(true);
	}
}
//@@@@@@//
//threads/Mover2.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: Mover2.java,v 1.3 2004/02/09 03:34:07 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.awt.*;
import java.awt.event.*;

/** Extend Mover by adding the ability to start multi threads. */
public class Mover2 extends Mover {
	public void init() {
		super.init();
		Button bx = new Button("Another");
		bx.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent evt) {
				startThread();
			}
		});
		add(bx);
	}
}
//@@@@@@//
//threads/Mover3.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: Mover3.java,v 1.4 2004/03/26 03:30:23 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

/** Extend Mover by adding the ability to start and stop the thread
 * just by clocking the mouse.
 */
public class Mover3 extends Mover implements MouseListener {

	protected volatile boolean threadSuspended;

	public void init() {
		System.out.println("Mover3 starting");
		super.init();
		addMouseListener(this);
		System.out.println("Mover3 initted");
	}

	public synchronized void mousePressed(MouseEvent e) {
		e.consume();

		System.out.println("mousePressed");

		threadSuspended = !threadSuspended;

		if (!threadSuspended)
			notifyAll();
	}

	/* Compute new position for the image, and ask it to be painted */
	public void run() {
		int w = getSize().width;
		while (!done) {
			try {
                Thread.sleep(interval);

                synchronized(this) {
                    while (threadSuspended)
                        wait();
                }

			} catch (InterruptedException canthappen) {
				// Do nothing
			}
			if (offset++ > w)
				offset = 0;
			repaint();
		}
	}

	// Methods required by MouseListener, but not interesting.
	public void mouseEntered(java.awt.event.MouseEvent $1) {
		// nothing
	}
	public void mouseExited(java.awt.event.MouseEvent $1) {
		// nothing
	}
	public void mouseReleased(MouseEvent e) {
		// nothing 
	}
	public void mouseClicked(MouseEvent e) {
		// nothing 
	}
}
//@@@@@@//
//threads/NotifyError.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: NotifyError.java,v 1.2 2004/02/09 03:34:07 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/** Show WRONG use of notify() */
public class NotifyError {
	public static void main(String[] args) {
		Object o = new Object();
		o.notifyAll();	// NOT OWNER OF o's MONITOR. BAD. DO NOT DO THIS.
	}
}
//@@@@@@//
//threads/ProdCons1.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ProdCons1.java,v 1.5 2004/02/09 03:34:07 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.util.*;
import java.io.*;

/** Producer-Consumer in Java. Version 1.
 */
public class ProdCons1 {

	protected LinkedList list = new LinkedList();

	protected void produce() {
		int len = 0;
		synchronized(list) {
			Object justProduced = new Object();
			list.addFirst(justProduced);
			len = list.size();
			list.notifyAll();
		}
		System.out.println("List size now " + len);
	}

	protected void consume() {
		Object obj = null;
		int len = 0;
		synchronized(list) {
			while (list.size() == 0) {
				try {
					list.wait();
				} catch (InterruptedException ex) {
					return;
				}
			}
			obj = list.removeLast();
			len = list.size();
		}
		System.out.println("Consuming object " + obj);
		System.out.println("List size now " + len);
	}

	public static void main(String[] args) throws IOException {
		ProdCons1 pc = new ProdCons1();
		System.out.println("Ready (p to produce, c to consume):");
		int i;
		while ((i = System.in.read()) != -1) {
			char ch = (char)i;
			switch(ch) {
				case 'p':	pc.produce(); break;
				case 'c':	pc.consume(); break;
			}
		}
	}
}
//@@@@@@//
//threads/ProdCons15.java
//@@@@@@//
import java.util.*;
import java.io.*;
import java.util.concurrent.*;

/** Producer-Consumer in Java, for J2SE 1.5 using concurrent.
 */
public class ProdCons15 {

	protected boolean done = false;

	/** Inner class representing the Producer side */
	class Producer implements Runnable {

		protected BlockingQueue queue;

		Producer(BlockingQueue theQueue) { this.queue = theQueue; }

		public void run() {
			try {
				while (true) {
					Object justProduced = getRequestFromNetwork();
					queue.put(justProduced);
					System.out.println("Produced 1 object; List size now " + queue.size());
					if (done) {
						return;
					}
				}
			} catch (InterruptedException ex) {
				System.out.println("Producer INTERRUPTED");
			}
		}

		Object getRequestFromNetwork() {	// Simulation of reading from client
			try {
					Thread.sleep(10); // simulate time passing during read
			} catch (InterruptedException ex) {
			 	System.out.println("Producer Read INTERRUPTED");
			}
			return(new Object());
		}
	}

	/** Inner class representing the Consumer side */
	class Consumer implements Runnable {
		protected BlockingQueue queue;

		Consumer(BlockingQueue theQueue) { this.queue = theQueue; }

		public void run() {
			try {
				while (true) {
					Object obj = queue.take();
					int len = queue.size();
					System.out.println("List size now " + len);
					process(obj);
					if (done) {
						return;
					}
				}
			} catch (InterruptedException ex) {
					System.out.println("CONSUMER INTERRUPTED");
			}
		}

		void process(Object obj) {
			// Thread.sleep(xxx) // Simulate time passing
			System.out.println("Consuming object " + obj);
		}
	}

	ProdCons15(int nP, int nC) {
		BlockingQueue myQueue = new LinkedBlockingQueue();
		for (int i=0; i<nP; i++)
			new Thread(new Producer(myQueue)).start();
		for (int i=0; i<nC; i++)
			new Thread(new Consumer(myQueue)).start();
	}

	public static void main(String[] args)
	throws IOException, InterruptedException {

		// Start producers and consumers
		int numProducers = 4;
		int numConsumers = 3;
		ProdCons15 pc = new ProdCons15(numProducers, numConsumers);

		// Let the simulation run for, say, 10 seconds
		Thread.sleep(10*1000); 

		// End of simulation - shut down gracefully
		pc.done = true;
	}
}
//@@@@@@//
//threads/ProdCons2.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ProdCons2.java,v 1.9 2004/02/09 03:34:07 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.util.*;
import java.io.*;

/** Producer-consumer in Java, Take II.
 */
public class ProdCons2 {

	/** Throughout the code, this is the object we synchronize on so this
	 * is also the object we wait() and notifyAll() on.
	 */
	protected LinkedList list = new LinkedList();
	protected int MAX = 10;
	protected boolean done = false; // Also protected by lock on list.

	/** Inner class representing the Producer side */
	class Producer extends Thread {

		public void run() {
			while (true) {
				Object justProduced = getRequestFromNetwork();
				// Get request from the network - outside the synch section.
				// We're simulating this actually reading from a client, and it
				// might have to wait for hours if the client is having coffee.
				synchronized(list) {
						while (list.size() == MAX) // queue "full"
						try {
							System.out.println("Producer WAITING");
							list.wait();	 // Limit the size
						} catch (InterruptedException ex) {
							System.out.println("Producer INTERRUPTED");
						}
					list.addFirst(justProduced);
					list.notifyAll();	// must own the lock
					System.out.println("Produced 1; List size now " + list.size());
					if (done)
						break;
					// yield();	// Useful for green threads & demo programs.
				}
			}
		}

		Object getRequestFromNetwork() {	// Simulation of reading from client
			// try {
			// 	Thread.sleep(10); // simulate time passing during read
			// } catch (InterruptedException ex) {
			// 	System.out.println("Producer Read INTERRUPTED");
			// }
			return(new Object());
		}
	}

	/** Inner class representing the Consumer side */
	class Consumer extends Thread {
		public void run() {
			while (true) {
				Object obj = null;
				synchronized(list) {
					while (list.size() == 0) {
						try {
							System.out.println("CONSUMER WAITING");
							list.wait();	// must own the lock
						} catch (InterruptedException ex) {
							System.out.println("CONSUMER INTERRUPTED");
						}
					}
					obj = list.removeLast();
					list.notifyAll();
					int len = list.size();
					System.out.println("List size now " + len);
					if (done)
						break;
				}
				process(obj);	// Outside synch section (could take time)
				//yield(); DITTO
			}
		}

		void process(Object obj) {
			// Thread.sleep(xxx) // Simulate time passing
			System.out.println("Consuming object " + obj);
		}
	}

	ProdCons2(int nP, int nC) {
		for (int i=0; i<nP; i++)
			new Producer().start();
		for (int i=0; i<nC; i++)
			new Consumer().start();
	}

	public static void main(String[] args)
	throws IOException, InterruptedException {

		// Start producers and consumers
		int numProducers = 4;
		int numConsumers = 3;
		ProdCons2 pc = new ProdCons2(numProducers, numConsumers);

		// Let it run for, say, 10 seconds
		Thread.sleep(10*1000); 

		// End of simulation - shut down gracefully
		synchronized(pc.list) {
			pc.done = true;
			pc.list.notifyAll();
		}
	}
}
//@@@@@@//
//threads/ReadersWriterDemo.java
//@@@@@@//
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Simulate multiple readers 
 * @version $Id: ReadersWriterDemo.java,v 1.5 2004/04/26 02:35:51 ian Exp $
 */
public class ReadersWriterDemo {
	private static final int NUM_READER_THREADS = 3;
	public static void main(String[] args) {
		new ReadersWriterDemo().demo();
	}
	
	/** Set this to true to end the program */
	private boolean done = false;
	
	/** The data being protected. */
	private BallotBox theData;
	
	/** The read lock / write lock combination */
	private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
	
	/**
	 * Constructor: set up some quasi-random initial data
	 */
	public ReadersWriterDemo() {
		List questionsList = new ArrayList();
		questionsList.add("Agree");
		questionsList.add("Disagree");
		theData = new BallotBox(questionsList);
	}
	
	/**
	 * Run a demo with more readers than writers
	 */
	private void demo() {
		
		// Start two reader threads
		for (int i = 0; i < NUM_READER_THREADS; i++) {
			new Thread() {
				public void run() {
					while(!done) {
						Iterator results = null;
						try {
							lock.readLock().lock();
							results = theData.iterator();
						} finally {
							// Unlock in finally to be sure.
							lock.readLock().unlock();
						}
						// Now lock has been freed, take time to print
						print(results);
						try {
							Thread.sleep(((long)(Math.random()* 1000)));
						} catch (InterruptedException ex) {
							// nothing to do
						}
					}
				}
			}.start();
		}
		// Start one writer thread to simulate occasional voting
		new Thread() {
			public void run() {
				while(!done) {
					try {
						lock.writeLock().lock();
						theData.voteFor(
								(((int)(Math.random()*
								theData.getCandidateCount()))));
					} finally {
						lock.writeLock().unlock();
					}
					try {
						Thread.sleep(((long)(Math.random()*1500)));
					} catch (InterruptedException ex) {
						// nothing to do
					}
				}
			}
		}.start();
		
		// In the main thread, wait a while then terminate the run.
		try {
			Thread.sleep(10 *1000);
		} catch (InterruptedException ex) {
			// nothing to do
		} finally {
			done = true;
		}	
	}

	/** print the current totals */
	private void print(Iterator iter) {
		boolean first = true;
		while (iter.hasNext()) {
			BallotPosition pair = (BallotPosition) iter.next();
			if (!first)
				System.out.print(", ");
			System.out.print(pair.getName() + "(" + pair.getVotes() + ")");
			first = false;
		}
		System.out.println();
	}
	

}
//@@@@@@//
//threads/Reentrant.java
//@@@@@@//
/** 
 * Illustrate the following quotation:<blockquote>
 * "Threads are re-entrant. A given thread can acquire the same
 * monitor several times..."
 * </blockquote>
 *
 * @author	Ian Darwin
 */
public class Reentrant extends Thread {
	int count = 5;

	/** Run does the work: print a message, "count" number of times */ 
	public synchronized void run() {
		while (count-- > 0) {
			System.out.println("Count = " + count);
			run();
		}
	}

	/**
	 * Main program, test driver for ThreadSync class.
	 */
	public static void main(String[] argv) {
		Thread t = new Reentrant();
		t.start();
		try {
			t.join();
		} catch (InterruptedException ex) {
			//
		}
		System.out.println("All done.");
	}
}
//@@@@@@//
//threads/ShutDownHook.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ShutDownHook.java,v 1.2 2004/02/09 03:34:07 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/** Demonstrate adding a Shutdown Hook to the Runtime.
 */
public class ShutDownHook {
	public static void main(String[] args) {
		System.err.println("Starting main program");
		Runtime rt = Runtime.getRuntime();
		System.err.println("Main: adding shutdown hook");
		rt.addShutdownHook(new Thread() {
			public void run() {
				// In real life this might close a Connection or something.
				System.err.println("Running my shutdown hook");
			}
		});
		System.err.println("Main: calling Runtime.exit()");
		rt.exit(0);
	}
}
//@@@@@@//
//threads/Sprite.java
//@@@@@@//
import java.awt.*;

/** A Sprite is one Image that moves around the screen on its own */
public class Sprite extends Component implements Runnable {
	protected static int spriteNumber = 0;
	protected Thread t;
	protected int x, y;
	protected Component parent;
	protected Image img;
	protected boolean done = false;
	/** The time in mSec to pause between each move. */
	protected int sleepTime = 250;
	/** The direction for this particular sprite. */
	protected int direction;
	/** The direction for going across the page */
	public static final int HORIZONTAL = 1;
	/** The direction for going up and down */
	public static final int VERTICAL = 2;
	/** The direction for moving diagonally */
	public static final int DIAGONAL = 3;

	/** Construct a Sprite with a Component parent, image and direction.
	 * Construct and start a Thread to drive this Sprite.
	 */
	public Sprite(Component parent, Image img, int dir) {
		super();
		this.parent = parent;
		this.img = img;
		switch(dir) {
			case VERTICAL: case HORIZONTAL: case DIAGONAL:
				direction = dir;
				break;
			default:
				throw new IllegalArgumentException(
					"Direction " + dir + " invalid");
		}
		setSize(img.getWidth(this), img.getHeight(this));
	}

	/** Construct a sprite with the default direction */
	public Sprite(Component parent, Image img) {
		this(parent, img, DIAGONAL);
	}

	/** Start this Sprite's thread. */
	public void start() {
		t = new Thread(this);
		t.setName("Sprite #" + ++spriteNumber);
		t.start();
	}

	/** Stop this Sprite's thread. */
	public void stop() {
		if (t == null)
			return;
		System.out.println("Stopping " + t.getName());
		done = true;
	}

	/** Adjust the motion rate */
	protected void setSleepTime(int n) {
		sleepTime = n;
	}

	/**
	 * Run one Sprite around the screen.
	 * This version just moves them around either across, down, or
	 * at some 45-degree angle.
	 */
    public void run() {
		int width = parent.getSize().width;
		int height = parent.getSize().height;
		// Set initial location
		x = (int)(Math.random() * width);
		y = (int)(Math.random() * height);
		// Flip coin for x & y directions
		int xincr = Math.random()>0.5?1:-1;
		int yincr = Math.random()>0.5?1:-1;
		while (!done) {
			width = parent.getSize().width;
			height = parent.getSize().height;
			if ((x+=xincr) >= width)
				x=0;
			if ((y+=yincr) >= height)
				y=0;
			if (x<0)
				x = width;
			if (y<0)
				y = height;
			switch(direction) {
				case VERTICAL: 
					x = 0;
					break;
				case HORIZONTAL: 
					y = 0;
					break;
				case DIAGONAL: break;
			}
			//System.out.println("from " + getLocation() + "->" + x + "," + y);
			setLocation(x, y);
			repaint();
			try {
				Thread.sleep(sleepTime);
			} catch (InterruptedException e) {
				return;
			}
		}
	}

	/** paint -- just draw our image at its current location */
    public void paint(Graphics g) {
		g.drawImage(img, 0, 0, this);
    }
}
//@@@@@@//
//threads/StopBoolean.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: StopBoolean.java,v 1.5 2004/02/09 03:34:07 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/** Show stopping a Thread using a flag.
 */
public class StopBoolean extends Thread {

	// MUST be volatile... If not, aggressive optimizing compiler
	// wil break this code!
	protected volatile boolean done = false;

	public void run() {
		while (!done) {
			System.out.println("StopBoolean running");
			try {
				sleep(720);
			} catch (InterruptedException ex) {
				// nothing to do 
			}
		}
		System.out.println("StopBoolean finished.");
	}
	public void shutDown() {
		done = true;
	}

	public static void main(String[] args) 
	throws InterruptedException {
		StopBoolean t1 = new StopBoolean();
		t1.start();
		Thread.sleep(1000*5);
		t1.shutDown();
	}
}
//@@@@@@//
//threads/StopClose.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: StopClose.java,v 1.5 2004/02/09 03:34:07 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.io.*;
import java.net.*;

/** Stop a thread by closing a socket.
 */
public class StopClose extends Thread {
	protected Socket io;

	public void run() {
		try {
			io = new Socket("localhost", 80);	// HTTP
			BufferedReader is = new BufferedReader(
				new InputStreamReader(io.getInputStream()));
			System.out.println("StopClose reading");

			// The following line will deadlock (intentionally), since HTTP 
			// enjoins the client to send a request (like "GET / HTTP/1.0")
			// and a null line, before reading the response.

			String line = is.readLine();	// DEADLOCK

			// Should only get out of the readLine if an interrupt
			// is thrown, as a result of closing the socket.

			// So we shouldn't get here, ever:
			System.out.println("StopClose FINISHED!?");
		} catch (IOException ex) {
			System.err.println("StopClose terminating: " + ex);
		}
	}

	public void shutDown() throws IOException {
		if (io != null) {
			// This is supposed to interrupt the waiting read.
			io.close();
		}
	}

	public static void main(String[] args) 
	throws InterruptedException, IOException {
		StopClose t = new StopClose();
		t.start();
		Thread.sleep(1000*5);
		t.shutDown();
	}
}
//@@@@@@//
//threads/StopStop.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: StopStop.java,v 1.2 2004/02/09 03:34:07 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/** Show stopping a Thread using deprecated stop() method.
 */
public class StopStop extends Thread {
	public void run() {
		while (true) {
			System.out.println("StopBoolean running");
			try {
				sleep(720);
			} catch (InterruptedException ex) {
				// nothing to do 
			}
		}
	}

	public static void main(String[] args) 
	throws InterruptedException {
		StopBoolean t1 = new StopBoolean();
		t1.start();
		Thread.sleep(1000*5);
		System.out.println("Stopping thread...");
		t1.stop();		// EXPECT COMPILER WARNING
	}
}
//@@@@@@//
//threads/Stopwatch.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: Stopwatch.java,v 1.5 2004/02/09 03:34:07 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/**
 * Count the seconds up from zero, until terminated.
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: Stopwatch.java,v 1.5 2004/02/09 03:34:07 ian Exp $
 */
public class Stopwatch {
	public static void main(String[] argv) {
		//+
		long t0 = System.currentTimeMillis();
		while (true) {
			long t1 = System.currentTimeMillis();
			int seconds = (int) (t1-t0)/1000;
			System.out.print("Elapsed: " + seconds + "\r");
			try {
				Thread.sleep(999);
			} catch (InterruptedException e) {
				// nothing to say
			}
		}
		//-
	}
}
//@@@@@@//
//threads/SyncNeeded.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: SyncNeeded.java,v 1.4 2004/02/09 03:34:07 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/** Show a method that may fail due to lack of synchronization */
public class SyncNeeded {

	public static final int MAX = 10000;

	protected static int[] data;
	protected static int ix = 0;

	public static void main(String[] args) throws InterruptedException { 
		class R implements Runnable {
			public void run() {
				// System.out.println(
				//	"Running " + Thread.currentThread().getName());

				// This statement may do bad things!
				data[ix] = ix++;
			}
		}
		data = new int[MAX];
		System.out.println("Starting " + MAX + " threads...");
		for (int i=0; i<MAX; i++) {
			new Thread(new R()).start();
		}
		System.out.println("Sleeping to let threads finish");
		Thread.sleep(4000);
		for (int i=0; i<MAX; i++) {
			if (i != data[i])
				System.out.println("Discrepancy at " + i + ": " + data[i]);
		}
		System.out.println("Done.");
	}
}
//@@@@@@//
//threads/ThreadDeathCatch.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ThreadDeathCatch.java,v 1.4 2004/03/26 03:30:23 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

/**
 * Catch a ThreadDeath by hitting a Thread with stop.
 */
public class ThreadDeathCatch {
	public static void main(String[] args) {
		try {
			Thread t = new Thread() {
				public void run() {
					try {
						Thread.sleep(2500);
					} catch (Throwable ex)  {
						System.out.println("Caught in run: " + ex);
					}
				}
			};
			t.start();
			// Give t time to get going...
			Thread.sleep(1000);
			t.stop();				// EXPECT COMPILER WARNING
		} catch (Throwable t) {
			System.out.println("Caught in main: " + t);
		}
	}
}
//@@@@@@//
//threads/ThreadGroupDemo.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ThreadGroupDemo.java,v 1.3 2004/02/09 03:34:07 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/** Simple demo of ThreadGroup usage.
 */
public class ThreadGroupDemo {

	class MyThreadGroup extends ThreadGroup {
		public void uncaughtException(Thread t, Throwable ex) {
			System.err.println("I caught " + ex);
		}
		public MyThreadGroup(String name) {
			super(name);
		}
	}

	public static void main(String[] args) {
		new ThreadGroupDemo().work();
	}

	protected void work() {
		ThreadGroup g = new MyThreadGroup("bulk threads");
		Runnable r = new Runnable() {
			public void run() {
				System.out.println(Thread.currentThread().getName() + " started");
				for (int i=0; i<5; i++) {
					System.out.println(Thread.currentThread().getName() + ": " + i);
					try {
						Thread.sleep(1776);
					} catch (InterruptedException ex) {
						System.out.println("Huh?");
					}
				}
			}
		};

		// Create and start all the Threads
		for (int i = 0; i< 10; i++) {
			new Thread(g, r).start();
		}

		// List them.
		Thread[] list = new Thread[g.activeCount()];
		g.enumerate(list);
		for (int i=0; i<list.length; i++) {
			if (list[i] == null)
				continue;
			Thread t = list[i];
			System.out.println(i + ": " + t);
		}
	}
}
//@@@@@@//
//threads/ThreadLocalDemo.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ThreadLocalDemo.java,v 1.2 2004/02/09 03:34:08 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

/** Demonstrate use of ThreadLocal */
public class ThreadLocalDemo extends Thread {

	/** A serial number for clients */
	private static int clientNum = 0;

	/** This ThreadLocal holds the Client reference for each Thread */
	private ThreadLocal myClient = new ThreadLocal() {
		// The initialValue() method is called magically when you call get().
		protected synchronized Object initialValue() {
			return new Client(clientNum++);
		}
	};

	public void run() {
		System.out.println("Thread " + Thread.currentThread().getName() +
			" has client " + myClient.get());
	}

	public static void main(String[] args) {
		Thread t1 = new ThreadLocalDemo();
		Thread t2 = new ThreadLocalDemo();
		t1.start();
		t2.start();
	}

	/** Simple data class, in real life clients would have more fields! */
	private class Client {

		private int clNum;

		Client(int n) {
			clNum = n;
		}

		public String toString() {
			return "Client[" + clNum + "]";
		}
	}
}
//@@@@@@//
//threads/ThreadName.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ThreadName.java,v 1.3 2004/02/09 03:34:08 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

// import - none

/** Get the name of a Thread. */
public class ThreadName {
	public static void main(String[] args) {
		System.out.println(new Thread().getName());
	}
}
//@@@@@@//
//threads/ThreadsDemo1.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ThreadsDemo1.java,v 1.6 2004/03/14 01:24:06 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

/** 
 * Threaded demo application, as a Threads subclass.
 *
 * @author	Ian Darwin
 * @version	1.0
 */
public class ThreadsDemo1 extends Thread {
	String mesg;
	int count;

	/** Run does the work: print a message, "count" number of times */ 
	public void run() {
		while (count-- > 0) {
			println(mesg);
			try {
				Thread.sleep(100);	// 100 msec
			} catch (InterruptedException e) {
				return;
			}
		}
		println(mesg + " all done.");
	}

	void println(String s) {
		System.out.println(s);
	}

	/**
	 * Construct a ThreadsDemo1 object.
	 * @param m Message to display
	 * @param n How many times to display it
	 */
	public ThreadsDemo1(String m, int n) {
		count = n;
		mesg  = m;
		setName(m + " runner Thread");
	}

	/**
	 * Main program, test driver for ThreadsDemo1 class.
	 */
	public static void main(String[] argv) {
		// could say: new ThreadsDemo1("Hello from X", 10).run();
		// could say: new ThreadsDemo1("Hello from Y", 15).run();
		// But then it wouldn't be multi-threaded!
		new ThreadsDemo1("Hello from X", 10).start();
		new ThreadsDemo1("Hello from Y", 15).start();
	}
}
//@@@@@@//
//threads/ThreadsDemo2.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ThreadsDemo2.java,v 1.8 2004/03/14 01:25:36 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

/** 
 * Threaded demo application, version 2, using Runnable.
 * @author	Ian Darwin
 * @version	$Id: ThreadsDemo2.java,v 1.8 2004/03/14 01:25:36 ian Exp $
 */
public class ThreadsDemo2 implements Runnable {
	String mesg;
	Thread t;
	int count;

	/**
	 * Main program, test driver for ThreadsDemo2 class.
	 */
	public static void main(String[] argv) {
		new ThreadsDemo2("Hello from X", 10);
		new ThreadsDemo2("Hello from Y", 15);
	}

	/**
	 * Construct a ThreadsDemo2 object
	 * @param m Message to display
	 * @param n How many times to display it
	 */
	public ThreadsDemo2(String m, int n) {
		count = n;
		mesg  = m;
		t = new Thread(this);
		t.setName(m + " runner Thread");
		t.start();
	}

	/** Run does the work. We override the run() method in Runnable. */ 
	public void run() {
		while (count-- > 0) {
			println(mesg);
			try {
				Thread.sleep(100);	// 100 msec
			} catch (InterruptedException e) {
				return;
			}
		}
		println(mesg + " thread all done.");
	}

	void println(String s) {
		System.out.println(s);
	}
}
//@@@@@@//
//threads/ThreadsDemo3.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ThreadsDemo3.java,v 1.6 2004/03/14 01:24:06 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

/** 
 * Threaded demo application, using inner class as Runnable.
 *
 * @author	Ian Darwin
 *
 * @version	1.0
 */
public class ThreadsDemo3 {
	String mesg;
	Thread t;
	int count;

	/**
	 * Main program, test driver for ThreadsDemo3 class.
	 */
	public static void main(String[] argv) {
		new ThreadsDemo3("Hello from X", 10);
		new ThreadsDemo3("Hello from Y", 15);
	}

	/**
	 * Construct a ThreadDemo object
	 * @param m Message to display
	 * @param n How many times to display it
	 */
	public ThreadsDemo3(String m, int n) {
		count = n;
		mesg  = m;
		t = new Thread(new Runnable() {
			public void run() {
				while (count-- > 0) {
					println(mesg);
					try {
						Thread.sleep(100);	// 100 msec
					} catch (InterruptedException e) {
						return;
					}
				}
				println(mesg + " thread all done.");
			}
		});
		t.setName(m + " runner Thread");
		t.start();
	}

	void println(String s) {
		System.out.println(s);
	}
}
//@@@@@@//
//threads/ThreadsOne.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ThreadsOne.java,v 1.4 2004/02/09 03:34:08 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.awt.*;
import java.awt.event.*;
import java.applet.*;

/**
 * Threaded Labels: each instance of this class
 * runs its own thread, with a counter that counts down to zero.
 * <br/>Older version	0.5, July 1997, for JDK1.1
 * @author	Ian Darwin
 * @version $id$
 */
public class ThreadsOne extends Applet implements Runnable {
	Label lab;	
	Button but;
	Thread t;
	int count;

	/** run() - do the work of the thread. Might get confused if
	 * the user pushes the button a second time before we finish.
	 */
	public void run() {
		int c = count;
		while (c-- > 0) {
			lab.setText(Integer.toString(c));
			try {
				Thread.sleep(100);	// 100 msec
			} catch (Exception e) {
				return;
			}
		}
		System.out.println("All done");
	}

	/** Set the number of times the counter is to decrement */
	public void setCount(int i) {
		count = i;
	}

	/** init() [from Applet] - set up the GUI */
	public void init() {

		// Create the start button.
		add(but = new Button("Start"));
		but.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
			t = new Thread(ThreadsOne.this);
			t.start();
			}
		});

		// Make label large enough to hold three-digit number
		add(lab = new Label("000"));
	
		// Provide a count from the PARAM, default to 100.
		String snum;
		if ((snum = getParameter("count")) != null)
			setCount(Integer.parseInt(snum));
		else
			setCount(100);
	}
}
//@@@@@@//
//threads/ThreadStoppers.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ThreadStoppers.java,v 1.3 2004/02/09 03:34:08 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.io.IOException;

/** Demonstrate both StopXXX classes.
 */
public class ThreadStoppers {
	public static void main(String[] args) 
	throws InterruptedException, IOException {
		Thread t1 = new StopBoolean();
		Thread t2 = new StopClose();
		t1.start();
		t2.start();
		Thread.sleep(1000*5);
		((StopBoolean)t1).shutDown();
		((StopClose  )t2).shutDown();
	}
}

//@@@@@@//
//threads/ThreadSync.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: ThreadSync.java,v 1.3 2004/02/09 03:34:08 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

/** 
 * Threaded demo application, as a Threads subclass.
 *
 * @author	Ian Darwin
 * @version	1.0
 */
public class ThreadSync extends Thread {
	String mesg;
	int count;

	/** Run does the work: print a message, "count" number of times */ 
	public void run() {
		while (count-- > 0) {
			println(mesg);
			try {
				Thread.sleep(100);	// 100 msec
			} catch (InterruptedException e) {
				return;
			}
		}
		println(mesg + " all done.");
	}

	/* The output routine has been synchronized to interlock the Threads */
	synchronized void println(String s) {
		System.out.println(s);
	}

	/**
	 * Construct a ThreadSync object.
	 * @param	String m	Message to display
	 * @param	int n		How many times to display it
	 */
	public ThreadSync(String m, int n) {
		count = n;
		mesg  = m;
		setName(m + " runner Thread");
	}

	/**
	 * Main program, test driver for ThreadSync class.
	 */
	public static void main(String[] argv) {
		new ThreadSync("Hello from X", 10).start();
		new ThreadSync("Hello from Y", 15).start();
	}
}
//@@@@@@//
//threads/UpdateSlowGUI.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: UpdateSlowGUI.java,v 1.4 2004/03/26 03:30:24 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.SwingUtilities;

/** Update a GUI after some slow operation completes.
 * Do it right, using the AWT event thread.
 */
public class UpdateSlowGUI extends JFrame {
	public static void main(String[] args) {
		// Create the GUI; will implicitly create and start AWT GUI thread
		new UpdateSlowGUI().setVisible(true); 
	}

	public UpdateSlowGUI() {
		super("UpdateSlowGUI");
		final JButton b;
		final JLabel status;
		Container cp = getContentPane();
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		cp.add(BorderLayout.CENTER, b = new JButton("Update..."));
		cp.add(BorderLayout.SOUTH, status = new JLabel("Ready"));
		b.addActionListener(new ActionListener() {
			// Pressed when the user wants to do the action...
			public void actionPerformed(ActionEvent evt) {
				status.setText("Busy...");
				b.setEnabled(false);
				Thread t = new Thread() {
					public void run() {
						// Simulate something slow, like a large DB query
						try {
							Thread.sleep(5000);
						} catch(InterruptedException ex) {
							return;
						}

						// OK, the long-running thing has finished.
						// Now go back into AWT/Swing to update the GUI
						SwingUtilities.invokeLater(new Runnable() {
							public void run() {
								status.setText("Ready");
								b.setEnabled(true);
							}
						});
					}
				};
				t.start();
			}
		});
		setSize(150, 200);
		setLocation(200, 200);
	}
}
//@@@@@@//
//threads/UUID.java
//@@@@@@//
/*
 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
 * All rights reserved. Software written by Ian F. Darwin and others.
 * $Id: UUID.java,v 1.2 2004/02/09 03:34:08 ian Exp $
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by Ian F. Darwin.
 * 4. Neither the name of the author nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
 * pioneering role in inventing and promulgating (and standardizing) the Java 
 * language and environment is gratefully acknowledged.
 * 
 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
 * inventing predecessor languages C and C++ is also gratefully acknowledged.
 */

import java.util.Random;

/** Show generation of a unique identifier
 */
public class UUID {

	/** A sequence number */
	static int num = 98765;
	/** A Random generator */
	static Random r = new Random();

	/** Generate a new UUID. Uses both num and r; easier to
	 * synchronize the method than the two access/modifies.
	 */
	synchronized static String getUUID() {
		return "o-" + ++num + "-" + r.nextLong();
	}

	public static void main(String[] args) {
		System.out.println(getUUID());
	}
}
//@@@@@@//
//webserver/Handler.java
//@@@@@@//
import java.io.*;
import java.net.*;
import java.util.*;

import com.darwinsys.util.Debug;

/** Called from Httpd in a Thread to handle one connection.
 * We are created with just a Socket, and read the
 * HTTP request, extract a name, read it (saving it
 * in Hashtable h for next time), and write it back.
 * <p>
 * TODO split into general handler stuff and "FileServlet",
 *	then handle w/ either user HttpServlet subclasses or FileServlet.
 * @version $Id: Handler.java,v 1.14 2004/03/14 17:47:22 ian Exp $
 */
public class Handler {

	/** inputStream, from Viewer */
	protected BufferedReader is;
	/** outputStream, to Viewer */
	protected PrintStream os;
	/** Main program */
	protected Httpd parent;
	/** The default filename in a directory. */
	protected final static String DEF_NAME = "/index.html";

	/** The Hashtable used to cache all URLs we've read.
	 * Static, shared by all instances of Handler (one Handler per request;
	 * this is probably quite inefficient, but simple. Need ThreadPool).
	 * Note that Hashtable methods *are* synchronized.
	 */
	private static Hashtable h = new Hashtable();

	static {
		h.put("", "<html><body><b>Unknown server error</b>".getBytes());
	}

	/** Construct a Handler */
	Handler(Httpd parent) {
		this.parent = parent;
	}
	
	protected static final int RQ_INVALID = 0, RQ_GET = 1, RQ_HEAD = 2,
		RQ_POST = 3; 

	public void process(Socket clntSock) {
		String request;		// what Viewer sends us.
		int methodType = RQ_INVALID;
		try {
			System.out.println("Connection accepted from " +
				clntSock.getInetAddress());
			is = new BufferedReader(new InputStreamReader(
				clntSock.getInputStream()));
			// Must do before any chance of errorResponse being called!
			os = new PrintStream(clntSock.getOutputStream());

			request = is.readLine();
			if (request == null || request.length() == 0) {
				// No point nattering: the sock died, nobody will hear
				// us if we scream into cyberspace... Could log it though.
				return;
			}

			// Use a StringTokenizer to break the request into its three parts:
			// HTTP method, resource name, and HTTP version
			StringTokenizer st = new StringTokenizer(request);
			if (st.countTokens() != 3) {
				errorResponse(444, "Unparseable input " + request);
				return;
			}
			String rqCode = st.nextToken();
			String rqName = st.nextToken();
			String rqHttpVer = st.nextToken();
			System.out.println("Request: Command " + rqCode +
					", file " + rqName + ", version " + rqHttpVer);


			// Read headers, up to the null line before the body,
			// so the body can be read directly if it's a POST.
			HashMap map = new HashMap();
			String hdrLine;
			while ((hdrLine = is.readLine()) != null &&
					hdrLine.length() != 0) {
					int ix;
					if ((ix=hdrLine.indexOf(':')) != -1) {
						String hdrName = hdrLine.substring(0, ix);
						String hdrValue = hdrLine.substring(ix+1).trim();
						Debug.println("hdr", hdrName+","+hdrValue);
						map.put(hdrName, hdrValue);
					} else {
						System.err.println("INVALID HEADER: " + hdrLine);
					}
			}

			// check that rqCode is either GET or HEAD or ...
			if ("get".equalsIgnoreCase(rqCode))
				  methodType = RQ_GET;
			else if ("head".equalsIgnoreCase(rqCode))
				  methodType = RQ_HEAD;
			else if ("post".equalsIgnoreCase(rqCode))
				  methodType = RQ_POST;
			else {
				errorResponse(400, "invalid method: " + rqCode);
				return;
			}

			// A bit of paranoia may be a good thing...
			if (rqName.indexOf("..") != -1) {
				errorResponse(404, "can't seem to find: " + rqName);
				return;
			}
				
			// XXX new MyRequest(clntSock, rqName, methodType);
			// XXX new MyResponse(clntSock, os);

			// XXX if (isServlet(rqName)) [
			// 		doServlet(rqName, methodType, map);
			// else
				doFile(rqName, methodType == RQ_HEAD, os /*, map */);
			os.flush();
			clntSock.close();
		} catch (IOException e) {
			System.out.println("IOException " + e);
		}
		System.out.println("END OF REQUEST");
	}

	/** Processes one file request */
	void doFile(String rqName, boolean headerOnly, PrintStream os) throws IOException {
		File f;
		byte[] content = null;
		Object o = h.get(rqName);
		if (o != null && o instanceof byte[]) {
			content = (byte[])o;
			System.out.println("Using cached file " + rqName);
			sendFile(rqName, headerOnly, content, os);
		} else if ((f = new File(parent.getRootDir() + rqName)).isDirectory()) {
			// Directory with index.html? Process it.
			File index = new File(f, DEF_NAME);
			if (index.isFile()) {
				doFile(rqName + DEF_NAME, index, headerOnly, os);
				return;
			}
			else {
				// Directory? Do not cache; always make up dir list.
				System.out.println("DIRECTORY FOUND");
				doDirList(rqName, f, headerOnly, os);
				sendEnd();
			}
		} else if (f.canRead()) {
			// REGULAR FILE
			doFile(rqName, f, headerOnly, os);
		}
		else {
			errorResponse(404, "File not found");
		}
	}

	void doDirList(String rqName, File dir, boolean justAHead, PrintStream os) {
		os.println("HTTP/1.0 200 directory found");
		os.println("Content-type: text/html");
		os.println("Date: " + new Date().toString());
		os.println("");
		if (justAHead)
			return;
		os.println("<HTML>");
		os.println("<TITLE>Contents of directory " + rqName + "</TITLE>");
		os.println("<H1>Contents of directory " + rqName + "</H1>");
		String fl[] = dir.list();
		Arrays.sort(fl);
		for (int i=0; i<fl.length; i++)
			os.println("<br/><a href=\"" + rqName + File.separator + fl[i] + "\">" +
			"<img align='center' border='0' src=\"/images/file.jpg\">" +
			' ' + fl[i] + "</a>");
	}

	/** Send one file, given a File object. */
	void doFile(String rqName, File f, boolean headerOnly, PrintStream os) throws IOException {
		System.out.println("Loading file " + rqName);
		InputStream in = new FileInputStream(f);
		byte c_content[] = new byte[(int)f.length()];
		// Single large read, should be fast.
		int n = in.read(c_content);
		h.put(rqName, c_content);
		sendFile(rqName, headerOnly, c_content, os);
		in.close();
	}

	/** Send one file, given the filename and contents.
	 * @param justHead - if true, send heading and return.
	 */
	void sendFile(String fname, boolean justHead,
		byte[] content, PrintStream os) throws IOException {
		os.println("HTTP/1.0 200 Here's your file");
		os.println("Content-type: " + guessMime(fname));
		os.println("Content-length: " + content.length);
		os.println();
		if (justHead)
			return;
		os.write(content);
	}

	/** The type for unguessable files */
	final static String UNKNOWN = "unknown/unknown";
	
	protected String guessMime(String fn) {
		String lcname = fn.toLowerCase();
		int extenStartsAt = lcname.lastIndexOf('.');
		if (extenStartsAt<0) {
			if (fn.equalsIgnoreCase("makefile"))
				return "text/plain";
			return UNKNOWN;
		}
		String exten = lcname.substring(extenStartsAt);
		String guess = parent.getMimeType(exten, UNKNOWN);

		return guess;
	}

	/** Sends an error response, by number, hopefully localized. */
	protected void errorResponse(int errNum, String errMsg) {

		// Check for localized messages
		ResourceBundle messages = ResourceBundle.getBundle("errors");

		String response;
		try { response = messages.getString(Integer.toString(errNum)); }
		catch (MissingResourceException e) { response=errMsg; }

		// Generate and send the response
		os.println("HTTP/1.0 " + errNum + " " + response);
		os.println("Content-type: text/html");
		os.println();
		os.println("<html>");
		os.println("<head><title>Error " + errNum + "--" + response +
			"</title></head>");
		os.println("<h1>" + errNum + " " + response + "</h1>");
		sendEnd();
	}

	/** Send the tail end of any page we make up. */
	protected void sendEnd() {
		os.println("<hr>");
		os.println("<address>Java Web Server,");
		String myAddr = "http://www.darwinsys.com/freeware/";
		os.println("<a href=\"" + myAddr + "\">" +
			myAddr + "</a>");
		os.println("</address>");
		os.println("</html>");
		os.println();
	}
}
//@@@@@@//
//webserver/Httpd.java
//@@@@@@//
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Properties;

import com.darwinsys.util.FileProperties;

/**
 * A very very simple Web server.
 * <p>
 * NO SECURITY. ALMOST NO CONFIGURATION. NO CGI. NO SERVLETS.
 *<p>
 * This version is threaded. I/O is done in Handler.
 * @version $Id: Httpd.java,v 1.10 2004/03/14 02:22:29 ian Exp $
 */
public class Httpd {
	/** The default port number */
	public static final int HTTP = 80;
	/** The server socket used to connect from clients */
	protected ServerSocket sock;
	/** A Properties, for loading configuration info */
	private Properties wsp;
	/** A Properties, for loading mime types into */
	private Properties mimeTypes;
	/** The root directory */
	private String rootDir;

	public static void main(String argv[]) throws Exception {
		System.out.println("DarwinSys JavaWeb Server 0.1 starting...");
		Httpd w = new Httpd();
		if (argv.length == 2 && argv[0].equals("-p")) {
			w.startServer(Integer.parseInt(argv[1]));
		} else {
			w.startServer(HTTP);
		}
		w.runServer();
		// NOTREACHED
	}

	/** Run the main loop of the Server. Each time a client connects,
	 * the ServerSocket accept() returns a new Socket for I/O, and
	 * we pass that to the Handler constructor, which creates a Thread,
	 * which we start.
	 */
	void runServer() throws Exception  {
		while (true) {
				final Socket clntSock = sock.accept();
				Thread t = new Thread(){
					public void run() {
						new Handler(Httpd.this).process(clntSock);
					}
				};
				t.start();
		}
	}

	/** Construct a server object for a given port number */
	Httpd() throws Exception {
		super();
		wsp=new FileProperties("httpd.properties");
		rootDir = wsp.getProperty("rootDir", ".");
		mimeTypes = new FileProperties(wsp.getProperty("mimeProperties", "mime.properties"));
	}

	public void startServer(int portNum) throws Exception {
		String portNumString = null;
		if (portNum == HTTP) {
			portNumString = wsp.getProperty("portNum");
			if (portNumString != null) {
				portNum = Integer.parseInt(portNumString);
			}
		}
		sock = new ServerSocket(portNum);
		System.out.println("Listening on port " + portNum);
	
	}

	public String getMimeType(String type) {
		return mimeTypes.getProperty(type);
	}
	public String getMimeType(String type, String dflt) {
		return mimeTypes.getProperty(type, dflt);
	}
	public String getServerProperty(String name) {
		return wsp.getProperty(name);
	}

	public String getRootDir() {
		return rootDir;
	}
}
//@@@@@@//
//webserver/HttpdConcurrent.java
//@@@@@@//
import java.net.Socket;
import java.util.concurrent.*;

/**
 * HttpConcurrent - Httpd Subclass using java.lang.concurrent
 */
public class HttpdConcurrent extends Httpd {
	Executor myThreadPool = Executors.newFixedThreadPool(5);

	public HttpdConcurrent() throws Exception {
		super();
	}
	
	public static void main(String[] argv) throws Exception {
		System.out.println("DarwinSys JavaWeb Server 0.1 starting...");
		HttpdConcurrent w = new HttpdConcurrent();
		if (argv.length == 2 && argv[0].equals("-p")) {
			w.startServer(Integer.parseInt(argv[1]));
		} else {
			w.startServer(HTTP);
		}
		w.runServer();
	}
	public void runServer() throws Exception {
		while (true) {
			final Socket clientSocket = sock.accept();
			myThreadPool.execute(new Runnable() {
				public void run() {
					new Handler(HttpdConcurrent.this).process(clientSocket);
				}
			});
		}
	}
}//@@@@@@//
//webserver/MyRequest.java
//@@@@@@//
import java.io.InputStream;

import javax.servlet.http.HttpServletRequest;

public class MyRequest implements HttpServletRequest {
	/* Construct a dummy MyRequest */
	public MyRequest() {
	}
	/** Construct a MyRequest for the given input */
	public MyRequest(InputStream s) {
	}

	public String getAuthType() { return null; }
	public String getContextPath() { return null; }
	public javax.servlet.http.Cookie[] getCookies() { return null; }
	public long getDateHeader(String name) { return 0; }
	public String getHeader(String name) { return null; }
	public java.util.Enumeration getHeaderNames() { return null; }
	public java.util.Enumeration getHeaders(String name) { return null; }
	public int getIntHeader(String name) {
		return Integer.parseInt(getHeader(name));
	}
	public String getMethod() { return null; }
	public String getPathInfo() { return null; }
	public String getPathTranslated() { return null; }
	public String getQueryString() { return null; }
	public String getRemoteUser() { return null; }
	public StringBuffer getRequestURL() { 
		return null;
	}
	public String getRequestURI() { 
		return getRequestURL().toString();
	}
	public String getRequestedSessionId() { return null; }
	public String getServletPath() { return null; }
	public javax.servlet.http.HttpSession getSession() { return null; }
	public javax.servlet.http.HttpSession getSession(boolean create) { return null; }
	public java.security.Principal getUserPrincipal() { return null; }
	public boolean isRequestedSessionIdFromCookie() { return false; }
	public boolean isRequestedSessionIdFromURL() { return false; }
	public boolean isRequestedSessionIdFromUrl() { return false; }
	public boolean isRequestedSessionIdValid() { return false; }
	public boolean isUserInRole(String user) { return false; }
	protected String enc = "iso-8859-1";
	public String getCharacterEncoding() { return enc; }
	public void setCharacterEncoding(String nenc) { enc = nenc; }
	public int getContentLength() { return 0; }
	public String getContentType() { return "text/html"; }
	public javax.servlet.ServletInputStream getInputStream() { return null; }
	public java.util.Locale getLocale() { return null; }
	public java.util.Enumeration getLocales() { return null; }
	public String getParameter(String s1) { return null; }
	public java.util.Enumeration getParameterNames() { return null; }
	public java.util.Map getParameterMap() { return null; }
	public String[] getParameterValues(String s1) { return null; }
	public String getProtocol() { return "http"; }
	public java.io.BufferedReader getReader() { return null; }
	public String getRealPath(String s1) { return null; }
	public String getRemoteAddr() { return null; }
	public String getRemoteHost() { return null; }
	public javax.servlet.RequestDispatcher getRequestDispatcher(String req) {
		return null;
	}
	public String getScheme() { return "http"; }
	public String getServerName() { return "localhost"; }
	public int getServerPort() { return 80; }
	public boolean isSecure() { return false; }

	public void setAttribute(String s1, Object s2) { }
	public void removeAttribute(String s1) { }
	public Object getAttribute(String s1) { return null; }
	public java.util.Enumeration getAttributeNames() { return null; }
}
//@@@@@@//
//webserver/MyResponse.java
//@@@@@@//
import javax.servlet.http.*;
import java.io.*;
import java.util.*;

public class MyResponse implements HttpServletResponse {
	/** Construct a dummy Response */
	public MyResponse() {
	}
	/** Construct a Response to the given Socket */
	public MyResponse(OutputStream out) {
	}

    public void addCookie(javax.servlet.http.Cookie cookie) { return; }
    public void addDateHeader(String name, long val) { return; }
    public void addHeader(String name, String val) { return; }
    public void addIntHeader(String name, int val) { return; }
    public boolean containsHeader(String hdrName) { return false; }
    public String encodeRedirectURL(String url) { return null; }
    public String encodeRedirectUrl(String url) { return null; }
    public String encodeURL(String url) { return null; }
    public String encodeUrl(String url) { return null; }
    public void sendError(int code) throws java.io.IOException { return; }
    public void sendError(int code, String val) throws java.io.IOException { return; }
    public void sendRedirect(String url) throws java.io.IOException { return; }
    public void setDateHeader(String val, long dval) {
		setHeader("Date", new java.util.Date(dval).toString());
	}
    public void setHeader(String name, String val) { return; }
    public void setIntHeader(String name, int ival) {
		setHeader(name, Integer.toString(ival));
	}
	public void setContentLength(int len) { }
	public void setContentType(String type) { }
    public void setStatus(int status) { return; }
    public void setStatus(int status, String mesg) { return; }
	public void setLocale(Locale loc) { }
	public Locale getLocale() { return Locale.US; }

	public void flushBuffer() { }
	public void resetBuffer() { }
	public int getBufferSize() { return 42; }
	public String getCharacterEncoding() { return "iso-8859-1"; }
	public javax.servlet.ServletOutputStream getOutputStream() { return null; }
	public java.io.PrintWriter getWriter() { return null; }
	public boolean isCommitted() { return true; }
	public void reset() { }
	public void setBufferSize(int size) { }

}
//@@@@@@//
//webserver/SSIServlet.java
//@@@@@@//
import javax.servlet.*;
import javax.servlet.http.HttpServlet;

/** A first stab at adding SSI (Server Side Include) to the server */
public class SSIServlet extends HttpServlet {
	/** The string we look for (not a full parse, obviously) */
	public static String header = "<!--#include";

	public void service(ServletRequest request, ServletResponse response) {

	}
}
//@@@@@@//
//xml/DocWriteDOM.java
//@@@@@@//
import java.io.IOException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Node;

/** Make up and write an XML document, using DOM
 * UPDATED FOR JAXP.
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: DocWriteDOM.java,v 1.6 2004/03/01 03:42:57 ian Exp $
 */
public class DocWriteDOM {

	public static void main(String[] av) throws IOException {
		DocWriteDOM dw = new DocWriteDOM();
		Document doc = dw.makeDoc();

		// Sadly, the write() method is not in the DOM spec, so we
		// have to cast the Document to its implementing class
		// in order to call the Write method.
		//
		// WARNING
		//
		// This code therefore depends upon the particular
		// parser implementation.
		//
		((org.apache.crimson.tree.XmlDocument)doc).write(System.out);
	}

	/** Generate the XML document */
	protected Document makeDoc() {
		try {
			DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();
			DocumentBuilder parser = fact.newDocumentBuilder();
			Document doc = parser.newDocument();

			Node root = doc.createElement("Poem");
			doc.appendChild(root);

			Node stanza = doc.createElement("Stanza");
			root.appendChild(stanza);
			
			Node line = doc.createElement("Line");
			stanza.appendChild(line);
			line.appendChild(doc.createTextNode("Once, upon a midnight dreary"));
			line = doc.createElement("Line");
			stanza.appendChild(line);
			line.appendChild(doc.createTextNode("While I pondered, weak and weary"));

			return doc;

		} catch (Exception ex) {
			System.err.println("+============================+");
			System.err.println("|        XML Error           |");
			System.err.println("+============================+");
			System.err.println(ex.getClass());
			System.err.println(ex.getMessage());
			System.err.println("+============================+");
			return null;
		}
	}
}
//@@@@@@//
//xml/DocWriteJDOM.java
//@@@@@@//
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.output.XMLOutputter;

/** Make up and write an XML document, using JDOM
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: DocWriteJDOM.java,v 1.4 2004/02/09 03:34:10 ian Exp $
 */
public class DocWriteJDOM {

	public static void main(String[] av) throws Exception {
		DocWriteJDOM dw = new DocWriteJDOM();
		Document doc = dw.makeDoc();
		// Create an output formatter, and have it write the doc.
		new XMLOutputter().output(doc, System.out);
	}

	/** Generate the XML document */
	protected Document makeDoc() throws Exception {
			Document doc = new Document(new Element("Poem"));
			doc.getRootElement().
				addContent(new Element("Stanza").
					addContent(new Element("Line").
							setText("Once, upon a midnight dreary")).
					addContent(new Element("Line").
							setText("While I pondered, weak and weary")));

			return doc;
	}
}
//@@@@@@//
//xml/JAXPTransform.java
//@@@@@@//
import java.io.File;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

/** Illustrate simplest use of JAXP to transform using XSL
 * @param args three filenames: XML, XSL, and Output (this order is historical).
 * */
public class JAXPTransform {
	public static void main(String[] args) throws Exception {
		
		// Require three input args
		if (args.length != 3) {
			System.out.println("Usage: java JAXPTransform inputFile.xml inputFile.xsl outputFile");
			System.exit(1);
		}
		
		// Create a transformer object
		Transformer tx = TransformerFactory.newInstance().newTransformer(
				new StreamSource(new File(args[1]))); // not 0
		
		// Use its transform() method to perform the transformation
		tx.transform(new StreamSource(new File(args[0])), // not 1
				new StreamResult(new File(args[2])));
	}
}
//@@@@@@//
//xml/JDOMDemo.java
//@@@@@@//
import java.io.IOException;
import java.util.Iterator;
import java.util.List;

import org.jdom.Comment;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.ProcessingInstruction;
import org.jdom.input.DOMBuilder;
import org.jdom.input.SAXBuilder;
import org.jdom.output.DOMOutputter;

/*
 * Simple demo of JDOM
 */
public class JDOMDemo {

    public static void main(String[] args) {
  
		// Must be at least one file or URL argument
        if (args.length == 0) {
            System.out.println("Usage: java JDOMDemo URL [...]"); 
        } 
        
        SAXBuilder saxBuilder = new SAXBuilder();
        DOMBuilder domBuilder = new DOMBuilder();
                
        for (int i = 0; i < args.length; i++) {
      
            try {
                Document jdomDocument = saxBuilder.build(args[i]);

                DOMOutputter domOutputter = new DOMOutputter();

                /*
                 * Test getting DOM Document from JDOM Document
                org.w3c.dom.Document domDocument = domOutputter.output(doc);
                 */

                /*
                 * Test getting DOM Element from JDOM Element
                 */
                org.w3c.dom.Element domElement = 
                	domOutputter.output(jdomDocument.getRootElement());

                /*
                 * Test getting JDOM Element from DOM Element
                 */
                org.jdom.Element jdomElement = domBuilder.build(domElement);
                demo(jdomElement);

            } catch (JDOMException e) { // indicates a well-formedness or other error
                System.out.println(args[i] + " is not a well formed XML document.");
                System.out.println(e.getMessage());
            } catch (IOException ex) {
				System.out.println("Input or Output error:" + 
					args[i] + ": " + ex);
			}     
        }
    }

    public static void demo(Document doc) {

        List children = doc.getContent();
        Iterator iterator = children.iterator();
        while (iterator.hasNext()) {
            Object o = iterator.next();
            if (o instanceof Element) {
                demo((Element) o);
            }
            else if (o instanceof Comment)
				doComment((Comment) o);
            else if (o instanceof ProcessingInstruction) 
				doPI((ProcessingInstruction) o);
        }
    }     

    public static void demo(Element element) {
		System.out.println("Element " + element);

        List attributes = element.getAttributes();
        List children = element.getContent();
        Iterator iterator = children.iterator();
        while (iterator.hasNext()) {
            Object o = iterator.next();
            if (o instanceof Element) {
                demo((Element) o);
            }
            else if (o instanceof Comment) 
				doComment((Comment)o);
            else if (o instanceof ProcessingInstruction) 
				doPI((ProcessingInstruction)o);
            else if (o instanceof String) {
                System.out.println("String: " + o);
            }   
        }
    }  

	public static void doComment(Comment c) {
		System.out.println("Comment: " + c);
	}

	public static void doPI(ProcessingInstruction pi) {
		System.out.println("PI: " + pi);
	}
}
//@@@@@@//
//xml/JDOMLister.java
//@@@@@@//
import java.io.File;

import org.jdom.Document;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;

/**
 * List an XML file after building it into a JDOM Document.
 * Notice it is easier than using SAX or DOM directly.
 */
public class JDOMLister {
	public static void main(String[] args) { 
		try {
			SAXBuilder b = new SAXBuilder(true);	// true -> validate

			// Create a JDOM document.
			Document doc = b.build(new File("people+dtd.xml"));

			// Create an output formatter, and have it write the doc.
			new XMLOutputter().output(doc, System.out);
		} catch (JDOMException jex) {
			System.out.print("PARSE ERROR: " + jex.getMessage());
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}
}
//@@@@@@//
//xml/MyDTDResolver.java
//@@@@@@//
import java.io.FileReader;
import java.io.IOException;

import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;

public class MyDTDResolver implements EntityResolver {
	public static final String[] dtds = {
		"http://java.sun.com/dtd/web-app_2_3.dtd",
		"http://java.sun.com/j2ee/dtds/ejb-jar_2_0.dtd",
		"http://java.sun.com/dtd/ejb-jar_2_0.dtd",
		"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd",
	};

	public static final String DTDDIR = "/home/ian/dtds";

	public InputSource resolveEntity (String publicId, String systemId) {
		for (int i=0; i<dtds.length; i++) {
			if (systemId.equals(dtds[i])) {
				// return a local copy
				try {
					String dtdFile = 
						systemId.substring(systemId.lastIndexOf('/'));
						// includes the /
					return new InputSource(
						new FileReader(DTDDIR + dtdFile));
				} catch (IOException ex) {
					System.err.println("+================================+");
					System.err.println("DTD ERROR: " + ex.toString());
					System.err.println("... Trying to get from web...");
					System.err.println("+================================+");
					return null;
				}
			}
		}
		// Not matched any of the ones in the array.
		return null;
	}
}
//@@@@@@//
//xml/SAXLister.java
//@@@@@@//
import java.io.IOException;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.helpers.XMLReaderFactory;
import com.darwinsys.util.Debug;

/**
 * Simple lister - extract name and children tags from a user file. Version for
 * SAX 2.0
 * 
 * @author Ian Darwin
 * @version $Id: SAXLister.java,v 1.12 2004/03/14 17:19:18 ian Exp $
 */
public class SAXLister {
	public static void main(String[] args) throws Exception {
		new SAXLister(args);
	}
	
	public SAXLister(String[] args) throws SAXException, IOException {
		XMLReader parser = XMLReaderFactory
				.createXMLReader();
		// should load properties rather than hardcoding class name
		parser.setContentHandler(new PeopleHandler());
		parser.parse(args.length == 1 ? args[0] : "people.xml");
	}
	
	/** Inner class provides DocumentHandler
	 */
	class PeopleHandler extends DefaultHandler {
		boolean person = false;
		boolean email = false;
		public void startElement(String nsURI, String localName,
				String rawName, Attributes attributes) throws SAXException {
			Debug.println("docEvents", "startElement: " + localName + ","
					+ rawName);
			// Consult rawName since we aren't using xmlns prefixes here.
			if (rawName.equalsIgnoreCase("name"))
				person = true;
			if (rawName.equalsIgnoreCase("email"))
				email = true;
		}
		public void characters(char[] ch, int start, int length) {
			if (person) {
				System.out.println("Person:  " +
					new String(ch, start, length));
				person = false;
			} else if (email) {
				System.out.println("Email: " + 
					new String(ch, start, length));
				email = false;
			}
		}
	}
}
//@@@@@@//
//xml/StyleServlet.java
//@@@@@@//
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.xalan.xslt.XSLTInputSource;
import org.apache.xalan.xslt.XSLTProcessor;
import org.apache.xalan.xslt.XSLTProcessorFactory;
import org.apache.xalan.xslt.XSLTResultTarget;

import com.darwinsys.io.FileIO;

/** Output the given XML file in XML if viewable, else in HTML. */
public class StyleServlet extends HttpServlet {

	public String XML_FILE;
	public String SHEET_FILE;

	public void doGet(HttpServletRequest request, HttpServletResponse response)
	throws IOException, ServletException {

		/** Servlet API 2.1: Web App Root/WEB-INF/web.xml contains
		 * context-param name & value elements; this retrieves 'em.
		 */
		ServletContext ctx = getServletContext();
		String value = ctx.getInitParameter("name");
		XML_FILE = ctx.getInitParameter("xml_file_name");
		SHEET_FILE = ctx.getInitParameter("xsl_sheet_name"); 

		String browser = request.getHeader("user-agent");
		PrintWriter out = response.getWriter();

		// At this point in time, MSIE5 is the only one that can do XML.
		if (browser.indexOf("MSIE5") != -1) {

			out.println("<?xml version=\"1.0\"?>");

			output_stylesheet_ref(out);

			output_body(XML_FILE, out);

		} else {
			// Any other browser, output HTML
			transform_into_html(out);
		}
	}

	void output_stylesheet_ref(PrintWriter out) {
		out.print("<?xml-stylesheet type=\"text/xsl\" href=\"" +
			SHEET_FILE + "\"?>");
	}

	void transform_into_html(PrintWriter out) throws ServletException {

		try {
			XSLTProcessor myProcessor = XSLTProcessorFactory.getProcessor();
			XSLTInputSource xmlSource = new XSLTInputSource(XML_FILE);
			XSLTInputSource xslStylesheet = new XSLTInputSource(SHEET_FILE);
			XSLTResultTarget xmlOutput = new XSLTResultTarget(out);
			myProcessor.process(xmlSource, xslStylesheet, xmlOutput);
		}
		catch (org.xml.sax.SAXException exc) {
			throw new ServletException("XML error: " + exc.toString());
		}
		catch (Exception exc) {
			throw new ServletException(exc.toString());
		}
	}

	void output_body(String XML_FILE, PrintWriter out) throws IOException {
		FileIO.copyFile(XML_FILE, out, false);
	}
}
//@@@@@@//
//xml/XParse.java
//@@@@@@//
import java.io.File;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

/** Parse an XML file using DOM, via JAXP.
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: XParse.java,v 1.9 2004/03/13 23:21:04 ian Exp $
 */
public class XParse {

	/** Parse the file */
	public static void parse(String fileName, boolean validate) {
		try {
			System.err.println("Parsing " + fileName + "...");

			// Make the document a URL so relative DTD works.
			String uri = "file:" + new File(fileName).getAbsolutePath();

			DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();
			if (validate)
				f.setValidating(true);
			DocumentBuilder p = f.newDocumentBuilder();
			// Get local copies of DTDs...
			p.setEntityResolver(new MyDTDResolver());
			Document doc = p.parse(uri);
			System.out.println("Parsed OK");

		} catch (SAXParseException ex) {
			System.err.println("+================================+");
			System.err.println("|       *SAX Parse Error*        |");
			System.err.println("+================================+");
			System.err.println(ex.toString());
			System.err.println("At line " + ex.getLineNumber());
			System.err.println("+================================+");
		} catch (SAXException ex) {
			System.err.println("+================================+");
			System.err.println("|          *SAX Error*           |");
			System.err.println("+================================+");
			System.err.println(ex.toString());
			System.err.println("+================================+");
		} catch (Exception ex) {
			System.err.println("+================================+");
			System.err.println("|           *XML Error*          |");
			System.err.println("+================================+");
			System.err.println(ex.toString()); 
		}
	}

	public static void main(String[] av) {
		if (av.length == 0) {
			System.err.println("Usage: XParse file");
			return;
		}
		boolean validate = false;
		for (int i=0; i<av.length; i++) {
			if (av[i].equals("-v"))
				validate = true;
			else
				parse(av[i], validate);
		}
	}
}
//@@@@@@//
//xml/XSLTransform.java
//@@@@@@//
import org.apache.xalan.xslt.XSLTInputSource;
import org.apache.xalan.xslt.XSLTProcessor;
import org.apache.xalan.xslt.XSLTProcessorFactory;
import org.apache.xalan.xslt.XSLTResultTarget;

/**
 * Demonstrate transforming a file using XSLT, with Apache Xalan API.
 * See also: JAXPTransform.
 */
public class XSLTransform {

	public static void main(String[] args) {

		try {
			// Require three input args
			if (args.length != 3) {
				System.out.println("Usage: java XSLTransform <input XML file> <input XSL file> <output file>");
				System.exit(1);
			}

			XSLTProcessor myProcessor = XSLTProcessorFactory.getProcessor();

			myProcessor.process(new XSLTInputSource(args[0]),
					new XSLTInputSource(args[1]),
					new XSLTResultTarget(args[2]));
		}
		catch (org.xml.sax.SAXException exc) {
			System.err.println("Found invalid XML during processing:");
			exc.printStackTrace();
		}
	}
}
//@@@@@@//
//xml/XTW.java
//@@@@@@//
import java.io.File;
import java.io.Reader;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.darwinsys.util.Debug;

/** XML Tree Walker
 * UPDATED FOR JAXP.
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: XTW.java,v 1.11 2004/03/01 03:42:57 ian Exp $
 */
public class XTW {

	public static void main(String[] av) {
		if (av.length == 0) {
			System.err.println("Usage: XTW file [...]");
			return;
		}
		for (int i=0; i<av.length; i++) {
			String name = av[i];
			new XTW().convert(name, true);
		}
	}

	/** Convert the file */
	protected void convert(String fileName, boolean verbose) {
		Reader is;
		try {
			if (verbose)
				System.err.println(">>>Parsing " + fileName + "...");
			// Make the document a URL so relative DTD works.
			String uri = "file:" + new File(fileName).getAbsolutePath();

			DocumentBuilderFactory factory =
				DocumentBuilderFactory.newInstance();
			DocumentBuilder builder = factory.newDocumentBuilder();
			Document doc = builder.parse( uri );
 
			if (verbose)
				System.err.println(">>>Walking " + fileName + "...");
			doRecursive(doc);

		} catch (Exception ex) {
			System.err.println("+============================+");
			System.err.println("|        XTW Error           |");
			System.err.println("+============================+");
			System.err.println(ex.getClass());
			System.err.println(ex.getMessage());
			System.err.println("+============================+");
		}
		if (verbose) {
			System.err.println(">>>Done " + fileName + "...");
		}
	}

	/* Process all the nodes, recursively. */
	protected void doRecursive(Node p) {
		if (p == null) {
			return;
		}
		NodeList nodes = p.getChildNodes();
		Debug.println("xml-tree", "Element has " + 
			nodes.getLength() + " children");
		for (int i = 0; i < nodes.getLength(); i++) {
			Node n = nodes.item(i);
			if (n == null) {
				continue;
			}

			doNode(n);

		}
	}

	protected void doNode(Node n) {

		switch(n.getNodeType()) {
			case Node.ELEMENT_NODE:
				System.out.println("ELEMENT<" + n.getNodeName() + ">");
				doRecursive(n);
				break;
			case Node.TEXT_NODE:
				String text = n.getNodeValue();
				if (text.length() == 0 || 
					text.equals("\n") || text.equals("\\r")) {
					break;
				}
				System.out.println("TEXT: " + text);
				break;
			default:
				System.err.println( "OTHER NODE " +
					n.getNodeType() + ": " + n.getClass());
				break;
		}
	}
}
//@@@@@@//
//xml/XTWalker.java
//@@@@@@//
import org.apache.crimson.tree.TreeWalker;
import org.w3c.dom.Node;

/** Subclass XML Tree Walker to use the Crimson-provided TreeWalker
 * STATUS -- UNKNOWN.
 * @version $Id: XTWalker.java,v 1.8 2004/03/13 23:05:25 ian Exp $
 */
public class XTWalker extends XTW {

	public static void main(String[] av) {
		if (av.length == 0) {
			System.err.println("Usage: XTWalker file [...]");
			return;
		}
		for (int i=0; i<av.length; i++) {
			String name = av[i];
			new XTWalker().convert(name, true);
		}
	}

	/* Process all the nodes, recursively. */
	protected void doRecursive(Node p) {

		// NOTE -- YOU HAVE TO WRITE YOUR OWN TREEWALKER CLASS.
		// OTHERWISE JUST USE XTW AS IT IS, NOT THIS SUBCLASS.

		TreeWalker tw = new TreeWalker(p);
		Node n;
		while ((n = (Node)tw.getNext()) != null) {

			doNode(n);

		}
	}
}
//@@@@@@//
//xmlform/GenMIF.java
//@@@@@@//
import java.io.*;
import org.w3c.dom.*;
import java.lang.reflect.*;
import java.util.*;

/**
 * Class with code to walk a tree and convert it to Maker Interchange
 * Format (MIF). Must make MIF (not MML) since, alas, MML loses named
 * character codes in input.
 * <P>
 * Along the way, we do some book-specific things, like running
 * another Java class and grabbing the output back into here.
 *
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: GenMIF.java,v 1.26 2004/02/09 03:34:11 ian Exp $
 */
public class GenMIF implements XmlFormWalker {
	/** The normal output writer */
	protected PrintStream msg;
	/** Specialized PrintStream for use by GetMark. */
	protected StyledPrintStream smsg;
	/** A GetMark converter for source code. */
	protected GetMark gm = new GetMark();
	/** Vector used to print indented lines */
	protected Vector indents;
	/** The Document */
	Document theDocument;

	/** Construct a converter object */
	GenMIF(Document doc, PrintStream pw) {
		theDocument = doc;
		msg = new PrintStream(pw);
		smsg = new StyledPrintStream(msg);
		// Reassign System.out to go there as well, so when we
		// run other main classes, their output gets grabbed.
		System.setOut(smsg);
		indents = new Vector();
		indents.addElement("");
	}

	protected int indent = 0;
	protected void indent() {
		if (indent > indents.size()) {
			StringBuffer sb = new StringBuffer();
			for (int i=0; i<indent; i++) {
				sb.append(' ');
				sb.append(' ');
			}
			indents.addElement(sb.toString());
		}
		msg.print(indents.elementAt(indent>0?indent-1:0));
	}

	protected Stack tagStack = new Stack();
	protected void startTag(String tag) {
		++indent;
		indent(); msg.println('<' + tag);
		tagStack.push(tag);
	}

	protected void endTag() {
		indent(); msg.println('>' + " # end of " + tagStack.pop());
		indent--;
	}

	/** Convert all the nodes in the current document. */
	public void convertAll() {

		msg.println("<MIFFile 3.00 -- MIF produced by XmlForm>");

		doRecursive(theDocument);		// start recursing the document
	}

	protected void doRecursive(Node n) {
		NodeList kids;
		if (n == null)
			return;

		doNode(n);

		kids = n.getChildNodes();
		int nkids = kids.getLength();
		for (int i=0; i<nkids; i++) {
			doRecursive(kids.item(i));
		}
	}

	protected void doNode(Node p) {
		if (p.getNodeType() == Node.ELEMENT_NODE)
			doElement((Element)p);
		else if (p.getNodeType() == Node.TEXT_NODE)
			doCData((org.w3c.dom.CharacterData)p);
		else
			System.err.println("IGNORING non-Element: " +
				p.getClass() + ':' + p.toString() + "\n" +
				p.getNodeValue());
	}

	protected void doElement(Element p) {
		String tag = p.getTagName().toLowerCase();
		//
		// STRUCTURE TAGS
		//
		if (tag.equals("head")) {
			System.err.println(">>>>Start HEAD");
		} else if (tag.equals("body")) {
			System.err.println(">>>>Start BODY");
		} else if (tag.equals("chapter")) {
			doChapter(p);
		//
		// PARAGRAPH TAGS
		// This is the application-specific bit of code.
		// SHOULD BE MAP RULES, NOT HARD-CODED.
		//
		} else if (tag.equals("title")) {
			doParagraph("ChapterTitle", p);
		} else if (tag.equals("simplesect")) {
			doParagraph("HeadA", p);
		} else if (tag.equals("sect1")) {
			doParagraph("HeadA", p);
		} else if (tag.equals("para")) {
			doParagraph("Body", p);
		} else if (tag.equals("sect2")) {
			doParagraph("HeadB", p);
		} else if (tag.equals("programlisting")) {
			doPre(p);
		} else if (tag.equals("graphic")) {
			doPre(p);
		} else if (tag.equals("runoutput")) {
			doRun(p);
		} else if (tag.equals("figure")) {
			doPre(p);
		//
		// STYLE TAGS
		//
		} else if (tag.equals("kb")) {	// keyboard, map to code
			System.err.println("<KB> handler not written yet");
		} else if (tag.equals("bt")) {	// book title, map to Citation
			System.err.println("<BT> handler not written yet");
		} else
			System.err.println("IGNORING UNHANDLED TAG " + tag + '(' +
				p.getClass() + '@' + p.hashCode() + ')');
	}

	protected void doChapter(Element p) {
		msg.println("# START OF CHAPTER");
		makeUpParagraph("ChapterStart", null);
	}

	protected void pgfTag(String s) {
		startTag("Para");
		startTag("Pgf");
		indent(); msg.println("<PgfTag `" + s + "'>");
		endTag();	// end of Pgf, not of Para!
	}

	/** Generate a paragraph from the input */
	protected void doParagraph(String tag, Element p) {
		indent(); pgfTag(tag);
		doChildren(p);
		endTag();
	}

	/** Synthesize a paragraph when we know its content.
	 * content can be null for things like Label paragraphs.
	 */
	protected void makeUpParagraph(String tag, String contents) {
		indent(); pgfTag(tag);
		if (contents != null)
			pgfString(contents);
		endTag();
	}

	/** EXAMPLEs are longer than CODEs, and are not limited by //+ //-
	 * marks, which are therefore not required.
	 * XXX TODO wrap a TABLE around the output.
	 */
	protected void doExample(Element p) {
		NamedNodeMap attrs = p.getAttributes();
		Node href;
		if ((href = attrs.getNamedItem("HREF")) == null)
			throw new IllegalArgumentException(
				"node " + p + "lacks required HREF Attribute");
		String fname = href.getNodeValue();
		System.err.println("Making an EXAMPLE out of " + fname);
	
		makeUpParagraph("ExampleLabel", null);
		makeUpParagraph("ExampleTitle", fname);

		try {
			fname = System.getProperty("codedir", ".") + '/' + fname;	
			LineNumberReader is = new LineNumberReader(new FileReader(fname));
			String line;
			while ((line = is.readLine()) != null) {
				indent(); pgfTag("Code");
				pgfString(line);
				endTag();	// end of Para
			}
		} catch(IOException e) {
			throw new IllegalArgumentException(e.toString());
		}
	}

	/** Run a java class' Main Program and capture the output.
	 */
	protected void doRun(Element p) {
		NamedNodeMap attrs = p.getAttributes();
		Node myClass;
		if ((myClass = attrs.getNamedItem("CLASS")) == null)
			throw new IllegalArgumentException(
				"node " + p + "lacks required CLASS Attribute");
		String className = myClass.getNodeValue();

		// makeUpParagraph("Example", "Example XX: " + className);

		try {
			// First, find the class.
			Class c = Class.forName(className);

			// Create a dummy argv to pass it.
			String[] argv = new String[0];

			// Create the array of Argument Types
			Class[] argTypes = {
				argv.getClass(),	// array is Object!
			};

			// Now find the method
			Method m = c.getMethod("main", argTypes);

			// Create the actual argument array
			Object passedArgv[] = { argv };

			// Now invoke the method.
			System.err.println("Invoking " + m + "...");
			m.invoke(null, passedArgv);

		} catch (Exception e) {
			System.err.println(e);
		}
	}

	protected void doCData(org.w3c.dom.CharacterData p) {
		String s = p.getData().trim();
		// System.err.println("doCData: String: " + s);
		if (s.length() == 0)	// Sun's parser returns extra 1-space "Text"s
			return;
		pgfString(s);
	}

	protected void pgfString(String s) {
		indent();
		startTag("ParaLine");
		mifString(s);
		endTag();
	}

	/** Code is inserted, but only between / / + and / / - tags */
	protected void doCode(Element p) {
		NamedNodeMap attrs = p.getAttributes();
		Node href;
		if ((href = attrs.getNamedItem("HREF")) == null)
			throw new IllegalArgumentException(
				"node " + p + "lacks required HREF Attribute");
		String fname = href.getNodeValue();
		System.err.println("En-CODE-ing " + fname);

		makeUpParagraph("Code", "// " + fname);
	
		try {
			fname = System.getProperty("codedir", ".") + '/' + fname;	
			LineNumberReader is = new LineNumberReader(new FileReader(fname));
			gm.process(fname, is, smsg);
		} catch(IOException e) {
			throw new IllegalArgumentException(e.toString());
		}
	}

	protected void doPre(Element p) {
		doParagraph("Code", p);
	}

	protected void doChildren(Element p) {
		NodeList nodes = p.getChildNodes();
		int numElem = nodes.getLength();
		// System.err.println("Element has " + numElem + " children");
		for (int i=0; i<numElem; i++) {
			Node n = nodes.item(i);
			if (n == null) {
				continue;
			}
			// System.err.println("NODE " + n.getNodeType());
			switch(n.getNodeType()) {
				case Node.TEXT_NODE:
					// System.err.println("\tCDATA: " + n.getNodeValue());
					doCData((CharacterData)n);
					p.removeChild(n);
					break;
				case Node.ELEMENT_NODE:
					// System.err.println("\tELEMENT<" + n.getNodeName() + ">");
					doChildren((Element)n);
					p.removeChild(n);
					break;
				default:
					System.err.println( "Warning: unhandled child node " +
						n.getNodeType() + ": " + n.getClass());
					break;
			}
		}
	}

	/** Do the minumum needed to make "line" a valid MIF string. */
	protected void mifString(String line) {
		// Make new, big enough for translations
		StringBuffer b = new StringBuffer(line.length() * 2);
		b.append('<');
		b.append("String");	// maybe parameterize?
		b.append(' ');
		b.append('`');

		// Process each character.
		for (int i=0; i<line.length(); i++) {
			char c = line.charAt(i);
			switch (c) {
			case '\\':	b.append("\\"); break;
			case '\t':	b.append("\\t"); break;
			case '\'':	b.append("\\xd5 "); break;
			case '<':	b.append("\\<"); break;
			case '>':	b.append("\\>"); break;
			case '\r': case '\n': b.append(' '); break;
			default:	b.append(c); break;
			}
		}
		b.append(' ');
		b.append('\'');
		b.append('>');
		indent(); msg.println(b.toString());
	}

	/** Simply subclass PrintStream so we don't have to modify
	 * GetMark to change the format of lines that it writes, or
	 * resort to other kluges like passing it a prefix and/or suffix.
	 * <P>
	 * The goal is to make each LINE of output be a separate paragraph,
	 * since that's how Frame does Tables, and since O'Reilly uses
	 * Frame Tables for multi-line code examples.
	 * <P>
	 * Note that we never actually write anything to the StyledPrintStream's
	 * internal buffer: its println() method indirectly writes to msg.
	 * This is an example of "subclassing for indirect effect".
	 */
	public class StyledPrintStream extends PrintStream {
		public StyledPrintStream(PrintStream p) {
			super(p, true);
		}
		public void println(String s) {
			indent(); pgfTag("Code");
			pgfString(s);
			endTag();	// end of Para
		}
	}
}
//@@@@@@//
//xmlform/GenMML.java
//@@@@@@//
import java.io.*;
import org.w3c.dom.*;
import java.lang.reflect.*;
import java.util.*;

/**
 * Class with code to walk a tree and convert it to MML (not MIF).
 * WAY OUT OF DATE W.R.T. THE "DTD" -- DO NOT USE!!
 * @author Ian F. Darwin, http://www.darwinsys.com/
 * @version $Id: GenMML.java,v 1.11 2004/02/09 03:34:11 ian Exp $
 */
public class GenMML implements XmlFormWalker {
	/** The normal output writer */
	PrintStream msg;
	/** Specialized PrintWriter for use by GetMark. */
	StyledPrintStream smsg;
	/** A GetMark converter for source code. */
	GetMark gm = new GetMark();

	Document theDocument;

	/** Construct a converter object */
	GenMML(Document doc, PrintStream pw) {
		theDocument = doc;
		msg = new PrintStream(pw);
		smsg = new StyledPrintStream(msg);
	}

	/** Convert all the nodes in the current document. */
	public void convertAll() {

		msg.println("<MML 1.00 -- MML produced by XmlForm>");
		msg.println("<Include \"xmlformat.mml\">");

		doRecursive(theDocument);
	}

    protected void doRecursive(Node n) {
        NodeList kids;
        if (n == null)
            return;

        doNode(n);

        kids = n.getChildNodes();
        int nkids = kids.getLength();
        for (int i=0; i<nkids; i++) {
            doRecursive(kids.item(i));
        }
    }

	public void doNode(Node p) {
		if (p.getNodeType() == Node.ELEMENT_NODE)
			doElement((Element)p);
		else if (p.getNodeType() == Node.TEXT_NODE)
			doCData((org.w3c.dom.CharacterData)p);
		else
			System.err.println("IGNORING non-Element: " +
				p.getClass() + ':' + p.toString() + "\n" +
				p.getNodeValue());
	}

	protected void doElement(Element p) {
		String tag = p.getTagName().toLowerCase();
		if (tag.equals("ch")) {
			doChapter(p);
		} else if (tag.equals("sc")) {
			doSection(p);
		} else if (tag.equals("ss")) {
			doSubSection(p);
		} else if (tag.equals("p")) {
			doParagraph(p);
		} else if (tag.equals("pr")) {
			msg.println("<HeadB>Problem");
		} else if (tag.equals("so")) {
			msg.println("<HeadB>Solution");
		} else if (tag.equals("di")) {
			msg.println("<HeadB>Discussion");
		} else if (tag.equals("b")) {
			doBold(p);
		} else if (tag.equals("i")) {
			doItalic(p);
		} else if (tag.equals("example")) {
			doExample(p);
		} else
			System.err.println("IGNORING UNHANDLED TAG " + tag + '(' +
				p.getClass() + '@' + p.hashCode() + ')');
	}

	protected void doChapter(Element p) {
		msg.println("<ChapterTitle>");
	}

	protected void doSection(Element p) {
		msg.println("<HeadA>");
	}

	protected void doSubSection(Element p) {
		msg.println("<HeadB>");
	}

	protected void doParagraph(Element p) {
		msg.println("<Body>");
	}

	protected void doExample(Element p) {
		NamedNodeMap attrs = p.getAttributes();
		Node href;
		if ((href = attrs.getNamedItem("HREF")) == null)
			throw new IllegalArgumentException(
				"node " + p + "lacks required HREF Attribute");
		String fname = href.getNodeValue();
		msg.println("<Example>");
		try {
			fname = "/javasrc/" + fname;
			LineNumberReader is = new LineNumberReader(new FileReader(fname));
			gm.process(fname, is, smsg);
		} catch(IOException e) {
			throw new IllegalArgumentException(e.toString());
		}
	}

	protected void doCData(org.w3c.dom.CharacterData p) {
		String s = p.getData().trim();
		if (s.length() == 0)	// Suns parser returns extra 1-space "Text"s
			return;
		msg.println(s);
	}

	protected void doBold(Element p) {
		msg.print("<Bold>");
		doNodes(p);
		msg.print("<Plain>");
	}
	protected void doItalic(Element p) {
		msg.print("<Italic>");
		doNodes(p);
		msg.print("<Plain>");
	}
	protected void doNodes(Element p) {
		NodeList nodes = p.getChildNodes();
		for (int i=0; i<nodes.getLength(); i++) {
			Node n = nodes.item(i);
			if (n instanceof CharacterData) {
				doCData((CharacterData)n);
				p.removeChild(n);
			}
		}
	}
	/** Simply subclass PrintWriter so we dont have to modify
	 * GetMark to change the format of lines that it writes, or
	 * resort to other kluges like passing it a prefix and/or suffix.
	 */
	public class StyledPrintStream extends PrintStream {
		public StyledPrintStream(PrintStream p) {
			super(p, true);
		}
		public void println(String s) {
			super.println("<CellBody>" + s);
		}
	}
}
//@@@@@@//
//xmlform/XmlForm.java
//@@@@@@//
import java.io.*;
import org.w3c.dom.*;
import javax.xml.parsers.*;

/** Convert a simple XML file to text.
 * @author Ian Darwin, http://www.darwinsys.com/
 * @version $Id: XmlForm.java,v 1.19 2004/02/09 03:34:11 ian Exp $
 */
public class XmlForm {
	protected Reader is;
	protected String fileName;

	protected static PrintStream msg = System.out;

	/** Construct a converter given an input filename */
	public XmlForm(String fn) {
		fileName = fn;
	}

	/** Convert the file */
	public void convert(boolean verbose) {
		try {
			if (verbose)
				System.err.println(">>>Parsing " + fileName + "...");
			// Make the document a URL so relative DTD works.
			//String uri = "file:" + new File(fileName).getAbsolutePath();
			InputStream uri = getClass().getResourceAsStream(fileName);
			DocumentBuilderFactory factory =
				DocumentBuilderFactory.newInstance();
			DocumentBuilder builder = factory.newDocumentBuilder();
			Document doc = builder.parse( uri );
			if (verbose)
				System.err.println(">>>Walking " + fileName + "...");
			XmlFormWalker c = new GenMIF(doc, msg);
			c.convertAll();

		} catch (Exception ex) {
			System.err.println("+================================+");
			System.err.println("|         *Parse Error*          |");
			System.err.println("+================================+");
			System.err.println(ex.getClass());
			System.err.println(ex.getMessage());
			System.err.println("+================================+");
		}
		if (verbose)
			System.err.println(">>>Done " + fileName + "...");
	}

	public static void main(String[] av) {
		if (av.length == 0) {
			System.err.println("Usage: XmlForm file");
			return;
		}
		for (int i=0; i<av.length; i++) {
			String name = av[i];
			new XmlForm(name).convert(true);
		}
		msg.close();
	}
}
//@@@@@@//
//xmlform/XmlFormWalker.java
//@@@@@@//
interface XmlFormWalker {
	public abstract void convertAll();
}
